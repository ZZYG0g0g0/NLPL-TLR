








TODO verify, this is never covered in test, possibly as qualifiedName visitor "ingest" it directly.













(non-Javadoc) @see org.kie.reteoo.LinkedListNode#remove() (non-Javadoc) @see org.kie.reteoo.LinkedListNode#getPrevious() (non-Javadoc) @see org.kie.reteoo.LinkedListNode#setNext(org.kie.reteoo.LinkedListNode) (non-Javadoc) @see org.kie.reteoo.LinkedListNode#setPrevious(org.kie.reteoo.LinkedListNode)
public Collection<J> children(BitSet key) { return null;  //To change body of implemented methods use File | Settings | File Templates. } ---------------needed by sub classes of TypeHierarchy--------------- public void addMember(LatticeElement<H> val, BitSet key) { System.out.println(">>>>>>************* it should not happen"); } ------------------------------

Adds a field to this type declaration

* Return the "ceiling" of the key's descendants, excluding the element whose code is key, if any Return the "floor" of the key's ancetsors, down to and excluding the element whose code is key Return the "ceiling" of the key's descendants, up to and including the element whose code is key Returns all elements whose code is a descendant of key These methods assume that a node is known, by value or key, and will navigate the precomputed structure Returns all elements whose code is an ancestor of key These methods work with a generic key, which need not correspond to a particular element Return the "floor" of the key's ancestors, down to and including the element whose code is key, if any


Returns a variable name based on the simple name of the specified class appended with the specified nodeId.
Adds an alpha constraint to the multi field OR constraint Adds a beta constraint to this multi field OR constraint Adds a constraint too all lists it belongs to by checking for its type {@inheritDoc } {@inheritDoc } {@inheritDoc } Updades the cached required declaration array




Entry point method of a DRL compilation unit compilationUnit := packageStatement? ( statement SEMICOLON? )* ------------------------------------------------------------------------------------------------ GENERAL INTERFACING METHODS ------------------------------------------------------------------------------------------------

send generated event and execute corresponding actions
Adds the specified listener to the list of listeners. Note that this method needs to be synchonized because it performs two independent operations on the underlying list Removes all event listeners of the specified class. Note that this method needs to be synchonized because it performs two independent operations on the underlying list


(non-Javadoc) @see org.kie.reteoo.FactHandleFactory#newFactHandle(long) (non-Javadoc) @see org.kie.reteoo.FactHandleFactory#newFactHandle(long) (non-Javadoc) @see org.kie.reteoo.FactHandleFactory#newFactHandle() (non-Javadoc) @see org.kie.reteoo.FactHandleFactory#newInstance()



Returns the list of in-code, declared variables that are available in the scope of this block Sets the list of in-code, declared variables that are available in the scope of this block

Returns the list of in-code, declared variables that are available in the scope of this block Sets the list of in-code, declared variables that are available in the scope of this block




Returns the partition to which this propagator belongs to Sets the partition to which this propagator belongs to
A method that tries to generate a model identifier for those times when models arrive without an identifier Default method returns an empty Map
















Test compatiblity only, do not use













Executes the accumulate (action) code for the given fact handle Gets the result of the accumulation Executes the initialization block of code  Executes the reverse (action) code for the given fact handle Returns true if this accumulate supports reverse


For accumulate CEs that use custom code blocks, this call sets the content of the action code block. Please node that the use of custom code blocks is discouraged, as they are usually a bad practice. Accumulate uses either accumulate functions or the custom code blocks (init/action/reverse/result). It is not possible to mix them. For accumulate CEs that use accumulate functions, this call instantiate one accumulate function call. Example: ... accumulate( X(), $sum : sum( $value ) ) Requires the call to this method with parameters: function( "sum", "$sum", new String[] { "$value" } ) Please note that accumulate supports multiple function calls and this method should be called for each function call. Accumulate uses either accumulate functions or the custom code blocks (init/action/reverse/result). It is not possible to mix them. For accumulate CEs that use custom code blocks, this call sets the content of the init code block. Please node that the use of custom code blocks is discouraged, as they are usually a bad practice. Accumulate uses either accumulate functions or the custom code blocks (init/action/reverse/result). It is not possible to mix them. For accumulate CEs that use custom code blocks, this call sets the content of the result expression. Please node that the use of custom code blocks is discouraged, as they are usually a bad practice. Accumulate uses either accumulate functions or the custom code blocks (init/action/reverse/result). It is not possible to mix them. For accumulate CEs that use custom code blocks, this call sets the content of the reverse code block. Please node that the use of custom code blocks is discouraged, as they are usually a bad practice. Accumulate uses either accumulate functions or the custom code blocks (init/action/reverse/result). It is not possible to mix them. Defines the source CE for the Accumulate CE. It is always an AND descriptor that contains one or more Patterns and other CEs.
{@inheritDoc } {@inheritDoc }





Sets the function name for the accumulate import Sets the import target


Creates a BetaMemory for the BetaNode's memory.




Since accumulate are always relative to the Pattern, it may happen that the declaration inside the accumulate was already set in the relative Pattern. Here though the type is more precise as it checks the result type Accumulate Function, so we use addDeclarationReplacing instead of addDeclaration to overwrite the previous declaration. By design this legacy accumulate (with inline custome code) visitor supports only with 1-and-only binding in the accumulate code/expressions.


Executes the accumulate (action) code for the given fact handle Creates the context object for an accumulator session. The context is passed as a parameter to every subsequent accumulator method call in the same session. Creates and return a context object for each working memory instance Gets the result of the accummulation Executes the initialization block of code Reverses the accumulate action for the given fact handle Returns true if this accumulator supports operation reversal


ActionCallMethods do not support chained method invocations



This will return the line number of the error, if possible Otherwise it will be -1



(non-Javadoc) @see org.drools.ide.common.client.modeldriven.brl.FieldNature#getField() (non-Javadoc) @see org.drools.ide.common.client.modeldriven.brl.FieldNature#getNature() (non-Javadoc) @see org.drools.ide.common.client.modeldriven.brl.FieldNature#getType() (non-Javadoc) @see org.drools.ide.common.client.modeldriven.brl.FieldNature#getValue() (non-Javadoc) @see org.drools.ide.common.client.modeldriven.brl.FieldNature#isFormula() (non-Javadoc) @see org.drools.ide.common.client.modeldriven.brl.FieldNature#setField(java .lang.String) (non-Javadoc) @see org.drools.ide.common.client.modeldriven.brl.FieldNature#setNature(long) (non-Javadoc) @see org.drools.ide.common.client.modeldriven.brl.FieldNature#setType(java .lang.String) (non-Javadoc) @see org.drools.ide.common.client.modeldriven.brl.FieldNature#setValue(java .lang.String)





















Values are added to populate the template. The source builder contained needs to be "cleared" when the resultant snippet is extracted. Create a new action type that matches this cell, and add it to the map, keyed on that column. This is where a code snippet template is added. Retrieves the code. This is only set for LHS or RHS building.











Each PropgationContext is assigned an id from a counter for the WorkingMemory action it represents. All Activations return this id as the ActivationNumber, thus all Activations created from the same PropgationContext will return the same long for this method. Retrieve the <code>PropagationContext</code> for the <code>Activation</code>  Retrieve the subrule that was activated. Retrieve the <code>Tuple</code> that was activated. Cancel the <code>Activation</code> by removing it from the <code>Agenda</code>.










Returns a unique id for the activation. Returns a String representation of the declarations in the activation. Returns the name of the rule of the activation.



Returns true if a new activation should be created for the given propagation or false otherwise





This method is called after the rule nodes have been added to the network For add tuples are processed after the segments and pmems have been adjusted Create all missing peers Populates the SegmentMemory with staged LeftTuples. If the parent is not a Beta or From node, it iterates up to find the first node with memory. If necessary It traverses to the LiaNode's ObjectTypeNode. It then iterates the LeftTuple chains, where an existing LeftTuple is staged as delete. Or a new LeftTuple is created and staged as an insert. This method is called before the rule nodes are removed from the network. For remove tuples are processed before the segments and pmems have been adjusted





public void receiveMessage(List cmd) { Performative p = null;  switch ( p ) { case REQUEST : //Performatives r = ( Performatives ) p ; } }





























(non-Javadoc) @see org.kie.spi.AgendaGroup#getName() (non-Javadoc) @see org.kie.spi.AgendaGroup#size()


(non-Javadoc) @see java.lang.Object#equals(java.lang.Object) (non-Javadoc) @see org.kie.spi.Activation#getActivationNumber() Retrieve the rule. Retrieve the tuple. Return the hashCode of the <code>TupleKey<code> as the hashCode of the AgendaItem











Retruns the <code>FieldConstraint</code> Returns the next node Returns the previous node Sets the next node Sets the previous node
Clone this constraints only if it is already used by a different node, otherwise returns this




Returns the array of lists<String> of bound identifiers Returns the Set<String> of all used identifiers Returns the Set<String> of declared local variables Returns the Set<String> of not bounded identifiers





Assigns a new annotation to this type with the respective name and value Assigns a new annotation to this type Returns the annotation with the given name Returns the set of annotation names for this type



Returns the metadata value as a single object or a Map '' and 'a' are passed through as

























Checks whether the index is valid or not. Properties ----------------------------------------------------------------------- Gets the array that this iterator is iterating over. Iterator interface ----------------------------------------------------------------------- Returns true if there are more elements to return from the array. Returns the next element in the array. Throws {@link UnsupportedOperationException}. Sets the array that the ArrayIterator should iterate over. <p> If an array has previously been set (using the single-arg constructor or this method) then that array is discarded in favour of this one. Iteration is restarted at the start of the new array. Although this can be used to reset iteration, the {@link #clear()} method is a more effective choice.














Clones this attribute column instance.


Sets the attribute value type Sets the attribute value

Adds a new attribute to the statement Adds a new attribute with the given name and value Adds a new attribute with the given name and value

Not supported. Add a new AuditLogEntry at the beginning of the list. This is different behaviour to a regular List but it prevents the need to sort entries in descending order. Not supported. Not supported. Not supported. Not supported. Not supported.
@Override @Override @Override @Override @Override @Override
This is the filtering method. When an AuditLogEntry is added to an AuditLog the AuditLog calls this method to determine whether the AuditLogEntry should be added. Register a type this Filter understands. When a new entry is added the AuditLogFilter is set to not accept the type by default.


Checks to see if a specific port is available. Returns the {@link Set} of currently available port numbers ({@link Integer}). This method is identical to <code>getAvailablePorts(MIN_PORT_NUMBER, MAX_PORT_NUMBER)</code>. WARNING: this can take a very long time. Returns the {@link Set} of currently avaliable port numbers ({@link Integer}) between the specified port range. Gets the next available port starting at the lowest port number. Gets the next available port starting at a port.
(non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#createContext() (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#getResult(java.lang.Object) {@inheritDoc } (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#init(java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#supportsReverse()







































Check whether two Objects are equal or both null. Check whether two List are same size or both null. Check whether two Map are same size or both null. Check whether two Objects are equal or both null.







this method should be overriden by custom function implementations that should be invoked reflectively




Returns the lines of the error in the source file Classes that extend this must provide a printable message, which summarises the error.
Had to add the set method because sink adapters must override the tuple sink set when the tuple was created.
















This method is used by the consequence invoker (generated via asm by the ConsequenceGenerator) to always pass to the consequence the original fact handle even in case when it has been cloned and linked by a WindowNode





Gets the value of the abortWorkItemOrCompleteWorkItemOrFireAllRules property. <p> This accessor method returns a reference to the live list, not a snapshot. Therefore any modification you make to the returned list will be present inside the JAXB object. This is why there is not a <CODE>set</CODE> method for the abortWorkItemOrCompleteWorkItemOrFireAllRules property. <p> For example, to add a new item, do as follows: <pre> getCommand().add(newItem); </pre> <p> Objects of the following type(s) are allowed in the list {@link SetGlobalCommand} {@link CompleteWorkItemCommand} {@link AbortWorkItemCommand} {@link SignalEventCommand} {@link FireAllRulesCommand} {@link StartProcessCommand} {@link GetGlobalCommand} {@link InsertElementsCommand} {@link QueryCommand} {@link InsertObjectCommand}








private static void absorb(BayesVariable[] sepVars, JunctionTreeNode node, JunctionTreeSeparator sep, double[] oldSepPots ) { public T createBayesFact() { Object[] args = new Object[targetParameterMap.length]; args[0] = this; try { return targetConstructor.newInstance( args ); } catch (Exception e) { throw new RuntimeException( "Unable to instantiate " + targetClass.getSimpleName() + " " + Arrays.asList( args ), e ); } } Passes a message from node1 to node2. node1 projects its trgPotentials into the separator. node2 then absorbs those trgPotentials from the separator. private static void project(BayesVariable[] sepVars, JunctionTreeNode node, JunctionTreeSeparator sep) {









@Override public BayesInstance createBayesFact(Class cls) { // using the two-tone pattern, to ensure only one is created BayesInstance instance = instances.get( cls.getName() ); if ( instance == null ) { instance = createInstance(cls); }  return instance; }





























Makes the behavior aware of the new fact entering behavior's scope Creates the context object associated with this behavior. The object is given as a parameter in all behavior call backs. A callback method that allows behaviors to expire facts Some behaviors might change the expiration offset for the associated fact type. Example: time sliding windows. For these behaviors, this method must return the expiration offset associated to them. Returns the type of the behavior Removes a right tuple from the behavior's scope



Register a newly asserted right tuple into the behaviors' context Creates the behaviors' context  Removes a newly asserted fact handle from the behaviors' context
This will remove all entries and do clean up, like retract FHs. This will remove all entries, but not do cleanup, the FH is most likely needed else where public boolean isPropagated();
The typeConf has not yet been looked up, so we leave it to the implementation to decide if it needs it or not.  TypeConf is already available, so we pass it, to avoid additional lookups









Returns the next node Returns the next node Returns the previous node Returns the previous node Sets the next node Sets the next node Sets the previous node Sets the previous node

Clone this constraints only if it is already used by a different node, otherwise returns this



(non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#createContext() (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#getResult(java.lang.Object) {@inheritDoc } (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#init(java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#supportsReverse()






Clears all elements from queue. Compares two objects using the comparator if specified, or the natural order otherwise. Returns the Queueable on top of heap and remove it. Inserts an Queueable into queue. Increases the size of the heap to support additional elements Tests if queue is empty. Tests if queue is full. Percolates element down heap from the position given by the index. <p> Assumes it is a maximum heap. Percolates element up heap from from the position given by the index. <p> Assume it is a maximum heap. Percolates a new element up heap from the bottom. <p> Assume it is a maximum heap. ----------------------------------------------------------------------- Returns the number of elements in this heap.


























public void addValue(Map vars, Object value) { vars.put(getName(), value); }









Returns context rulebase Returns an Id for the next node      Return the array of working memories associated with the given rulebase. Returns the top stack element without removing it Peeks at the top element from the rule component stack. The rule component stack is used to add trackability to the ReteOO nodes so that they can be linked to the rule components that originated them. Removes the top stack element Removes the top element from the rule component stack. The rule component stack is used to add trackability to the ReteOO nodes so that they can be linked to the rule components that originated them. Adds the rce to the build stack Adds the ruleComponent to the top of the rule component stack. The rule component stack is used to add trackability to the ReteOO nodes so that they can be linked to the rule components that originated them. Method used to undo previous id assignment        Returns a list iterator to iterate over the stacked elements

Adds the given builder for the given target to the builders map Attaches a node into the network. If a node already exists that could substitute, it is used instead. Calculates the temporal distance between all event patterns in the given subrule. Make sure the required declarations are previously bound Creates and returns a BetaConstraints object for the given list of constraints Returns a builder for the given target from the builders map Utility function to check if sharing is enabled for nodes of the given class

Appends compilation problems to builder if object is an array of {@link CompilationProblem} or object itself if not Appends compilation problems to summary message if object is an array of {@link CompilationProblem} separated with backspaces Appends compilation problems to summary message if object is an array of {@link CompilationProblem} with custom separator




























Defines a top level ACCUMULATE CE Creates a set of AND'ed Conditional Elements Defines a Conditional Branch Conditional Elements Defines an EVAL Conditional Elements Creates a set of EXIST'ed Conditional Elements Defines a FORALL Conditional Element Defines a Named Consequence Conditional Elements Creates a set of NOT'ed Conditional Elements Creates a set of OR'ed Conditional Elements
{@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc }





This will return true if the value is really a "formula" - in the sense of like an excel spreadsheet. <p/> If it IS a formula, then the value should never be turned into a string, always left as-is.



Delegate methods












(non-Javadoc) @see sudoku.CellFile#toString()
Retrieves the row or column number. (non-Javadoc) @see java.lang.Object#toString()
Add another Cell object to the cells of this group. Returns the Cell objects in this group.
(non-Javadoc) @see sudoku.CellFile#toString()



































///////////////////// /// Internal Store /////////////////////



Adds a field definition to this class   Returns the field at position index, as defined by the builder using the @position annotation Returns the field definition object for the given field name
Generates a bean, and adds it to the composite class loader that everything is using.


Creates a constructor for the field extractor receiving the index, field type and value type Builds the class header Creates the proxy reader method for the given method Creates the set method for the given field definition Returns the appropriate Base class field extractor class for the given fieldType Returns the appropriate Base class field extractor class for the given fieldType


class.getDeclaredField(String) doesn't walk the inheritance tree; this does Return a mapping of the field "names" (ie bean property name convention) to the numerical index by which they can be accessed.    Convert it to a form so we can load the bytes from the classpath.  sotty: Checks whether a returned field is actually a getter or not Walk up the inheritance hierarchy recursively, reading in fields
Utility method to take a string and convert it to normal Java variable name capitalization.  This normally means converting the first character from upper case to lower case, but in the (unusual) special case when there is more than one character and both the first and second characters are upper case, we leave it alone. <p> Thus "FooBah" becomes "fooBah" and "X" becomes "x", but "URL" stays as "URL". Taken from

FieldDescr Accessors
In order to build a declared class, the fields inherited from its superclass(es) are added to its declaration. Inherited descriptors are marked as such to distinguish them from native ones. Various scenarioes are possible. (i) The superclass has been declared in the DRL as well : the fields are cloned as inherited (ii) The superclass is imported (external), but some of its fields have been tagged with metadata (iii) The superclass is imported. <p> The search for field descriptors is carried out in the order. (i) and (ii+iii) are mutually exclusive. The search is as such: (i) The superclass' declared fields are used to build the base class additional fields (iii) The superclass is inspected to discover its (public) fields, from which descriptors are generated (ii) Both (i) and (iii) are applied, but the declared fields override the inspected ones Utility method to sort declared beans. Linearizes the hierarchy, i.e.generates a sequence of declaration such that, if Sub is subclass of Sup, then the index of Sub will be > than the index of Sup in the resulting collection. This ensures that superclasses are processed before their subclasses





Determine if another object is equal to this. Return the Java object class.
This will return the package name - if the package is null, it will work it out from the class name (this is in cases where funky classloading is used).
This implementation opens an InputStream for the given class path resource. This implementation returns a URL for the underlying class path resource.

Populates the import style pattern map from give comma delimited string Please do not use - internal org.my.Class -> org/my/Class.class Please do not use - internal org/my/Class.xxx -> org.my.Class Extracts the package name from the given class object This method will attempt to create an instance of the specified Class. It uses a syncrhonized HashMap to cache the reflection Class lookup. This method will attempt to create an instance of the specified Class. It uses a synchronized HashMap to cache the reflection Class lookup.  It will execute the default constructor with the passed in arguments This method will attempt to create an instance of the specified Class. It uses a synchronized HashMap to cache the reflection Class lookup.  It will execute the default constructor with the passed in arguments Checks if running on Android operating system Determines if a given full qualified class name matches any import style patterns. This method will attempt to load the specified Class. It uses a syncrhonized HashMap to cache the reflection Class lookup. Please do not use - internal org/my/Class.xxx -> org/my/Class














These methods assume that a node is known, by value or key, and will navigate the precomputed structure * Return the "ceiling" of the key's descendants, excluding the element whose code is key, if any Return the "floor" of the key's ancetsors, down to and excluding the element whose code is key These methods will work for any key code Return the "ceiling" of the key's descendants, up to and including the element whose code is key Returns all elements whose code is a descendant of key These methods assume that a node is known, by value or key, and will navigate the precomputed structure Returns all elements whose code is an ancestor of key These methods work with a generic key, which need not correspond to a particular element Return the "floor" of the key's ancestors, down to and including the element whose code is key, if any



If the user uses an interface as a result type, use a default concrete class. List -> ArrayList Collection -> ArrayList Set -> HashSet
(non-Javadoc) @see org.kie.spi.Accumulator#accumulate(java.lang.Object, org.kie.spi.Tuple, org.kie.common.InternalFactHandle, org.kie.rule.Declaration[], org.kie.rule.Declaration[], org.kie.WorkingMemory) (non-Javadoc) @see org.kie.spi.Accumulator#createContext() (non-Javadoc) @see org.kie.spi.Accumulator#getResult(java.lang.Object, org.kie.spi.Tuple, org.kie.rule.Declaration[], org.kie.WorkingMemory) (non-Javadoc) @see org.kie.spi.Accumulator#init(java.lang.Object, org.kie.spi.Tuple, org.kie.rule.Declaration[], org.kie.WorkingMemory)



{@inheritDoc } {@inheritDoc }

(non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#createContext() (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#getResult(java.lang.Object) {@inheritDoc } (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#init(java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#supportsReverse()
(non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#createContext() (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#getResult(java.lang.Object) {@inheritDoc } (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#init(java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#supportsReverse()










Deprecated use {@link #getIdentifier()} instead






position of where the problem stops in the source code name of the file where the problem occurred the description of the problem position of where the problem starts in the source code is the problem an error and compilation cannot continue or just a warning and compilation can proceed





Generated code should be able to return a List which represents the bytecode. The elements in the list will be used to compare one semantic invoker with another by making sure each item in the list is equivalent (equals()). There are utilities in the ASM package to retrieve the bytecode for this.
Returns the unique id that represents the node in the Rete network Returns the partition ID to which this node belongs to The object implements the readExternal method to restore its contents by calling the methods of DataInput for primitive types and readObject for objects, strings and arrays.  The readExternal method must read the values in the same sequence and with the same types as were written by writeExternal. Generated subclasses need to implement this method to set member variables based on the specified NetworkNode. Sets the OTN for this network. Calling this method will set all variables in the generated subclasses by walking the {@link org.kie.reteoo.ObjectTypeNode} using a {@link ObjectTypeNodeParser}. The object implements the writeExternal method to save its contents by calling the methods of DataOutput for its primitive values or calling the writeObject method of ObjectOutput for objects, strings, and arrays.








Remove a FactPattern at the provided index. If index is less than zero or greater than or equal to the number of patterns the effect of this method is "no operation".
Note this is a bit ugly, GWT had some early limitations which required this to kind of work this way. when generics are available, could probably switch to it, but remember this is persistent stuff so don't want to break backwards compat (as XStream is used) Unfortunately, this is kinda duplicate code with other methods, but with typed arrays, and GWT, its not really possible to do anything "better" at this point in time.





This is a Hook method for subclasses to override. Please keep it protected unless you know what you are doing. Returns a FieldIndex which Keeps a count on how many times a particular field is used with an equality check in the sinks.








Checks if a memory does not exists for the given node and creates it. The implementation tries to delay locking as much as possible, by running some potentially unsafe operations out of the critical session. In case it fails the checks, it will move into the critical sessions and re-check everything before effectively doing any change on data structures.







There is not reason to clone this object since it is stateless. So a clone() call will return the instance itself. (non-Javadoc) @see java.lang.Object#equals(java.lang.Object) It is not possible to declare any new variables, so always return an Empty Map It is not possible to nest elements inside a conditional branch, so always return an empty list. It is not possible to declare and export any variables, so always return an empty map (non-Javadoc) @see java.lang.Object#hashCode() Not possible to resolve any declaration, so always return null.


Defines the condition for this conditional branch Defines a Consequence activated when the condition is evaluated to true Defines a else branch used when the condition is evaluated to false


Returns the next node Returns the previous node Sets the next node Sets the previous node Produce a debug string.








Load a Properties file from a URL, return null if it fails Return the URL for a given conf file Return URL for given filename
(non-Javadoc) @see org.kie.compiler.DroolsProblem#getProblemType()






Set arbitrary extra information about the condition. <p> The info property may be used to communicate the actual block text or other information in the case that Consequence does not have block text. </p>






Clones the constraint Returns all the declarations required by the given constraint implementation. Returns the type of the constraint, either ALPHA, BETA or UNKNOWN Returns true in case this constraint is a temporal constraint When a rule contains multiple logical branches, i.e., makes use of 'OR' CE, it is required to clone patterns and declarations for each logical branch. Since this is done at ReteOO build type, when constraints were already created, eventually some constraints need to update their references to the declarations.


























Get all messages of all types Get all messages of a particular type



(non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#accumulate(java.lang.Object, java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#createContext() (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#getResult(java.lang.Object) {@inheritDoc } (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#init(java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#reverse(java.lang.Object, java.lang.Object) (non-Javadoc) @see org.kie.base.accumulators.AccumulateFunction#supportsReverse()




//////////////////////////////////////////////////////////////////////////  Expression Parsing Functions  ////////////////////////////////////////////////////////////////////////// NOT YET IMPLEMENTED: Returns the final time that the <code>CronExpression</code> will match. Returns the next date/time <I>after</I> the given date/time which does <I>not</I> satisfy the expression Returns the next date/time <I>after</I> the given date/time which satisfies the cron expression. //////////////////////////////////////////////////////////////////////////  Computation Functions  ////////////////////////////////////////////////////////////////////////// NOT YET IMPLEMENTED: Returns the time before the given time that the <code>CronExpression</code> matches. Returns the time zone for which this <code>CronExpression</code> will be resolved. Indicates whether the given date satisfies the cron expression. Note that milliseconds are ignored, so two Dates falling on different milliseconds of the same second will always have the same result here. Indicates whether the specified cron expression can be parsed into a valid cron expression Advance the calendar to the particular hour paying particular attention to daylight saving problems. Sets the time zone for which  this <code>CronExpression</code> will be resolved. Returns the string representation of the <CODE>CronExpression</CODE>

<p> Get the time at which the <code>CronTrigger</code> should quit repeating - even if repeastCount isn't yet satisfied. </p> <p> Returns the next time at which the <code>Trigger</code> is scheduled to fire. If the trigger will not fire again, <code>null</code> will be returned.  Note that the time returned can possibly be in the past, if the time that was computed for the trigger to next fire has already arrived, but the scheduler has not yet been able to fire the trigger (which would likely be due to lack of resources e.g. threads). </p> <p>The value returned is not guaranteed to be valid until after the <code>Trigger</code> has been added to the scheduler. </p> <p> Returns the previous time at which the <code>CronTrigger</code> fired. If the trigger has not yet fired, <code>null</code> will be returned. <p> Returns the time zone for which the <code>cronExpression</code> of this <code>CronTrigger</code> will be resolved. </p> <p> Returns the next time at which the <code>CronTrigger</code> will fire, after the given time. If the trigger will not fire after the given time, <code>null</code> will be returned. </p> <p> Note that the date returned is NOT validated against the related org.quartz.Calendar (if any) </p> <p> Sets the next time at which the <code>CronTrigger</code> will fire. <b>This method should not be invoked by client code.</b> </p> <p> Set the previous time at which the <code>CronTrigger</code> fired. </p> <p> <b>This method should not be invoked by client code.</b> </p> <p> Sets the time zone for which the <code>cronExpression</code> of this <code>CronTrigger</code> will be resolved. </p> <p>If {@link #setCronExpression(CronExpression)} is called after this method, the TimeZon setting on the CronExpression will "win".  However if {@link #setCronExpression(String)} is called after this method, the time zone applied by this method will remain in effect, since the String cron expression does not carry a time zone!
Use the current lineParser implementation to return a CSV line as a List of cells. (Strings).


















Utility method to ensure any QName references contained inside the ItemDefinition have the namespace correctly valorized, also accordingly to the prefix. (Even in the case of {@link XMLConstants.DEFAULT_NS_PREFIX} it will take the DMN model namespace for the no-prefix accordingly.)




Returns the decision ID Returns the decision name Returns the evaluation status of this decision. Returns a list of DMN messages generated during the evaluation of this decision. Returns the result of the evaluation of the decision Returns true if any error occurred during evaluation.





Utility method for DecisionTable with only 1 output, to infer typeRef from parent Utility method to have a error message is reported if a DMN Variable is missing typeRef.

Evaluates the expression, returning its result type (SUCCESS/FAILURE) and result value.

Return a FEEL instance to be used in invokers/impls, which is however configured correctly accordingly to profiles This FEEL instance is potentially not the same shared by the compiler during the compilation phase.









If this message relates to a java exception, this method returns a reference to the actual Throwable object. If this message relates to a FEEL compilation or runtime event, this method returns the reference to the actual FEEL event. Returns a human readable text with the explanation of the event that raised the message. Returns a classification of the event that raised the message. Returns the severity of the message. Either TRACE, INFO, WARN or ERROR Returns the ID of the model element to which this message relates to or null if this message does not refer to a specific model element. Returns the actual model element reference to which this message relates to or null if this message does not refer to a specific model element.
Returns a list of all the messages produced during the DMN service invocation. Returns a list of all the messages produced during the DMN service invocation, filtered by the list of severities given. A helper method to quick check for the presence of error messages. The actual error messages can be retrieved by invoking <code>#getMessages()</code>



If the model was created from a {@link Resource}, provide the original resource; null otherwise.

children element references are populated during deserialization, enabling fast access for Validation. Returns an approximated location of the XML origin for this DMN Model node. Namespace context map as defined at the level of the given element. Please notice it support also default namespace (no prefix) as "" as defined in {@link XMLConstants#DEFAULT_NS_PREFIX} .







Returns the full context, including all input variables and additional variables and decisions set during the service invocation Returns the result of a single decision. Returns the result of a single decision. Returns a list containing all the results of the decisions executed
Returns the model this DMNResult belongs to.
Evaluate all decisions for the model, given the context Evaluate all decision identified by the given IDs and all dependent decisions, given the context Evaluate all decisions identified by the given names and all dependent decisions, given the context Evaluate the decision identified by the given ID and all dependent decisions, given the context Evaluate the decision identified by the given name and all dependent decisions, given the context Returns the model registered with the given namespace and model name. Returns a list of all models available to this runtime Creates a new empty DMNContext

Registers a runtime listener Returns the set of all registered listeners Removes a runtime listener






Check if the value passed as parameter can be assigned to this type. Definition of `instance of` accordingly to FEEL specifications Table 49.

Release all resources associated with this DMNValidator. Validate the model and return the results. This is the same as invoking method Validate the model and return the results. The options field defines which validations to apply. E.g.: <code>validate( xmlFile, VALIDATE_MODEL, VALIDATE_COMPILATION )</code> Validate the model and return the results. This is the same as invoking method Validate the model and return the results. The options field defines which validations to apply. E.g.: <code>validate( reader, VALIDATE_MODEL, VALIDATE_COMPILATION )</code> Validate the model and return the results. This is the same as invoking method Validate the model and return the results. The options field defines which validations to apply. E.g.: <code>validate( dmnModel, VALIDATE_MODEL, VALIDATE_COMPILATION )</code> <b>IMPORTANT:</b> this method does not support VALIDATE_SCHEMA. In order to validate the schema, please use one of the other signatures of this method, like @{link #validate(Reader reader, Validation... options)}.






$ANTLR end "shiftOp" $ANTLR start "additiveExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:456:1: additiveExpression returns [BaseDescr result] : left= multiplicativeExpression ( ( PLUS | MINUS )=> ( PLUS | MINUS ) multiplicativeExpression )* ; $ANTLR end "exclusiveOrExpression" $ANTLR start "andExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:272:1: andExpression returns [BaseDescr result] : left= equalityExpression ( AMPER right= equalityExpression )* ; $ANTLR end "orRestriction" $ANTLR start "andRestriction" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:405:1: andRestriction returns [BaseDescr result] : left= singleRestriction ( ( DOUBLE_AMPER ( fullAnnotation[null] )? operator )=>lop= DOUBLE_AMPER (args= fullAnnotation[null] )? right= singleRestriction )* ; $ANTLR end "fullAnnotation" $ANTLR start "annotationArgs" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:187:1: annotationArgs[AnnotationDescr descr] : LEFT_PAREN (value= ID | annotationElementValuePairs[descr] )? RIGHT_PAREN ; $ANTLR end "annotationValue" $ANTLR start "annotationArray" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:208:1: annotationArray : LEFT_CURLY ( annotationValue ( COMMA annotationValue )* )? RIGHT_CURLY ; $ANTLR end "annotationElementValuePairs" $ANTLR start "annotationElementValuePair" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:200:1: annotationElementValuePair[AnnotationDescr descr] : key= ID EQUALS_ASSIGN val= annotationValue ; $ANTLR end "annotationArgs" $ANTLR start "annotationElementValuePairs" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:196:1: annotationElementValuePairs[AnnotationDescr descr] : annotationElementValuePair[descr] ( COMMA annotationElementValuePair[descr] )* ; $ANTLR start "annotationValue" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:204:1: annotationValue : ( expression | annotationArray ); $ANTLR end "squareArguments" $ANTLR start "arguments" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:672:1: arguments : LEFT_PAREN ( expressionList )? RIGHT_PAREN ; $ANTLR end "innerCreator" $ANTLR start "arrayCreatorRest" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:618:1: arrayCreatorRest : LEFT_SQUARE ( RIGHT_SQUARE ( LEFT_SQUARE RIGHT_SQUARE )* arrayInitializer | expression RIGHT_SQUARE ({...}? => LEFT_SQUARE expression RIGHT_SQUARE )* ( ( LEFT_SQUARE RIGHT_SQUARE )=> LEFT_SQUARE RIGHT_SQUARE )* ) ; $ANTLR end "variableInitializer" $ANTLR start "arrayInitializer" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:630:1: arrayInitializer : LEFT_CURLY ( variableInitializer ( COMMA variableInitializer )* ( COMMA )? )? RIGHT_CURLY ; $ANTLR end "expressionList" $ANTLR start "assignmentOperator" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:684:1: assignmentOperator : ( EQUALS_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | MULT_ASSIGN | DIV_ASSIGN | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | MOD_ASSIGN | LESS LESS EQUALS_ASSIGN | ( GREATER GREATER GREATER )=> GREATER GREATER GREATER EQUALS_ASSIGN | ( GREATER GREATER )=> GREATER GREATER EQUALS_ASSIGN ); $ANTLR end "instanceof_key" $ANTLR start "boolean_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:714:1: boolean_key :{...}? =>id= ID ; $ANTLR end "char_key" $ANTLR start "byte_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:722:1: byte_key :{...}? =>id= ID ; $ANTLR end "unaryExpressionNotPlusMinus" $ANTLR start "castExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:520:1: castExpression : ( ( LEFT_PAREN primitiveType )=> LEFT_PAREN primitiveType RIGHT_PAREN expr= unaryExpression | ( LEFT_PAREN type )=> LEFT_PAREN type RIGHT_PAREN unaryExpressionNotPlusMinus ); $ANTLR end "boolean_key" $ANTLR start "char_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:718:1: char_key :{...}? =>id= ID ; $ANTLR end "arrayInitializer" $ANTLR start "classCreatorRest" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:634:1: classCreatorRest : arguments ; $ANTLR end "this_key" $ANTLR start "class_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:754:1: class_key :{...}? =>id= ID ; $ANTLR end "relationalOp" $ANTLR start "complexOp" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:125:1: complexOp returns [String opr] : t= TILDE e= EQUALS_ASSIGN ; $ANTLR end "conditionalOrExpression" $ANTLR start "conditionalAndExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:230:1: conditionalAndExpression returns [BaseDescr result] : left= inclusiveOrExpression ( DOUBLE_AMPER (args= fullAnnotation[null] )? right= inclusiveOrExpression )* ; $ANTLR end "expression" $ANTLR start "conditionalExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:168:1: conditionalExpression returns [BaseDescr result] : left= conditionalOrExpression ( ternaryExpression )? ; $ANTLR end "annotationArray" $ANTLR start "conditionalOrExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:214:1: conditionalOrExpression returns [BaseDescr result] : left= conditionalAndExpression ( DOUBLE_PIPE (args= fullAnnotation[null] )? right= conditionalAndExpression )* ; $ANTLR end "creator" $ANTLR start "createdName" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:608:1: createdName : ( ID ( typeArguments )? ( DOT ID ( typeArguments )? )* | primitiveType ); $ANTLR end "identifierSuffix" $ANTLR start "creator" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:603:1: creator : ( nonWildcardTypeArguments )? createdName ( arrayCreatorRest | classCreatorRest ) ; $ANTLR end "long_key" $ANTLR start "double_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:742:1: double_key :{...}? =>id= ID ; $ANTLR end "typeArgument" $ANTLR start "dummy" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:156:1: dummy : expression ( AT | SEMICOLON | EOF | ID | RIGHT_PAREN ) ; $ANTLR end "dummy" $ANTLR start "dummy2" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:159:1: dummy2 : relationalExpression EOF ; $ANTLR end "andExpression" $ANTLR start "equalityExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:285:1: equalityExpression returns [BaseDescr result] : left= instanceOfExpression ( (op= EQUALS |op= NOT_EQUALS ) right= instanceOfExpression )* ; $ANTLR end "inclusiveOrExpression" $ANTLR start "exclusiveOrExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:259:1: exclusiveOrExpression returns [BaseDescr result] : left= andExpression ( XOR right= andExpression )* ; $ANTLR end "classCreatorRest" $ANTLR start "explicitGenericInvocation" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:638:1: explicitGenericInvocation : nonWildcardTypeArguments arguments ; $ANTLR end "nonWildcardTypeArguments" $ANTLR start "explicitGenericInvocationSuffix" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:646:1: explicitGenericInvocationSuffix : ( super_key superSuffix | ID arguments ); $ANTLR start "expression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:163:1: expression returns [BaseDescr result] : left= conditionalExpression ( ( assignmentOperator )=>op= assignmentOperator right= expression )? ; $ANTLR end "arguments" $ANTLR start "expressionList" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:678:1: expressionList returns [java.util.List<String> exprs] : f= expression ( COMMA s= expression )* ; $ANTLR end "assignmentOperator" $ANTLR start "extends_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:702:1: extends_key :{...}? =>id= ID ; $ANTLR end "int_key" $ANTLR start "float_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:734:1: float_key :{...}? =>id= ID ; $ANTLR end "ternaryExpression" $ANTLR start "fullAnnotation" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:180:1: fullAnnotation[AnnotatedDescrBuilder inDescrBuilder] returns [AnnotationDescr result] : AT name= ID ( DOT x= ID )* annotationArgs[result] ; delegates $ANTLR end "parExpression" $ANTLR start "identifierSuffix" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:588:1: identifierSuffix : ( ( LEFT_SQUARE RIGHT_SQUARE )=> ( LEFT_SQUARE RIGHT_SQUARE )+ DOT class_key | ( ( LEFT_SQUARE )=> LEFT_SQUARE expression RIGHT_SQUARE )+ | arguments ); $ANTLR end "instanceOfExpression" $ANTLR start "inExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:311:1: inExpression returns [BaseDescr result] : left= relationalExpression ( ( not_key in_key )=> not_key in= in_key LEFT_PAREN e1= expression ( COMMA e2= expression )* RIGHT_PAREN |in= in_key LEFT_PAREN e1= expression ( COMMA e2= expression )* RIGHT_PAREN )? ; $ANTLR end "not_key" $ANTLR start "in_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:766:1: in_key :{...}? =>id= ID ; $ANTLR end "conditionalAndExpression" $ANTLR start "inclusiveOrExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:246:1: inclusiveOrExpression returns [BaseDescr result] : left= exclusiveOrExpression ( PIPE right= exclusiveOrExpression )* ; $ANTLR end "primary" $ANTLR start "inlineListExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:559:1: inlineListExpression : LEFT_SQUARE ( expressionList )? RIGHT_SQUARE ; $ANTLR end "inlineListExpression" $ANTLR start "inlineMapExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:563:1: inlineMapExpression : LEFT_SQUARE mapExpressionList RIGHT_SQUARE ; $ANTLR end "createdName" $ANTLR start "innerCreator" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:614:1: innerCreator :{...}? => ID classCreatorRest ; $ANTLR end "equalityExpression" $ANTLR start "instanceOfExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:298:1: instanceOfExpression returns [BaseDescr result] : left= inExpression (op= instanceof_key right= type )? ; $ANTLR start "instanceof_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:710:1: instanceof_key :{...}? =>id= ID ; $ANTLR end "short_key" $ANTLR start "int_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:730:1: int_key :{...}? =>id= ID ; $ANTLR start "literal" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:89:1: literal : ( STRING | DECIMAL | HEX | FLOAT | BOOL | NULL | TIME_INTERVAL | STAR ); $ANTLR end "float_key" $ANTLR start "long_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:738:1: long_key :{...}? =>id= ID ; $ANTLR end "mapExpressionList" $ANTLR start "mapEntry" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:573:1: mapEntry : expression COLON expression ; $ANTLR end "inlineMapExpression" $ANTLR start "mapExpressionList" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:569:1: mapExpressionList : mapEntry ( COMMA mapEntry )* ; $ANTLR end "additiveExpression" $ANTLR start "multiplicativeExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:461:1: multiplicativeExpression returns [BaseDescr result] : left= unaryExpression ( ( STAR | DIV | MOD ) unaryExpression )* ; $ANTLR start "neg_operator_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:774:1: neg_operator_key :{...}? =>id= ID ; $ANTLR end "class_key" $ANTLR start "new_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:758:1: new_key :{...}? =>id= ID ; $ANTLR end "explicitGenericInvocation" $ANTLR start "nonWildcardTypeArguments" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:642:1: nonWildcardTypeArguments : LESS typeList GREATER ; $ANTLR end "new_key" $ANTLR start "not_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:762:1: not_key :{...}? =>id= ID ; $ANTLR start "operator" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:100:1: operator returns [boolean negated, String opr] : (x= TILDE )? (op= EQUALS |op= NOT_EQUALS |rop= relationalOp ) ; $ANTLR start "operator_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:770:1: operator_key :{...}? =>id= ID ; $ANTLR end "relationalExpression" $ANTLR start "orRestriction" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:391:1: orRestriction returns [BaseDescr result] : left= andRestriction ( ( DOUBLE_PIPE ( fullAnnotation[null] )? andRestriction )=>lop= DOUBLE_PIPE (args= fullAnnotation[null] )? right= andRestriction )* ( EOF )? ; $ANTLR end "mapEntry" $ANTLR start "parExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:577:1: parExpression returns [BaseDescr result] : LEFT_PAREN expr= expression RIGHT_PAREN ; $ANTLR end "primitiveType" $ANTLR start "primary" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:536:1: primary returns [BaseDescr result] : ( ( LEFT_PAREN )=>expr= parExpression | ( nonWildcardTypeArguments )=> nonWildcardTypeArguments ( explicitGenericInvocationSuffix | this_key arguments ) | ( literal )=> literal | ( super_key )=> super_key superSuffix | ( new_key )=> new_key creator | ( primitiveType )=> primitiveType ( LEFT_SQUARE RIGHT_SQUARE )* DOT class_key | ( inlineMapExpression )=> inlineMapExpression | ( inlineListExpression )=> inlineListExpression | ( ID )=>i1= ID ( ( ( DOT ID )=> DOT i2= ID ) | ( ( SHARP ID )=> SHARP i2= ID ) | ( ( HASH ID )=> HASH i2= ID ) | ( ( NULL_SAFE_DOT ID )=> NULL_SAFE_DOT i2= ID ) )* ( ( identifierSuffix )=> identifierSuffix )? ); $ANTLR end "castExpression" $ANTLR start "primitiveType" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:525:1: primitiveType : ( boolean_key | char_key | byte_key | short_key | int_key | long_key | float_key | double_key ); $ANTLR start "relationalExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:354:1: relationalExpression returns [BaseDescr result] : left= shiftExpression ( ( operator | LEFT_PAREN )=>right= orRestriction )* ; $ANTLR start "relationalOp" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:112:1: relationalOp returns [boolean negated, String opr, java.util.List<String> params] : (op= LESS_EQUALS |op= GREATER_EQUALS |op= LESS |op= GREATER |xop= complexOp | not_key nop= neg_operator_key |cop= operator_key ) ; $ANTLR end "explicitGenericInvocationSuffix" $ANTLR start "selector" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:651:1: selector : ( ( DOT super_key )=> DOT super_key superSuffix | ( DOT new_key )=> DOT new_key ( nonWildcardTypeArguments )? innerCreator | ( DOT ID )=> DOT ID ( ( LEFT_PAREN )=> arguments )? | ( LEFT_SQUARE )=> LEFT_SQUARE expression RIGHT_SQUARE ); $ANTLR start "shiftExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:445:1: shiftExpression returns [BaseDescr result] : left= additiveExpression ( ( shiftOp )=> shiftOp additiveExpression )* ; $ANTLR end "shiftExpression" $ANTLR start "shiftOp" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:450:1: shiftOp : ( LESS LESS | GREATER GREATER GREATER | GREATER GREATER ) ; $ANTLR end "byte_key" $ANTLR start "short_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:726:1: short_key :{...}? =>id= ID ; $ANTLR end "andRestriction" $ANTLR start "singleRestriction" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:421:1: singleRestriction returns [BaseDescr result] : (op= operator ( ( squareArguments shiftExpression )=>sa= squareArguments value= shiftExpression |value= shiftExpression ) | LEFT_PAREN or= orRestriction RIGHT_PAREN ); $ANTLR end "superSuffix" $ANTLR start "squareArguments" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:668:1: squareArguments returns [java.util.List<String> args] : LEFT_SQUARE (el= expressionList )? RIGHT_SQUARE ; $ANTLR end "selector" $ANTLR start "superSuffix" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:663:1: superSuffix : ( arguments | DOT ID ( ( LEFT_PAREN )=> arguments )? ); $ANTLR end "extends_key" $ANTLR start "super_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:706:1: super_key :{...}? =>id= ID ; $ANTLR end synpred9_DRL5Expressions $ANTLR start synpred10_DRL5Expressions $ANTLR end synpred10_DRL5Expressions $ANTLR start synpred11_DRL5Expressions $ANTLR end synpred11_DRL5Expressions $ANTLR start synpred12_DRL5Expressions $ANTLR end synpred12_DRL5Expressions $ANTLR start synpred13_DRL5Expressions $ANTLR end synpred13_DRL5Expressions $ANTLR start synpred14_DRL5Expressions $ANTLR end synpred14_DRL5Expressions $ANTLR start synpred15_DRL5Expressions $ANTLR end synpred15_DRL5Expressions $ANTLR start synpred16_DRL5Expressions $ANTLR end synpred16_DRL5Expressions $ANTLR start synpred17_DRL5Expressions $ANTLR end synpred17_DRL5Expressions $ANTLR start synpred18_DRL5Expressions $ANTLR end synpred18_DRL5Expressions $ANTLR start synpred19_DRL5Expressions $ANTLR end "neg_operator_key" $ANTLR start synpred1_DRL5Expressions $ANTLR end synpred19_DRL5Expressions $ANTLR start synpred20_DRL5Expressions $ANTLR end synpred20_DRL5Expressions $ANTLR start synpred21_DRL5Expressions $ANTLR end synpred21_DRL5Expressions $ANTLR start synpred22_DRL5Expressions $ANTLR end synpred22_DRL5Expressions $ANTLR start synpred23_DRL5Expressions $ANTLR end synpred23_DRL5Expressions $ANTLR start synpred24_DRL5Expressions $ANTLR end synpred24_DRL5Expressions $ANTLR start synpred25_DRL5Expressions $ANTLR end synpred25_DRL5Expressions $ANTLR start synpred26_DRL5Expressions $ANTLR end synpred26_DRL5Expressions $ANTLR start synpred27_DRL5Expressions $ANTLR end synpred27_DRL5Expressions $ANTLR start synpred28_DRL5Expressions $ANTLR end synpred28_DRL5Expressions $ANTLR start synpred29_DRL5Expressions $ANTLR end synpred1_DRL5Expressions $ANTLR start synpred2_DRL5Expressions $ANTLR end synpred29_DRL5Expressions $ANTLR start synpred30_DRL5Expressions $ANTLR end synpred30_DRL5Expressions $ANTLR start synpred31_DRL5Expressions $ANTLR end synpred31_DRL5Expressions $ANTLR start synpred32_DRL5Expressions $ANTLR end synpred32_DRL5Expressions $ANTLR start synpred33_DRL5Expressions $ANTLR end synpred33_DRL5Expressions $ANTLR start synpred34_DRL5Expressions $ANTLR end synpred34_DRL5Expressions $ANTLR start synpred35_DRL5Expressions $ANTLR end synpred35_DRL5Expressions $ANTLR start synpred36_DRL5Expressions $ANTLR end synpred43_DRL5Expressions Delegated rules $ANTLR end synpred36_DRL5Expressions $ANTLR start synpred37_DRL5Expressions $ANTLR end synpred37_DRL5Expressions $ANTLR start synpred38_DRL5Expressions $ANTLR end synpred38_DRL5Expressions $ANTLR start synpred39_DRL5Expressions $ANTLR end synpred2_DRL5Expressions $ANTLR start synpred3_DRL5Expressions $ANTLR end synpred39_DRL5Expressions $ANTLR start synpred40_DRL5Expressions $ANTLR end synpred40_DRL5Expressions $ANTLR start synpred41_DRL5Expressions $ANTLR end synpred41_DRL5Expressions $ANTLR start synpred42_DRL5Expressions $ANTLR end synpred42_DRL5Expressions $ANTLR start synpred43_DRL5Expressions $ANTLR end synpred3_DRL5Expressions $ANTLR start synpred4_DRL5Expressions $ANTLR end synpred4_DRL5Expressions $ANTLR start synpred5_DRL5Expressions $ANTLR end synpred5_DRL5Expressions $ANTLR start synpred6_DRL5Expressions $ANTLR end synpred6_DRL5Expressions $ANTLR start synpred7_DRL5Expressions $ANTLR end synpred7_DRL5Expressions $ANTLR start synpred8_DRL5Expressions $ANTLR end synpred8_DRL5Expressions $ANTLR start synpred9_DRL5Expressions $ANTLR end "conditionalExpression" $ANTLR start "ternaryExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:173:1: ternaryExpression : QUESTION ts= expression COLON fs= expression ; $ANTLR end "void_key" $ANTLR start "this_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:750:1: this_key :{...}? =>id= ID ; $ANTLR start "type" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:133:1: type : tm= typeMatch ; $ANTLR end "typeArguments" $ANTLR start "typeArgument" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:146:1: typeArgument : ( type | QUESTION ( ( extends_key | super_key ) type )? ); $ANTLR end "typeMatch" $ANTLR start "typeArguments" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:142:1: typeArguments : LESS typeArgument ( COMMA typeArgument )* GREATER ; $ANTLR end "complexOp" $ANTLR start "typeList" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:129:1: typeList : type ( COMMA type )* ; $ANTLR end "type" $ANTLR start "typeMatch" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:137:1: typeMatch : ( ( primitiveType )=> ( primitiveType ( ( LEFT_SQUARE RIGHT_SQUARE )=> LEFT_SQUARE RIGHT_SQUARE )* ) | ( ID ( ( typeArguments )=> typeArguments )? ( DOT ID ( ( typeArguments )=> typeArguments )? )* ( ( LEFT_SQUARE RIGHT_SQUARE )=> LEFT_SQUARE RIGHT_SQUARE )* ) ); $ANTLR end "multiplicativeExpression" $ANTLR start "unaryExpression" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:466:1: unaryExpression returns [BaseDescr result] : ( PLUS ue= unaryExpression | MINUS ue= unaryExpression | INCR primary | DECR primary |left= unaryExpressionNotPlusMinus ); $ANTLR start "unaryExpressionNotPlusMinus" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:486:1: unaryExpressionNotPlusMinus returns [BaseDescr result] : ( TILDE unaryExpression | NEGATION unaryExpression | ( castExpression )=> castExpression | ( ({...}? (var= ID COLON ) ) | ({...}? (var= ID UNIFY ) ) )? left= primary ( ( selector )=> selector )* ( ( INCR | DECR )=> ( INCR | DECR ) )? ); $ANTLR end "arrayCreatorRest" $ANTLR start "variableInitializer" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:625:1: variableInitializer : ( arrayInitializer | expression ); $ANTLR end "double_key" $ANTLR start "void_key" src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:746:1: void_key :{...}? =>id= ID ;
The standard method called to automatically emit a token at the outermost lexical rule.  The token object should point into the char buffer start..stop.  If there is a text override in 'text', use that to set the token's text.  Override this method to emit custom Token objects. Overrided this method to not output mesages delegates delegators return the raw DroolsParserException errors $ANTLR end "PIPE" $ANTLR start "AMPER" $ANTLR end "DIV_ASSIGN" $ANTLR start "AND_ASSIGN" $ANTLR end "INCR" $ANTLR start "ARROW" $ANTLR end "NULL" $ANTLR start "AT" $ANTLR end "UnicodeEscape" $ANTLR start "BOOL" $ANTLR end "SEMICOLON" $ANTLR start "COLON" $ANTLR end "RIGHT_CURLY" $ANTLR start "COMMA" $ANTLR end "HASH" $ANTLR start "C_STYLE_SINGLE_LINE_COMMENT" $ANTLR end "HEX" $ANTLR start "DECIMAL" $ANTLR end "UNIFY" $ANTLR start "DECR" $ANTLR end "ID" $ANTLR start "DIV" $ANTLR end "MULT_ASSIGN" $ANTLR start "DIV_ASSIGN" $ANTLR end "COMMA" $ANTLR start "DOT" $ANTLR end "NULL_SAFE_DOT" $ANTLR start "DOUBLE_AMPER" $ANTLR end "DOUBLE_AMPER" $ANTLR start "DOUBLE_PIPE" $ANTLR end "WS" $ANTLR start "EOL" $ANTLR end "COLON" $ANTLR start "EQUALS" $ANTLR end "LESS" $ANTLR start "EQUALS_ASSIGN" $ANTLR end "HexDigit" $ANTLR start "EscapeSequence" $ANTLR end "FLOAT" $ANTLR start "Exponent" $ANTLR end "EOL" $ANTLR start "FLOAT" $ANTLR end "Exponent" $ANTLR start "FloatTypeSuffix" $ANTLR end "LESS_EQUALS" $ANTLR start "GREATER" $ANTLR end "NOT_EQUALS" $ANTLR start "GREATER_EQUALS" $ANTLR end "PLUS" $ANTLR start "HASH" $ANTLR end "FloatTypeSuffix" $ANTLR start "HEX" $ANTLR end "TIME_INTERVAL" $ANTLR start "HexDigit" $ANTLR end "MULTI_LINE_COMMENT" $ANTLR start "ID" $ANTLR end "DECR" $ANTLR start "INCR" $ANTLR end "IdentifierStart" $ANTLR start "IdentifierPart" $ANTLR end "MISC" $ANTLR start "IdentifierStart" $ANTLR end "DECIMAL" $ANTLR start "IntegerTypeSuffix" $ANTLR end "RIGHT_SQUARE" $ANTLR start "LEFT_CURLY" $ANTLR end "EQUALS_ASSIGN" $ANTLR start "LEFT_PAREN" $ANTLR end "RIGHT_PAREN" $ANTLR start "LEFT_SQUARE" $ANTLR end "GREATER" $ANTLR start "LESS" $ANTLR end "GREATER_EQUALS" $ANTLR start "LESS_EQUALS" $ANTLR end "STAR" $ANTLR start "MINUS" $ANTLR end "PLUS_ASSIGN" $ANTLR start "MINUS_ASSIGN" $ANTLR end "DIV" $ANTLR start "MISC" $ANTLR end "XOR" $ANTLR start "MOD" $ANTLR end "XOR_ASSIGN" $ANTLR start "MOD_ASSIGN" $ANTLR end "C_STYLE_SINGLE_LINE_COMMENT" $ANTLR start "MULTI_LINE_COMMENT" $ANTLR end "MINUS_ASSIGN" $ANTLR start "MULT_ASSIGN" $ANTLR end "QUESTION" $ANTLR start "NEGATION" $ANTLR end "EQUALS" $ANTLR start "NOT_EQUALS" $ANTLR end "BOOL" $ANTLR start "NULL" $ANTLR end "DOT" $ANTLR start "NULL_SAFE_DOT" $ANTLR end "AND_ASSIGN" $ANTLR start "OR_ASSIGN" $ANTLR end "EscapeSequence" $ANTLR start "OctalEscape" $ANTLR end "TILDE" $ANTLR start "PIPE" $ANTLR end "MINUS" $ANTLR start "PLUS" $ANTLR end "AT" $ANTLR start "PLUS_ASSIGN" $ANTLR end "DOUBLE_PIPE" $ANTLR start "QUESTION" $ANTLR end "LEFT_CURLY" $ANTLR start "RIGHT_CURLY" $ANTLR end "LEFT_PAREN" $ANTLR start "RIGHT_PAREN" $ANTLR end "LEFT_SQUARE" $ANTLR start "RIGHT_SQUARE" $ANTLR end "ARROW" $ANTLR start "SEMICOLON" $ANTLR end "MOD" $ANTLR start "STAR" $ANTLR end "IntegerTypeSuffix" $ANTLR start "STRING" $ANTLR end "NEGATION" $ANTLR start "TILDE" $ANTLR end "STRING" $ANTLR start "TIME_INTERVAL" $ANTLR end "IdentifierPart" $ANTLR end "MOD_ASSIGN" $ANTLR start "UNIFY" $ANTLR end "OctalEscape" $ANTLR start "UnicodeEscape" $ANTLR start "WS" $ANTLR end "AMPER" $ANTLR start "XOR" $ANTLR end "OR_ASSIGN" $ANTLR start "XOR_ASSIGN" $ANTLR end synpred1_DRL5Lexer $ANTLR start synpred1_DRL5Lexer
accumulateFunction := label? ID parameters accumulateFunctionBinding := label accumulateFunction ------------------------------------------------------------------------------------------------ ANNOTATION ------------------------------------------------------------------------------------------------ annotation := fullAnnotation | AT ID chunk_(_)? attribute := salience |   enabled |   ( NO-LOOP | AUTO-FOCUS | LOCK-ON-ACTIVE | REFRACT ) BOOLEAN? |   ( AGENDA-GROUP | ACTIVATION-GROUP | RULEFLOW-GROUP | DATE-EFFECTIVE | DATE-EXPIRES | DIALECT ) STRING |   CALENDARS STRING (COMMA STRING)* |   TIMER ( DECIMAL | chunk_(_) ) |   DURATION ( DECIMAL | chunk_(_) ) The above syntax is not quite how this is parsed, because the soft keyword is determined by look-ahead and passed on to one of the x-Attribute methods (booleanAttribute, stringAttribute, stringListAttribute, intOrChunkAttribute) which will actually gobble the tokens. attributes := (ATTRIBUTES COLON?)? [ attribute ( COMMA? attribute )* ] booleanAttribute := attributeKey (BOOLEAN)? breakingNamedConsequence := BREAK LEFT_SQUARE ID RIGHT_SQUARE Matches a chunk started by the leftDelimiter and ended by the rightDelimiter. ------------------------------------------------------------------------------------------------ GRAMMAR RULES ------------------------------------------------------------------------------------------------ conditionalBranch := IF LEFT_PAREN conditionalExpression RIGHT_PAREN ( namedConsequence | breakingNamedConsequence ) ( ELSE ( namedConsequence | breakingNamedConsequence | conditionalBranch ) )? Matches a conditional expression Matches a conditional || expression consequenceInvocation := conditionalBranch | namedConsequence constraint := nestedConstraint | conditionalOrExpression constraints := constraint (COMMA constraint)* ------------------------------------------------------------------------------------------------ DECLARE STATEMENT ------------------------------------------------------------------------------------------------ declare := DECLARE | (ENTRY-POINT) => entryPointDeclaration | (WINDOW) => windowDeclaration | (TRAIT) => typeDeclaration (trait) | (ENUM) => enumDeclaration | typeDeclaration (class) END defaultConsequence := THEN chunk enabled := ENABLED conditionalExpression entryPointDeclaration := ENTRY-POINT stringId annotation* END typeDeclaration := [ENUM] qualifiedIdentifier annotation* enumerative+ field* END @return @throws RecognitionException enumerative := ID ( LEFT_PAREN expression (COMMA expression)* RIGHT_PAREN )? field := label fieldType (EQUALS_ASSIGN conditionalExpression)? annotation* SEMICOLON? filterDef := label ID LEFT_PAREN parameters RIGHT_PAREN fromAccumulate := ACCUMULATE LEFT_PAREN lhsAnd COMMA ( INIT chunk_(_) COMMA ACTION chunk_(_) COMMA ( REVERSE chunk_(_) COMMA)? RESULT chunk_(_) | accumulateFunction ) RIGHT_PAREN fromCollect := COLLECT LEFT_PAREN lhsPatternBind RIGHT_PAREN fromEntryPoint := ENTRY-POINT stringId fromExpression := conditionalOrExpression fromWindow := WINDOW ID ------------------------------------------------------------------------------------------------ FUNCTION STATEMENT ------------------------------------------------------------------------------------------------ function := FUNCTION type? ID parameters(typed) chunk_{_} ------------------------------------------------------------------------------------------------ GLOBAL STATEMENT ------------------------------------------------------------------------------------------------ globalStatement := GLOBAL type ID ------------------------------------------------------------------------------------------------ IMPORT STATEMENT ------------------------------------------------------------------------------------------------ importStatement := IMPORT (FUNCTION|STATIC)? qualifiedIdentifier (DOT STAR)? intOrChunkAttribute := attributeKey ( DECIMAL | chunk_(_) ) label := ID COLON lhs := WHEN COLON? lhsExpression lhsAccumulate := ACCUMULATE LEFT_PAREN lhsAnd (COMMA|SEMICOLON) accumulateFunctionBinding (COMMA accumulateFunctionBinding)* (SEMICOLON constraints)? RIGHT_PAREN SEMICOLON? lhsAnd := LEFT_PAREN AND lhsUnary+ RIGHT_PAREN | lhsUnary (AND lhsUnary)* lhsEval := EVAL LEFT_PAREN conditionalExpression RIGHT_PAREN lhsExists := EXISTS ( (LEFT_PAREN (or_key|and_key))=> lhsOr  // prevents '((' for prefixed and/or | LEFT_PAREN lhsOr RIGHT_PAREN | lhsPatternBind ) lhsExpression := lhsOr* lhsForall := FORALL LEFT_PAREN lhsPatternBind+ RIGHT_PAREN lhsNot := NOT ( (LEFT_PAREN (or_key|and_key))=> lhsOr  // prevents '((' for prefixed and/or | LEFT_PAREN lhsOr RIGHT_PAREN | lhsPatternBind ) lhsOr := LEFT_PAREN OR lhsAnd+ RIGHT_PAREN | lhsAnd (OR lhsAnd)* lhsParen := LEFT_PAREN lhsOr RIGHT_PAREN lhsPattern := QUESTION? qualifiedIdentifier LEFT_PAREN positionalConstraints? constraints? RIGHT_PAREN (OVER patternFilter)? (FROM patternSource)? lhsPatternBind := label? ( LEFT_PAREN lhsPattern (OR lhsPattern)* RIGHT_PAREN | lhsPattern ) lhsUnary := ( lhsExists namedConsequence? | lhsNot namedConsequence? | lhsEval consequenceInvocation* | lhsForall | lhsAccumulate | LEFT_PAREN lhsOr RIGHT_PAREN namedConsequence? | lhsPatternBind consequenceInvocation* ) SEMICOLON? ------------------------------------------------------------------------------------------------ GENERAL UTILITY METHODS ------------------------------------------------------------------------------------------------ Match current input symbol against ttype and optionally check the text of the token against text.  Attempt single token insertion or deletion error recovery.  If that fails, throw MismatchedTokenException. namedConsequence := DO LEFT_SQUARE ID RIGHT_SQUARE BREAK? namedConsequence := THEN LEFT_SQUARE ID RIGHT_SQUARE chunk nestedConstraint := ( ID ( DOT | HASH ) )* ID DOT LEFT_PAREN constraints RIGHT_PAREN Parses a package statement and returns the name of the package or null if none is defined. packageStatement := PACKAGE qualifiedIdentifier SEMICOLON? parameter := ({requiresType}?=>type)? ID (LEFT_SQUARE RIGHT_SQUARE)* parameters := LEFT_PAREN (conditionalExpression (COMMA conditionalExpression)* )? RIGHT_PAREN parameters := LEFT_PAREN ( parameter ( COMMA parameter )* )? RIGHT_PAREN patternFilter :=   OVER filterDef DISALLOWED:        | ( PIPE filterDef )+ patternSource := FROM ( fromAccumulate | fromCollect | fromEntryPoint | fromWindow | fromExpression ) positionalConstraints := constraint (COMMA constraint)* SEMICOLON Matches a qualified identifier qualifiedIdentifier := ID ( DOT ID )* ------------------------------------------------------------------------------------------------ QUERY STATEMENT ------------------------------------------------------------------------------------------------ query := QUERY stringId parameters? annotation* lhsExpression END Attempt to recover from a single missing or extra token. EXTRA TOKEN LA(1) is not what we are looking for.  If LA(2) has the right token, however, then assume LA(1) is some extra spurious token.  Delete it and LA(2) as if we were doing a normal match(), which advances the input. MISSING TOKEN If current token is consistent with what could come after ttype then it is ok to "insert" the missing token, else throw exception For example, Input "i=(3;" is clearly missing the ')'.  When the parser returns from the nested call to expr, it will have call chain: stat -> expr -> atom and it will be trying to match the ')' at this point in the derivation: => ID '=' '(' INT ')' ('+' atom)* ';' ^ match() will see that ';' doesn't match ')' and report a mismatched token error.  To recover, it sees that LA(1)==';' is in the set of tokens that can follow the ')' token reference in rule atom.  It can assume that you forgot the ')'. rhs := defaultConsequence namedConsequence* (~END)* ------------------------------------------------------------------------------------------------ RULE STATEMENT ------------------------------------------------------------------------------------------------ rule := RULE stringId (EXTENDS stringId)? annotation* attributes? lhs? rhs END salience := SALIENCE conditionalExpression Invokes the expression parser, trying to parse the annotation as a full java-style annotation statement := importStatement |  globalStatement |  declare |  rule |  ruleAttribute |  function |  query ; stringAttribute := attributeKey STRING stringId := ( ID | STRING ) stringListAttribute := attributeKey STRING (COMMA STRING)* ------------------------------------------------------------------------------------------------ UTILITY RULES ------------------------------------------------------------------------------------------------ Matches a type name type := ID typeArguments? ( DOT ID typeArguments? )* (LEFT_SQUARE RIGHT_SQUARE)* Matches a type argument typeArguments := QUESTION (( EXTENDS | SUPER ) type )? |  type ; Matches type arguments typeArguments := LESS typeArgument (COMMA typeArgument)* GREATER typeDeclaration := [TYPE] qualifiedIdentifier (EXTENDS qualifiedIdentifier)? annotation* field* END unif := ID UNIFY windowDeclaration := WINDOW ID annotation* lhsPatternBind END
$ANTLR end "shiftOp" $ANTLR start "additiveExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:470:1: additiveExpression returns [BaseDescr result] : left= multiplicativeExpression ( ( PLUS | MINUS )=> ( PLUS | MINUS ) multiplicativeExpression )* ; $ANTLR end "exclusiveOrExpression" $ANTLR start "andExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:286:1: andExpression returns [BaseDescr result] : left= equalityExpression ( AMPER right= equalityExpression )* ; $ANTLR end "orRestriction" $ANTLR start "andRestriction" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:419:1: andRestriction returns [BaseDescr result] : left= singleRestriction ( ( DOUBLE_AMPER ( fullAnnotation[null] )? operator )=>lop= DOUBLE_AMPER (args= fullAnnotation[null] )? right= singleRestriction )* ; $ANTLR end "fullAnnotation" $ANTLR start "annotationArgs" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:196:1: annotationArgs[AnnotationDescr descr, AnnotatedDescrBuilder inDescrBuilder] : LEFT_PAREN ( ( ID EQUALS_ASSIGN )=> annotationElementValuePairs[descr, inDescrBuilder] |value= annotationValue[inDescrBuilder] )? RIGHT_PAREN ; $ANTLR end "annotationValue" $ANTLR start "annotationArray" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:219:1: annotationArray[AnnotatedDescrBuilder inDescrBuilder] returns [java.util.List result] : LEFT_CURLY (anno= annotationValue[inDescrBuilder] ( COMMA anno= annotationValue[inDescrBuilder] )* )? RIGHT_CURLY ; $ANTLR end "annotationElementValuePairs" $ANTLR start "annotationElementValuePair" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:209:1: annotationElementValuePair[AnnotationDescr descr, AnnotatedDescrBuilder inDescrBuilder] : key= ID EQUALS_ASSIGN val= annotationValue[inDescrBuilder] ; $ANTLR end "annotationArgs" $ANTLR start "annotationElementValuePairs" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:205:1: annotationElementValuePairs[AnnotationDescr descr, AnnotatedDescrBuilder inDescrBuilder] : annotationElementValuePair[descr, inDescrBuilder] ( COMMA annotationElementValuePair[descr, inDescrBuilder] )* ; $ANTLR end "annotationElementValuePair" $ANTLR start "annotationValue" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:213:1: annotationValue[AnnotatedDescrBuilder inDescrBuilder] returns [Object result] : (exp= expression |annos= annotationArray[inDescrBuilder] |anno= fullAnnotation[inDescrBuilder] ); $ANTLR end "squareArguments" $ANTLR start "arguments" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:717:1: arguments : LEFT_PAREN ( expressionList )? RIGHT_PAREN ; $ANTLR end "innerCreator" $ANTLR start "arrayCreatorRest" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:663:1: arrayCreatorRest : LEFT_SQUARE ( RIGHT_SQUARE ( LEFT_SQUARE RIGHT_SQUARE )* arrayInitializer | expression RIGHT_SQUARE ({...}? => LEFT_SQUARE expression RIGHT_SQUARE )* ( ( LEFT_SQUARE RIGHT_SQUARE )=> LEFT_SQUARE RIGHT_SQUARE )* ) ; $ANTLR end "variableInitializer" $ANTLR start "arrayInitializer" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:675:1: arrayInitializer : LEFT_CURLY ( variableInitializer ( COMMA variableInitializer )* ( COMMA )? )? RIGHT_CURLY ; $ANTLR end "expressionList" $ANTLR start "assignmentOperator" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:729:1: assignmentOperator : ( EQUALS_ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | MULT_ASSIGN | DIV_ASSIGN | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | MOD_ASSIGN | LESS LESS EQUALS_ASSIGN | ( GREATER GREATER GREATER )=> GREATER GREATER GREATER EQUALS_ASSIGN | ( GREATER GREATER )=> GREATER GREATER EQUALS_ASSIGN ); $ANTLR end "castExpression" $ANTLR start "backReferenceExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:544:1: backReferenceExpression : ( DOT DOT DIV )=> ( DOT DOT DIV )+ unaryExpressionNotPlusMinus ; $ANTLR end "instanceof_key" $ANTLR start "boolean_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:759:1: boolean_key :{...}? =>id= ID ; $ANTLR end "char_key" $ANTLR start "byte_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:767:1: byte_key :{...}? =>id= ID ; $ANTLR end "unaryExpressionNotPlusMinus" $ANTLR start "castExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:539:1: castExpression : ( ( LEFT_PAREN primitiveType )=> LEFT_PAREN primitiveType RIGHT_PAREN expr= unaryExpression | ( LEFT_PAREN type )=> LEFT_PAREN type RIGHT_PAREN unaryExpressionNotPlusMinus ); $ANTLR end "boolean_key" $ANTLR start "char_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:763:1: char_key :{...}? =>id= ID ; $ANTLR end "arrayInitializer" $ANTLR start "classCreatorRest" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:679:1: classCreatorRest : arguments ; $ANTLR end "this_key" $ANTLR start "class_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:799:1: class_key :{...}? =>id= ID ; $ANTLR end "relationalOp" $ANTLR start "complexOp" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:125:1: complexOp returns [String opr] : t= TILDE e= EQUALS_ASSIGN ; $ANTLR end "conditionalOrExpression" $ANTLR start "conditionalAndExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:244:1: conditionalAndExpression returns [BaseDescr result] : left= inclusiveOrExpression ( DOUBLE_AMPER (args= fullAnnotation[null] )? right= inclusiveOrExpression )* ; $ANTLR end "expression" $ANTLR start "conditionalExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:168:1: conditionalExpression returns [BaseDescr result] : left= conditionalOrExpression ( ternaryExpression )? ; $ANTLR end "annotationArray" $ANTLR start "conditionalOrExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:228:1: conditionalOrExpression returns [BaseDescr result] : left= conditionalAndExpression ( DOUBLE_PIPE (args= fullAnnotation[null] )? right= conditionalAndExpression )* ; $ANTLR end "creator" $ANTLR start "createdName" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:653:1: createdName : ( ID ( typeArguments )? ( DOT ID ( typeArguments )? )* | primitiveType ); $ANTLR end "identifierSuffix" $ANTLR start "creator" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:648:1: creator : ( nonWildcardTypeArguments )? createdName ( arrayCreatorRest | classCreatorRest ) ; $ANTLR end "long_key" $ANTLR start "double_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:787:1: double_key :{...}? =>id= ID ; $ANTLR end "typeArgument" $ANTLR start "dummy" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:156:1: dummy : expression ( AT | SEMICOLON | EOF | ID | RIGHT_PAREN ) ; $ANTLR end "dummy" $ANTLR start "dummy2" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:159:1: dummy2 : relationalExpression EOF ; $ANTLR end "andExpression" $ANTLR start "equalityExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:299:1: equalityExpression returns [BaseDescr result] : left= instanceOfExpression ( (op= EQUALS |op= NOT_EQUALS ) right= instanceOfExpression )* ; $ANTLR end "inclusiveOrExpression" $ANTLR start "exclusiveOrExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:273:1: exclusiveOrExpression returns [BaseDescr result] : left= andExpression ( XOR right= andExpression )* ; $ANTLR end "classCreatorRest" $ANTLR start "explicitGenericInvocation" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:683:1: explicitGenericInvocation : nonWildcardTypeArguments arguments ; $ANTLR end "nonWildcardTypeArguments" $ANTLR start "explicitGenericInvocationSuffix" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:691:1: explicitGenericInvocationSuffix : ( super_key superSuffix | ID arguments ); $ANTLR start "expression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:163:1: expression returns [BaseDescr result] : left= conditionalExpression ( ( assignmentOperator )=>op= assignmentOperator right= expression )? ; $ANTLR end "arguments" $ANTLR start "expressionList" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:723:1: expressionList returns [java.util.List<String> exprs] : f= expression ( COMMA s= expression )* ; $ANTLR end "assignmentOperator" $ANTLR start "extends_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:747:1: extends_key :{...}? =>id= ID ; $ANTLR end "int_key" $ANTLR start "float_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:779:1: float_key :{...}? =>id= ID ; $ANTLR end "ternaryExpression" $ANTLR start "fullAnnotation" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:180:1: fullAnnotation[AnnotatedDescrBuilder inDescrBuilder] returns [AnnotationDescr result] : AT name= ID ( DOT x= ID )* annotationArgs[result, annoBuilder] ; delegates $ANTLR end "parExpression" $ANTLR start "identifierSuffix" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:633:1: identifierSuffix : ( ( LEFT_SQUARE RIGHT_SQUARE )=> ( LEFT_SQUARE RIGHT_SQUARE )+ DOT class_key | ( ( LEFT_SQUARE )=> LEFT_SQUARE expression RIGHT_SQUARE )+ | arguments ); $ANTLR end "instanceOfExpression" $ANTLR start "inExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:325:1: inExpression returns [BaseDescr result] : left= relationalExpression ( ( not_key in_key )=> not_key in= in_key LEFT_PAREN e1= expression ( COMMA e2= expression )* RIGHT_PAREN |in= in_key LEFT_PAREN e1= expression ( COMMA e2= expression )* RIGHT_PAREN )? ; $ANTLR end "not_key" $ANTLR start "in_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:811:1: in_key :{...}? =>id= ID ; $ANTLR end "conditionalAndExpression" $ANTLR start "inclusiveOrExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:260:1: inclusiveOrExpression returns [BaseDescr result] : left= exclusiveOrExpression ( PIPE right= exclusiveOrExpression )* ; $ANTLR end "primary" $ANTLR start "inlineListExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:604:1: inlineListExpression : LEFT_SQUARE ( expressionList )? RIGHT_SQUARE ; $ANTLR end "inlineListExpression" $ANTLR start "inlineMapExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:608:1: inlineMapExpression : LEFT_SQUARE mapExpressionList RIGHT_SQUARE ; $ANTLR end "createdName" $ANTLR start "innerCreator" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:659:1: innerCreator :{...}? => ID classCreatorRest ; $ANTLR end "equalityExpression" $ANTLR start "instanceOfExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:312:1: instanceOfExpression returns [BaseDescr result] : left= inExpression (op= instanceof_key right= type )? ; $ANTLR start "instanceof_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:755:1: instanceof_key :{...}? =>id= ID ; $ANTLR end "short_key" $ANTLR start "int_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:775:1: int_key :{...}? =>id= ID ; $ANTLR start "literal" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:89:1: literal : ( STRING | DECIMAL | HEX | FLOAT | BOOL | NULL | TIME_INTERVAL | STAR ); $ANTLR end "float_key" $ANTLR start "long_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:783:1: long_key :{...}? =>id= ID ; $ANTLR end "mapExpressionList" $ANTLR start "mapEntry" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:618:1: mapEntry : expression COLON expression ; $ANTLR end "inlineMapExpression" $ANTLR start "mapExpressionList" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:614:1: mapExpressionList : mapEntry ( COMMA mapEntry )* ; $ANTLR end "additiveExpression" $ANTLR start "multiplicativeExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:475:1: multiplicativeExpression returns [BaseDescr result] : left= unaryExpression ( ( STAR | DIV | MOD ) unaryExpression )* ; $ANTLR start "neg_operator_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:819:1: neg_operator_key :{...}? =>id= ID ; $ANTLR end "class_key" $ANTLR start "new_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:803:1: new_key :{...}? =>id= ID ; $ANTLR end "explicitGenericInvocation" $ANTLR start "nonWildcardTypeArguments" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:687:1: nonWildcardTypeArguments : LESS typeList GREATER ; $ANTLR end "new_key" $ANTLR start "not_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:807:1: not_key :{...}? =>id= ID ; $ANTLR start "operator" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:100:1: operator returns [boolean negated, String opr] : (x= TILDE )? (op= EQUALS |op= NOT_EQUALS |rop= relationalOp ) ; $ANTLR start "operator_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:815:1: operator_key :{...}? =>id= ID ; $ANTLR end "relationalExpression" $ANTLR start "orRestriction" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:405:1: orRestriction returns [BaseDescr result] : left= andRestriction ( ( DOUBLE_PIPE ( fullAnnotation[null] )? andRestriction )=>lop= DOUBLE_PIPE (args= fullAnnotation[null] )? right= andRestriction )* ( EOF )? ; $ANTLR end "mapEntry" $ANTLR start "parExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:622:1: parExpression returns [BaseDescr result] : LEFT_PAREN expr= expression RIGHT_PAREN ; $ANTLR end "xpathExpressionList" $ANTLR start "primary" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:578:1: primary returns [BaseDescr result] : ( ( LEFT_PAREN )=>expr= parExpression | ( nonWildcardTypeArguments )=> nonWildcardTypeArguments ( explicitGenericInvocationSuffix | this_key arguments ) | ( literal )=> literal | ( super_key )=> super_key superSuffix | ( new_key )=> new_key creator | ( primitiveType )=> primitiveType ( LEFT_SQUARE RIGHT_SQUARE )* DOT class_key | ( inlineMapExpression )=> inlineMapExpression | ( inlineListExpression )=> inlineListExpression | ( ID )=>i1= ID ( ( ( DOT ID )=>d= DOT i2= ID ) | ( ( ( DOT | NULL_SAFE_DOT ) LEFT_PAREN )=>d= ( DOT | NULL_SAFE_DOT ) LEFT_PAREN expression ( COMMA expression )* RIGHT_PAREN ) | ( ( HASH ID )=>h= HASH i2= ID ) | ( ( NULL_SAFE_DOT ID )=>n= NULL_SAFE_DOT i2= ID ) )* ( ( identifierSuffix )=> identifierSuffix )? ); $ANTLR end "backReferenceExpression" $ANTLR start "primitiveType" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:548:1: primitiveType : ( boolean_key | char_key | byte_key | short_key | int_key | long_key | float_key | double_key ); $ANTLR start "relationalExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:368:1: relationalExpression returns [BaseDescr result] : left= shiftExpression ( ( operator | LEFT_PAREN )=>right= orRestriction )* ; $ANTLR start "relationalOp" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:112:1: relationalOp returns [boolean negated, String opr, java.util.List<String> params] : (op= LESS_EQUALS |op= GREATER_EQUALS |op= LESS |op= GREATER |xop= complexOp | not_key nop= neg_operator_key |cop= operator_key ) ; $ANTLR end "explicitGenericInvocationSuffix" $ANTLR start "selector" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:696:1: selector : ( ( DOT super_key )=> DOT super_key superSuffix | ( DOT new_key )=> DOT new_key ( nonWildcardTypeArguments )? innerCreator | ( DOT ID )=> DOT ID ( ( LEFT_PAREN )=> arguments )? | ( LEFT_SQUARE )=> LEFT_SQUARE expression RIGHT_SQUARE ); $ANTLR start "shiftExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:459:1: shiftExpression returns [BaseDescr result] : left= additiveExpression ( ( shiftOp )=> shiftOp additiveExpression )* ; $ANTLR end "shiftExpression" $ANTLR start "shiftOp" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:464:1: shiftOp : ( LESS LESS | GREATER GREATER GREATER | GREATER GREATER ) ; $ANTLR end "byte_key" $ANTLR start "short_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:771:1: short_key :{...}? =>id= ID ; $ANTLR end "andRestriction" $ANTLR start "singleRestriction" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:435:1: singleRestriction returns [BaseDescr result] : (op= operator ( ( squareArguments shiftExpression )=>sa= squareArguments value= shiftExpression |value= shiftExpression ) | LEFT_PAREN or= orRestriction RIGHT_PAREN ); $ANTLR end "superSuffix" $ANTLR start "squareArguments" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:713:1: squareArguments returns [java.util.List<String> args] : LEFT_SQUARE (el= expressionList )? RIGHT_SQUARE ; $ANTLR end "selector" $ANTLR start "superSuffix" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:708:1: superSuffix : ( arguments | DOT ID ( ( LEFT_PAREN )=> arguments )? ); $ANTLR end "extends_key" $ANTLR start "super_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:751:1: super_key :{...}? =>id= ID ; $ANTLR end synpred9_DRL6Expressions $ANTLR start synpred10_DRL6Expressions $ANTLR end synpred10_DRL6Expressions $ANTLR start synpred11_DRL6Expressions $ANTLR end synpred11_DRL6Expressions $ANTLR start synpred12_DRL6Expressions $ANTLR end synpred12_DRL6Expressions $ANTLR start synpred13_DRL6Expressions $ANTLR end synpred13_DRL6Expressions $ANTLR start synpred14_DRL6Expressions $ANTLR end synpred14_DRL6Expressions $ANTLR start synpred15_DRL6Expressions $ANTLR end synpred15_DRL6Expressions $ANTLR start synpred16_DRL6Expressions $ANTLR end synpred16_DRL6Expressions $ANTLR start synpred17_DRL6Expressions $ANTLR end synpred17_DRL6Expressions $ANTLR start synpred18_DRL6Expressions $ANTLR end synpred18_DRL6Expressions $ANTLR start synpred19_DRL6Expressions $ANTLR end "neg_operator_key" $ANTLR start synpred1_DRL6Expressions $ANTLR end synpred19_DRL6Expressions $ANTLR start synpred20_DRL6Expressions $ANTLR end synpred20_DRL6Expressions $ANTLR start synpred21_DRL6Expressions $ANTLR end synpred21_DRL6Expressions $ANTLR start synpred24_DRL6Expressions $ANTLR end synpred24_DRL6Expressions $ANTLR start synpred25_DRL6Expressions $ANTLR end synpred25_DRL6Expressions $ANTLR start synpred26_DRL6Expressions $ANTLR end synpred26_DRL6Expressions $ANTLR start synpred27_DRL6Expressions $ANTLR end synpred27_DRL6Expressions $ANTLR start synpred28_DRL6Expressions $ANTLR end synpred28_DRL6Expressions $ANTLR start synpred29_DRL6Expressions $ANTLR end synpred48_DRL6Expressions Delegated rules $ANTLR end synpred1_DRL6Expressions $ANTLR start synpred2_DRL6Expressions $ANTLR end synpred29_DRL6Expressions $ANTLR start synpred30_DRL6Expressions $ANTLR end synpred30_DRL6Expressions $ANTLR start synpred31_DRL6Expressions $ANTLR end synpred31_DRL6Expressions $ANTLR start synpred32_DRL6Expressions $ANTLR end synpred32_DRL6Expressions $ANTLR start synpred33_DRL6Expressions $ANTLR end synpred33_DRL6Expressions $ANTLR start synpred34_DRL6Expressions $ANTLR end synpred34_DRL6Expressions $ANTLR start synpred35_DRL6Expressions $ANTLR end synpred35_DRL6Expressions $ANTLR start synpred36_DRL6Expressions $ANTLR end synpred36_DRL6Expressions $ANTLR start synpred37_DRL6Expressions $ANTLR end synpred37_DRL6Expressions $ANTLR start synpred38_DRL6Expressions $ANTLR end synpred38_DRL6Expressions $ANTLR start synpred39_DRL6Expressions $ANTLR end synpred2_DRL6Expressions $ANTLR start synpred3_DRL6Expressions $ANTLR end synpred39_DRL6Expressions $ANTLR start synpred40_DRL6Expressions $ANTLR end synpred40_DRL6Expressions $ANTLR start synpred41_DRL6Expressions $ANTLR end synpred41_DRL6Expressions $ANTLR start synpred42_DRL6Expressions $ANTLR end synpred42_DRL6Expressions $ANTLR start synpred43_DRL6Expressions $ANTLR end synpred43_DRL6Expressions $ANTLR start synpred44_DRL6Expressions $ANTLR end synpred44_DRL6Expressions $ANTLR start synpred45_DRL6Expressions $ANTLR end synpred45_DRL6Expressions $ANTLR start synpred46_DRL6Expressions $ANTLR end synpred46_DRL6Expressions $ANTLR start synpred47_DRL6Expressions $ANTLR end synpred47_DRL6Expressions $ANTLR start synpred48_DRL6Expressions $ANTLR end synpred3_DRL6Expressions $ANTLR start synpred4_DRL6Expressions $ANTLR end synpred4_DRL6Expressions $ANTLR start synpred5_DRL6Expressions $ANTLR end synpred5_DRL6Expressions $ANTLR start synpred6_DRL6Expressions $ANTLR end synpred6_DRL6Expressions $ANTLR start synpred7_DRL6Expressions $ANTLR end synpred7_DRL6Expressions $ANTLR start synpred8_DRL6Expressions $ANTLR end synpred8_DRL6Expressions $ANTLR start synpred9_DRL6Expressions $ANTLR end "conditionalExpression" $ANTLR start "ternaryExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:173:1: ternaryExpression : QUESTION ts= expression COLON fs= expression ; $ANTLR end "void_key" $ANTLR start "this_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:795:1: this_key :{...}? =>id= ID ; $ANTLR start "type" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:133:1: type : tm= typeMatch ; $ANTLR end "typeArguments" $ANTLR start "typeArgument" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:146:1: typeArgument : ( type | QUESTION ( ( extends_key | super_key ) type )? ); $ANTLR end "typeMatch" $ANTLR start "typeArguments" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:142:1: typeArguments : LESS typeArgument ( COMMA typeArgument )* GREATER ; $ANTLR end "complexOp" $ANTLR start "typeList" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:129:1: typeList : type ( COMMA type )* ; $ANTLR end "type" $ANTLR start "typeMatch" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:137:1: typeMatch : ( ( primitiveType )=> ( primitiveType ( ( LEFT_SQUARE RIGHT_SQUARE )=> LEFT_SQUARE RIGHT_SQUARE )* ) | ( ID ( ( typeArguments )=> typeArguments )? ( DOT ID ( ( typeArguments )=> typeArguments )? )* ( ( LEFT_SQUARE RIGHT_SQUARE )=> LEFT_SQUARE RIGHT_SQUARE )* ) ); $ANTLR end "multiplicativeExpression" $ANTLR start "unaryExpression" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:480:1: unaryExpression returns [BaseDescr result] : ( PLUS ue= unaryExpression | MINUS ue= unaryExpression | INCR primary | DECR primary |left= unaryExpressionNotPlusMinus ); $ANTLR start "unaryExpressionNotPlusMinus" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:500:1: unaryExpressionNotPlusMinus returns [BaseDescr result] : ( TILDE unaryExpression | NEGATION unaryExpression | ( castExpression )=> castExpression | ( backReferenceExpression )=> backReferenceExpression | ( ({...}? (var= ID COLON ) ) | ({...}? (var= ID UNIFY ) ) )? ( ( xpathSeparator ID )=>left2= xpathPrimary |left1= primary ) ( ( selector )=> selector )* ( ( INCR | DECR )=> ( INCR | DECR ) )? ); $ANTLR end "arrayCreatorRest" $ANTLR start "variableInitializer" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:670:1: variableInitializer : ( arrayInitializer | expression ); $ANTLR end "double_key" $ANTLR start "void_key" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:791:1: void_key :{...}? =>id= ID ; $ANTLR end "xpathPrimary" $ANTLR start "xpathChunk" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:568:1: xpathChunk returns [BaseDescr result] : ( xpathSeparator ID )=> xpathSeparator ID ( DOT ID )* ( HASH ID )? ( LEFT_SQUARE xpathExpressionList RIGHT_SQUARE )? ; $ANTLR end "xpathChunk" $ANTLR start "xpathExpressionList" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:572:1: xpathExpressionList returns [java.util.List<String> exprs] : f= expression ( COMMA s= expression )* ; $ANTLR end "xpathSeparator" $ANTLR start "xpathPrimary" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:564:1: xpathPrimary returns [BaseDescr result] : ( xpathChunk )+ ; $ANTLR end "primitiveType" $ANTLR start "xpathSeparator" src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:559:1: xpathSeparator : ( DIV | QUESTION_DIV );
The standard method called to automatically emit a token at the outermost lexical rule.  The token object should point into the char buffer start..stop.  If there is a text override in 'text', use that to set the token's text.  Override this method to emit custom Token objects. Overridden to not output messages delegates delegators return the raw DroolsParserException errors $ANTLR end "PIPE" $ANTLR start "AMPER" $ANTLR end "DIV_ASSIGN" $ANTLR start "AND_ASSIGN" $ANTLR end "INCR" $ANTLR start "ARROW" $ANTLR end "NULL" $ANTLR start "AT" $ANTLR end "UnicodeEscape" $ANTLR start "BOOL" $ANTLR end "SEMICOLON" $ANTLR start "COLON" $ANTLR end "RIGHT_CURLY" $ANTLR start "COMMA" $ANTLR end "HASH" $ANTLR start "C_STYLE_SINGLE_LINE_COMMENT" $ANTLR end "HEX" $ANTLR start "DECIMAL" $ANTLR end "UNIFY" $ANTLR start "DECR" $ANTLR end "ID" $ANTLR start "DIV" $ANTLR end "MULT_ASSIGN" $ANTLR start "DIV_ASSIGN" $ANTLR end "COMMA" $ANTLR start "DOT" $ANTLR end "NULL_SAFE_DOT" $ANTLR start "DOUBLE_AMPER" $ANTLR end "DOUBLE_AMPER" $ANTLR start "DOUBLE_PIPE" $ANTLR end "WS" $ANTLR start "EOL" $ANTLR end "COLON" $ANTLR start "EQUALS" $ANTLR end "LESS" $ANTLR start "EQUALS_ASSIGN" $ANTLR end "HexDigit" $ANTLR start "EscapeSequence" $ANTLR end "FLOAT" $ANTLR start "Exponent" $ANTLR end "EOL" $ANTLR start "FLOAT" $ANTLR end "Exponent" $ANTLR start "FloatTypeSuffix" $ANTLR end "LESS_EQUALS" $ANTLR start "GREATER" $ANTLR end "NOT_EQUALS" $ANTLR start "GREATER_EQUALS" $ANTLR end "PLUS" $ANTLR start "HASH" $ANTLR end "FloatTypeSuffix" $ANTLR start "HEX" $ANTLR end "TIME_INTERVAL" $ANTLR start "HexDigit" $ANTLR end "MULTI_LINE_COMMENT" $ANTLR start "ID" $ANTLR end "DECR" $ANTLR start "INCR" $ANTLR end "IdentifierStart" $ANTLR start "IdentifierPart" $ANTLR end "MISC" $ANTLR start "IdentifierStart" $ANTLR end "DECIMAL" $ANTLR start "IntegerTypeSuffix" $ANTLR end "RIGHT_SQUARE" $ANTLR start "LEFT_CURLY" $ANTLR end "EQUALS_ASSIGN" $ANTLR start "LEFT_PAREN" $ANTLR end "RIGHT_PAREN" $ANTLR start "LEFT_SQUARE" $ANTLR end "GREATER" $ANTLR start "LESS" $ANTLR end "GREATER_EQUALS" $ANTLR start "LESS_EQUALS" $ANTLR end "STAR" $ANTLR start "MINUS" $ANTLR end "PLUS_ASSIGN" $ANTLR start "MINUS_ASSIGN" $ANTLR end "QUESTION_DIV" $ANTLR start "MISC" $ANTLR end "XOR" $ANTLR start "MOD" $ANTLR end "XOR_ASSIGN" $ANTLR start "MOD_ASSIGN" $ANTLR end "C_STYLE_SINGLE_LINE_COMMENT" $ANTLR start "MULTI_LINE_COMMENT" $ANTLR end "MINUS_ASSIGN" $ANTLR start "MULT_ASSIGN" $ANTLR end "QUESTION" $ANTLR start "NEGATION" $ANTLR end "EQUALS" $ANTLR start "NOT_EQUALS" $ANTLR end "BOOL" $ANTLR start "NULL" $ANTLR end "DOT" $ANTLR start "NULL_SAFE_DOT" $ANTLR end "AND_ASSIGN" $ANTLR start "OR_ASSIGN" $ANTLR end "EscapeSequence" $ANTLR start "OctalEscape" $ANTLR end "TILDE" $ANTLR start "PIPE" $ANTLR end "MINUS" $ANTLR start "PLUS" $ANTLR end "AT" $ANTLR start "PLUS_ASSIGN" $ANTLR end "DOUBLE_PIPE" $ANTLR start "QUESTION" $ANTLR end "DIV" $ANTLR start "QUESTION_DIV" $ANTLR end "LEFT_CURLY" $ANTLR start "RIGHT_CURLY" $ANTLR end "LEFT_PAREN" $ANTLR start "RIGHT_PAREN" $ANTLR end "LEFT_SQUARE" $ANTLR start "RIGHT_SQUARE" $ANTLR end "ARROW" $ANTLR start "SEMICOLON" $ANTLR end "MOD" $ANTLR start "STAR" $ANTLR end "IntegerTypeSuffix" $ANTLR start "STRING" $ANTLR end "NEGATION" $ANTLR start "TILDE" $ANTLR end "STRING" $ANTLR start "TIME_INTERVAL" $ANTLR end "IdentifierPart" $ANTLR end "MOD_ASSIGN" $ANTLR start "UNIFY" $ANTLR end "OctalEscape" $ANTLR start "UnicodeEscape" $ANTLR start "WS" $ANTLR end "AMPER" $ANTLR start "XOR" $ANTLR end "OR_ASSIGN" $ANTLR start "XOR_ASSIGN" $ANTLR end synpred1_DRL6Lexer $ANTLR start synpred1_DRL6Lexer
accumulateFunction := label? ID parameters accumulateFunctionBinding := label accumulateFunction ------------------------------------------------------------------------------------------------ ANNOTATION ------------------------------------------------------------------------------------------------ annotation := fullAnnotation | AT ID chunk_(_)? attribute := salience |   enabled |   ( NO-LOOP | AUTO-FOCUS | LOCK-ON-ACTIVE | REFRACT | DIRECT ) BOOLEAN? |   ( AGENDA-GROUP | ACTIVATION-GROUP | RULEFLOW-GROUP | DATE-EFFECTIVE | DATE-EXPIRES | DIALECT ) STRING |   CALENDARS STRING (COMMA STRING)* |   TIMER ( DECIMAL | chunk_(_) ) |   DURATION ( DECIMAL | chunk_(_) ) The above syntax is not quite how this is parsed, because the soft keyword is determined by look-ahead and passed on to one of the x-Attribute methods (booleanAttribute, stringAttribute, stringListAttribute, intOrChunkAttribute) which will actually gobble the tokens. attributes := (ATTRIBUTES COLON?)? [ attribute ( COMMA? attribute )* ] booleanAttribute := attributeKey (BOOLEAN)? breakingNamedConsequence := BREAK LEFT_SQUARE ID RIGHT_SQUARE Matches a chunk started by the leftDelimiter and ended by the rightDelimiter. ------------------------------------------------------------------------------------------------ GRAMMAR RULES ------------------------------------------------------------------------------------------------ conditionalBranch := IF LEFT_PAREN conditionalExpression RIGHT_PAREN ( namedConsequence | breakingNamedConsequence ) ( ELSE ( namedConsequence | breakingNamedConsequence | conditionalBranch ) )? Matches a conditional expression Matches a conditional || expression consequenceInvocation := conditionalBranch | namedConsequence constraint := nestedConstraint | conditionalOrExpression constraints := constraint (COMMA constraint)* ------------------------------------------------------------------------------------------------ DECLARE STATEMENT ------------------------------------------------------------------------------------------------ declare := DECLARE | (ENTRY-POINT) => entryPointDeclaration | (WINDOW) => windowDeclaration | (TRAIT) => typeDeclaration (trait) | (ENUM) => enumDeclaration | typeDeclaration (class) END defaultConsequence := THEN chunk enabled := ENABLED conditionalExpression entryPointDeclaration := ENTRY-POINT stringId annotation* END typeDeclaration := [ENUM] qualifiedIdentifier annotation* enumerative+ field* END @return @throws RecognitionException enumerative := ID ( LEFT_PAREN expression (COMMA expression)* RIGHT_PAREN )? field := label fieldType (EQUALS_ASSIGN conditionalExpression)? annotation* SEMICOLON? filterDef := label ID LEFT_PAREN parameters RIGHT_PAREN fromAccumulate := ACCUMULATE LEFT_PAREN lhsAnd (COMMA|SEMICOLON) ( INIT chunk_(_) COMMA ACTION chunk_(_) COMMA ( REVERSE chunk_(_) COMMA)? RESULT chunk_(_) | accumulateFunction ) RIGHT_PAREN fromCollect := COLLECT LEFT_PAREN lhsPatternBind RIGHT_PAREN fromEntryPoint := ENTRY-POINT stringId fromExpression := conditionalOrExpression fromWindow := WINDOW ID ------------------------------------------------------------------------------------------------ FUNCTION STATEMENT ------------------------------------------------------------------------------------------------ function := FUNCTION type? ID parameters(typed) chunk_{_} ------------------------------------------------------------------------------------------------ GLOBAL STATEMENT ------------------------------------------------------------------------------------------------ globalStatement := GLOBAL type ID ------------------------------------------------------------------------------------------------ IMPORT STATEMENT ------------------------------------------------------------------------------------------------ importStatement := IMPORT ((FUNCTION|STATIC)? qualifiedIdentifier ((DOT STAR)? |(ACC|ACCUMULATE) qualifiedIdentifier ID) intOrChunkAttribute := attributeKey ( DECIMAL | chunk_(_) ) label := ID COLON lhs := WHEN COLON? lhsExpression lhsAccumulate := (ACCUMULATE|ACC) LEFT_PAREN lhsAnd (COMMA|SEMICOLON) accumulateFunctionBinding (COMMA accumulateFunctionBinding)* (SEMICOLON constraints)? RIGHT_PAREN SEMICOLON? lhsAnd := LEFT_PAREN AND lhsUnary+ RIGHT_PAREN | lhsUnary (AND lhsUnary)* lhsEval := EVAL LEFT_PAREN conditionalExpression RIGHT_PAREN lhsExists := EXISTS ( (LEFT_PAREN (or_key|and_key))=> lhsOr  // prevents '((' for prefixed and/or | LEFT_PAREN lhsOr RIGHT_PAREN | lhsPatternBind ) lhsExpression := lhsOr* lhsForall := FORALL LEFT_PAREN lhsPatternBind+ RIGHT_PAREN lhsNot := NOT ( (LEFT_PAREN (or_key|and_key))=> lhsOr  // prevents '((' for prefixed and/or | LEFT_PAREN lhsOr RIGHT_PAREN | lhsPatternBind ) lhsOr := LEFT_PAREN OR lhsAnd+ RIGHT_PAREN | lhsAnd (OR lhsAnd)* lhsParen := LEFT_PAREN lhsOr RIGHT_PAREN lhsPattern := xpathPrimary | ( QUESTION? qualifiedIdentifier LEFT_PAREN positionalConstraints? constraints? RIGHT_PAREN (OVER patternFilter)? (FROM patternSource)? ) lhsPatternBind := label? ( LEFT_PAREN lhsPattern (OR lhsPattern)* RIGHT_PAREN | lhsPattern ) lhsUnary := ( lhsExists namedConsequence? | lhsNot namedConsequence? | lhsEval consequenceInvocation* | lhsForall | lhsAccumulate | LEFT_PAREN lhsOr RIGHT_PAREN namedConsequence? | lhsPatternBind consequenceInvocation* ) SEMICOLON? ------------------------------------------------------------------------------------------------ GENERAL UTILITY METHODS ------------------------------------------------------------------------------------------------ Match current input symbol against ttype and optionally check the text of the token against text.  Attempt single token insertion or deletion error recovery.  If that fails, throw MismatchedTokenException. namedConsequence := DO LEFT_SQUARE ID RIGHT_SQUARE BREAK? namedConsequence := THEN LEFT_SQUARE ID RIGHT_SQUARE chunk nestedConstraint := ( ID ( DOT | HASH ) )* ID DOT LEFT_PAREN constraints RIGHT_PAREN Parses a package statement and returns the name of the package or null if none is defined. packageStatement := PACKAGE qualifiedIdentifier SEMICOLON? parameter := ({requiresType}?=>type)? ID (LEFT_SQUARE RIGHT_SQUARE)* parameters := LEFT_PAREN (conditionalExpression (COMMA conditionalExpression)* )? RIGHT_PAREN parameters := LEFT_PAREN ( parameter ( COMMA parameter )* )? RIGHT_PAREN patternFilter :=   OVER filterDef DISALLOWED:        | ( PIPE filterDef )+ patternSource := FROM ( fromAccumulate | fromCollect | fromEntryPoint | fromWindow | fromExpression ) positionalConstraints := constraint (COMMA constraint)* SEMICOLON Matches a qualified identifier qualifiedIdentifier := ID ( DOT ID )* ------------------------------------------------------------------------------------------------ QUERY STATEMENT ------------------------------------------------------------------------------------------------ query := QUERY stringId parameters? annotation* lhsExpression END Attempt to recover from a single missing or extra token. EXTRA TOKEN LA(1) is not what we are looking for.  If LA(2) has the right token, however, then assume LA(1) is some extra spurious token.  Delete it and LA(2) as if we were doing a normal match(), which advances the input. MISSING TOKEN If current token is consistent with what could come after ttype then it is ok to "insert" the missing token, else throw exception For example, Input "i=(3;" is clearly missing the ')'.  When the parser returns from the nested call to expr, it will have call chain: stat -> expr -> atom and it will be trying to match the ')' at this point in the derivation: => ID '=' '(' INT ')' ('+' atom)* ';' ^ match() will see that ';' doesn't match ')' and report a mismatched token error.  To recover, it sees that LA(1)==';' is in the set of tokens that can follow the ')' token reference in rule atom.  It can assume that you forgot the ')'. rhs := defaultConsequence namedConsequence* (~END)* ------------------------------------------------------------------------------------------------ RULE STATEMENT ------------------------------------------------------------------------------------------------ rule := RULE stringId (EXTENDS stringId)? annotation* attributes? lhs? rhs END salience := SALIENCE conditionalExpression Invokes the expression parser, trying to parse the annotation as a full java-style annotation statement := importStatement |  globalStatement |  declare |  rule |  ruleAttribute |  function |  query ; stringAttribute := attributeKey STRING stringId := ( ID | STRING ) stringListAttribute := attributeKey STRING (COMMA STRING)* ------------------------------------------------------------------------------------------------ UTILITY RULES ------------------------------------------------------------------------------------------------ Matches a type name type := ID typeArguments? ( DOT ID typeArguments? )* (LEFT_SQUARE RIGHT_SQUARE)* Matches a type argument typeArguments := QUESTION (( EXTENDS | SUPER ) type )? |  type ; Matches type arguments typeArguments := LESS typeArgument (COMMA typeArgument)* GREATER typeDeclaration := [TYPE] qualifiedIdentifier (EXTENDS qualifiedIdentifier)? annotation* field* END unif := ID UNIFY unitStatement := UNIT qualifiedIdentifier SEMICOLON? windowDeclaration := WINDOW ID annotation* lhsPatternBind END
accumulateFunction := label? ID parameters accumulateFunctionBinding := label accumulateFunction ------------------------------------------------------------------------------------------------ ANNOTATION ------------------------------------------------------------------------------------------------ annotation := fullAnnotation | AT ID chunk_(_)? attribute := salience |   enabled |   ( NO-LOOP | AUTO-FOCUS | LOCK-ON-ACTIVE | REFRACT | DIRECT ) BOOLEAN? |   ( AGENDA-GROUP | ACTIVATION-GROUP | RULEFLOW-GROUP | DATE-EFFECTIVE | DATE-EXPIRES | DIALECT ) STRING |   CALENDARS STRING (COMMA STRING)* |   TIMER ( DECIMAL | chunk_(_) ) |   DURATION ( DECIMAL | chunk_(_) ) The above syntax is not quite how this is parsed, because the soft keyword is determined by look-ahead and passed on to one of the x-Attribute methods (booleanAttribute, stringAttribute, stringListAttribute, intOrChunkAttribute) which will actually gobble the tokens. attributes := (ATTRIBUTES COLON?)? [ attribute ( COMMA? attribute )* ] booleanAttribute := attributeKey (BOOLEAN)? breakingNamedConsequence := BREAK LEFT_SQUARE ID RIGHT_SQUARE Matches a chunk started by the leftDelimiter and ended by the rightDelimiter. ------------------------------------------------------------------------------------------------ GRAMMAR RULES ------------------------------------------------------------------------------------------------ conditionalBranch := IF LEFT_PAREN conditionalExpression RIGHT_PAREN ( namedConsequence | breakingNamedConsequence ) ( ELSE ( namedConsequence | breakingNamedConsequence | conditionalBranch ) )? Matches a conditional expression Matches a conditional || expression consequenceInvocation := conditionalBranch | namedConsequence constraint := nestedConstraint | conditionalOrExpression constraints := constraint (COMMA constraint)* ------------------------------------------------------------------------------------------------ DECLARE STATEMENT ------------------------------------------------------------------------------------------------ declare := DECLARE | (ENTRY-POINT) => entryPointDeclaration | (WINDOW) => windowDeclaration | (TRAIT) => typeDeclaration (trait) | (ENUM) => enumDeclaration | typeDeclaration (class) END defaultConsequence := THEN chunk enabled := ENABLED conditionalExpression entryPointDeclaration := annotation* ENTRY-POINT stringId END typeDeclaration := annotation* [ENUM] qualifiedIdentifier enumerative+ field* END @return @throws RecognitionException enumerative := ID ( LEFT_PAREN expression (COMMA expression)* RIGHT_PAREN )? field := annotation* label fieldType (EQUALS_ASSIGN conditionalExpression)? SEMICOLON? filterDef := label ID LEFT_PAREN parameters RIGHT_PAREN fromAccumulate := ACCUMULATE LEFT_PAREN lhsAnd (COMMA|SEMICOLON) ( INIT chunk_(_) COMMA ACTION chunk_(_) COMMA ( REVERSE chunk_(_) COMMA)? RESULT chunk_(_) | accumulateFunction ) RIGHT_PAREN fromCollect := COLLECT LEFT_PAREN lhsPatternBind RIGHT_PAREN fromEntryPoint := ENTRY-POINT stringId fromExpression := conditionalOrExpression fromWindow := WINDOW ID ------------------------------------------------------------------------------------------------ FUNCTION STATEMENT ------------------------------------------------------------------------------------------------ function := FUNCTION type? ID parameters(typed) chunk_{_} ------------------------------------------------------------------------------------------------ GLOBAL STATEMENT ------------------------------------------------------------------------------------------------ globalStatement := GLOBAL type ID ------------------------------------------------------------------------------------------------ IMPORT STATEMENT ------------------------------------------------------------------------------------------------ importStatement := IMPORT ((FUNCTION|STATIC)? qualifiedIdentifier ((DOT STAR)? |(ACC|ACCUMULATE) qualifiedIdentifier ID) intOrChunkAttribute := attributeKey ( DECIMAL | chunk_(_) ) label := ID COLON lhs := WHEN COLON? lhsExpression lhsAccumulate := (ACCUMULATE|ACC) LEFT_PAREN lhsAnd (COMMA|SEMICOLON) accumulateFunctionBinding (COMMA accumulateFunctionBinding)* (SEMICOLON constraints)? RIGHT_PAREN SEMICOLON? lhsAnd := LEFT_PAREN AND lhsUnary+ RIGHT_PAREN | lhsUnary (AND lhsUnary)* lhsEval := EVAL LEFT_PAREN conditionalExpression RIGHT_PAREN lhsExists := EXISTS ( (LEFT_PAREN (or_key|and_key))=> lhsOr  // prevents '((' for prefixed and/or | LEFT_PAREN lhsOr RIGHT_PAREN | lhsPatternBind ) lhsExpression := lhsOr* lhsForall := FORALL LEFT_PAREN lhsPatternBind+ RIGHT_PAREN lhsNot := NOT ( (LEFT_PAREN (or_key|and_key))=> lhsOr  // prevents '((' for prefixed and/or | LEFT_PAREN lhsOr RIGHT_PAREN | lhsPatternBind ) lhsOr := LEFT_PAREN OR lhsAnd+ RIGHT_PAREN | lhsAnd (OR lhsAnd)* lhsParen := LEFT_PAREN lhsOr RIGHT_PAREN lhsPattern := xpathPrimary | ( QUESTION? qualifiedIdentifier LEFT_PAREN positionalConstraints? constraints? RIGHT_PAREN (OVER patternFilter)? (FROM patternSource)? ) lhsPatternBind := label? ( LEFT_PAREN lhsPattern (OR lhsPattern)* RIGHT_PAREN | lhsPattern ) lhsUnary := annotation* ( lhsExists namedConsequence? | lhsNot namedConsequence? | lhsEval consequenceInvocation* | lhsForall | lhsAccumulate | LEFT_PAREN lhsOr RIGHT_PAREN namedConsequence? | lhsPatternBind consequenceInvocation* ) SEMICOLON? ------------------------------------------------------------------------------------------------ GENERAL UTILITY METHODS ------------------------------------------------------------------------------------------------ Match current input symbol against ttype and optionally check the text of the token against text.  Attempt single token insertion or deletion error recovery.  If that fails, throw MismatchedTokenException. namedConsequence := DO LEFT_SQUARE ID RIGHT_SQUARE BREAK? namedConsequence := THEN LEFT_SQUARE ID RIGHT_SQUARE chunk nestedConstraint := ( ID ( DOT | HASH ) )* ID DOT LEFT_PAREN constraints RIGHT_PAREN Parses a package statement and returns the name of the package or null if none is defined. packageStatement := PACKAGE qualifiedIdentifier SEMICOLON? parameter := ({requiresType}?=>type)? ID (LEFT_SQUARE RIGHT_SQUARE)* parameters := LEFT_PAREN (conditionalExpression (COMMA conditionalExpression)* )? RIGHT_PAREN parameters := LEFT_PAREN ( parameter ( COMMA parameter )* )? RIGHT_PAREN patternFilter :=   OVER filterDef DISALLOWED:        | ( PIPE filterDef )+ patternSource := FROM ( fromAccumulate | fromCollect | fromEntryPoint | fromWindow | fromExpression ) positionalConstraints := constraint (COMMA constraint)* SEMICOLON Matches a qualified identifier qualifiedIdentifier := ID ( DOT ID )* ------------------------------------------------------------------------------------------------ QUERY STATEMENT ------------------------------------------------------------------------------------------------ query := annotation* QUERY stringId parameters? lhsExpression END Attempt to recover from a single missing or extra token. EXTRA TOKEN LA(1) is not what we are looking for.  If LA(2) has the right token, however, then assume LA(1) is some extra spurious token.  Delete it and LA(2) as if we were doing a normal match(), which advances the input. MISSING TOKEN If current token is consistent with what could come after ttype then it is ok to "insert" the missing token, else throw exception For example, Input "i=(3;" is clearly missing the ')'.  When the parser returns from the nested call to expr, it will have call chain: stat -> expr -> atom and it will be trying to match the ')' at this point in the derivation: => ID '=' '(' INT ')' ('+' atom)* ';' ^ match() will see that ';' doesn't match ')' and report a mismatched token error.  To recover, it sees that LA(1)==';' is in the set of tokens that can follow the ')' token reference in rule atom.  It can assume that you forgot the ')'. rhs := defaultConsequence namedConsequence* (~END)* ------------------------------------------------------------------------------------------------ RULE STATEMENT ------------------------------------------------------------------------------------------------ rule := annotation* RULE stringId (EXTENDS stringId)? attributes? lhs? rhs END salience := SALIENCE conditionalExpression Invokes the expression parser, trying to parse the annotation as a full java-style annotation statement := importStatement |  globalStatement |  declare |  rule |  ruleAttribute |  function |  query ; stringAttribute := attributeKey STRING stringId := ( ID | STRING ) stringListAttribute := attributeKey STRING (COMMA STRING)* ------------------------------------------------------------------------------------------------ UTILITY RULES ------------------------------------------------------------------------------------------------ Matches a type name type := ID typeArguments? ( DOT ID typeArguments? )* (LEFT_SQUARE RIGHT_SQUARE)* Matches a type argument typeArguments := QUESTION (( EXTENDS | SUPER ) type )? |  type ; Matches type arguments typeArguments := LESS typeArgument (COMMA typeArgument)* GREATER typeDeclaration := annotation* [TYPE] qualifiedIdentifier (EXTENDS qualifiedIdentifier)? field* END unif := ID UNIFY unitStatement := UNIT qualifiedIdentifier SEMICOLON? windowDeclaration := annotation* WINDOW ID lhsPatternBind END
Concatenate a String to the provided buffer suitable for the fieldValue and fieldType. Strings and Dates are escaped with double-quotes, whilst Numerics, Booleans, (Java 1.5+) enums and all other fieldTypes are not escaped at all. Guvnor-type enums are really a pick list of Strings and in these cases the underlying fieldType is a String. Concatenate a String to the provided buffer suitable for the fieldType and fieldValue. Strings are escaped with double-quotes, Dates are wrapped with a call to a pre-constructed SimpleDateFormatter, whilst Numerics, Booleans, (Java 1.5+) enums and all other fieldTypes are not escaped at all. Guvnor-type enums are really a pick list of Strings and in these cases the underlying fieldType is a String.


Helper method that creates a user friendly token definition

Each node can add its contribution to the output

Return the rendered DRL so far
This will expand the DRL. useful for debugging. This will expand the DRL using the given expander resolver. useful for debugging.  Convert the antlr exceptions to drools parser exceptions Parse and build a rule package from a DRL source with a domain specific language. Parse and build a rule package from a DRL source with a domain specific language. Parse a rule from text
Legay case - source is defined in the generated Invoker class -- Accumulate Functions -- -- Variable -- -- RHS -- -- Expressions -- -- Temporal Constraints -- -- Existential operator -- -- Prototype -- -- DataSource -- -- TypeMetaData --



Override this method to not output mesages delegates delegators $ANTLR end "DOT" $ANTLR start "COLON" $ANTLR end "COLON" $ANTLR start "COMMA" $ANTLR end "EQUALS" $ANTLR start "DOT" $ANTLR end "WS" $ANTLR start "EOL" $ANTLR end "RIGHT_CURLY" $ANTLR start "EQUALS" $ANTLR end "EOL" $ANTLR start "EscapeSequence" $ANTLR end "MISC" $ANTLR start "IdentifierPart" $ANTLR end "RIGHT_SQUARE" $ANTLR start "LEFT_CURLY" $ANTLR end "EscapeSequence" $ANTLR start "LEFT_SQUARE" $ANTLR end "COMMA" $ANTLR start "LITERAL" $ANTLR end "LITERAL" $ANTLR start "MISC" $ANTLR end "LEFT_CURLY" $ANTLR start "RIGHT_CURLY" $ANTLR end "LEFT_SQUARE" $ANTLR start "RIGHT_SQUARE" $ANTLR end "IdentifierPart" $ANTLR start "WS" $ANTLR end synpred1_DSLMap $ANTLR start synpred1_DSLMap
$ANTLR start "any_key" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:266:1: any_key :{...}?value= LITERAL -> VT_ANY[$value] ; $ANTLR start "condition_key" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:251:1: condition_key :{...}?value= LITERAL -> VT_CONDITION[$value] ; $ANTLR start "consequence_key" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:256:1: consequence_key :{...}?value= LITERAL -> VT_CONSEQUENCE[$value] ; Override this method to not output mesages $ANTLR start "entry" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:119:1: entry : scope_section ( meta_section )? key_section EQUALS ( value_section )? ( EOL | EOF ) -> ^( VT_ENTRY scope_section ( meta_section )? key_section ( value_section )? ) ; delegates $ANTLR start "key_chunk" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:163:1: key_chunk : ( literal )+ ; $ANTLR start "key_section" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:149:1: key_section : (ks= key_sentence )+ -> ^( VT_ENTRY_KEY ( key_sentence )+ ) ; $ANTLR start "key_sentence" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:154:1: key_sentence : ( variable_definition |cb= key_chunk -> VT_LITERAL[$cb.start, text] ); $ANTLR start "keyword_key" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:261:1: keyword_key :{...}?value= LITERAL -> VT_KEYWORD[$value] ; $ANTLR start "literal" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:185:1: literal : ( LITERAL | COLON | LEFT_SQUARE | RIGHT_SQUARE ) ; $ANTLR start "mapping_file" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:106:1: mapping_file : ( statement )* -> ^( VT_DSL_GRAMMAR ( statement )* ) ; $ANTLR start "meta_section" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:144:1: meta_section : LEFT_SQUARE ( LITERAL )? RIGHT_SQUARE -> ^( VT_META[$LEFT_SQUARE, \"META SECTION\"] ( LITERAL )? ) ; $ANTLR start "pattern" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:219:1: pattern : ( literal | DOT | MISC | LEFT_CURLY literal RIGHT_CURLY | LEFT_SQUARE pattern RIGHT_SQUARE )+ ; $ANTLR start "scope_section" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:130:1: scope_section : LEFT_SQUARE (value1= condition_key |value2= consequence_key |value3= keyword_key |value4= any_key ) RIGHT_SQUARE -> ^( VT_SCOPE[$LEFT_SQUARE, \"SCOPE SECTION\"] ( $value1)? ( $value2)? ( $value3)? ( $value4)? ) ; $ANTLR start "statement" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:111:1: statement : ( entry | EOL !); $ANTLR end synpred8_DSLMap $ANTLR start synpred12_DSLMap $ANTLR end synpred12_DSLMap $ANTLR start synpred15_DSLMap $ANTLR end synpred15_DSLMap $ANTLR start synpred16_DSLMap $ANTLR end synpred16_DSLMap $ANTLR start synpred17_DSLMap $ANTLR end synpred17_DSLMap $ANTLR start synpred18_DSLMap $ANTLR end synpred18_DSLMap $ANTLR start synpred22_DSLMap $ANTLR end synpred22_DSLMap $ANTLR start synpred24_DSLMap $ANTLR end synpred24_DSLMap $ANTLR start synpred28_DSLMap $ANTLR end synpred28_DSLMap Delegated rules $ANTLR end "any_key" $ANTLR start synpred3_DSLMap $ANTLR end synpred3_DSLMap $ANTLR start synpred6_DSLMap $ANTLR end synpred6_DSLMap $ANTLR start synpred7_DSLMap $ANTLR end synpred7_DSLMap $ANTLR start synpred8_DSLMap $ANTLR start "value_chunk" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:181:1: value_chunk : ( literal | EQUALS | COMMA | DOT )+ ; $ANTLR start "value_section" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:167:1: value_section : ( value_sentence )+ -> ^( VT_ENTRY_VAL ( value_sentence )+ ) ; $ANTLR start "value_sentence" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:172:1: value_sentence : ( variable_reference |vc= value_chunk -> VT_LITERAL[$vc.start, text] ); $ANTLR start "variable_definition" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:190:1: variable_definition : lc= LEFT_CURLY name= LITERAL ( ( COLON q= LITERAL )? COLON pat= pattern )? rc= RIGHT_CURLY -> { hasSpaceBefore && !\"\".equals(text) && !hasSpaceAfter}? VT_SPACE ^( VT_VAR_DEF $name ^( VT_QUAL ( $q)? ) VT_PATTERN[$pat.start, text] ) -> {!hasSpaceBefore && !\"\".equals(text) && !hasSpaceAfter}? ^( VT_VAR_DEF $name ^( VT_QUAL ( $q)? ) VT_PATTERN[$pat.start, text] ) -> { hasSpaceBefore && !hasSpaceAfter}? VT_SPACE ^( VT_VAR_DEF $name ^( VT_QUAL ( $q)? ) ) -> {!hasSpaceBefore && !hasSpaceAfter}? ^( VT_VAR_DEF $name ^( VT_QUAL ( $q)? ) ) -> { hasSpaceBefore && !\"\".equals(text) && hasSpaceAfter}? VT_SPACE ^( VT_VAR_DEF $name ^( VT_QUAL ( $q)? ) VT_PATTERN[$pat.start, text] ) VT_SPACE -> {!hasSpaceBefore && !\"\".equals(text) && hasSpaceAfter}? ^( VT_VAR_DEF $name ^( VT_QUAL ( $q)? ) VT_PATTERN[$pat.start, text] ) VT_SPACE -> { hasSpaceBefore && hasSpaceAfter}? VT_SPACE ^( VT_VAR_DEF $name ^( VT_QUAL ( $q)? ) ) VT_SPACE -> {!hasSpaceBefore && hasSpaceAfter}? ^( VT_VAR_DEF $name ^( VT_QUAL ( $q)? ) ) VT_SPACE -> ^( VT_VAR_DEF $name ^( VT_QUAL ( $q)? ) ) ; $ANTLR start "variable_reference" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:228:1: variable_reference : lc= LEFT_CURLY name= variable_reference_expr rc= RIGHT_CURLY -> { hasSpaceBefore && hasSpaceAfter}? VT_SPACE ^( VT_VAR_REF LITERAL[$name.start,$name.text] ) VT_SPACE -> { hasSpaceBefore && !hasSpaceAfter}? VT_SPACE ^( VT_VAR_REF LITERAL[$name.start,$name.text] ) -> {!hasSpaceBefore && hasSpaceAfter}? ^( VT_VAR_REF LITERAL[$name.start,$name.text] ) VT_SPACE -> ^( VT_VAR_REF LITERAL[$name.start,$name.text] ) ; $ANTLR start "variable_reference_expr" src/main/resources/org/drools/compiler/lang/dsl/DSLMap.g:247:1: variable_reference_expr : ( LITERAL | EQUALS )+ ;
$ANTLR end "keyword_key" $ANTLR start "any_key" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:172:1: any_key : VT_ANY ; $ANTLR end "variable_reference" $ANTLR start "condition_key" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:157:1: condition_key : VT_CONDITION ; $ANTLR end "condition_key" $ANTLR start "consequence_key" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:162:1: consequence_key : VT_CONSEQUENCE ; $ANTLR start "entry" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:34:1: entry returns [DSLMappingEntry mappingEntry] : ^( VT_ENTRY scope_section ( meta_section )? key_section ( value_section )? ) ; delegates $ANTLR end "meta_section" $ANTLR start "key_section" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:83:1: key_section : ^( VT_ENTRY_KEY ( key_sentence )+ ) ; $ANTLR end "key_section" $ANTLR start "key_sentence" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:87:1: key_sentence : ( variable_definition |vtl= VT_LITERAL | VT_SPACE ); $ANTLR end "consequence_key" $ANTLR start "keyword_key" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:167:1: keyword_key : VT_KEYWORD ; $ANTLR end "value_sentence" $ANTLR start "literal" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:122:1: literal : theliteral= VT_LITERAL ; $ANTLR start "mapping_file" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:16:1: mapping_file returns [DSLMapping mapping] : ^( VT_DSL_GRAMMAR ( valid_entry )* ) ; $ANTLR end "scope_section" $ANTLR start "meta_section" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:72:1: meta_section : ^( VT_META (metalit= LITERAL )? ) ; $ANTLR end "entry" $ANTLR start "scope_section" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:66:1: scope_section : ^(thescope= VT_SCOPE ( condition_key )? ( consequence_key )? ( keyword_key )? ( any_key )? ) ; $ANTLR end "mapping_file" $ANTLR start "valid_entry" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:29:1: valid_entry returns [DSLMappingEntry mappingEntry] : ent= entry ; $ANTLR end "key_sentence" $ANTLR start "value_section" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:101:1: value_section : ^( VT_ENTRY_VAL ( value_sentence )+ ) ; $ANTLR end "value_section" $ANTLR start "value_sentence" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:108:1: value_sentence : ( variable_reference |vtl= VT_LITERAL | VT_SPACE ); $ANTLR end "literal" $ANTLR start "variable_definition" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:126:1: variable_definition : ^( VT_VAR_DEF varname= LITERAL ^( VT_QUAL (q= LITERAL )? ) (pattern= VT_PATTERN )? ) ; $ANTLR end "variable_definition" $ANTLR start "variable_reference" src/main/resources/org/drools/compiler/lang/dsl/DSLMapWalker.g:149:1: variable_reference : ^(varref= VT_VAR_REF lit= LITERAL ) ;
Adds all entries in the given list to this DSL Mapping Add one entry to the list of the entries Returns a String description of this mapping Returns the list of entries in this mapping Returns the list of mappings for the given section Returns the string identifier for this mapping Retrieves an an expansion option. Removes the given entry from the list of entries Sets the description for this mapping Sets the identifier for this mapping Sets an expansion option.
Returns a list of errors found in this mapping Returns the compiled pattern based on the given MappingKey Returns the key of this mapping, i.e., the source that needs to be translated Returns the result of the translation Returns the meta data info about this mapping entry Returns the section this mapping entry refers to Returns the transformed mapping value using place holders for variables Returns the list of variables found in the given pattern key in the same order they were found
Method to return the current mapping as a String object Returns the list of parsing errors Returns the DSL mapping loaded from this file Parses the file. Throws IOException in case there is any problem reading the file; Saves current mapping into a DSL mapping file Saves the given mapping into a DSL mapping file Sets the


This is used by the GUI when adding a sentence to LHS or RHS. This will strip off any "{" stuff, substituting values accordingly Build the Values from the Definition. Build the Definition and Values from a legacy Sentence. Legacy DSLSentence did not separate DSL definition from values, which led to complications when a user wanted to set the value of a DSL parameter to text including the special escaping used to differentiate value, from data-type, from restriction This will strip off any residual "{" stuff...
Read a DSL file and convert it to a String. Comment lines are removed. Split lines are joined, inserting a space for an EOL, but maintaining the original number of lines by inserting EOLs. Options are recognized. Keeps track of original line lengths for fixing parser error messages.


Clones this default value instance. A clone of this class is used while editing a column. Overriding this method allows us to easily compare the clone and the original to check if a change has been made

Clones the configuration (width, header, hide, default value) of the argument into this instance. Check whether two Objects are equal or both null
The instances of UnaryTests that specify the input conditions that this DecisionRule must match for the corresponding (by index) inputExpression. A list of the instances of LiteralExpression that compose the output components of this DecisionRule.






Come to the end of the sheet. Enter a new cell. Do NOT call this event for trailling cells at the end of the line. It will just confuse the parser. If all the trailing cells are empty, just stop raising events. Enter a new row. Start a new sheet

Generates DRL from a data provider for the spreadsheet data and templates. Generates DRL from a data provider for the spreadsheet data and templates. Generates DRL from a data provider for the spreadsheet data and templates. Generates DRL from a data provider for the spreadsheet data and templates. Generates DRL from a data provider for the spreadsheet data and templates. Generates DRL from a data provider for the spreadsheet data and templates.









Convert a two-dimensional array of Strings to a List of Lists, with type-safe individual entries Convert a single dimension array of Strings to a List with type-safe entries. The first entry is converted into a numerical row number






Use the simple date formatter to convert the Date into a String Check for the system property override, if it exists Converts the right hand side date as appropriate Use the simple date formatter to read the date from a string




























Convert row to DTDecisionRule

If valid input values are defined, check that all parameters match the respective valid inputs This checks one "column" of the decision table output(s). No hits matched for the DT, so calculate result based on default outputs Evaluates this decision table returning the result Finds all rules that match a given set of parameters Each hit results in one output value (multiple outputs are collected into a single context value) Checks if the parameters match a single rule Checks that a given parameter matches a single cell test


Parse a file, store the resulting rulebase. Parse an input stream, store the resulting rulebase.





Returns the Extractor expression ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Retrieve the variable's identifier. Returns the index of the pattern Retrieve the <code>ValueType</code>. Returns true if this declaration is a pattern declaration - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Return all declarations scoped to the current RuleConditionElement in the build stack




Declares a new entry point Declares a new enum Declares a new type Declares a new window



If the item belongs to an activation group, add it (non-Javadoc) @see org.kie.common.AgendaI#agendaSize() (non-Javadoc) @see org.kie.common.AgendaI#clearActivationGroup(java.lang.String) (non-Javadoc) @see org.kie.common.AgendaI#clearActivationGroup(org.kie.spi.ActivationGroup) (non-Javadoc) @see org.kie.common.AgendaI#clearAgendaGroup(java.lang.String) (non-Javadoc) @see org.kie.common.AgendaI#clearAgendaGroup(org.kie.common.AgendaGroupImpl) Fire the next scheduled <code>Agenda</code> item, skipping items that are not allowed by the agenda filter. (non-Javadoc) @see org.kie.common.AgendaI#focusStackSize() (non-Javadoc) @see org.kie.common.AgendaI#getActivations() (non-Javadoc) @see org.kie.common.AgendaI#getFocus() (non-Javadoc) @see org.kie.common.AgendaI#getNextFocus() (non-Javadoc) @see org.kie.common.AgendaI#setFocus(java.lang.String) (non-Javadoc) @see org.kie.common.AgendaI#setFocus(org.kie.spi.AgendaGroup)


This is the filtering method. When an AuditLogEntry is added to an AuditLog the AuditLog calls this method to determine whether the AuditLogEntry should be added. Register a type this Filter understands. When a new entry is added the AuditLogFilter is set to not accept the type by default.
Dynamically builds, defines and loads a class based on the given class definition Defines the class header for the given class definition Creates a constructor that takes and assigns values to all fields in the order they are declared. Creates a default constructor for the class A traitable class is a special class with support for dynamic properties and types. This method builds the property map, containing the key/values pairs to implement any property defined in a trait interface but not supported by the traited class fields. Creates the field defined by the given FieldDefinition A traitable class is a special class with support for dynamic properties and types. A traitable class in logical mode provides additional control over the values and type(s) of its fields. Creates the get method for the given field definition Creates the set method for the given field definition A traitable class is a special class with support for dynamic properties and types. This method builds the trait map, containing the references to the proxies for each trait carried by an object at a given time. Initializes the trait map and dynamic property map to empty values
Determine if another object is equal to this. (non-Javadoc) @see org.kie.common.BetaNodeConstraints#getConstraints() (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedLeft(java.lang.Object) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedRight(org.kie.reteoo.ReteTuple) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromFactHandle(org.kie.common.InternalFactHandle) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromTuple(org.kie.reteoo.ReteTuple)




Adds all entries in the given list to this DSL Mapping Add one entry to the list of the entries  Returns an unmodifiable list of entries Returns the list of mappings for the given section Returns the identifier for this mapping
Dynamically builds, defines and loads a class based on the given class definition
Add the new mapping to this expander. Clean up constructions that exists only in the unexpanded code   Expand constructions like rules and queries Expand all configured keywords Expand LHS for a construction Expand RHS for rules   Reads the stream into a String private int countAll( Matcher matcher ){ int n = 0; while( matcher.find() ){ n++; } return n; } Perform the substitutions.
Add an expander with the given name, which will be used by looking for the "expander" keyword in the DRL. If a default expander is installed, it will always be returned if none matching the given name can be found. You don't need to use this unless you have multiple expanders/DSLs involved when compiling multiple rule packages at the same time. If you don't know what that sentence means, you probably don't need to use this method.
---------------------------------------------------------------------- Instance members ----------------------------------------------------------------------    Always returns false, since the DefaultFactHandle is only used for regular Facts, and not for Events  format_version:id:identity:hashcode:recency
(non-Javadoc) @see org.kie.decisiontable.parser.Generator#generate(java.lang.String, org.kie.decisiontable.parser.Row) (non-Javadoc) @see org.kie.decisiontable.parser.Generator#getDrl()



Trait helper methods







Add a new rule to the current list of rules (non-Javadoc) @see my.hssf.util.SheetListener#finishSheet() This makes sure that the rules have all their components added. As when there are merged/spanned cells, they may be left out. (non-Javadoc) @see org.kie.decisiontable.parser.RuleSheetListener#getProperties() (non-Javadoc) @see org.kie.decisiontable.parser.RuleSheetListener#getRuleSet() This gets called each time a "new" rule table is found. (non-Javadoc) @see my.hssf.util.SheetListener#newCell(int, int, java.lang.String) (non-Javadoc) @see my.hssf.util.SheetListener#newRow() This is for handling a row where an object declaration may appear, this is the row immediately above the snippets. It may be blank, but there has to be a row here. Merged cells have "special meaning" which is why this is so freaking hard. A future refactor may be to move away from an "event" based listener. Called after rule table initialisation. Subclasses may override this method to do additional processing. Called before rule table initialisation. Subclasses may override this method to do additional processing. (non-Javadoc) @see my.hssf.util.SheetListener#startSheet(java.lang.String)


(non-Javadoc) @see org.kie.decisiontable.parser.TemplateContainer#getColumns() (non-Javadoc) @see org.kie.decisiontable.parser.TemplateContainer#getHeader() (non-Javadoc) @see org.kie.decisiontable.parser.TemplateContainer#getTemplates()
(non-Javadoc) @see org.kie.decisiontable.parser.TemplateRuleBase#newWorkingMemory()










public int getAttacks() { return attacks; }  public void incAttacks() { attacks++; }  public void decAttacks() { attacks--; }







@Override







This will return the line number of the error, if possible Otherwise it will be -1
This will return the line number of the error, if possible Otherwise it will be -1
Returns the parent container of this descr builder. Example: ruleDescrBuilder.end() will return the PackageDescrBuilder as that is its parent container. Sets the offset of the starting character of the corresponding construction in the source file. Sets the end location of the corresponding construction in the source file. Returns the descriptor generated by this builder. Sets the offset of the starting character of the corresponding construction in the source file. Sets the start location of the corresponding construction in the source file.






this is needed because some dialects use other dialects to build complex expressions. Example: java dialect uses MVEL to execute complex expressions
Add a DialectConfiguration to the registry Iterates all registered dialects, informing them of an import added to the PackageBuilder Add all registered Dialect results to the provided List. Iterates all registered dialects, informing them of a static imports added to the PackageBuilder Instruct all registered dialects to compile what ever they have attempted to build. Get a DialectConfiguration for a named dialect Return an Iterator of DialectConfigurations



Handles the read serialization of the PackageCompilationData. Patterns in Rules may reference generated data which cannot be serialized by default methods. The PackageCompilationData holds a reference to the generated bytecode; which must be restored before any Rules. A custom ObjectInputStream, able to resolve classes against the bytecode, is used to restore the Rules. Handles the write serialization of the PackageCompilationData. Patterns in Rules may reference generated data which cannot be serialized by default methods. The PackageCompilationData holds a reference to the generated bytecode. The generated bytecode must be restored before any Rules.

Takes a given name and makes sure that its legal and doesn't already exist. If the file exists it increases counter appender untill it is unique. This code is not currently used, it's commented out in method caller. This is because we couldn't get this to work and will have to wait until MVEL supports genercs (mdp).

Analyze differences between two columns of same type.













Determine if another object is equal to this. (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedLeft(java.lang.Object) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedRight(org.kie.reteoo.ReteTuple) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromFactHandle(org.kie.common.InternalFactHandle) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromTuple(org.kie.reteoo.ReteTuple)






Parse an expression from text







Mutates expression such that, if it contains a <pre>nameRef</pre>, it is replaced and forcibly casted with <pre>(type) nameRef</pre>. Mutates expression such that, if it contains a NameExpr for any of the <code>names</code>, it is replaced with a FieldAccessExpr having <code>newScope</code> as the scope.









Default implementation (overriden where possible and meaningful) returning just an empty string





Get currently registered session monitor, eventually creating it if necessary.








getter for column position getter for error code getter for line number getter for char offset
This method creates a DroolsParserException full of information. This will take a RecognitionException, and create a sensible error message out of it This method creates a DroolsParserException for trailing semicolon exception, full of information. This will take Paraphrases stack, and create a sensible location Helper method that creates a user friendly token definition Helper method that creates a user friendly token definition Returns a string based on Paraphrase Type


Add a location to the content Add a token to the content and sets char offset info getter of sentence content getter for end char offset getter for start char offset getter of sentence type Reverses the content linked list setter for end char offset setter for start char offset setter of sentence type


This method reads the contents from the given byte array and returns the object.  It is expected that the contents in the given buffer was not compressed, and the content stream was written by the corresponding streamOut methods of this class. This method reads the contents from the given byte array and returns the object.  The contents in the given buffer could be compressed or uncompressed depending on the given flag.  It is assumed that the content stream was written by the corresponding streamOut methods of this class. This method reads the contents from the given byte array and returns the object.  It is expected that the contents in the given buffer was not compressed, and the content stream was written by the corresponding streamOut methods of this class. This method reads the contents from the given byte array and returns the object.  The contents in the given buffer could be compressed or uncompressed depending on the given flag.  It is assumed that the content stream was written by the corresponding streamOut methods of this class. This method reads the contents from the given input stream and returns the object.  It is expected that the contents in the given stream was not compressed, and it was written by the corresponding streamOut methods of this class. This method reads the contents from the given input stream and returns the object.  It is expected that the contents in the given stream was not compressed, and it was written by the corresponding streamOut methods of this class. This method reads the contents from the given input stream and returns the object.  The contents in the given stream could be compressed or uncompressed depending on the given flag.  It is assumed that the content stream was written by the corresponding streamOut methods of this class. This method would stream out the given object to the given output stream uncompressed. The output contents could only be read by the corresponding "streamIn" method of this class. This method would stream out the given object to the given output stream uncompressed or compressed depending on the given flag.  The output contents could only be read by the corresponding "streamIn" methods of this class. This routine would stream out the give object uncompressed and store the streamed contents in the return byte array.  The output contents could only be read by the corresponding "streamIn" method of this class. This routine would stream out the give object, uncompressed or compressed depending on the given flag, and store the streamed contents in the return byte array. The output contents could only be read by the corresponding "streamIn" method of this class.
getter of editor type setter of editor type
getter of editor type getter of end char offset getter for start char offset setter of editor type setter of end char offset setter for start char offset










Retrieve the new conflicting <code>Rule</code>. Retrieve the original <code>Rule</code> in the <code>Package</code>. Retrieve the <code>Package</code>.
<p> Retrieve the duration for which the conditions of this <code>Tuple</code> must remain true before the rule will fire. </p>
This is the identity function implementation




Return the underlying fact itself. This is what you asset into the session/engine.














Determine if another object is equal to this. (non-Javadoc) @see org.kie.common.BetaNodeConstraints#getConstraints() (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedLeft(java.lang.Object) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedRight(org.kie.reteoo.ReteTuple) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromFactHandle(org.kie.common.InternalFactHandle) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromTuple(org.kie.reteoo.ReteTuple)










Return the encoding to use for reading from the resource, or <code>null</code> if none specified. Open a <code>java.io.Reader</code> for the specified resource, using the specified encoding (if any). Return the Resource held.













(non-Javadoc) @see org.kie.reteoo.builder.ReteooComponentBuilder#build(org.kie.reteoo.builder.BuildContext, org.kie.reteoo.builder.BuildUtils, org.kie.rule.RuleConditionElement) (non-Javadoc) @see org.kie.reteoo.builder.ReteooComponentBuilder#requiresLeftActivation(org.kie.reteoo.builder.BuildUtils, org.kie.rule.RuleConditionElement)

{@inheritDoc } {@inheritDoc }
Declares the entry point id


There is not reason to clone this object since it is stateless. So a clone() call will return the instance itself. (non-Javadoc) @see java.lang.Object#equals(java.lang.Object) {@inheritDoc } It is not possible to declare any new variables, so always return an Empty Map It is not possible to nest elements inside an entry point, so always return an empty list. It is not possible to declare and export any variables, so always return an empty map (non-Javadoc) @see java.lang.Object#hashCode() Not possible to resolve any declaration, so always return null.

Adds the <code>ObjectSink</code> so that it may receive <code>Objects</code> propagated from this <code>ObjectSource</code>. This is the entry point into the network for all asserted Facts. Iterates a cache of matching <code>ObjectTypdeNode</code>s asserting the Fact. If the cache does not exist it first iterates and builds the cache.  ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Retract a fact object from this <code>RuleBase</code> and the specified <code>WorkingMemory</code>.



Defines the type name Adds an enum literal














Special comparator  that  allows FactHandles to  be  keys, but always  checks equals with the  identity of the  objects involved
Equality for the EqualityKey means two things. It returns true if the object is also an EqualityKey the of the same the same identity as this. It also returns true if the object is equal to the head FactHandle's referenced Object.  Returns the cached hashCode
Equality key  reverses the compare, so  that  the  key  controls the  comparison

We must use an error of JCI problem objects. If there are no problems, null is returned. These errors are placed in the DroolsError instances. Its not 1 to 1 with reported errors.  This needes to be checked if there is infact an error



------------------------------------------------------------ Instance methods ------------------------------------------------------------ Retrieve the <code>Test</code> associated with this node. Returns the next node Returns the previous node Sets the next node Sets the previous node Produce a debug string.







Compares left and right operands using the given predicate and returns TRUE/FALSE accordingly JavaBean -spec compliant accessor. FEEL annotated or else Java accessor. {@link #getDefinedValue(Object, String)} method instead. Compares left and right for equality applying FEEL semantics to specific data types Inverse of {@link #getAccessor(Class, String)}

(non-Javadoc) @see org.kie.reteoo.LeftTuple#getBlockedNext() (non-Javadoc) @see org.kie.reteoo.LeftTuple#getBlockedPrevious() (non-Javadoc) @see org.kie.reteoo.LeftTuple#getBlocker() (non-Javadoc) @see org.kie.reteoo.LeftTuple#setBlockedNext(org.kie.reteoo.LeftTuple) (non-Javadoc) @see org.kie.reteoo.LeftTuple#setBlockedPrevious(org.kie.reteoo.LeftTuple) (non-Javadoc) @see org.kie.reteoo.LeftTuple#setBlocker(org.kie.reteoo.RightTuple) (non-Javadoc) @see org.kie.reteoo.LeftTuple#toString() (non-Javadoc) @see org.kie.reteoo.LeftTuple#unlinkFromLeftParent() (non-Javadoc) @see org.kie.reteoo.LeftTuple#unlinkFromRightParent()





Evaluates the expression using the provided parameters. This method is used when evaluating alpha-constraints, i.e., a fact attribute against a constant value. For instance: Person( name == "Bob" ) So, it uses a constant value "Bob" that is sent into the method as the FieldValue (value), and compares it to the value of the name field, read by using the extractor on the fact instance (object1). Evaluates the expression using the provided parameters. This method is used for internal indexing and hashing, when drools needs to extract and evaluate both left and right values at once. For instance: Person( name == $someName ) This method will be used to extract and evaluate both the "name" attribute and the "$someName" variable at once. Evaluates the expression using the provided parameters. This method is used when evaluating left-activated beta-constraints, i.e., a fact attribute against a variable value, that is activated from the left. For instance: Person( name == $someName ) This method will be used when a new $someName variable is bound. So it will cache the value of $someName and will iterate over the right memory (Person instances) evaluating each occurrence. Evaluates the expression using the provided parameters. This method is used when evaluating right-activated beta-constraints, i.e., a fact attribute against a variable value, that is activated from the right. For instance: Person( name == $someName ) This method will be used when a new Person instance is evaluated. So it will cache the value of the "Person" instance and will iterate over the left memory comparing it to each "$someName" bound values. Returns the value type this evaluator will coerce operands to, during evaluation. This is useful for operators like "memberOf", that always convert to Object when evaluating, independently of the source operand value type. In case this is a temporal evaluator, returns the interval in which this evaluator may match the target fact Returns the operator representation object for this evaluator Returns the type of the values this evaluator operates upon. Returns true if this evaluator implements a temporal evaluation, i.e., a time sensitive evaluation whose properties of matching only events within an specific time interval can be used for determining event expirations automatically.
Returns the evaluator ID for this restriction In case there is any parameter text, this method returns it. Returns null otherwise. A parameter text is evaluator parameters like "after[1,10]". In the previous example, the parameter text will be "1,10". Returns true if this evaluator is boolean negated. Example: "contains" is boolean negated if you want to check the elements that are not contained ("not contains") Sets the evaluator ID for this restriction Sets if this evaluator is negated. Example: "contains" is boolean negated if you want to check the elements that are not contained ("not contains")

Externalizable
Returns the evaluator instance for the given type and the defined parameterText Returns the evaluator instance for the given type and the defined parameterText Returns the evaluator instance for the given type and the defined parameterText Returns the evaluator instance for the given type and the defined parameterText Returns the list of identifies this evaluator implementation supports There are evaluators that operate on *fact* attributes, evaluators that operate on *fact handle* attributes, and evaluators that operate on both. This method returns the target of the current evaluator. My apologies to English speakers if the word "negatable" does not exist. :) This method returns true if this evaluator supports negation. Example: the "matches" operator supports "not matches" and so is "negatable" (!?) Returns true in case this evaluator supports operations over values of that specific type.

Adds an evaluator definition class to the registry using the evaluator class name. The class will be loaded and the corresponting evaluator ID will be added to the registry. In case there exists an implementation for that ID already, the new implementation will replace the previous one. Adds an evaluator definition class to the registry. In case there exists an implementation for that evaluator ID already, the new implementation will replace the previous one. Returns the evaluator instance for the given type and the defined parameterText Returns the evaluator instance for the given type and the defined parameterText Returns the evaluator instance for the given type and the defined parameterText Returns the evaluator definition for the given evaluator ID or null if no one was found Returns the evaluator definition for the given operator or null if no one was found Return the set of registered keys.


This method is called when operators are rewritten as function calls. For instance, x after y Is rewritten as after.evaluate( x, y )



Returns the duration of this event. In case this is a primitive event, returns 0 (zero). Returns the end timestamp for this event. This is the same as: startTimestamp + duration Returns the timestamp of the occurrence of this event. Always returns true, since the EventFactHandle is only used for Events, and not for regular Facts

private static WorkingMemoryFileLogger logger;













(non-Javadoc) @see org.kie.batchexecution.BatchExecutionResult#getIdentifiers() (non-Javadoc) @see org.kie.batchexecution.BatchExecutionResult#getResults()










Add the new mapping to this expander. Expands (process) the expression Just-In-Time for the parser. If the source is not meant to be expanded, or if no appropriate match was found for expansion, it will echo back the same expression. Expands (process) the expression Just-In-Time for the parser. If the source is not meant to be expanded, or if no appropriate match was found for expansion, it will echo back the same expression. Returns the list of errors from the last expansion made Returns true in case the last expansion had any errors


Return false if the assertion

















@Override public String getText() { return "." + getName() + (remove() == null ? "" : remove().getText()); }



















End a configuration node. Get the <code>Locator</code>. Timeout for retrieving remote resources Initializes EntityResolver that is configured via system property ENTITY_RESOLVER_PROPERTY_NAME. Read a <code>RuleSet</code> from an <code>InputStream</code>. ---------------------------------------------------------------------- Instance methods ---------------------------------------------------------------------- Read a <code>RuleSet</code> from a <code>Reader</code>. Read a <code>RuleSet</code> from an <code>InputSource</code>.  Sets the timeout for retrieving remote resources, e.g. xsd schemas  Start a configuration node.

Generates DRL from the input stream containing the spreadsheet.

Registers a new event listener into this FEEL instance. The event listeners are notified about signitificative events during compilation or evaluation of expressions. Compiles the string expression using the given compiler context. Evaluates the given FEEL expression and returns the result Evaluates the given FEEL expression using the given input variables, and returns the result Evaluates the given FEEL expression using the given EvaluationContext, and returns the result Evaluates the given compiled FEEL expression using the given input variables, and returns the result Evaluates the given compiled FEEL expression using the given EvaluationContext, and returns the result Evaluates the given expression as a list of of unary tests. The syntax for this is defined in the FEEL grammar rule #17, i.e., a list of unary tests separated by commas. Evaluates the given expression as a list of of unary tests. The syntax for this is defined in the FEEL grammar rule #17, i.e., a list of unary tests separated by commas. Retrieves the set of registered event listeners Factory method to create a new compiler context Factory method to create a new FEEL engine instance Factory method to create a new FEEL engine instance using custom FEELProfile(s) Removes a listener from the list of event listeners.
Marshalls the given value into FEEL code that can be executed to reconstruct the value. For instance, here are some examples of the marshalling process: * number 10 marshalls as: 10 * string foo marshalls as: "foo" * duration P1D marshalls as: duration( "P1D" ) * context { x : 10, y : foo } marshalls as: { x : 10, y : "foo" } Unmarshalls the string into a FEEL value by executing it.
In case the event refers to the source code, returns the character in the line of the the source code where the event was generated or -1 if it does not refer to a source code character. The column is 0-based. I.e. the first character in the line is 0, the second is 1, and so on. In case the event refers to the source code, returns the line in the source code where the event was generated or -1 if it does not refer to a source code line. The line is 1-based. I.e., the first line is 1, second line is 2, etc. Returns a human readable message about the event In case the event refers to a symbol in the source code, this method returns the offending symbol, as an ANTLR CommonToken instance. Otherwise, it returns null. Returns the severity of the event In case the event relates to an exception, returns the caught Throwable


Registers a new event listener into this FEEL instance. The event listeners are notified about signitificative events during compilation or evaluation of expressions. Retrieves the set of registered event listeners Removes a listener from the list of event listeners.

Returns the name of the function Returns the parameter names for each supported signature. Returns the Symbol of the function Invokes the function reflectively based on the parameters

Marshalls the given FEEL value into an object of type T Unmarshals the marshalled T value into a FEEL object
Either namePart is a string of digits, or it must be a valid name itself


Marshalls the give FEEL value into a String. The result is similar to calling the string() function in a FEEL expression, with the difference that a null value is returned as the "null" string instead of the null value itself. Unmarshalls the given string into a FEEL value. IMPORTANT: please note that it is only possible to unmarshall simple values, like strings and numbers. Complex values like lists and contexts don't have enough metadata marshalled in the string to enable them to be unmarshalled.













Increases the recency of the FactHandle Construct a handle with a new id.
Return the long factId Return the deftemplate for the fact Method returns the value of the given slot at the id. this is used to reset the id, in the event an user tries to assert the same fact again, we reset the id to the existing one.
This will add a top level constraint. This will return the list of field constraints that are in the root CompositeFieldConstraint object. If there is no root, then an empty array will be returned. Returns true if there is a variable bound to this fact. WARNING! This method should only be used for fixtures purposes!




Return an array of all the slots. Get the Slot at the given pattern id Return the slot with the String name Get the pattern index with the given name The name of the template may be the fully qualified class name, or an alias. templates may have 1 or more slots. A slot is a named pattern with a specific type of value.

This will return the line number of the error, if possible Otherwise it will be -1

Method takes a list of Slots and creates a deffact from it. Return all the slots get the Slot at the given pattern id A convienance method for finding the slot matching the String name. Look up the pattern index of the slot the template name is an alias for an object Return the number of slots in the deftemplate Method will return a string format with the int type code for the slot type
Determine if another object is equal to this. ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Return the Fact Template. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - org.kie.spi.ObjectType - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Determine if the passed <code>Object</code> belongs to the object type defined by this <code>objectType</code> instance.

get the value of the specified field on the dynamic fact. Get a map of the fields and their values for the bean. Create a new fact based on the declared fact type. This object will normally be a javabean. Set the value of the field on a dynamic fact. Set the values of the bean from a map.




























End End End End <p/> Foo( bar == $bar )<br> $bar is a VariableRestrictionDescr




Creates the String name for the get method for a field with the given name and type  Returns the value of this attribute in the target bean instance Creates the String name for the set method for a field with the given name and type      Sets the value of this attribute in the target bean instance



This will return true if the value is really a "formula" - in the sense of like an excel spreadsheet. <p/> If it IS a formula, then the value should never be turned into a string, always left as-is.






This will return the line number of the error, if possible Otherwise it will be -1
(non-Javadoc) @see org.kie.facttemplates.FieldTemplate#getQueueIndex() (non-Javadoc) @see org.kie.facttemplates.FieldTemplate#getName() (non-Javadoc) @see org.kie.facttemplates.FieldTemplate#getValueType()

Returns true if the given field value implements the Collection interface






This implementation opens a FileInputStream for the underlying file. This implementation returns a URL for the underlying file.


Looks for multiplication pattern, on each step x multiplied or divided. *x is the same as *(1/x) so this works for both. Looks for sum pattern, on each step x is added or removed. -x is the same as +(-x) so this works for both. Test if the values in constraints are in pattern.















Add days. Add hours. Add minutes. ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Add seconds. Add weeks. - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -










-- Temporal Constraints -- -- query -- -- rule -- -- LHS -- -- Conditional Named Consequnce --





Add a class that should be included in the Kjar. Add one or more dependencies (specified by a "G:A:V" string) that the Kjar should use. Add a path containing one or more resources. If the path is a directory, all files in the directory will be added as resource files. Create the Kjar Create the Kjar and deploy (install) it to the local maven repository. Get the {@link KieModuleModel}. Use the {@link KieModuleModel} instance to add more {@link KieBase} or {@link KieSession} instances as well as add or change the default configuration of the {@link KieSession}'s. Reset the helper. This clears <i>ALL</i> configuration that has been done up to this point on the helper instance. Set the artifact id of the Kjar Set the list of classes to be added to the Kjar. Set the list of dependencies that the Kjar should use. Fluent API Set the group id of the Kjar Set a {@link KieBase} name. </p> If you want to add multiple {@link KieBase}'s, use the {@link FluentKieModuleDeploymentHelper#getKieModuleModel()} method. Set the {@link KieSession} name. </p> If you want to add multiple {@link KieSession}'s, use the {@link FluentKieModuleDeploymentHelper#getKieModuleModel()} method. Set the list of paths containing resources. If the path refers to a directory, all files in that directory will be added as resource files. Set the (pom) version of the Kjar





Adds one more pattern to the list of remaining patterns (non-Javadoc) @see org.kie.rule.ConditionalElement#clone()  Forall inner declarations are only provided by the base patterns since it negates the remaining patterns Forall does not export any declarations  Forall can only resolve declarations from its base pattern

(non-Javadoc) @see org.kie.lang.descr.ConditionalElementDescr#addDescr(org.kie.lang.descr.BaseDescr) Returns the base pattern from the forall CE (non-Javadoc) @see org.kie.lang.descr.ConditionalElementDescr#getDescrs() Returns the remaining patterns from the forall CE

{@inheritDoc } {@inheritDoc }
(non-Javadoc) @see org.kie.xml.Handler#end(java.lang.String, java.lang.String) (non-Javadoc) @see org.kie.xml.Handler#generateNodeFor() (non-Javadoc) @see org.kie.xml.Handler#start(java.lang.String, java.lang.String, org.xml.sax.Attributes)



(non-Javadoc) @see org.kie.reteoo.builder.ReteooComponentBuilder#build(org.kie.reteoo.builder.BuildContext, org.kie.reteoo.builder.BuildUtils, org.kie.rule.RuleConditionElement)








Returns the next node Returns the previous node Sets the next node Sets the previous node




{@inheritDoc }











{@inheritDoc }
Sets the function body Sets the function dialect. Default is java. Sets function name Sets an alternate namespace for the function Sets function return type



















Initialize the contents of the frame.







ActionInsertFact, ActionSetField, ActionpdateField TODO Handle definition and value
DeclarationMatcher
(non-Javadoc) @see org.drools.core.management.KnowledgeSessionMonitoringMBean#getAverageFiringTime() (non-Javadoc) @see org.drools.core.management.KnowledgeSessionMonitoringMBean#getKnowledgeBaseId() (non-Javadoc) @see org.drools.core.management.KnowledgeSessionMonitoringMBean#getStatsForRule(java.lang.String) (non-Javadoc) @see org.drools.core.management.KnowledgeSessionMonitoringMBean#getTotalFiringTime() (non-Javadoc) @see org.drools.core.management.KnowledgeSessionMonitoringMBean#getTotalMatchesCancelled() (non-Javadoc) @see org.drools.core.management.KnowledgeSessionMonitoringMBean#getTotalMatchesCreated() (non-Javadoc) @see org.drools.core.management.KnowledgeSessionMonitoringMBean#getTotalMatchesFired()








































Sets the identifier for the global. E.g.: list Sets the type of the global. E.g.: java.util.List


This method is called internally by the StatelessSession, which will provide the WorkingMemory. The returned GlobalResolver is used by the StatefulSessionResult

















Adds the given child as the (index)th child of the this GroupElement Adds a child to the current GroupElement. Restrictions are: NOT/EXISTS: can have only one child, either a single Pattern or another CE Clones all Conditional Elements but references the non ConditionalElement children   Optimize the group element subtree by removing redundancies like an AND inside another AND, OR inside OR, single branches AND/OR, etc. LogicTransformer does further, more complicated, transformations






Extract data relating to a single column Retrieve the correct OtherwiseBuilder for the given column
Labelled Actions are used to group actions on the same bound Fact. Only ActionSetField and ActionUpdateField need to be grouped in this manner. Labelled Actions are used to group actions on the same bound Fact. Only ActionSetField and ActionUpdateField need to be grouped in this manner. take a CSV list and turn it into DRL syntax Build a normal SingleFieldConstraint for a non-otherwise cell value Build a SingleFieldConstraint for an otherwise cell value
Utility method to convert DTCellValues to their String representation



Retrieve, or lazily instantiate a new, AuditLog. This method expands Composite columns into individual columns where knowledge of individual columns is necessary; for example separate columns in the user-interface or where individual columns need to be analysed. Return an immutable list of Pattern columns


Check if the model uses DSLSentences and hence requires expansion. This code is copied from GuidedDecisionTableUtils. GuidedDecisionTableUtils also handles data-types, enums etc and hence requires a DataModelOracle to function. Loading a DataModelOracle just to determine whether the model has DSLs is an expensive operation and not needed here.
Ensure Condition columns are grouped by pattern (as we merge equal patterns in the UI). This operates on the original Model data and therefore should be called before the Decision Table's internal data representation (i.e. DynamicData, DynamicDataRow and CellValue) is populated Convert the legacy Decision Table model to the new
Convert the data-types in the Decision Table model
Convert the Default Values in the Decision Table model


Convert a typed Value into legacy DataType



















Get operator Set operator
Clear all parameters Delete a parameter Get a parameter Get all parameters Set a parameter Set all parameters


(non-Javadoc) @see org.kie.util.Iterator#next() (non-Javadoc) @see org.kie.util.Iterator#reset()

Call this method from your application whenever you want to dump the heap snapshot into a file. get the hotspot diagnostic MBean from the platform MBean server initialize the hotspot diagnostic MBean field







Debug only























Returns whether the given event should be filtered from the event log or not.








Special comparator that allows FactHandles to be keys, but always  checks like for like.



@Override public boolean equals(Object o) { if (this == o) return true;  Imp imp = (Imp) o;  if (getName() != null ? !getName().equals(imp.getName()) : imp.getName() != null) return false; if (getSchool() != null ? !getSchool().equals(imp.getSchool()) : imp.getSchool() != null) return false;  return true; }

public Map getTraits() { return __$$dynamic_traits_set$$; }


Returns true if this ImportDeclaration correctly matches to the given clazz
(non-Javadoc) @see java.lang.Object#equals(java.lang.Object) (non-Javadoc) @see java.lang.Object#hashCode()
Sets the import target









Creates incompatibility map from Incompatibility objects, one rule may have several incompatibility dependencies.


Evaluates the expression using the provided parameters. This method is used for internal indexing and hashing, when drools needs to extract and evaluate both left and right values at once. For instance: Person( name == $someName ) This method will be used to extract and evaluate both the "name" attribute and the "$someName" variable at once.




{@inheritDoc }

Implements the ternary logic AND operation Implements the ternary logic OR operation














































Activates the <code>RuleFlowGroup</code> with the given name. All activations in the given <code>RuleFlowGroup</code> are added to the agenda. As long as the <code>RuleFlowGroup</code> remains active, its activations are automatically added to the agenda. Activates the <code>RuleFlowGroup</code> with the given name. All activations in the given <code>RuleFlowGroup</code> are added to the agenda. As long as the <code>RuleFlowGroup</code> remains active, its activations are automatically added to the agenda. The given processInstanceId and nodeInstanceId define the process context in which this <code>RuleFlowGroup</code> is used. Iterates all the modules in the focus stack returning the total number of <code>Activation</code>s Clears all Activations from the Agenda Clears all Activations from an Activation-Group. Any Activations that are also in an Agenda Group are removed from the Agenda Group. Clears all Activations from an Activation Group. Any Activations that are also in an Agenda Group are removed from the Agenda Group. Clears all Activations from an Agenda Group. Any Activations that are also in an Xor Group are removed the the Xor Group. Clears all Activations from an Agenda Group. Any Activations that are also in an Xor Group are removed the the Xor Group. Deactivates the <code>RuleFlowGroup</code> with the given name. All activations in the given <code>RuleFlowGroup</code> are removed from the agenda. As long as the <code>RuleFlowGroup</code> remains deactive, its activations are not added to the agenda Fires all activations currently in agenda that match the given agendaFilter until the fireLimit is reached or no more activations exist. Keeps firing activations until a halt is called. If in a given moment, there is no activation to fire, it will wait for an activation to be added to an active agenda group or rule flow group. Keeps firing activations until a halt is called. If in a given moment, there is no activation to fire, it will wait for an activation to be added to an active agenda group or rule flow group. Iterates all the <code>AgendGroup<code>s in the focus stack returning the total number of <code>Activation</code>s Returns the current activations filter or null if none is set Returns the name of the agenda group that currently has the focus Returns the WorkignMemory for this Agenda Stop agenda from firing any other rule. It will finish the current rule execution though. Returns true if there is at least one activation of the given rule name in the given ruleflow group name Adds the activation to the agenda. Depending on the mode the agenda is running, the activation may be added to the agenda priority queue (synchronously or asynchronously) or be executed immediately. Sets a filter that prevents activations from being added to the agenda. Sets the Agenda's focus to the specified AgendaGroup
Sets the auto-deactivate status of this RuleFlowGroup. If this is set to true, an active RuleFlowGroup automatically deactivates if it has no more activations.  If it had no activations when it was activated, it will be deactivated immediately.


Returns true if this FactHandle represents and Event or false if this FactHandle represents a regular Fact
Returns the RelaseId configured while creating the Kiecontainer. Returns the ID assigned to the container. Internal use: returns the RelaseId configured while creating the Kiecontainer, or alternatively if the RelaseId was NOT configured while creating the Kiecontainer, returns the the ReleaseId of the KieModule wrapped by this KieContainer. Additionally, please notice this will always gets updated to the parameter passed as updateToVersion(ReleaseId). Returns an already created defualt KieSession for this KieContainer or creates a new one Returns an already created KieSession with the given name for this KieContainer or creates a new one  Returns the actual resolved ReleaseId.



Clear the containerId reference from the internal registry hold by the KieServices. Epsecially helpful to avoid leaking reference on container dispose(), to inadvertently keep a reference in the internal registry which would never be GC.







Returns the description of the resource. This is just a text description of the resource used to add more information about it. This is not a mandatory attribute





This method is called by the agenda right after an activation was fired to allow the working memory to resume any activities blocked during activation firing. This method must be called after finishing any work in the engine, like inserting a new fact or firing a new rule. It will reset the engine idle time counter. This method must be extremely light to avoid contentions when called by multiple threads/entry-points Returns a map of channel Id->Channel of all channels in this working memory Looks for the fact handle associated to the given object by looking up the object IDENTITY (==), even if rule base is configured to AssertBehavior.EQUALITY. Returns the number of time units (usually ms) that the engine is idle according to the session clock or -1 if it is not idle. This method is not synchronised and might return an approximate value. Returns the number of time units (usually ms) to the next scheduled job Returns the TimerService instance (session clock) for this session. Returns the total number of facts in the working memory, i.e., counting all facts from all entry points. This is an approximate value and may not be accurate due to the concurrent nature of the entry points. This method is called by the agenda before firing a new activation to ensure the working memory is in a safe state to fire the activation. This method must be called before starting any new work in the engine, like inserting a new fact or firing a new rule. It will reset the engine idle time counter. This method must be extremely light to avoid contentions when called by multiple threads/entry-points




Calculates the path addition of this interval with another interval. This is given by the following rule: lowerBound = ( this.lowerBound == MIN || another.lowerBound == MIN ) ? MIN : this.lowerBound+another.lowerBound; upperBound = ( this.upperBound == MAX || another.upperBound == MAX ) ? MAX : this.upperBound+another.upperBound; Calculates the value of the intersection between this Interval and another interval. This is given by the following rule: lowerBound = max( this.lowerBound, another.lowerBound ) upperBound = min( this.upperBound, another.upperBound )


<p> Get the time at which the <code>CronTrigger</code> should quit repeating - even if repeastCount isn't yet satisfied. </p>
















Retrieve the invalid <code>Rule</code>.



TODO FIXME make this return an invertible MetaProperty












Returns {@link File#listFiles()} on a given file, avoids returning null when an IO error occurs.












Performs a depth first visit, but keeping a separate reference of visited/visiting nodes, _also_ to avoid potential issues of circularities. Return a new list of ItemDefinition sorted by dependencies (required dependencies comes first)





Changed implementation, using EntityManager Metamodel in spite of Reflection.


void setNegativeFactHandle(InternalFactHandle insert);  InternalFactHandle getNegativeFactHandle();  void setPositiveFactHandle(InternalFactHandle fh);  InternalFactHandle getPositiveFactHandle();







(non-Javadoc) @see org.kie.spi.Accumulator#accumulate(java.lang.Object, org.kie.spi.Tuple, org.kie.common.InternalFactHandle, org.kie.rule.Declaration[], org.kie.rule.Declaration[], org.kie.WorkingMemory) (non-Javadoc) @see org.kie.spi.Accumulator#createContext() (non-Javadoc) @see org.kie.spi.Accumulator#getResult(java.lang.Object, org.kie.spi.Tuple, org.kie.rule.Declaration[], org.kie.WorkingMemory) (non-Javadoc) @see org.kie.spi.Accumulator#init(java.lang.Object, org.kie.spi.Tuple, org.kie.rule.Declaration[], org.kie.WorkingMemory)

For internal use, returns a new JavaBackedType if clazz can be represented as such, returns null otherwise. If method m is annotated with FEELProperty, will return FEELProperty.value, otherwise empty. If clazz can be represented as a JavaBackedType, returns a JavaBackedType for representing clazz. If clazz can not be represented as a JavaBackedType, returns BuiltInType.UNKNOWN. This method performs memoization when necessary.
Returns the list of in-code, declared variables that are available in the scope of this block Sets the list of in-code, declared variables that are available in the scope of this block

uses the default compiler settings and the current classloader uses the default compiler settings Compiles the java resources "some/path/to/MyJava.java" read through the ResourceReader and then stores the resulting classes in the ResourceStore under "some/path/to/MyJava.class". Note: As these are resource path you always have to use "/" The result of the compilation run including detailed error information is returned as CompilationResult. If you need to get notified already during the compilation process you can register a CompilationProblemHandler. Note: Not all compilers might support this notification mechanism. factory method to create the underlying default settings Set the the handler that gets the notification of an error or warning as soon as this information is available from the compiler. Note: Some compilers might not support this feature.
Tries to guess the class name by convention. So for compilers following the naming convention org.apache.commons.jci.compilers.SomeJavaCompiler you can use the short-hands "some"/"Some"/"SOME". Otherwise you have to provide the full class name. The compiler is getting instanciated via (cached) reflection.


Concatenate a String to the provided buffer suitable for the fieldType and fieldValue. Strings are escaped with double-quotes, Dates are wrapped with a call to a pre-constructed SimpleDateFormatter, whilst Numerics, Booleans, (Java 1.5+) enums and all other fieldTypes are not escaped at all. Guvnor-type enums are really a pick list of Strings and in these cases the underlying fieldType is a String.
This adds a compile "task" for when the compiler of semantics (JCI) is called later on with compileAll()\ which actually does the compiling. The ErrorHandler is required to map the errors back to the element that caused it. This will add the rule for compiling later on. It will not actually call the compiler This actually triggers the compiling of all the resources. Errors are mapped back to the element that originally generated the semantic code.  Returns the current type resolver instance
This will attempt to read the System property to work out what default to set. This should only be done once when the class is loaded. After that point, you will have to programmatically override it. Set the compiler to be used when building the rules semantic code blocks. This overrides the default, and even what was set as a system property. You cannot set language level below 1.5, as we need static imports, 1.5 is now the default.

Handles the read serialization of the PackageCompilationData. Patterns in Rules may reference generated data which cannot be serialized by default methods. The PackageCompilationData holds a reference to the generated bytecode; which must be restored before any Rules. A custom ObjectInputStream, able to resolve classes against the bytecode, is used to restore the Rules. This class drops the classLoader and reloads it. During this process  it must re-wire all the invokeables. Handles the write serialization of the PackageCompilationData. Patterns in Rules may reference generated data which cannot be serialized by default methods. The PackageCompilationData holds a reference to the generated bytecode. The generated bytecode must be restored before any Rules.



Analyze an expression. ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Analyze an expression.




(non-Javadoc) @see org.kie.rule.builder.dialect.java.JavaFunctionBuilder#build(org.kie.rule.Package, org.kie.lang.descr.FunctionDescr, org.codehaus.jfdi.interpreter.TypeResolver, java.util.Map)

(non-Javadoc) @see org.kie.rule.builder.dialect.java.parser.JavaBlockDescr#getEnd() (non-Javadoc) @see org.kie.rule.builder.dialect.java.parser.JavaBlockDescr#getStart()

delegates delegators $ANTLR end "WS" $ANTLR start "COMMENT" $ANTLR end "FloatTypeSuffix" $ANTLR start "CharacterLiteral" $ANTLR end "HexLiteral" $ANTLR start "DecimalLiteral" $ANTLR end "Digits" $ANTLR start "Digit" $ANTLR end "NonZeroDigit" $ANTLR start "DigitOrUnderscore" $ANTLR end "FloatingPointLiteral" $ANTLR start "Digits" $ANTLR end "UnicodeEscape" $ANTLR start "ENUM" $ANTLR end "StringLiteral" $ANTLR start "EscapeSequence" $ANTLR end "Underscores" $ANTLR start "Exponent" $ANTLR end "Exponent" $ANTLR start "FloatTypeSuffix" $ANTLR end "IntegerTypeSuffix" $ANTLR start "FloatingPointLiteral" $ANTLR end "OctalLiteral" $ANTLR start "HexDigit" $ANTLR end "T__126" $ANTLR start "HexLiteral" $ANTLR end "ENUM" $ANTLR start "Identifier" $ANTLR end "HexDigit" $ANTLR start "IntegerTypeSuffix" $ANTLR end "Identifier" $ANTLR start "JavaLetter" $ANTLR end "JavaLetter" $ANTLR start "JavaLetterOrDigit" $ANTLR end "COMMENT" $ANTLR start "LINE_COMMENT" $ANTLR end "Digit" $ANTLR start "NonZeroDigit" $ANTLR end "EscapeSequence" $ANTLR start "OctalEscape" $ANTLR end "DecimalLiteral" $ANTLR start "OctalLiteral" $ANTLR end "CharacterLiteral" $ANTLR start "StringLiteral" $ANTLR end "T__99" $ANTLR start "T__100" $ANTLR end "T__100" $ANTLR start "T__101" $ANTLR end "T__101" $ANTLR start "T__102" $ANTLR end "T__102" $ANTLR start "T__103" $ANTLR end "T__103" $ANTLR start "T__104" $ANTLR end "T__104" $ANTLR start "T__105" $ANTLR end "T__105" $ANTLR start "T__106" $ANTLR end "T__106" $ANTLR start "T__107" $ANTLR end "T__107" $ANTLR start "T__108" $ANTLR end "T__108" $ANTLR start "T__109" $ANTLR end "T__109" $ANTLR start "T__110" $ANTLR end "T__110" $ANTLR start "T__111" $ANTLR end "T__111" $ANTLR start "T__112" $ANTLR end "T__112" $ANTLR start "T__113" $ANTLR end "T__113" $ANTLR start "T__114" $ANTLR end "T__114" $ANTLR start "T__115" $ANTLR end "T__115" $ANTLR start "T__116" $ANTLR end "T__116" $ANTLR start "T__117" $ANTLR end "T__117" $ANTLR start "T__118" $ANTLR end "T__118" $ANTLR start "T__119" $ANTLR end "T__119" $ANTLR start "T__120" $ANTLR end "T__120" $ANTLR start "T__121" $ANTLR end "T__121" $ANTLR start "T__122" $ANTLR end "T__122" $ANTLR start "T__123" $ANTLR end "T__123" $ANTLR start "T__124" $ANTLR end "T__124" $ANTLR start "T__125" $ANTLR end "T__125" $ANTLR start "T__126" $ANTLR start "T__29" $ANTLR end "T__29" $ANTLR start "T__30" $ANTLR end "T__30" $ANTLR start "T__31" $ANTLR end "T__31" $ANTLR start "T__32" $ANTLR end "T__32" $ANTLR start "T__33" $ANTLR end "T__33" $ANTLR start "T__34" $ANTLR end "T__34" $ANTLR start "T__35" $ANTLR end "T__35" $ANTLR start "T__36" $ANTLR end "T__36" $ANTLR start "T__37" $ANTLR end "T__37" $ANTLR start "T__38" $ANTLR end "T__38" $ANTLR start "T__39" $ANTLR end "T__39" $ANTLR start "T__40" $ANTLR end "T__40" $ANTLR start "T__41" $ANTLR end "T__41" $ANTLR start "T__42" $ANTLR end "T__42" $ANTLR start "T__43" $ANTLR end "T__43" $ANTLR start "T__44" $ANTLR end "T__44" $ANTLR start "T__45" $ANTLR end "T__45" $ANTLR start "T__46" $ANTLR end "T__46" $ANTLR start "T__47" $ANTLR end "T__47" $ANTLR start "T__48" $ANTLR end "T__48" $ANTLR start "T__49" $ANTLR end "T__49" $ANTLR start "T__50" $ANTLR end "T__50" $ANTLR start "T__51" $ANTLR end "T__51" $ANTLR start "T__52" $ANTLR end "T__52" $ANTLR start "T__53" $ANTLR end "T__53" $ANTLR start "T__54" $ANTLR end "T__54" $ANTLR start "T__55" $ANTLR end "T__55" $ANTLR start "T__56" $ANTLR end "T__56" $ANTLR start "T__57" $ANTLR end "T__57" $ANTLR start "T__58" $ANTLR end "T__58" $ANTLR start "T__59" $ANTLR end "T__59" $ANTLR start "T__60" $ANTLR end "T__60" $ANTLR start "T__61" $ANTLR end "T__61" $ANTLR start "T__62" $ANTLR end "T__62" $ANTLR start "T__63" $ANTLR end "T__63" $ANTLR start "T__64" $ANTLR end "T__64" $ANTLR start "T__65" $ANTLR end "T__65" $ANTLR start "T__66" $ANTLR end "T__66" $ANTLR start "T__67" $ANTLR end "T__67" $ANTLR start "T__68" $ANTLR end "T__68" $ANTLR start "T__69" $ANTLR end "T__69" $ANTLR start "T__70" $ANTLR end "T__70" $ANTLR start "T__71" $ANTLR end "T__71" $ANTLR start "T__72" $ANTLR end "T__72" $ANTLR start "T__73" $ANTLR end "T__73" $ANTLR start "T__74" $ANTLR end "T__74" $ANTLR start "T__75" $ANTLR end "T__75" $ANTLR start "T__76" $ANTLR end "T__76" $ANTLR start "T__77" $ANTLR end "T__77" $ANTLR start "T__78" $ANTLR end "T__78" $ANTLR start "T__79" $ANTLR end "T__79" $ANTLR start "T__80" $ANTLR end "T__80" $ANTLR start "T__81" $ANTLR end "T__81" $ANTLR start "T__82" $ANTLR end "T__82" $ANTLR start "T__83" $ANTLR end "T__83" $ANTLR start "T__84" $ANTLR end "T__84" $ANTLR start "T__85" $ANTLR end "T__85" $ANTLR start "T__86" $ANTLR end "T__86" $ANTLR start "T__87" $ANTLR end "T__87" $ANTLR start "T__88" $ANTLR end "T__88" $ANTLR start "T__89" $ANTLR end "T__89" $ANTLR start "T__90" $ANTLR end "T__90" $ANTLR start "T__91" $ANTLR end "T__91" $ANTLR start "T__92" $ANTLR end "T__92" $ANTLR start "T__93" $ANTLR end "T__93" $ANTLR start "T__94" $ANTLR end "T__94" $ANTLR start "T__95" $ANTLR end "T__95" $ANTLR start "T__96" $ANTLR end "T__96" $ANTLR start "T__97" $ANTLR end "T__97" $ANTLR start "T__98" $ANTLR end "T__98" $ANTLR start "T__99" $ANTLR end "LINE_COMMENT" $ANTLR end "DigitOrUnderscore" $ANTLR start "Underscores" $ANTLR end "OctalEscape" $ANTLR start "UnicodeEscape" $ANTLR end "JavaLetterOrDigit" $ANTLR start "WS"


$ANTLR end "shiftOp" $ANTLR start "additiveExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1187:1: additiveExpression : multiplicativeExpression ( ( '+' | '-' ) multiplicativeExpression )* ; $ANTLR end "exclusiveOrExpression" $ANTLR start "andExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1157:1: andExpression : equalityExpression ( '&' equalityExpression )* ; $ANTLR end "annotations" $ANTLR start "annotation" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:612:1: annotation : '@' annotationName ( '(' ( elementValuePairs )? ')' )? ; $ANTLR end "annotationMethodRest" $ANTLR start "annotationConstantRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:671:1: annotationConstantRest : variableDeclarators ; $ANTLR end "annotationTypeElementRest" $ANTLR start "annotationMethodOrConstantRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:662:1: annotationMethodOrConstantRest : ( annotationMethodRest | annotationConstantRest ); $ANTLR end "annotationMethodOrConstantRest" $ANTLR start "annotationMethodRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:667:1: annotationMethodRest : Identifier '(' ')' ( defaultValue )? ; $ANTLR end "annotation" $ANTLR start "annotationName" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:616:1: annotationName : Identifier ( '.' Identifier )* ; $ANTLR end "annotationTypeDeclaration" $ANTLR start "annotationTypeBody" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:642:1: annotationTypeBody : '{' ( annotationTypeElementDeclarations )? '}' ; $ANTLR end "elementValueArrayInitializer" $ANTLR start "annotationTypeDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:638:1: annotationTypeDeclaration : '@' 'interface' Identifier annotationTypeBody ; $ANTLR end "annotationTypeElementDeclarations" $ANTLR start "annotationTypeElementDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:650:1: annotationTypeElementDeclaration : ( modifier )* annotationTypeElementRest ; $ANTLR end "annotationTypeBody" $ANTLR start "annotationTypeElementDeclarations" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:646:1: annotationTypeElementDeclarations : ( annotationTypeElementDeclaration ) ( annotationTypeElementDeclaration )* ; $ANTLR end "annotationTypeElementDeclaration" $ANTLR start "annotationTypeElementRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:654:1: annotationTypeElementRest : ( type annotationMethodOrConstantRest ';' | classDeclaration ( ';' )? | interfaceDeclaration ( ';' )? | enumDeclaration ( ';' )? | annotationTypeDeclaration ( ';' )? ); $ANTLR end "booleanLiteral" $ANTLR start "annotations" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:608:1: annotations : ( annotation )+ ; $ANTLR end "superSuffix" $ANTLR start "arguments" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1296:5: arguments : '(' ( expressionList )? ')' ; $ANTLR end "innerCreator" $ANTLR start "arrayCreatorRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1259:1: arrayCreatorRest : '[' ( ']' ( '[' ']' )* arrayInitializer | expression ']' ( '[' expression ']' )* ( '[' ']' )* ) ; $ANTLR end "variableInitializer" $ANTLR start "arrayInitializer" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:499:1: arrayInitializer : '{' ( variableInitializer ( ',' variableInitializer )* ( ',' )? )? '}' ; $ANTLR end "expression" $ANTLR start "assignmentOperator" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1122:1: assignmentOperator : ( '=' | '+=' | '-=' | '*=' | '/=' | '&=' | '|=' | '^=' | '%=' | '<' '<' '=' | '>' '>' '=' | '>' '>' '>' '=' ); $ANTLR end "defaultValue" $ANTLR start "block" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:682:1: block : '{' ( blockStatement )* '}' ; $ANTLR end "block" $ANTLR start "blockStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:696:1: blockStatement : ( localVariableDeclaration | classOrInterfaceDeclaration | statement ); $ANTLR end "integerLiteral" $ANTLR start "booleanLiteral" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:601:1: booleanLiteral : ( 'true' | 'false' ); $ANTLR end "typeParameter" $ANTLR start "bound" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:313:1: bound : type ( '&' type )* ; $ANTLR end "unaryExpressionNotPlusMinus" $ANTLR start "castExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1210:1: castExpression : ( '(' primitiveType ')' unaryExpression | '(' ( type | expression ) ')' unaryExpressionNotPlusMinus ); $ANTLR end "typeList" $ANTLR start "classBody" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:350:1: classBody : '{' ( classBodyDeclaration )* '}' ; $ANTLR end "interfaceBody" $ANTLR start "classBodyDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:358:1: classBodyDeclaration : ( ';' | ( 'static' )? block | ( modifier )* memberDecl ); $ANTLR end "arrayCreatorRest" $ANTLR start "classCreatorRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1266:1: classCreatorRest : arguments ( classBody )? ; $ANTLR end "classOrInterfaceDeclaration" $ANTLR start "classDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:293:1: classDeclaration : ( normalClassDeclaration | enumDeclaration ); $ANTLR end "typeDeclaration" $ANTLR start "classOrInterfaceDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:289:1: classOrInterfaceDeclaration : ( modifier )* ( classDeclaration | interfaceDeclaration ) ; $ANTLR start "compilationUnit" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:269:1: compilationUnit : ( annotations )? ( packageDeclaration )? ( importDeclaration )* ( typeDeclaration )* ; $ANTLR end "conditionalOrExpression" $ANTLR start "conditionalAndExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1145:1: conditionalAndExpression : inclusiveOrExpression ( '&&' inclusiveOrExpression )* ; $ANTLR end "assignmentOperator" $ANTLR start "conditionalExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1137:1: conditionalExpression : conditionalOrExpression ( '?' expression ':' expression )? ; $ANTLR end "conditionalExpression" $ANTLR start "conditionalOrExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1141:1: conditionalOrExpression : conditionalAndExpression ( '||' conditionalAndExpression )* ; $ANTLR end "constructorDeclaratorRest" $ANTLR start "constantDeclarator" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:446:1: constantDeclarator : Identifier constantDeclaratorRest ; $ANTLR end "constantDeclaratorsRest" $ANTLR start "constantDeclaratorRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:486:1: constantDeclaratorRest : ( '[' ']' )* '=' variableInitializer ; $ANTLR end "variableDeclaratorRest" $ANTLR start "constantDeclaratorsRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:482:1: constantDeclaratorsRest : constantDeclaratorRest ( ',' constantDeclarator )* ; $ANTLR end "statementExpression" $ANTLR start "constantExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1114:1: constantExpression : expression ; $ANTLR end "voidInterfaceMethodDeclaratorRest" $ANTLR start "constructorDeclaratorRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:442:1: constructorDeclaratorRest : formalParameters ( 'throws' qualifiedNameList )? methodBody ; This will take a RecognitionException, and create a sensible error message out of it $ANTLR end "creator" $ANTLR start "createdName" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1249:1: createdName : ( Identifier ( typeArguments )? ( '.' Identifier ( typeArguments )? )* | primitiveType ); $ANTLR end "identifierSuffix" $ANTLR start "creator" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1244:1: creator : ( nonWildcardTypeArguments )? createdName ( arrayCreatorRest | classCreatorRest ) ; $ANTLR end "annotationConstantRest" $ANTLR start "defaultValue" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:676:1: defaultValue : 'default' elementValue ; $ANTLR end "retractStatement" $ANTLR start "deleteStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:962:1: deleteStatement : s= 'delete' '(' expression c= ')' ; $ANTLR end "elementValuePair" $ANTLR start "elementValue" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:628:1: elementValue : ( conditionalExpression | annotation | elementValueArrayInitializer ); $ANTLR end "elementValue" $ANTLR start "elementValueArrayInitializer" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:634:1: elementValueArrayInitializer : '{' ( elementValue ( ',' elementValue )* )? '}' ; $ANTLR end "elementValuePairs" $ANTLR start "elementValuePair" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:624:1: elementValuePair : ( Identifier '=' )? elementValue ; $ANTLR end "annotationName" $ANTLR start "elementValuePairs" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:620:1: elementValuePairs : elementValuePair ( ',' elementValuePair )* ; $ANTLR end "enumDeclaration" $ANTLR start "enumBody" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:321:1: enumBody : '{' ( enumConstants )? ( ',' )? ( enumBodyDeclarations )? '}' ; $ANTLR end "enumConstant" $ANTLR start "enumBodyDeclarations" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:333:1: enumBodyDeclarations : ';' ( classBodyDeclaration )* ; $ANTLR end "enumConstants" $ANTLR start "enumConstant" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:329:1: enumConstant : ( annotations )? Identifier ( arguments )? ( classBody )? ; $ANTLR end "packageOrTypeName" $ANTLR start "enumConstantName" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:522:1: enumConstantName : Identifier ; $ANTLR end "enumBody" $ANTLR start "enumConstants" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:325:1: enumConstants : enumConstant ( ',' enumConstant )* ; $ANTLR end "bound" $ANTLR start "enumDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:317:1: enumDeclaration : ENUM Identifier ( 'implements' typeList )? enumBody ; $ANTLR end "insertStatement" $ANTLR start "epStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:986:1: epStatement : (s= 'exitPoints' '[' id= StringLiteral c= ']' |s= 'entryPoints' '[' id= StringLiteral c= ']' |s= 'channels' '[' id= StringLiteral c= ']' ) ; $ANTLR end "andExpression" $ANTLR start "equalityExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1161:1: equalityExpression : instanceOfExpression ( ( '==' | '!=' ) instanceOfExpression )* ; $ANTLR end "inclusiveOrExpression" $ANTLR start "exclusiveOrExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1153:1: exclusiveOrExpression : andExpression ( '^' andExpression )* ; $ANTLR end "classCreatorRest" $ANTLR start "explicitGenericInvocation" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1270:1: explicitGenericInvocation : nonWildcardTypeArguments explicitGenericInvocationSuffix ; $ANTLR end "nonWildcardTypeArguments" $ANTLR start "explicitGenericInvocationSuffix" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1278:1: explicitGenericInvocationSuffix : ( 'super' superSuffix | Identifier arguments ); $ANTLR start "expression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1118:1: expression : conditionalExpression ( assignmentOperator expression )? ; $ANTLR end "parExpression" $ANTLR start "expressionList" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1106:1: expressionList : expression ( ',' expression )* ; $ANTLR end "methodDeclaration" $ANTLR start "fieldDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:388:1: fieldDeclaration : type variableDeclarators ';' ; $ANTLR end "moreStatementExpressions" $ANTLR start "forControl" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1040:1: forControl options {k=3; } : ( forVarControl | ( forInit )? ';' ( expression )? ';' ( forUpdate )? ); $ANTLR end "forControl" $ANTLR start "forInit" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1055:1: forInit : ( ( variableModifier )* type variableDeclarators | expressionList ); $ANTLR end "ifStatement" $ANTLR start "forStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:801:1: forStatement options {k=3; } : x= 'for' y= '(' ( ( ( variableModifier )* type id= Identifier z= ':' expression ) | ( ( forInit )? z= ';' ( expression )? ';' ( forUpdate )? ) ) ')' bs= statement ; $ANTLR end "forVarControl" $ANTLR start "forUpdate" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1096:1: forUpdate : expressionList ; $ANTLR end "forInit" $ANTLR start "forVarControl" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1072:1: forVarControl : ( variableModifier )* type id= Identifier ':' expression ; $ANTLR start "formalParameter" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1018:1: formalParameter : ( variableModifier )* type variableDeclaratorId ; $ANTLR end "formalParameters" $ANTLR start "formalParameterDecls" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:569:1: formalParameterDecls : ( variableModifier )* type ( formalParameterDeclsRest )? ; $ANTLR end "formalParameterDecls" $ANTLR start "formalParameterDeclsRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:573:1: formalParameterDeclsRest : ( variableDeclaratorId ( ',' formalParameterDecls )? | '...' variableDeclaratorId ); $ANTLR end "qualifiedNameList" $ANTLR start "formalParameters" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:565:1: formalParameters : '(' ( formalParameterDecls )? ')' ; $ANTLR end "memberDecl" $ANTLR start "genericMethodOrConstructorDecl" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:374:1: genericMethodOrConstructorDecl : typeParameters genericMethodOrConstructorRest ; $ANTLR end "genericMethodOrConstructorDecl" $ANTLR start "genericMethodOrConstructorRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:378:1: genericMethodOrConstructorRest : ( ( type | 'void' ) Identifier methodDeclaratorRest | Identifier constructorDeclaratorRest ); delegates Return a list of pretty strings summarising the errors return the raw RecognitionException errors return true if any parser errors were accumulated $ANTLR end "methodName" $ANTLR start "identifierSuffix" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1233:1: identifierSuffix : ( ( '[' ']' )+ '.' 'class' | ( '[' expression ']' )+ | arguments | '.' 'class' | '.' explicitGenericInvocation | '.' 'this' | '.' 'super' arguments | '.' 'new' ( nonWildcardTypeArguments )? innerCreator ); $ANTLR end "throwStatement" $ANTLR start "ifStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:766:1: ifStatement : s= 'if' parExpression x= statement (y= 'else' ( 'if' parExpression )? z= statement )* ; $ANTLR end "packageDeclaration" $ANTLR start "importDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:280:1: importDeclaration : 'import' ( 'static' )? Identifier ( '.' Identifier )* ( '.' '*' )? ';' ; $ANTLR end "conditionalAndExpression" $ANTLR start "inclusiveOrExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1149:1: inclusiveOrExpression : exclusiveOrExpression ( '|' exclusiveOrExpression )* ; $ANTLR end "createdName" $ANTLR start "innerCreator" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1255:1: innerCreator : Identifier classCreatorRest ; $ANTLR end "deleteStatement" $ANTLR start "insertStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:974:1: insertStatement : s= 'insert' '(' expression c= ')' ; $ANTLR end "equalityExpression" $ANTLR start "instanceOfExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1165:1: instanceOfExpression : relationalExpression ( 'instanceof' type )? ; $ANTLR end "literal" $ANTLR start "integerLiteral" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:595:1: integerLiteral : ( HexLiteral | OctalLiteral | DecimalLiteral ); $ANTLR end "classBody" $ANTLR start "interfaceBody" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:354:1: interfaceBody : '{' ( interfaceBodyDeclaration )* '}' ; $ANTLR end "fieldDeclaration" $ANTLR start "interfaceBodyDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:392:1: interfaceBodyDeclaration : ( ( modifier )* interfaceMemberDecl | ';' ); $ANTLR end "enumBodyDeclarations" $ANTLR start "interfaceDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:337:1: interfaceDeclaration : ( normalInterfaceDeclaration | annotationTypeDeclaration ); $ANTLR end "interfaceMethodDeclaratorRest" $ANTLR start "interfaceGenericMethodDecl" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:433:1: interfaceGenericMethodDecl : typeParameters ( type | 'void' ) Identifier interfaceMethodDeclaratorRest ; $ANTLR end "interfaceBodyDeclaration" $ANTLR start "interfaceMemberDecl" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:397:1: interfaceMemberDecl : ( interfaceMethodOrFieldDecl | interfaceGenericMethodDecl | 'void' Identifier voidInterfaceMethodDeclaratorRest | interfaceDeclaration | classDeclaration ); $ANTLR end "voidMethodDeclaratorRest" $ANTLR start "interfaceMethodDeclaratorRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:429:1: interfaceMethodDeclaratorRest : formalParameters ( '[' ']' )* ( 'throws' qualifiedNameList )? ';' ; $ANTLR end "interfaceMemberDecl" $ANTLR start "interfaceMethodOrFieldDecl" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:405:1: interfaceMethodOrFieldDecl : type Identifier interfaceMethodOrFieldRest ; $ANTLR end "interfaceMethodOrFieldDecl" $ANTLR start "interfaceMethodOrFieldRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:409:1: interfaceMethodOrFieldRest : ( constantDeclaratorsRest ';' | interfaceMethodDeclaratorRest ); $ANTLR end "qualifiedName" $ANTLR start "literal" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:586:1: literal : ( integerLiteral | FloatingPointLiteral | CharacterLiteral | StringLiteral | booleanLiteral | 'null' ); $ANTLR end "blockStatement" $ANTLR start "localVariableDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:702:1: localVariableDeclaration : ( variableModifier )* type variableDeclarators ';' ; $ANTLR end "classBodyDeclaration" $ANTLR start "memberDecl" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:364:1: memberDecl : ( genericMethodOrConstructorDecl | methodDeclaration | fieldDeclaration | 'void' Identifier voidMethodDeclaratorRest | Identifier constructorDeclaratorRest | interfaceDeclaration | classDeclaration ); $ANTLR end "formalParameterDeclsRest" $ANTLR start "methodBody" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:578:1: methodBody : block ; $ANTLR end "genericMethodOrConstructorRest" $ANTLR start "methodDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:383:1: methodDeclaration : type Identifier methodDeclaratorRest ; $ANTLR end "interfaceMethodOrFieldRest" $ANTLR start "methodDeclaratorRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:414:1: methodDeclaratorRest : formalParameters ( '[' ']' )* ( 'throws' qualifiedNameList )? ( methodBody | ';' ) ; $ANTLR end "primary" $ANTLR start "methodName" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1229:1: methodName : ( Identifier | 'insert' | 'update' | 'modify' | 'retract' | 'delete' ); $ANTLR end "arrayInitializer" $ANTLR start "modifier" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:503:1: modifier : ( annotation | 'public' | 'protected' | 'private' | 'static' | 'abstract' | 'final' | 'native' | 'synchronized' | 'transient' | 'volatile' | 'strictfp' ); $ANTLR end "tryStatement" $ANTLR start "modifyStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:917:1: modifyStatement : s= 'modify' parExpression '{' (e= expression ( ',' e= expression )* )? c= '}' ; $ANTLR end "switchLabel" $ANTLR start "moreStatementExpressions" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1036:1: moreStatementExpressions : ( ',' statementExpression )* ; $ANTLR end "additiveExpression" $ANTLR start "multiplicativeExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1191:1: multiplicativeExpression : unaryExpression ( ( '*' | '/' | '%' ) unaryExpression )* ; $ANTLR end "explicitGenericInvocation" $ANTLR start "nonWildcardTypeArguments" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1274:1: nonWildcardTypeArguments : '<' typeList '>' ; $ANTLR end "classDeclaration" $ANTLR start "normalClassDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:298:1: normalClassDeclaration : 'class' Identifier ( typeParameters )? ( 'extends' type )? ( 'implements' typeList )? classBody ; $ANTLR end "interfaceDeclaration" $ANTLR start "normalInterfaceDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:342:1: normalInterfaceDeclaration : 'interface' Identifier ( typeParameters )? ( 'extends' typeList )? interfaceBody ; $ANTLR end "compilationUnit" $ANTLR start "packageDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:276:1: packageDeclaration : 'package' qualifiedName ';' ; $ANTLR end "modifier" $ANTLR start "packageOrTypeName" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:518:1: packageOrTypeName : Identifier ( '.' Identifier )* ; $ANTLR start "parExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1102:1: parExpression : '(' expression ')' ; $ANTLR end "castExpression" $ANTLR start "primary" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1215:1: primary : ( parExpression | nonWildcardTypeArguments ( explicitGenericInvocationSuffix | 'this' arguments ) | 'this' ( '.' Identifier )* ( identifierSuffix )? | 'super' superSuffix | epStatement ( '.' methodName )* ( identifierSuffix )? | literal | 'new' creator |i= Identifier ( '.' methodName )* ( identifierSuffix )? | primitiveType ( '[' ']' )* '.' 'class' | 'void' '.' 'class' ); $ANTLR end "type" $ANTLR start "primitiveType" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:536:1: primitiveType : ( 'boolean' | 'char' | 'byte' | 'short' | 'int' | 'long' | 'float' | 'double' ); $ANTLR end "methodBody" $ANTLR start "qualifiedName" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:582:1: qualifiedName : Identifier ( '.' Identifier )* ; $ANTLR end "typeArgument" $ANTLR start "qualifiedNameList" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:561:1: qualifiedNameList : qualifiedName ( ',' qualifiedName )* ; $ANTLR end "instanceOfExpression" $ANTLR start "relationalExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1169:1: relationalExpression : shiftExpression ( relationalOp shiftExpression )* ; $ANTLR end "relationalExpression" $ANTLR start "relationalOp" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1173:1: relationalOp : ( '<' '=' | '>' '=' | '<' | '>' ) ; $ANTLR end "updateStatement" $ANTLR start "retractStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:950:1: retractStatement : s= 'retract' '(' expression c= ')' ; $ANTLR end "explicitGenericInvocationSuffix" $ANTLR start "selector" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1283:1: selector : ( '.' methodName ( arguments )? | '.' 'this' | '.' 'super' superSuffix | '.' 'new' ( nonWildcardTypeArguments )? innerCreator | '[' expression ']' ); $ANTLR end "relationalOp" $ANTLR start "shiftExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1177:1: shiftExpression : additiveExpression ( shiftOp additiveExpression )* ; $ANTLR end "shiftExpression" $ANTLR start "shiftOp" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1182:1: shiftOp : ( '<' '<' | '>' '>' '>' | '>' '>' ) ; $ANTLR start "statement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:726:1: statement : ( block | 'assert' expression ( ':' expression )? ';' | ifStatement | forStatement | whileStatement | 'do' statement 'while' parExpression ';' | tryStatement | 'switch' parExpression '{' switchBlockStatementGroups '}' | 'synchronized' parExpression block | 'return' ( expression )? ';' | throwStatement | 'break' ( Identifier )? ';' | 'continue' ( Identifier )? ';' | modifyStatement | updateStatement | retractStatement | deleteStatement | insertStatement | ';' | statementExpression ';' | Identifier ':' statement ); $ANTLR end "expressionList" $ANTLR start "statementExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1110:1: statementExpression : expression ; $ANTLR end "selector" $ANTLR start "superSuffix" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1291:1: superSuffix : ( arguments | '.' Identifier ( arguments )? ); $ANTLR end "switchBlockStatementGroups" $ANTLR start "switchBlockStatementGroup" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1026:1: switchBlockStatementGroup : switchLabel ( blockStatement )* ; $ANTLR end "formalParameter" $ANTLR start "switchBlockStatementGroups" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1022:1: switchBlockStatementGroups : ( switchBlockStatementGroup )* ; $ANTLR end "switchBlockStatementGroup" $ANTLR start "switchLabel" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1030:1: switchLabel : ( 'case' constantExpression ':' | 'case' enumConstantName ':' | 'default' ':' ); $ANTLR end synpred85_Java $ANTLR start synpred120_Java $ANTLR end synpred120_Java $ANTLR start synpred135_Java $ANTLR end synpred135_Java $ANTLR start synpred137_Java $ANTLR end synpred137_Java $ANTLR start synpred139_Java $ANTLR end synpred139_Java $ANTLR start synpred144_Java $ANTLR end synpred144_Java $ANTLR start synpred145_Java $ANTLR end synpred145_Java $ANTLR start synpred171_Java $ANTLR end synpred171_Java $ANTLR start synpred172_Java $ANTLR end synpred172_Java $ANTLR start synpred174_Java $ANTLR end synpred174_Java $ANTLR start synpred190_Java $ANTLR end synpred190_Java $ANTLR start synpred191_Java $ANTLR end synpred191_Java $ANTLR start synpred193_Java $ANTLR end synpred193_Java $ANTLR start synpred198_Java $ANTLR end "arguments" $ANTLR start synpred1_Java $ANTLR end synpred198_Java $ANTLR start synpred201_Java $ANTLR end synpred201_Java $ANTLR start synpred212_Java $ANTLR end synpred286_Java Delegated rules $ANTLR end synpred212_Java $ANTLR start synpred222_Java $ANTLR end synpred222_Java $ANTLR start synpred226_Java $ANTLR end synpred226_Java $ANTLR start synpred228_Java $ANTLR end synpred228_Java $ANTLR start synpred240_Java $ANTLR end synpred240_Java $ANTLR start synpred244_Java $ANTLR end synpred244_Java $ANTLR start synpred245_Java $ANTLR end synpred245_Java $ANTLR start synpred249_Java $ANTLR end synpred249_Java $ANTLR start synpred250_Java $ANTLR end synpred250_Java $ANTLR start synpred253_Java $ANTLR end synpred253_Java $ANTLR start synpred254_Java $ANTLR end synpred254_Java $ANTLR start synpred258_Java $ANTLR end synpred258_Java $ANTLR start synpred259_Java $ANTLR end synpred259_Java $ANTLR start synpred270_Java $ANTLR end synpred270_Java $ANTLR start synpred286_Java $ANTLR end synpred1_Java $ANTLR start synpred38_Java $ANTLR end synpred38_Java $ANTLR start synpred39_Java $ANTLR end synpred39_Java $ANTLR start synpred85_Java $ANTLR end "statement" $ANTLR start "throwStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:750:1: throwStatement : s= 'throw' expression c= ';' ; $ANTLR end "whileStatement" $ANTLR start "tryStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:875:1: tryStatement : s= 'try' bs= '{' ( blockStatement )* c= '}' (s= 'catch' '(' formalParameter ')' bs= '{' ( blockStatement )* c= '}' )* (s= 'finally' bs= '{' ( blockStatement )* c= '}' )? ; $ANTLR start "type" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:531:1: type : ( Identifier ( typeArguments )? ( '.' Identifier ( typeArguments )? )* ( '[' ']' )* | primitiveType ( '[' ']' )* ); $ANTLR end "typeArguments" $ANTLR start "typeArgument" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:556:1: typeArgument : ( type | '?' ( ( 'extends' | 'super' ) type )? ); $ANTLR end "variableModifier" $ANTLR start "typeArguments" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:552:1: typeArguments : '<' typeArgument ( ',' typeArgument )* '>' ; $ANTLR end "importDeclaration" $ANTLR start "typeDeclaration" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:284:1: typeDeclaration : ( classOrInterfaceDeclaration | ';' ); $ANTLR end "normalInterfaceDeclaration" $ANTLR start "typeList" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:346:1: typeList : type ( ',' type )* ; $ANTLR end "enumConstantName" $ANTLR start "typeName" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:526:1: typeName : ( Identifier | packageOrTypeName '.' Identifier ); $ANTLR end "typeParameters" $ANTLR start "typeParameter" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:309:1: typeParameter : Identifier ( 'extends' bound )? ; $ANTLR end "normalClassDeclaration" $ANTLR start "typeParameters" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:305:1: typeParameters : '<' typeParameter ( ',' typeParameter )* '>' ; $ANTLR end "multiplicativeExpression" $ANTLR start "unaryExpression" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1195:1: unaryExpression : ( '+' unaryExpression | '-' unaryExpression | '++' primary | '--' primary | unaryExpressionNotPlusMinus ); $ANTLR end "unaryExpression" $ANTLR start "unaryExpressionNotPlusMinus" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:1203:1: unaryExpressionNotPlusMinus : ( '~' unaryExpression | '!' unaryExpression | castExpression | primary ( selector )* ( '++' | '--' )? ); $ANTLR end "modifyStatement" $ANTLR start "updateStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:938:1: updateStatement : s= 'update' '(' expression c= ')' ; $ANTLR start "variableDeclarator" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:454:1: variableDeclarator : id= Identifier rest= variableDeclaratorRest ; $ANTLR end "constantDeclaratorRest" $ANTLR start "variableDeclaratorId" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:490:1: variableDeclaratorId : Identifier ( '[' ']' )* ; $ANTLR start "variableDeclaratorRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:476:1: variableDeclaratorRest : ( ( '[' ']' )+ ( '=' variableInitializer )? | '=' variableInitializer |); $ANTLR end "constantDeclarator" $ANTLR start "variableDeclarators" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:450:1: variableDeclarators : variableDeclarator ( ',' variableDeclarator )* ; $ANTLR end "variableDeclaratorId" $ANTLR start "variableInitializer" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:494:1: variableInitializer : ( arrayInitializer | expression ); $ANTLR start "variableModifier" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:547:1: variableModifier : ( 'final' | annotation ); $ANTLR end "interfaceGenericMethodDecl" $ANTLR start "voidInterfaceMethodDeclaratorRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:438:1: voidInterfaceMethodDeclaratorRest : formalParameters ( 'throws' qualifiedNameList )? ';' ; $ANTLR end "methodDeclaratorRest" $ANTLR start "voidMethodDeclaratorRest" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:422:1: voidMethodDeclaratorRest : formalParameters ( 'throws' qualifiedNameList )? ( methodBody | ';' ) ; $ANTLR end "forStatement" $ANTLR start "whileStatement" src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:859:1: whileStatement : s= 'while' parExpression bs= statement ;




(non-Javadoc) @see org.kie.rule.builder.dialect.java.RuleClassBuilder#buildRule(org.kie.rule.builder.BuildContext, org.kie.rule.builder.dialect.java.BuildUtils, org.kie.lang.descr.RuleDescr)













This method should only be called by the scheduler











Creates a {@link JtaTransactionManager} instance using any of the {@link javax.transaction.UserTransaction}, {@link javax.transaction.TransactionSynchronizationRegistry}, and {@link javax.transaction.TransactionManager} present in {@code env}.



Clones the provided array Given the set of cliques, mapped via ID in a Bitset, for a given bayes node, Find the best clique. Where best clique is one that contains all it's parents with the smallest number of nodes in that clique. When there are no parents then simply pick the clique with the smallest number nodes. Maps each Bayes node to cliques it's in. It uses a BitSet to map the ID of the cliques






Returns ReleaseId (GAV) of the kjar specified in given resource as properties 'groupId', 'artifactId', and 'version'. Some GAV components (typically 'version') are filtered by Maven, so it is useful to store them in resource files.




Checks the given byte[] data against the signature, using the public key with which this helper was initialised and the algorithm MD5 with RSA. Generates the signature for the given byte[] using MD5 with RSA algorithm and the private key with which this helper was initialised.


(non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#getAlphaNodeHashingThreshold() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#getAssertBehaviour() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#getCompositeKeyDepth() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#getEventProcessingMode() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#getMaxThreads() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#getSequentialAgenda() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#isAdvancedProcessRuleIntegration() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#isIndexLeftBetaMemory() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#isIndexRightBetaMemory() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#isMBeansEnabled() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#isMaintainTms() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#isMultithreadEvaluation() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#isRemoveIdentities() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#isSequential() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#isShareAlphaNodes() (non-Javadoc) @see org.kie.api.management.KBaseConfigurationMonitorMBean#isShareBetaNodes()


(non-Javadoc) @see org.kie.kproject.KieBaseModel#getEqualsBehavior() (non-Javadoc) @see org.kie.kproject.KieBaseModel#getEventProcessingMode() (non-Javadoc) @see org.kie.kproject.KieBaseModel#getKieSessionModels() (non-Javadoc) @see org.kie.kproject.KieBaseModel#getName() (non-Javadoc) @see org.kie.kproject.KieBaseModel#addKSession(org.kie.kproject.KieSessionModelImpl) (non-Javadoc) @see org.kie.kproject.KieBaseModel#removeKieSessionModel(org.kie.kproject.KieSessionModelImpl) (non-Javadoc) @see org.kie.kproject.KieBaseModel#setEqualsBehavior(org.kie.api.conf.EqualityBehaviorOption) (non-Javadoc) @see org.kie.kproject.KieBaseModel#setEventProcessingMode(org.kie.api.conf.EventProcessingOption) (non-Javadoc) @see org.kie.kproject.KieBaseModel#setKSessions(java.util.Map)




Gets a list of file names that represent PMML resources from a KieFileSystem This can be used for performance reason to avoid the recomputation of the pomModel when it is already available

Return an existing instance of a certain contextual type or a null value. Return an existing instance of certain contextual type or create a new instance by calling javax.enterprise.context.spi.Contextual.create(CreationalContext) and return the new instance. Get the scope type of the context object. Determines if the context object is active.

















Deploys the kjar in the given kieModule on the remote repository defined in the distributionManagement tag of the provided pom file. If the pom file doesn't define a distributionManagement no deployment will be performed and a warning message will be logged. Deploys the kjar in the given kieModule on a remote repository. Installs the kjar in the given kieModule into the local repository.


more efficient than instantiating byte buffers and opening streams Method that preloads the source stream into a byte array to bypass the message size limitations in Protobuf unmarshalling. (Protobuf does not enforce a message size limit when unmarshalling from a byte array)
Other methods Getter/Setter's

Add class to the {@link KieFileSystem}. Create the {@link KieFileSystem} instance to store the content going into the KJar. General/Single API Create the pom that will be placed in the KJar. Internal methods Create a KJar and deploy it to maven. Create a KJar for deployment; Create a list of {@link KJarResource} instances with the process files to be included in the KJar. Find the resource files specified and create {@link KJarResource} instances from them. Fluent API







(non-Javadoc) @see org.kie.kModule.KieProject#getKieBaseModels() (non-Javadoc) @see org.kie.kModule.KieProject#removeKieBaseModel(org.kie.kModule.KieBaseModel) (non-Javadoc) @see org.kie.kModule.KieProject#addKBase(org.kie.kModule.KieBaseModelImpl) (non-Javadoc) @see org.kie.kModule.KieProject#removeKieBaseModel(org.kie.kModule.KieBaseModel) (non-Javadoc) @see org.kie.kModule.KieProject#setKBases(java.util.Map) (non-Javadoc) @see org.kie.kModule.KieProject#toString()







(non-Javadoc) @see org.kie.scanner.management.KieScannerMBean#getCurrentReleaseId() (non-Javadoc) @see org.kie.scanner.management.KieScannerMBean#getScannerReleaseId() (non-Javadoc) @see org.kie.scanner.management.KieScannerMBean#getStatus() (non-Javadoc) @see org.kie.scanner.management.KieScannerMBean#scanNow() (non-Javadoc) @see org.kie.scanner.management.KieScannerMBean#start(long) (non-Javadoc) @see org.kie.scanner.management.KieScannerMBean#stop()




Returns KieContainer for the classpath Voids the internal map of containerId (s) used for handling reference and unique checks. This method is intended for use in unit test only.


(non-Javadoc) @see org.kie.kproject.KieSessionModel#getClockType() (non-Javadoc) @see org.kie.kproject.KieSessionModel#getName() (non-Javadoc) @see org.kie.kproject.KieSessionModel#getType() (non-Javadoc) @see org.kie.kproject.KieSessionModel#setClockType(org.kie.api.runtime.conf.ClockTypeOption) (non-Javadoc) @see org.kie.kproject.KieSessionModel#setType(java.lang.String)








Create a new KnowledgeBase using the default KnowledgeBaseConfiguration Create a new KnowledgeBase using the default KnowledgeBaseConfiguration and the given KnowledgeBase ID. Create a new KnowledgeBase using the given KnowledgeBaseConfiguration and the given KnowledgeBase ID. Create a new KnowledgeBase using the given KnowledgeBaseConfiguration Create a KnowledgeBaseConfiguration on which properties can be set. Create a KnowledgeBaseConfiguration on which properties can be set. Use the given properties file and ClassLoader - either of which can be null. Create a KnowledgeSessionConfiguration on which properties can be set. Create a KnowledgeSessionConfiguration on which properties can be set.
Add a <code>Package</code> to the network. Iterates through the <code>Package</code> adding Each individual <code>Rule</code> to the network. Before update network each referenced <code>WorkingMemory</code> is locked. TODO WARN: the below must be mutable as it's used by org.drools.compiler.builder.impl.KnowledgeBuilderTest  TODO WARN: the below must be mutale as that is used by TraitFactory.getClassFieldAccessorStore Retrieve the Rete-OO network for this <code>RuleBase</code>. Merge a new package with an existing package. Most of the work is done by the concrete implementations, but this class does some work (including combining imports, compilation data, globals, and the actual Rule objects into the package). globals class types must be re-wired after serialization type classes must be re-wired after serialization ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Handles the read serialization of the Package. Patterns in Rules may reference generated data which cannot be serialized by default methods. The Package uses PackageCompilationData to hold a reference to the generated bytecode; which must be restored before any Rules. A custom ObjectInputStream, able to resolve classes against the bytecode in the PackageCompilationData, is used to restore the Rules. Handles the write serialization of the Package. Patterns in Rules may reference generated data which cannot be serialized by default methods. The Package uses PackageCompilationData to hold a reference to the generated bytecode. The generated bytecode must be restored before any Rules.
(non-Javadoc) @see org.drools.core.management.KnowledgeBaseMBean#getGlobals() (non-Javadoc) @see org.drools.core.management.KnowledgeBaseMBean#getId() (non-Javadoc) @see org.drools.core.management.KnowledgeBaseMBean#getPackages() (non-Javadoc) @see org.drools.core.management.KnowledgeBaseMBean#getSessionCount() Initialize the open mbean metadata
Adds an evaluator definition class to the registry using the evaluator class name. The class will be loaded and the corresponting evaluator ID will be added to the registry. In case there exists an implementation for that ID already, the new implementation will replace the previous one. Adds an evaluator definition class to the registry. In case there exists an implementation for that evaluator ID already, the new implementation will replace the previous one. Used by droolsjbpm-tools Returns the evaluator registry for this package builder configuration Use this to override the classLoader that will be used for the rules.

This adds a package from a Descr/AST This will also trigger a compile, if there are any generated classes to compile of course. Load a rule package from DRL source. Load a rule package from DRL source using the supplied DSL configuration. Load a rule package from DRL source and associate all loaded artifacts with the given resource. Load a rule package from XML source. Add a ruleflow (.rfm) asset to this package. composite build lifecycle Return the PackageBuilderConfiguration for this PackageBuilder session Returns an expander for DSLs (only if there is a DSL configured for this package).  This will return true if there were errors in the package building and compiling phase Entity rules inherit package attributes Merge a new package with an existing package. Most of the work is done by the concrete implementations, but this class does some work (including combining imports, compilation data, globals, and the actual Rule objects into the package). Reset the error list. This is useful when incrementally building packages. Care should be used when building this, if you clear this when there were errors on items that a rule depends on (eg functions), then you will get spurious errors which will not be that helpful. test
Asserts an object Asserts an object specifying that it implement the onPropertyChange listener


Add a rule flow to this package. Add a <code>Rule</code> to this <code>Package</code>. This will throw an exception if the package is not valid This will return the error summary (if any) if the package is invalid. ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Retrieve the name of this <code>Package</code>. Retrieve a <code>Rule</code> by name. Get the rule flows for this package. The key is the ruleflow id. It will be Collections.EMPTY_MAP if none have been added.  Handles the read serialization of the Package. Patterns in Rules may reference generated data which cannot be serialized by default methods. The Package uses PackageCompilationData to hold a reference to the generated bytecode; which must be restored before any Rules. A custom ObjectInputStream, able to resolve classes against the bytecode in the PackageCompilationData, is used to restore the Rules. Rule flows can be removed by ID. Once this is called, the package will be marked as invalid Once this is called, the package will be marked as invalid public JavaDialectData getPackageCompilationData() { return this.packageCompilationData; } Handles the write serialization of the Package. Patterns in Rules may reference generated data which cannot be serialized by default methods. The Package uses PackageCompilationData to hold a reference to the generated bytecode. The generated bytecode must be restored before any Rules.





(non-Javadoc) @see org.kie.api.persistence.map.EnvironmentBuilder#getPersistenceContextManager() (non-Javadoc) @see org.kie.api.persistence.map.EnvironmentBuilder#getTransactionManager()
























Returns the next node Returns the previous node Sets the next node Sets the previous node



Had to add the set method because sink adapters must override the tuple sink set when the tuple was created.

(non-Javadoc) @see org.kie.reteoo.LeftTuple#getBlockedNext() (non-Javadoc) @see org.kie.reteoo.LeftTuple#getBlockedPrevious() (non-Javadoc) @see org.kie.reteoo.LeftTuple#getBlocker() (non-Javadoc) @see org.kie.reteoo.LeftTuple#setBlockedNext(org.kie.reteoo.LeftTuple) (non-Javadoc) @see org.kie.reteoo.LeftTuple#setBlockedPrevious(org.kie.reteoo.LeftTuple) (non-Javadoc) @see org.kie.reteoo.LeftTuple#setBlocker(org.kie.reteoo.RightTuple) (non-Javadoc) @see org.kie.reteoo.LeftTuple#unlinkFromRightParent()




Returns the next node Returns the previous node Sets the next node Sets the previous node
Add a <code>TupleSinkNode</code> to the list. If the <code>LinkedList</code> is empty then the first and last nodes are set to the added node. Iterates the list removing all the nodes until there are no more nodes to remove. Return the first node in the list Return the last node in the list  Returns a list iterator Removes a <code>TupleSinkNode</code> from the list. This works by attach the previous reference to the child reference. When the node to be removed is the first node it calls <code>removeFirst()</code>. When the node to be removed is the last node it calls <code>removeLast()</code>. Remove the first node from the list. The next node then becomes the first node. If this is the last node then both first and last node references are set to null. Remove the last node from the list. The previous node then becomes the last node. If this is the last node then both first and last node references are set to null.

Adds the <code>TupleSink</code> so that it may receive <code>Tuples</code> propagated from this <code>TupleSource</code>. ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Removes the <code>TupleSink</code>



Work out the type of "field" that is being specified, as in : age age < age == $param age == $1 || age == $2 forall{age < $}{,} <p/> etc. as we treat them all differently. If the type of the column is either FieldType.SINGLE_FIELD or FieldType.OPERATOR_FIELD we have added quotation-marks around the template parameter. Consequentially if a cell value included the quotation-marks (i.e. for an empty-string or white-space) we need to remove the additional quotation-marks. Check whether the column definition is a 'forall' construct. In these situations we do not attempt to strip quotation marks from field values. Returns true if this is building up multiple constraints as in: Foo(a ==b, c == d) etc... If not, then it it really just like the "classic" style DTs.












Add a <code>LinkedListNode</code> to the list. If the <code>LinkedList</code> is empty then the first and last nodes are set to the added node. Add a <code>LinkedListNode</code> to the end of the list. If the <code>LinkedList</code> is empty then the first and last nodes are set to the added node. Iterates the list removing all the nodes until there are no more nodes to remove. Return the first node in the list Return the last node in the list  Removes a <code>LinkedListNode</code> from the list. This works by attach the previous reference to the child reference. When the node to be removed is the first node it calls <code>removeFirst()</code>. When the node to be removed is the last node it calls <code>removeLast()</code>. Remove the first node from the list. The next node then becomes the first node. If this is the last node then both first and last node references are set to null. Remove the last node from the list. The previous node then becomes the last node. If this is the last node then both first and last node references are set to null.

Returns the previous node Sets the previous node

















Returns the type of the log event as defined in this class.


During the logic transformation, we eventually clone CEs, specially patterns and corresponding declarations. So now we need to fix any references to cloned declarations. sets up the parent->child transformations map recurse through the rule condition elements updating the declaration objecs Traverses a Tree, during the process it transforms Or nodes moving the upwards and it removes duplicate logic statement, this does not include Not nodes. Traversal involves three levels the graph for each iteration. The first level is the current node, this node will not be transformed, instead what we are interested in are the children of the current node (called the parent nodes) and the children of those parents (call the child nodes).







public void addValue(Map vars, Object value) { vars.put(getName(), value); }








(non-Javadoc) @see org.kie.spi.Accumulator#accumulate(java.lang.Object, org.kie.spi.Tuple, org.kie.common.InternalFactHandle, org.kie.rule.Declaration[], org.kie.rule.Declaration[], org.kie.WorkingMemory) (non-Javadoc) @see org.kie.spi.Accumulator#createContext() (non-Javadoc) @see org.kie.spi.Accumulator#getResult(java.lang.Object, org.kie.spi.Tuple, org.kie.rule.Declaration[], org.kie.WorkingMemory) (non-Javadoc) @see org.kie.spi.Accumulator#init(java.lang.Object, org.kie.spi.Tuple, org.kie.rule.Declaration[], org.kie.WorkingMemory)







Allows newlines to demarcate expressions, as per MVEL command line. If expression spans multiple lines (ie inside an unbalanced bracket) then it is left alone. Uses character based iteration which is at least an order of magnitude faster then a single simple regex.


{@inheritDoc } (non-Javadoc) @see org.kie.base.extractors.BaseObjectClassFieldExtractor#getValue(java.lang.Object) {@inheritDoc } {@inheritDoc }

Returns current debug mode.<br/> Holds lazy initialized internal reference to improve performance.<br/> Therefore you can't change System property "mvel.debugger" after isDebugMode is called at least once.<br/> <br/> To update debug mode at runtime use {@link MVELDebugHandler#setDebugMode(boolean)}<br/> This is catched by the remote debugger Notify remote debugger that runtime is ready to get latest breakpoint information Sets debug mode on/off.<br/> Updates local MVELDebugHandler property and System property "mvel.debugger"<br/> <br/> There's no need to ever call this method unless you write junit tests!<br/>
public static void setLanguageLevel(int level) { synchronized ( lang ) { // this synchronisation is needed as setLanguageLevel is not thread safe // and we do not want to be calling this while something else is being parsed. // the flag ensures it is just called once and no more. if ( languageSet.booleanValue() == false ) { languageSet = new Boolean( true ); AbstractParser.setLanguageLevel( level ); } } } private Map staticFieldImports = new HashMap(); private Map staticMethodImports = new HashMap();

TODO: FIXME: make it consistent with above



Builds and returns an Eval Conditional Element

Analyse an expression. ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Analyze an expression.


{@inheritDoc } (non-Javadoc) @see org.kie.base.extractors.BaseObjectClassFieldExtractor#getValue(java.lang.Object) {@inheritDoc } {@inheritDoc }
{@inheritDoc } (non-Javadoc) @see org.kie.base.extractors.BaseObjectClassFieldExtractor#getValue(java.lang.Object) {@inheritDoc } {@inheritDoc }








parameterized accessor

Convert the facts from the <code>InputStream</code> to a list of objects.






Javadocs recommend that this method not be overloaded. We overload this so that we can prioritise the fastFindClass over method calls to parent.loadClass(name, false); and c = findBootstrapClass0(name); which the default implementation would first - hence why we call it "fastFindClass" instead of standard findClass, this indicates that we give it a higher priority than normal.








Returns this error code





TODO missing what-if in the case of List..
























Rete visits each of its ObjectTypeNodes. RuleBaseImpl visits its Rete.

















Clones this metadata column instance.
Returns the header for the metadata column.




Compares 2 bytecode listings. Returns true if they are identical. This actually does the comparing. Class1 and Class2 are class reader instances to the respective classes. method1 and method2 are looked up on the respective classes and their contents compared. This is a convenience method. This will return a series of bytecode instructions which can be used to compare one method with another. debug info like local var declarations and line numbers are ignored, so the focus is on the content. This will return a series of bytecode instructions which can be used to compare one method with another. debug info like local var declarations and line numbers are ignored, so the focus is on the content.













Returns alway null, because there is no rule that this is related to.
Takes the given operator e, and returns a reversed version of it.





Check if it was called.

Returns the next node Returns the previous node Sets the next node Sets the previous node
Returns the next node Returns the previous node Sets the next node Sets the previous node











Build a list of method calls, representing each needed {@link org.drools.model.impl.RuleBuilder#attribute(org.drools.model.Rule.Attribute, Object)} starting from a drools-compiler {@link RuleDescr}. The tuple represent the Rule Attribute expressed in JavParser form, and the attribute value expressed in JavaParser form. Build a list of method calls, representing each needed {@link org.drools.model.impl.RuleBuilder#metadata(String, Object)} starting from a drools-compiler {@link RuleDescr}.








not used for execution but for provenance logging only





















(non-Javadoc) @see org.kie.spi.Accumulator#accumulate(java.lang.Object, org.kie.spi.Tuple, org.kie.common.InternalFactHandle, org.kie.rule.Declaration[], org.kie.rule.Declaration[], org.kie.WorkingMemory) (non-Javadoc) @see org.kie.spi.Accumulator#createContext() (non-Javadoc) @see org.kie.spi.Accumulator#getResult(java.lang.Object, org.kie.spi.Tuple, org.kie.rule.Declaration[], org.kie.WorkingMemory) (non-Javadoc) @see org.kie.spi.Accumulator#init(java.lang.Object, org.kie.spi.Tuple, org.kie.rule.Declaration[], org.kie.WorkingMemory)

Slot specific Splits the expression in token (words) ignoring everything that is between quotes Externalizable
Add a quote to literal values, if applicable Concatenate a String to the provided buffer suitable for the fieldValue and fieldType. Strings and Dates are escaped with double-quotes, whilst Numerics, Booleans, (Java 1.5+) enums and all other fieldTypes are not escaped at all. Guvnor-type enums are really a pick list of Strings and in these cases the underlying fieldType is a String. Concatenate a String to the provided buffer suitable for the fieldType and fieldValue. Strings are escaped with double-quotes, Dates are wrapped with a call to a pre-constructed SimpleDateFormatter, whilst Numerics, Booleans, (Java 1.5+) enums and all other fieldTypes are not escaped at all. Guvnor-type enums are really a pick list of Strings and in these cases the underlying fieldType is a String.















There is not reason to clone this object since it is stateless. So a clone() call will return the instance itself. (non-Javadoc) @see java.lang.Object#equals(java.lang.Object) It is not possible to declare any new variables, so always return an Empty Map It is not possible to nest elements inside an entry point, so always return an empty list. It is not possible to declare and export any variables, so always return an empty map (non-Javadoc) @see java.lang.Object#hashCode() Not possible to resolve any declaration, so always return null.


Sets the consequence invocation as breaking or not Sets the consequence name
















Creates list of 'javac' options which can be directly used in #{{@link javax.tools.JavaCompiler#getTask(Writer, JavaFileManager, DiagnosticListener, Iterable, Iterable, Iterable)}} See http://docs.oracle.com/javase/8/docs/technotes/tools/unix/javac.html for full list of javac options.




Receive notification of the end of a non-hashed {@link org.kie.reteoo.AlphaNode}. <p>The parser will invoke this method at the end of every alpha in the network; there will be a corresponding {@link #startNonHashedAlphaNode(org.kie.reteoo.AlphaNode)} event for every endNonHashedAlphaNode event.</p> Receive notification of the a group of hashed {@link org.kie.reteoo.AlphaNode}s. <p>The Parser will invoke this method at the beginning of every groups of hashed Alphas in the Network; there will be a corresponding {@link #endHashedAlphaNodes} event for every startHashedAlphaNodes() event. The actual alpha nodes will be reported via the {@link #startHashedAlphaNode} method, along with all of the node's decendants, in order, before the corresponding {@link #endHashedAlphaNode} event.</p> Receive notification of the a non-hashed {@link org.kie.reteoo.AlphaNode}. <p>The Parser will invoke this method at the beginning of every non-hashed Alpha in the Network; there will be a corresponding endNonHashedAlphaNode() event for every startNonHashedAlphaNode() event. All of the node's decendants will be reported, in order, before the corresponding endNonHashedAlphaNode() event.</p> Receive notification of the beginning of an {@link org.kie.reteoo.ObjectTypeNode} <p>The Network parser will invoke this method only once, before any other event callback.</p>

Returns the number of rules that are associated with this node, regardless of how many times the node is associated with a single rule. Returns how many times this nodes has been associated. Note that due to subnetworks this node could be associated to the same rule multiple times. Returns the unique id that represents the node in the Rete network Returns the partition ID to which this node belongs to










Returns the number of infered fact handles created in this node Returns the number of facts in the fact memory Returns this node ID Returns the actual node Returns the partition ID this node belongs to Returns the set of rules this node belongs to Returns the number of tuples in the tuple memory Returns true if memory is enabled for this node
Returns the number of positions in this memory Peeks at the content of the node memory for the given node ID. This method has no side effects, so if the given memory slot for the given node ID is null, it will return null.











(non-Javadoc) @see org.kie.reteoo.LeftTuple#getBlockedNext() (non-Javadoc) @see org.kie.reteoo.LeftTuple#getBlockedPrevious() (non-Javadoc) @see org.kie.reteoo.LeftTuple#getBlocker() (non-Javadoc) @see org.kie.reteoo.LeftTuple#setBlockedNext(org.kie.reteoo.LeftTuple) (non-Javadoc) @see org.kie.reteoo.LeftTuple#setBlockedPrevious(org.kie.reteoo.LeftTuple) (non-Javadoc) @see org.kie.reteoo.LeftTuple#setBlocker(org.kie.reteoo.RightTuple) (non-Javadoc) @see org.kie.reteoo.LeftTuple#unlinkFromLeftParent() (non-Javadoc) @see org.kie.reteoo.LeftTuple#unlinkFromRightParent()









Checks if an addition of 2 longs caused an overflow

Compile templates, substituting from a collection of maps or objects into the given template. Compile templates, substituting from a collection of maps or objects into the given template.








Returns the fact id of the object this event is about. Returns a toString of the fact this event is about at the time the event was created.
Old marshalling algorithm methods (non-Javadoc) @see org.kie.api.marshalling.impl.ObjectMarshallingStrategyStore#getStrategy(int) (non-Javadoc) @see org.kie.api.marshalling.impl.ObjectMarshallingStrategyStore#getStrategy(java.lang.Object) (non-Javadoc) @see org.kie.api.marshalling.impl.ObjectMarshallingStrategyStore#getStrategyObject(java.lang.Object) New marshalling algorithm methods (non-Javadoc) @see org.kie.api.marshalling.impl.ObjectMarshallingStrategyStore#getStrategyObject(java.lang.String)

Returns the next node Returns the previous node Sets the next node Sets the previous node
Add a <code>ObjectSinkNode</code> to the list. If the <code>LinkedList</code> is empty then the first and last nodes are set to the added node. Iterates the list removing all the nodes until there are no more nodes to remove. Return the first node in the list Return the last node in the list  Returns a list iterator Removes a <code>ObjectSinkNode</code> from the list. This works by attach the previous reference to the child reference. When the node to be removed is the first node it calls <code>removeFirst()</code>. When the node to be removed is the last node it calls <code>removeLast()</code>. Remove the first node from the list. The next node then becomes the first node. If this is the last node then both first and last node references are set to null. Remove the last node from the list. The previous node then becomes the last node. If this is the last node then both first and last node references are set to null.

Adds the <code>ObjectSink</code> so that it may receive <code>FactHandleImpl</code> propagated from this <code>ObjectSource</code>. ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Removes the <code>ObjectSink</code>
This class is not thread safe, changes to the working memory during iteration may give unexpected results This class is not thread safe, changes to the working memory during iteration may give unexpected results This class is not thread safe, changes to the working memory during iteration may give unexpected results This class is not thread safe, changes to the working memory during iteration may give unexpected results
Returns true if the object type represented by this object is an event object type. False otherwise.
Enable TMS for this object type. Whether or not, TMS is active for this object type.
Returns the ObjectTypeConfiguration object for the given object or creates a new one if none is found in the cache

Propagate the <code>FactHandleimpl</code> through the <code>Rete</code> network. All <code>FactHandleImpl</code> should be remembered in the node memory, so that later runtime rule attachmnents can have the matched facts propagated to them. Rete needs to know that this ObjectTypeNode has been added Creates memory for the node using PrimitiveLongMap as its optimised for storage and reteivals of Longs. However PrimitiveLongMap is not ideal for spase data. So it should be monitored incase its more optimal to switch back to a standard HashMap. OTN needs to override remove to avoid releasing the node ID, since OTN are never removed from the rulebase in the current implementation  Retrieve the semantic <code>ObjectType</code> differentiator. Returns the partition ID for which this node belongs to OTN needs to override remove to avoid releasing the node ID, since OTN are never removed from the rulebase in the current implementation Retract the <code>FactHandleimpl</code> from the <code>Rete</code> network. Also remove the <code>FactHandleImpl</code> from the node memory.
Creates a {@link CompiledNetwork} for the specified {@link ObjectTypeNode}. The {@link PackageBuilder} is used to compile the generated source and load the class. This method will output the package statement, followed by the opening of the class declaration Creates the constructor for the generated class. If the hashedAlphaDeclarations is empty, it will just output a empty default constructor; if it is not, the constructor will contain code to fill the hash alpha maps with the values and node ids. Returns the fully qualified binary name of the generated subclass of {@link CompiledNetwork} Returns the fully qualified name of the generated subclass of {@link CompiledNetwork}
(non-Javadoc) @see org.drools.core.management.ObjectTypeNodeMonitorMbean#getEntryPoint() (non-Javadoc) @see org.drools.core.management.ObjectTypeNodeMonitorMbean#getExpirationOffset() (non-Javadoc) @see org.drools.core.management.ObjectTypeNodeMonitorMbean#getId() (non-Javadoc) @see org.drools.core.management.ObjectTypeNodeMonitorMbean#getObjectType() (non-Javadoc) @see org.drools.core.management.ObjectTypeNodeMonitorMbean#getPartitionId() (non-Javadoc) @see org.drools.core.management.ObjectTypeNodeMonitorMbean#isEvent()
Parse the {@link #objectTypeNode}. <p/> <p>The application can use this method to instruct the OTN parser to begin parsing an {@link ObjectTypeNode}.</p> <p/> Once a parse is complete, an application may reuse the same Parser object, possibly with a different {@link NetworkHandler}.</p> Returns the {@link ClassFieldReader} for the hashed AlphaNode. The AlphaNode's constraint has to be a MvelConstraint. This is the only type of hashed alpha currently supported. Returns the first {@link org.kie.reteoo.AlphaNode} from the specified {@link ObjectHashMap}.





Changed with JBRULES-3257 Changed with JBRULES-3257





some BitSet compatability methods ** see {@link intersects} */ ** see {@link andNot} */ Returns the popcount or cardinality of "a and not b" or "intersection(a, not(b))". Neither set is modified. returns the number of 64 bit words it would take to hold numBits Returns the current capacity in bits (1 greater than the index of the last bit) public static int pop(long v0, long v1, long v2, long v3) { // derived from pop_array by setting last four elems to 0. // exchanges one pop() call for 10 elementary operations // saving about 7 instructions... is there a better way? long twosA=v0 & v1; long ones=v0^v1; long u2=ones^v2; long twosB =(ones&v2)|(u2&v3); ones=u2^v3; long fours=(twosA&twosB); long twos=twosA^twosB; return (pop(fours)<<2) + (pop(twos)<<1) + pop(ones); }  Clears a range of bits.  Clearing past the end does not change the size of the set. clears a bit, allowing access beyond the current set size without changing the size. Clears a range of bits.  Clearing past the end does not change the size of the set. Ensure that the long[] is big enough to hold numBits, expanding it if necessary. getNumWords() is unchanged by this call. Expand the long[] with the size given as a number of words (64 bit longs). getNumWords() is unchanged by this call. returns true if both sets have the same bits set clears a bit. The index should be less than the OpenBitSet size. clears a bit. The index should be less than the OpenBitSet size. flips a bit. The index should be less than the OpenBitSet size. flips a bit. The index should be less than the OpenBitSet size. Returns true or false for the specified bit index. The index should be less than the OpenBitSet size Returns true or false for the specified bit index. The index should be less than the OpenBitSet size. Sets the bit at the specified index. The index should be less than the OpenBitSet size. Sets the bit at the specified index. The index should be less than the OpenBitSet size. flips a bit, expanding the set size if necessary Flips a range of bits, expanding the set size if necessary flips a bit and returns the resulting bit value. The index should be less than the OpenBitSet size. flips a bit and returns the resulting bit value. The index should be less than the OpenBitSet size. Returns true or false for the specified bit index. Returns true or false for the specified bit index Sets a bit and returns the previous value. The index should be less than the OpenBitSet size. Sets a bit and returns the previous value. The index should be less than the OpenBitSet size. // alternate implementation of get() public boolean get1(int index) { int i = index >> 6;                // div 64 int bit = index & 0x3f;            // mod 64 return ((bits[i]>>>bit) & 0x01) != 0; // this does a long shift and a bittest (on x86) vs // a long shift, and a long AND, (the test for zero is prob a no-op) // testing on a P4 indicates this is slower than (bits[i] & bitmask) != 0; } returns 1 if the bit is set, 0 if not. The index should be less than the OpenBitSet size Expert: returns the long[] storing the bits Expert: gets the number of longs in the array that are in use this = this AND other Returns the popcount or cardinality of the intersection of the two sets. Neither set is modified. returns true if the sets have any elements in common Returns true if there are no set bits Returns the index of the first set bit starting at the index specified. -1 is returned if there are no more set bits. Returns the index of the first set bit starting at the index specified. -1 is returned if there are no more set bits. ** see {@link union} */ Returns an array size >= minTargetSize, generally over-allocating exponentially to achieve amortized linear-time cost as the array grows. NOTE: this was originally borrowed from Python 2.4.2 listobject.c sources (attribution in LICENSE.txt), but has now been substantially changed based on discussions from java-dev thread with subject "Dynamic array reallocation algorithms", started on Jan 12 2010. Returns the index of the first set bit starting downwards at the index specified. -1 is returned if there are no more set bits. Returns the index of the first set bit starting downwards at the index specified. -1 is returned if there are no more set bits. Remove all elements set in other. this = this AND_NOT other //////////////////////////////////////////////////////////////////////// // BitMask //////////////////////////////////////////////////////////////////////// public boolean get2(int index) { int word = index >> 6;            // div 64 int bit = index & 0x0000003f;     // mod 64 return (bits[word] << bit) < 0;   // hmmm, this would work if bit order were reversed // we could right shift and check for parity bit, if it was available to us. } sets a bit, expanding the set size if necessary Sets a range of bits, expanding the set size if necessary Expert: sets a new long[] to use as the bit storage Expert: sets the number of longs in the array that are in use Returns the current capacity of this set.  Included for compatibility.  This is *not* equal to {@link #cardinality} Lowers numWords, the number of words in use, by checking for trailing zero words. this = this OR other Returns the popcount or cardinality of the union of the two sets. Neither set is modified. this = this XOR other Returns the popcount or cardinality of the exclusive-or of the two sets. Neither set is modified.

Creates a new Operator instance for the given parameters, adds it to the registry and return it Returns the operator instance for the given parameters (non-Javadoc) @see org.kie.base.evaluators.OperatorInterface#getOperatorString() (non-Javadoc) @see org.kie.base.evaluators.OperatorInterface#isNegated()
This is an internal cache of the left string parameter that is set during the rewrite into MVEL, allowing for further analysis of the parameter type. This is an internal cache of the right string parameter that is set during the rewrite into MVEL, allowing for further analysis of the parameter type.     This is an internal cache of the left string parameter that is set during the rewrite into MVEL, allowing for further analysis of the parameter type.  This is an internal cache of the right string parameter that is set during the rewrite into MVEL, allowing for further analysis of the parameter type.

Generate Operator DRL for the given parameters. The parameter Map is not pruned and contains all entries made by the Widget corresponding to the type of operator for which DRL is being built.


Creates opposites map from Opposites objects, one rule may have several opposing dependencies.








(non-Javadoc) @see java.lang.Object#equals(java.lang.Object)   (non-Javadoc) @see java.lang.Object#hashCode()


















Imports a PMML source file, returning a Java descriptor




Returns a copy of the object, or null if the object cannot be serialized.  public String mapDatatypeToQuestion(DATATYPE datatype) { String s = datatype != null ? datatype.value() : null; if (s == null) return Object.class.getName(); if ("Integer".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_NUMBER.getValue(); else if ("Float".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_DECIMAL.getValue(); else if ("Double".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_DECIMAL.getValue(); else if ("Boolean".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_BOOLEAN.getValue(); else if ("String".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_TEXT.getValue(); else if ("Date".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_DATE.getValue(); else if ("Time".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_DATE.getValue(); else if ("DateTime".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_DATE.getValue(); else if ("DateDaysSince[0]".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_NUMBER.getValue(); else if ("DateDaysSince[1960]".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_NUMBER.getValue(); else if ("DateDaysSince[1970]".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_NUMBER.getValue(); else if ("DateDaysSince[1980]".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_NUMBER.getValue(); else if ("TimeSeconds".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_NUMBER.getValue(); else if ("DateTimeSecondsSince[0]".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_NUMBER.getValue(); else if ("DateTimeSecondsSince[1960]".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_NUMBER.getValue(); else if ("DateTimeSecondsSince[1970]".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_NUMBER.getValue(); else if ("DateTimeSecondsSince[1980]".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_NUMBER.getValue(); else if ("collection".equalsIgnoreCase(s)) return Question.QuestionType.TYPE_LIST.getValue(); else return Question.QuestionType.TYPE_TEXT.getValue(); }







Recursive method that adds children models (i.e. models contained within models) to the internal map of models Retrieves a Map whose entries consist of key -> a model identifier value -> the PMML4Model object that the key refers to where the PMML4Model indicates that it Retrieves a Map with entries that consist of key -> a model identifier value -> the List of raw MiningField objects belonging to the model referenced by the key Retrieves a List of the raw MiningField objects for a given model Retrieves a Map with entries that consist of key -> a model identifier value -> the PMML4Model object that the key refers to where the PMML4Model does not indicate a parent model (i.e. the model is not a child model) Initializes the internal structure that holds data dictionary information. This initializer should be called prior to any other initializers, since many other structures may have a dependency on the data dictionary. This method initializes the internal map structures. The order of initialization is important. The internal structures for many models will require that the data dictionary be available Initializes the internal map of models. This map includes all models that are defined within the PMML, including child models (i.e. models contained within models)

















Returns current counter value for generated method names Returns the Map<String invokerClassName, BaseDescr descr> of descriptor lookups Returns the list of errors found while building the current context Returns the Map<String invokerClassName, String invokerCode> of generated invokers Returns the list of generated methods Returns the current package being built Default constructor Allows the change of the current dialect in the context


This method checks for the conditions when local declarations should be read from a tuple instead of the right object when resolving declarations in an accumulate


Returns itself, as there is no container for a package descr builder. {@inheritDoc } Sets the name of the package Adds an accumulate import statement to the package Adds a new Declare statement to the package Adds a new Function statement to the package Adds a function import statement to the package Adds a global statement to the package Adds an import statement to the package Adds a new Query to the package Adds a new Rule to the package Adds a unit statement to the package
{@inheritDoc } {@inheritDoc }













Adds a parameter to the parameter list

The line number on which the error occurred. This will print out a summary, including the line number. It will also print out the cause message if applicable.
















The offset of the fact related to this pattern inside the tuple
Clones this pattern instance. Update this pattern instance properties with the given ones from other pattern instance.






Returns the descriptor generated by this builder.
-- query -- -- rule -- -- Conditional Named Consequnce --





End End leaf End leaf

















This method pessimistically locks the {@link WorkItemInfo} instance This method persists the entity. If pessimistic locking is being used, the method will also immediately lock the entity and return a reference to the locked entity.
This method should be called at the beginning of a {@link ExecutableRunner#execute(org.kie.api.command.Command)} method, when the given {@link ExecutableRunner} instance is responsible for handling persistence. See the {@link PersistableRunner} class. </p> The first responsibility of this method is to make sure that the Command Scoped EntityManager (CSEM) joins the ongoing transaction. </p> When the CSEM is internally managed, this method is also responsible for creating a new CSEM for use during execution of the {@link Command} or operation being executed by the {@link KieSession}. Executes the necessary actions in order to clean up and dispose of the internal fields of this instance. This method should only called in the {@link Synchronization#afterCompletion(int)} method. </p> It is responsible for cleaning up the Command Scoped EntityManager (CSEM) instance, but <i>only</i> when the CSEM is an <i>internal</i> one, and not one supplied (and managed) by the user. </p> If the CSEM is (internally) managed, then this method will take the necessary actions in order to make sure that a new CSEM can be generated at the beginning of the next operation or command on the persistent {@link KieSession}. </p> if the CSEM is supplied (and managed) by the user, this method will do nothing with the CSEM.
This method should be called in the @After method of a test to clean up the persistence unit and datasource. This reads in the (maven filtered) datasource properties from the test resource directory. Return the default database/datasource properties - These properties use an in-memory H2 database This is used when the developer is somehow running the tests but bypassing the maven filtering that's been turned on in the pom. This method uses the "jdbc/testDS1" datasource, which is the default. This sets up a PoolingDataSource.   This method does all of the setup for the test and returns a HashMap containing the persistence objects that the test might need. This method returns whether or not transactions should be used when dealing with the SessionInfo object (or any other persisted entity that contains @Lob's )



more efficient than instantiating byte buffers and opening streams Method that preloads the source stream into a byte array to bypass the message size limitations in Protobuf unmarshalling. (Protobuf does not enforce a message size limit when unmarshalling from a byte array)








Removes a match between left and right tuple



A branch has two potential sinks. rtnSink  is for the sink if the contained logic returns true. mainSink is for propagations after the branch node, if they are allowed. it may have one or the other or both. there is no state that indicates whether one or the other or both are present, so all tuple children must be inspected and references coalesced from that. when handling updates and deletes it must search the child tuples to colasce the references. This is done by checking the tuple sink with the known main or rtn sink.







(non-Javadoc) @see org.kie.reteoo.PropagationContext#getRuleOrigin()

















































{@inheritDoc }














This method is for test utility only.













This method is used in jBPM OSGi Activators as we need a way to force re-initialization when starting the bundles.








This method has to be public because is also used by the android ClassLoader This method has to be public because is also used by the android ClassLoader


Returns the offset of the fact that initiated this propagation in the current propagation context. This attribute is mutable as the same fact might have different offsets in different rules or logical branches. Sets the origin offset to the given offset.




Propagate all queued actions (asserts and retracts). <p/> This method implementation is based on optimistic behavior to avoid the use of locks. There may eventually be a minimum wasted effort, but overall it will be better than paying for the lock's cost.
(non-Javadoc) @see my.hssf.util.SheetListener#finishSheet() Return the key value pairs. If this is called before the sheet is finished, then it will build the properties map with what is known. Subsequent calls will update the properties map. (non-Javadoc) @see my.hssf.util.SheetListener#newCell(int, int, java.lang.String) Enter a new row. This is ignored. (non-Javadoc) @see my.hssf.util.SheetListener#startSheet(java.lang.String)
Gets the base directory of the test execution that was specified by System property <code>basedir</code>. Method expects the property to be set. Returns the directory to store log files. Get all properties defined in build.properties file. Retrieves the property value. Retrieves the property value. Returns location of directory for temporary files





Stream the data into an existing session Create a new session into which to read the stream data









{@inheritDoc }
using current system time as reference ------------------------------------------------------------------------------------ static convenience methods using an arbitrary starting point as reference (non-Javadoc) @see org.kie.temporal.SessionClock#getCurrentTime() convert seconds to milliseconds convert seconds to milliseconds convert seconds to milliseconds convert time given as hours, minutes, seconds, milliseconds to milliseconds

Determine if another object is equal to this. (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedLeft(java.lang.Object) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedRight(org.kie.reteoo.ReteTuple) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromFactHandle(org.kie.common.InternalFactHandle) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromTuple(org.kie.reteoo.ReteTuple)




































Returns the next node Returns the previous node Sets the next node Sets the previous node



Override this as Queries will NEVER have a consequence, and it should not be taken into account when deciding if it is valid.




Returns the Object for int position in the Tuple (non-Javadoc) @see org.kie.api.runtime.rule.QueryResultsRow#get(java.lang.String) Return the Object for the given Declaration. Return a map of Declarations where the key is the identifier and the value is the Declaration. (non-Javadoc) @see org.kie.api.runtime.rule.QueryResultsRow#getFactHandle(java.lang.String) Return the FactHandles for the Tuple. Get the Object for the given FactHandle The size of the Tuple; i.e. the number of columns (FactHandles) in this row result.


Returns the next node Returns the previous node  ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Sets the next node Sets the previous node

public void setBooleanAnswer(String booleanAnswer) { if ( booleanAnswer.trim().equals("y") ) { this.booleanAnswer = true; } else if ( booleanAnswer.trim().equals("y") ) { this.booleanAnswer = false; } else { throw new RuntimeException("String number be 'y' or 'c' it was " + booleanAnswer ); } }























Closes the Reader. Marks the read limit of the Reader.  Reads from the <code>Reader</code>, returning the same value. Reads from the <code>Reader</code> into a byte array Resets the Reader.







































FIXME: return the result of the remove



Returns true if this is a temporal restriction A restriction may be required to replace an old declaration object by a new updated one




Generates DRL from a data provider for the spreadsheet data and templates. Generates DRL from a data provider for the spreadsheet data and templates. Generates DRL from a data provider for the spreadsheet data and templates. Iterate through the resultset.


Adds the <code>ObjectSink</code> so that it may receive <code>Objects</code> propagated from this <code>ObjectSource</code>. This is the entry point into the network for all asserted Facts. Iterates a cache of matching <code>ObjectTypdeNode</code>s asserting the Fact. If the cache does not exist it first iteraes and builds the cache. Retract a fact object from this <code>RuleBase</code> and the specified <code>WorkingMemory</code>.




------------------------------------------------------------ Instance methods ------------------------------------------------------------ Add a <code>Rule</code> to the network. Path's must be removed starting from the outer most path, iterating towards the inner most path. Each time it reaches a subnetwork beta node, the current path evaluation ends, and instead the subnetwork path continues.
Builds and attach if needed the given RuleConditionalElement A boolean function that indicates if the builder requires a previous left (tuple) activation in order to corretly build the given component. In other words, if it returns true and no previous TupleSource is already created, an InitialFact pattern must be added with appropriate left input adapter for the network to be correctly built. For instance, NOT / EXISTS / ACCUMULATE are examples of builders that must return true for this method, while PATTERN must return false.
(non-Javadoc) @see org.kie.reteoo.FactHandleFactory#newFactHandle(long) (non-Javadoc) @see org.kie.reteoo.FactHandleFactory#newInstance()
Adds a query pattern to the given subrule Creates the corresponting Rete network for the given <code>Rule</code> and adds it to the given rule base.
















Creates and return the node memory Returns the next node Returns the previous node Sets the next node Sets the previous node























Move rows on top of the row it has priority over.


Return the hashCode of the <code>TupleKey<code> as the hashCode of the AgendaItem

Returns the configured number of maximum threads to use for concurrent propagation when multi-thread evaluation is enabled. Default is zero. Returns true if this configuration object is immutable or false otherwise. Returns true if the management and monitoring through MBeans is active Returns true if the partitioning of the rulebase is enabled and false otherwise. Default is false. Makes the configuration object immutable. Once it becomes immutable, there is no way to make it mutable again. This is done to keep consistency. Enable declarative agenda Defines if the RuleBase should expose management and monitoring MBeans If multi-thread evaluation is enabled, this parameter configures the maximum number of threads each session can use for concurrent Rete propagation. Defines if the RuleBase should be executed using a pool of threads for evaluating the rules ("true"), or if the rulebase should work in classic single thread mode ("false").
Returns the Package Name Returns the name of the rule


Returns the available declarationResolver instance Returns the current Rule being built Returns the current RuleDescriptor Sets the available declarationResolver instance







Returns a clone from itself Returns a Map of declarations that are visible inside this conditional element Returs a list of RuleConditionElement's that are nested inside the current element Returns a Map of declarations that are visible outside this conditional element. Returns true in case this RuleConditionElement delimits a pattern visibility scope. For instance, AND CE is not a scope delimiter, while NOT CE is a scope delimiter Resolves the given identifier in the current scope and returns the Declaration object for the declaration. Returns null if identifier can not be resolved.




Defines the name of the rule this rule extends. It will cause the rule to inherit the LHS from the parent rule. Defines the LHS (condition) of the rule. The name of the rule. Best practice is to keep rule names relatively short, i.e. under 60 characters. An additional named right hand side (consequence) of the rule. This is a code block that must be valid according to the used dialect (java or MVEL). In particular, the deprecated '#' character, that was used for one line comments is not supported. For one line comments, please use standard '//'. The default right hand side (consequence) of the rule. This is a code block that must be valid according to the used dialect (java or MVEL). In particular, the deprecated '#' character, that was used for one line comments is not supported. For one line comments, please use standard '//'.


Creates verifier object from rule consequence. Currently only supports text based consequences. End leaf







Sets the auto-deactivate status of this RuleFlowGroup. If this is set to true, an active RuleFlowGroup automatically deactivates if it has no more activations.  If it had no activations when it was activated, it will be deactivated immediately.






private void triggerActivations() {  // iterate all activations adding them to their AgendaGroups synchronized ( this.list ) { FastIterator it = list.fastIterator(); for ( ActivationNode entry =  list.getFirst(); entry != null; entry = (ActivationNode) it.next( entry ) ) { final Activation activation = entry.getActivation(); ((InternalAgendaGroup) activation.getAgendaGroup()).add( activation ); } }  // making sure we re-evaluate agenda in case we are waiting for activations ((InternalAgenda) workingMemory.getAgenda()).notifyWaitOnRest(); } Checks if this ruleflow group is active and should automatically deactivate. If the queue is empty, it deactivates the group.






Add a pattern to the rule. All patterns are searched for bindings which are then added to the rule as declarations Retrieve the <code>Consequence</code> associated with this <code>Rule</code>. Retrieve a parameter <code>Declaration</code> by identifier. Retrieve the set of all <i>root fact object </i> parameter <code>Declarations</code>. Returns the lists of queries from which this rule (or query) depends on ordered by their relative dependencies, e.g. if R1 -> A -> B -> C (where the letter are queries) it will return [C, B, A] Retrieve the <code>List</code> of <code>Conditions</code> for this rule. Retrieve the name of this rule. Retrieve the <code>Rule</code> salience. Retrieve the <code>Rule</code> salience value. Returns the Timer semantics for a rule. Timer based rules are not added directly to the Agenda instead they are scheduled for Agenda addition, based on the timer. Uses the LogicTransformer to process the Rule patters - if no ORs are used this will return an array of a single AND element. If there are Ors it will return an And element for each possible logic branch. The processing uses as a clone of the Rule's patterns, so they are not changed. This field is updated at runtime, when the first logical assertion is done. I'm currently not too happy about having this determine at runtime but its currently easier than trying to do this at compile time, although eventually this should be changed This returns true is the rule is effective. If the rule is not effective, it cannot activate. This uses the dateEffective, dateExpires and enabled flag to decide this. Returns <code>true</code> if the rule uses dynamic salience, <code>false</code> otherwise. This will return if the semantic actions or predicates in the rules are valid. This is provided so that lists of rules can be provided even if their semantic actions do not "compile" etc. Determine if this rule is internally consistent and valid. This will include checks to make sure the rules semantic components (actions and predicates) are valid. No exception is thrown. <p> A <code>Rule</code> must include at least one parameter declaration and one condition. </p> Set the <code>Consequence</code> that is associated with the successful match of this rule. Sets the date from which this rule takes effect (can include time to the millisecond). Sets the date after which the rule will no longer apply (can include time to the millisecond). A rule is enabled by default. This can explicitly disable it in which case it will never activate. Set the <code>Rule<code> salience. Sets the timer semantics for a rule. Timer based rules are not added directly to the Agenda instead they are scheduled for Agenda addition, based on the timer.



This gets called each time a "new" rule table is found.

Add metaData This will get a list of all LHS bound variables, including bound fields.. This will get a list of all RHS bound variables. This will get a list of all bound variables (LHS and RHS), including bound fields.. This uses a deceptively simple algorithm to determine what bound variables are in scope for a given constraint (including connectives). Does not take into account globals. Get the data-type associated with the binding This will return the FactPattern that a variable is bound Eto. This will return a List<String> of all FactPattern bindings This will return the FieldConstraint that a variable is bound to. This will return the FactPattern that a variable is bound to. If the variable is bound to a FieldConstraint the parent FactPattern will be returned. This will get a list of all LHS bound variables, excluding bound fields Locate metadata element This will return the ActionInsertFact that a variable is bound to. This will return a List<String> of all ActionInsertFact bindings Returns true if any DSLSentences are used.  Is the Rule to be negated, i.e. "not ( PatternX, PatternY... )" Checks to see if a variable is used or not, includes fields as well as facts.  Set whether the Rule is to be negated Update metaData element if it exists or add it otherwise

If the bound type is not in the DMO it probably hasn't been imported. So we have little option than to fall back to keeping the value as Text. Simple fall-back parser of DRL (non-Javadoc) @see org.drools.ide.common.server.util.RuleModelPersistence#marshal(org.drools.guvnor .client.modeldriven.brl.RuleModel) Marshal model attributes Marshal LHS patterns Marshal model metadata Append package name and imports to DRL Append rule header


TODO This is a naive implementation that won't handle parameter values containing "," TODO for example callMyMethod("Anstis, Michael", 41). This would parse as 3 parameters
Fixme, hack for a upgrade to add Metadata The way method calls are done changed after 5.0.0.CR1 so every rule done before that needs to be updated.
Descent into the model Connective Constraints in 5.2.0 were changed to include the Fact and Field to which they relate. While this should not be necessary (as a ConnectiveConstraint is a further constraint on an already known Fact and Field) it became essential as a hack to have ConnectiveConstraints on sub-fields in a Pattern when an Expression is not used. This codes ensures ConnectiveConstraints on legacy repositories have the fields correctly set.
Descent into the model As from 5.4.0 FieldConstraints hold the FactType to which they relate. This is necessary as both "nested" field constraints and ExpressionFormLine constraints didn't have knowledge of the FactType to which they related and hence field completions could not be ascertained. This also restores fieldNames, that were temporarily fully qualified with the factType, before this more complete fix was made. See BZ724448 (Support for BigDecimal in Guided Editors)
ActionInsertFact, ActionSetField, ActionUpdateField TODO Handle definition and value








Returns the reference to the rule being removed from the kbase



Return the rule sheet properties Build the final ruleset as parsed.
Create a list of Import model objects from cell contents. Create a list of Global model objects from cell contents.  Convert spreadsheet row, column numbers to a cell name.

Replace the optional columns in the rule contents with an if statement. if (column is empty) do not show the line.



(non-Javadoc) @see org.drools.ide.common.server.util.RuleModelPersistence#toXML(org.drools.guvnor .client.modeldriven.brl.RuleModel) (non-Javadoc) @see org.drools.ide.common.server.util.RuleModelPersistence#toModel(java.lang.String )
Returns the next node Returns the previous node Retrieve the <code>Action</code> associated with this node. ------------------------------------------------------------ Instance methods ------------------------------------------------------------ Sets the next node Sets the previous node
(non-Javadoc) @see org.kie.spi.Activation#getActivationNumber() Retrieve the rule. Retrieve the tuple.

Return a wm ready to go based on the rules in a drl at the specified uri (in the classpath).








Utility method showing how to get a rule sheet listener from a stream.








- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  ---------------------------------------------------------------------- Class methods ---------------------------------------------------------------------- Retrieve the singleton instance.


This will return a list of fact names that are in scope (including globals).     Will slip in a fixture after the specified one, but before the next execution trace.   Remove fixtures between this ExecutionTrace and the previous one. Remove the specified fixture. Returns true if this was a totally successful scenario, based on the results contained.






Remove the job identified by the given job handle from the scheduled queue Schedule a job for later execution
Remove the job identified by the given job handle from the scheduled queue Schedule a job for later execution



Adds an enclosed (child) scope Defines a new symbol in this scope This method is used during context-aware parsing to find multi-token symbols iteratively. It is used in conjunction with the #start method above. Gets a map of all children scopes. The key of the map is the string name of the children scope and the value is the scope itself. Returns the scope name Returns the enclosing (parent) scope maybe null. Searches and returns a symbol with the given id if it exists. The search is recursive up, so if a symbol is not found in the current scope, the algorithm searches the parent scopes all the way to the root built-in scope. Searches and returns a symbol with the given qualified name if it exists. The search is recursive up, so if a symbol is not found in the current scope, the algorith searches the parend scopes all the way to the root built-in scope. This method is used during context-aware parsing to find multi-token symbols iteratively. It is used in conjunction with the #followUp method below.











This is a temporary workaround till drools-chance is fully integrated. convienence method for use from Guvnor method for use from Guvnor





public static String getDataType(org.dmg.pmml_4_1.Characteristic c) { for (Extension extension : c.getExtensions()) { if (ScorecardPMMLExtensionNames.CHARACTERTISTIC_DATATYPE.equalsIgnoreCase(extension.getName())) { return extension.getValue(); } } return null; }














Initialises the NodeSegment memory for all nodes in the segment. Is the LeftTupleSource a node in the sub network for the RightInputAdapterNode To be in the same network, it must be a node is after the two output of the parent and before the rianode. Returns whether the node is the root of a segment. Lians are always the root of a segment. node cannot be null. The result should discount any removingRule. That means it gives you the result as if the rule had already been removed from the network. Returns whether the node is the tip of a segment. EndNodes (rtn and rian) are always the tip of a segment. node cannot be null. The result should discount any removingRule. That means it gives you the result as if the rule had already been removed from the network. This adds the segment memory to the terminal node or ria node's list of memories. In the case of the terminal node this allows it to know that all segments from the tip to root are linked. In the case of the ria node its all the segments up to the start of the subnetwork. This is because the rianode only cares if all of it's segments are linked, then it sets the bit of node it is the right input for.














- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ---------------------------------------------------------------------- Class methods ---------------------------------------------------------------------- Retrieve the singleton instance.
public void setFocus(final AgendaGroup focus) { this.workingMemory.setFocus( focus ); } public List getObjects() { return null; //this.workingMemory.getObjects(); }  public List getObjects(final Class objectClass) { return null; //this.workingMemory.getObjects( objectClass ); }  public void clearAgenda() { this.workingMemory.clearAgenda(); }  public void clearAgendaGroup(final String group) { this.workingMemory.clearAgendaGroup( group ); } public QueryResults getQueryResults(final String query) { return this.workingMemory.getQueryResults( query ); }  public AgendaGroup getFocus() { return this.workingMemory.getFocus(); }



Returns the lines of the error in the source file Classes that extend this must provide a printable message, which summarises the error.




If this session is stateful it is disposed Casts this session to KieSession Casts this session to StatelessKieSession

Returns true if this configuration object is immutable or false otherwise. Makes the configuration object immutable. Once it becomes immutable, there is no way to make it mutable again. This is done to keep consistency.












Redefine the set of acceptable values for this cell. Remove an Integer from the values still to be assigned to some cell of this group. Returns the set of Integers that still need to be assigned to some cell of this group. Returns the number of Integers that still need to be assigned to some cell of this group. Returns the first (only) permissible Integer value.




Returns the column number. Returns the row number. Returns the value.




















returns true if event source has no boundaries or all restrictions (i.e. a generation duration or max. number of event instances) are met, false otherwise     add source which will generate events from the given start time on, possibly forever (i.e. no boundaries) add source which will generate events from the given start time on, but only maxItems instances at the most AND not exceeding the time specified by maxDuration add source which will generate events from current clock time on, possibly forever (i.e. no boundaries) add source which will generate events from current clock time on, but only maxItems instances at the most AND not exceeding the time specified by maxDuration
(non-Javadoc) @see com.event.AbstractEventListener#generatedEventSent(com.event.Event)

(non-Javadoc) @see org.kie.common.LogicalDependency#getJustified() (non-Javadoc) @see org.kie.common.LogicalDependency#getJustifier() (non-Javadoc) @see org.kie.common.LogicalDependency#getValue()









JVM classloader can't "scan" for available classes, hence class in scope of Mac/OSX simulation of this classloader must be added manually.

Determine if another object is equal to this. (non-Javadoc) @see org.kie.common.BetaNodeConstraints#getConstraints() (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedLeft(java.lang.Object) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedRight(org.kie.reteoo.ReteTuple) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromFactHandle(org.kie.common.InternalFactHandle) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromTuple(org.kie.reteoo.ReteTuple)






This adds a new connective. Returns true of there is a field binding. This adds a new connective.
This adds a new connective. Returns true of there is a field binding.
General API








Length windows don't change expiration offset, so always return -1

Advances the sliding window      public int getNumberEventsInWindow() { return this.eventsInWindow.size(); }  public List<Event> getEventsInWindow() { return eventsInWindow; }  public void setEventsInWindow(List<Event> eventsInWindow) { this.eventsInWindow = eventsInWindow; }  public void addEventsInWindow(List<Event> additionalEventsInWindow) { this.eventsInWindow.addAll(additionalEventsInWindow); }  public void removeEventsInWindow(List<Event> expiredEventsInWindow) { this.eventsInWindow.removeAll(expiredEventsInWindow); }

Simple replacer. jakarta commons provided the inspiration for this.

Add new descr. Ends subSolvers data collection.









Defines the pattern source as being an accumulation Defines the pattern source as a collection Defines the pattern source as being an entry point Defines the pattern source as being an expression result Defines the pattern source as being a declared window



Generates DRL from the input stream containing the spreadsheet. Looks for a named worksheet to find the decision tables on. Only works with XLS format spreadsheets (as they have multiple worksheets). Generates DRL from the input stream containing the spreadsheet. Generates DRL from the input stream containing the spreadsheet. Convenience implementation, taking rules from the classpath. It is recommended to use the stream version, as you can then change rules dynamically. (that is a lot of the benefit of rule engines !).



























This method must be called after finishing any work in the engine, like inserting a new fact or firing a new rule. It will reset the engine idle time counter. This method must be extremely light to avoid contentions when called by multiple threads/entry-points Keeps firing activations until a halt is called. If in a given moment, there is no activation to fire, it will wait for an activation to be added to an active agenda group or rule flow group. Keeps firing activations until a halt is called. If in a given moment, there is no activation to fire, it will wait for an activation to be added to an active agenda group or rule flow group.   Returns the number of time units (usually ms) that the engine is idle according to the session clock or -1 if it is not idle. This method is not synchronised and might return an approximate value. Retrieve the <code>JoinMemory</code> for a particular <code>JoinNode</code>. Returns the fact Object for the given <code>FactHandle</code>. It actually attempts to return the value from the handle, before retrieving it from objects map. (This shall NOT be exposed on public API) Returns the number of time units (usually ms) to the next scheduled job  This class is not thread safe, changes to the working memory during iteration may give unexpected results This class is not thread safe, changes to the working memory during iteration may give unexpected results This class is not thread safe, changes to the working memory during iteration may give unexpected results This class is not thread safe, changes to the working memory during iteration may give unexpected results ///////////////////////////////////////////////////////////////////////// Start of utility methods used by droolsjbpm-tools ///////////////////////////////////////////////////////////////////////// Sets the AsyncExceptionHandler to handle exceptions thrown by the Agenda Scheduler used for duration rules. This method must be called before starting any new work in the engine, like inserting a new fact or firing a new rule. It will reset the engine idle time counter. This method must be extremely light to avoid contentions when called by multiple threads/entry-points modify is implemented as half way retract / assert due to the truth maintenance issues. ------------------------------------------------------------ Instance methods ------------------------------------------------------------






public void setCurrentValue(int currentValue) { setCurrentValue (currentValue, (Calendar)Calendar.getInstance().clone()); }










public void addValue(Map vars, Object value) { vars.put(getName(), value); }











Normalize the path by suppressing sequences like "path/.." and inner simple dots. <p>The result is convenient for path comparison. For other uses, notice that Windows separators ("\") are replaced by simple slashes. Compares two string being equals ignoring whitespaces, but preserving whitespace between double-quotes The two inputs MUST BE valid DRL/Java syntax (this validation is NOT performed by this method, this method assumes they are). Null check: if either of the input is null, this method will return true IFF both are null. Empty check: if either of the input is an empty string, it will be considered as a whitespace during code-aware comparison. Convenience method to return a Collection as a delimited (e.g. CSV) String. E.g. useful for <code>toString()</code> implementations. Convenience method to return a Collection as a delimited (e.g. CSV) String. E.g. useful for <code>toString()</code> implementations. Delete any character in a given String. Take a String which is a delimited list and convert it to a String array. <p>A single delimiter can consists of more than one character: It will still be considered as single delimiter string, rather than as bunch of potential delimiter characters - in contrast to <code>tokenizeToStringArray</code>. Take a String which is a delimited list and convert it to a String array. <p>A single delimiter can consists of more than one character: It will still be considered as single delimiter string, rather than as bunch of potential delimiter characters - in contrast to <code>tokenizeToStringArray</code>. Empty checks ----------------------------------------------------------------------- <p>Checks if a String is empty ("") or null.</p> <pre> StringUtils.isEmpty(null)      = true StringUtils.isEmpty("")        = true StringUtils.isEmpty(" ")       = false StringUtils.isEmpty("bob")     = false StringUtils.isEmpty("  bob  ") = false </pre> <p>NOTE: This method changed in Lang version 2.0. It no longer trims the String. That functionality is available in isBlank().</p> <p>Returns padding using the specified delimiter repeated to a given length.</p> <pre> StringUtils.padding(0, 'e')  = "" StringUtils.padding(3, 'e')  = "eee" StringUtils.padding(-2, 'e') = IndexOutOfBoundsException </pre> <p>Note: this method doesn't not support padding with <a href="http://www.unicode.org/glossary/#supplementary_character">Unicode Supplementary Characters</a> as they require a pair of <code>char</code>s to be represented. If you are needing to support full I18N of your applications consider using {@link #repeat(String, int)} instead. </p> Padding ----------------------------------------------------------------------- <p>Repeat a String <code>repeat</code> times to form a new String.</p> <pre> StringUtils.repeat(null, 2) = null StringUtils.repeat("", 0)   = "" StringUtils.repeat("", 2)   = "" StringUtils.repeat("a", 3)  = "aaa" StringUtils.repeat("ab", 2) = "abab" StringUtils.repeat("a", -2) = "" </pre> Replace all occurences of a substring within a string with another string. <p>Splits the provided text into an array, separators specified, preserving all tokens, including empty tokens created by adjacent separators. This is an alternative to using StringTokenizer.</p> <p>The separator is not included in the returned String array. Adjacent separators are treated as separators for empty tokens. For more control over the split use the StrTokenizer class.</p> <p>A <code>null</code> input String returns <code>null</code>. A <code>null</code> separatorChars splits on whitespace.</p> <pre> StringUtils.splitPreserveAllTokens(null, *)           = null StringUtils.splitPreserveAllTokens("", *)             = [] StringUtils.splitPreserveAllTokens("abc def", null)   = ["abc", "def"] StringUtils.splitPreserveAllTokens("abc def", " ")    = ["abc", "def"] StringUtils.splitPreserveAllTokens("abc  def", " ")   = ["abc", "", def"] StringUtils.splitPreserveAllTokens("ab:cd:ef", ":")   = ["ab", "cd", "ef"] StringUtils.splitPreserveAllTokens("ab:cd:ef:", ":")  = ["ab", "cd", "ef", ""] StringUtils.splitPreserveAllTokens("ab:cd:ef::", ":") = ["ab", "cd", "ef", "", ""] StringUtils.splitPreserveAllTokens("ab::cd:ef", ":")  = ["ab", "", cd", "ef"] StringUtils.splitPreserveAllTokens(":cd:ef", ":")     = ["", cd", "ef"] StringUtils.splitPreserveAllTokens("::cd:ef", ":")    = ["", "", cd", "ef"] StringUtils.splitPreserveAllTokens(":cd:ef:", ":")    = ["", cd", "ef", ""] </pre> Performs the logic for the <code>split</code> and <code>splitPreserveAllTokens</code> methods that return a maximum array length. Copy the given Collection into a String array. The Collection must contain String elements only. <p>Unescapes any Java literals found in the <code>String</code> to a <code>Writer</code>.</p> <p>For example, it will turn a sequence of <code>'\'</code> and <code>'n'</code> into a newline character, unless the <code>'\'</code> is preceded by another <code>'\'</code>.</p> <p>A <code>null</code> string input has no effect.</p> <p>Unescapes any Java literals found in the <code>String</code>. For example, it will turn a sequence of <code>'\'</code> and <code>'n'</code> into a newline character, unless the <code>'\'</code> is preceded by another <code>'\'</code>.</p>


get/set impl depends on bitmask
get/set impl depends on bitmask













Checks that everything is still according to the sudoku rules. Nice printout of the grid. (non-Javadoc) @see org.kie.examples.sudoku.swing.SudokuGridModel#getCellValue(int, int) (non-Javadoc) @see org.kie.examples.sudoku.swing.SudokuGridModel#setCellValues(java.lang.Integer[][]) (non-Javadoc) @see org.kie.examples.sudoku.swing.SudokuGridModel#solve() (non-Javadoc) @see org.kie.examples.sudoku.swing.SudokuGridModel#step() (non-Javadoc) @see java.lang.Object#toString()


Fired when a cell in the Sudoku grid is updated to a new value Fired when a cell in the Sudoku grid is resolved for the first time to a specific value





















Add a row of data at the specified index Append a row of data Needed for Errai-RPC marshalling
























private static final long    MON_MS = 30 * DAY_MS; private static final long    YEA_MS = 365 * DAY_MS; This method calculates the transitive closure of the given adjacency matrix in order to find the temporal distance between each event represented in the adjacency matrix. For more information on the calculation of the temporal distance, please refer to the paper: "Discarding Unused Temporal Information in a Production System", by Dan Teodosiu and Gunter Pollak. This method also uses an adaptation of the Floyd-Warshall algorithm to calculate the transitive closure of the interval matrix. More information can be found here: http://en.wikipedia.org/wiki/Floyd-Warshall_algorithm The adaptation of the algorithm follows the definition of the path addition and path intersection operations as defined in the paper previously mentioned. The algorithm runs in O(n^3). Parses the given time String and returns the corresponding time in milliseconds





Returns the next node Returns the previous node Sets the next node Sets the previous node Produce a debug string.
Returns the current time from the scheduler clock Returns the number of time units (usually ms) to the next scheduled job This method may return null for some TimerService implementations that do not want the overhead of maintain this. Shuts the service down

Sleeps for specified amount of time in milliseconds. Sleeps for specified amount of time in nanoseconds.







Utitlity functions for console output



Clears all the information Return true if the rule was fired at least once Returns number saying how many times the rule was fired















Edge case: due to the way traits are encoded, consider this hierarchy: A    B C D On don/insertion of C, C may be vetoed by its parents, but might have been already covered by one of its descendants (D)
















Retrieves the factory for creating {@link TransactionManager}s.








This method is used to query the trigger about the existence of a possible next fire time, but WITHOUT changing any internal state of the trigger.  In other words, this method MUST not have side effects. As an analogy, if a trigger was a stack, this method would be the equivalent of a "peek()" call. This method returns the date of the next fire time and updates the internal state of the Trigger to the following fire time if one exists. As an analogy, if a trigger was a stack, this method would be the equivalent of a "pop()" call.






Determine if another object is equal to this. (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedLeft(java.lang.Object) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#isAllowedCachedRight(org.kie.reteoo.ReteTuple) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromFactHandle(org.kie.common.InternalFactHandle) (non-Javadoc) @see org.kie.common.BetaNodeConstraints#updateFromTuple(org.kie.reteoo.ReteTuple)


(non-Javadoc) @see org.kie.core.util.Triple#getInstance() (non-Javadoc) @see org.kie.core.util.Triple#getProperty() (non-Javadoc) @see org.kie.core.util.Triple#getValue()





TMS will be automatically enabled when the first logical insert happens. We will take all the already asserted objects of the same type and initialize the equality map. Adds a justification for the FactHandle to the justifiedMap.

Returns the <code>FactHandle</code> for the given pattern index. If the pattern is empty It returns null. Returns the <code>FactHandle</code> for the given <code>Declaration</code>, which in turn specifcy the <code>Pattern</code> that they depend on. Returns the ReteTuple that contains the "elements" first elements in this tuple. <p/> Use carefully as no cloning is made during this process. <p/> This method is used by TupleStartEqualsConstraint when joining a subnetwork tuple into the main network tuple; Returns the size of this tuple in number of elements (patterns) Returns the fact handles in reverse order



We use this method to aviod to table lookups for the same hashcode; which is what we would have to do if we did a get and then a create if the value is null.



Iterates the entire data structure, regardless of whether TupleMemory is hashed or not. Iterator that resumes from the current RightTuple, regardless of whether the TupleMemory is hashed or not The FactHandle is always the context fact and is necessary when the object being modified is in the both left and right node memories. This is because the memory on the opposite side would not have yet memory.removeAdd the fact, so it could potentially be in the wrong bucket. So the bucket matches check always checks to ignore the first facthandle if it's the same as the context fact.

clear also ensures all contained LeftTuples are cleared reset does not touch any contained tuples


Check if the value passed as parameter can be assigned to this type. Definition of `instance of` accordingly to FEEL specifications Table 49.

{@inheritDoc }          {@inheritDoc } Returns true if the given parameter matches this type declaration
******************************************************************************************************************************************************************** 1) Process the TypeDeclaration Descriptors Resolve names Normalize field descriptors ********************************************************************************************************************************************************************



Defines the type name Defines the super type of this type. For POJOs, this is the super class it will extend



Merges all the missing FactFields from oldDefinition into newDeclaration.


Tries to determine the namespace (package) of a simple type chosen to be the superclass of a declared bean. Looks among imports, local declarations and previous declarations. Means that a class can't extend another class declared in package that has not been loaded yet. not the cleanest logic, but this is what the builders expect downstream





















(non-Javadoc) @see java.lang.Object#equals(java.lang.Object) (non-Javadoc) @see java.lang.Object#hashCode()
Sets the unit target
















Finds a link to object if one exists.
Save a copy in the local cache - in case remote source is not available in future. This implementation compares the underlying URL references. Determine a cleaned URL for the given original URL. This implementation opens an InputStream for the given URL. It sets the "UseCaches" flag to <code>false</code>, mainly to avoid jar file locking on Windows. This implementation returns the hash code of the underlying URL reference.





(non-Javadoc) @see org.kie.base.ValueTypeInterface#getClassType() (non-Javadoc) @see org.kie.base.ValueTypeInterface#getName() (non-Javadoc) @see org.kie.base.ValueTypeInterface#getSimpleType() (non-Javadoc) @see org.kie.base.ValueTypeInterface#isBoolean() (non-Javadoc) @see org.kie.base.ValueTypeInterface#isChar() (non-Javadoc) @see org.kie.base.ValueTypeInterface#isEvent() (non-Javadoc) @see org.kie.base.ValueTypeInterface#isFloatNumber() (non-Javadoc) @see org.kie.base.ValueTypeInterface#isIntegerNumber() (non-Javadoc) @see org.kie.base.ValueTypeInterface#isNumber()











Give model info optionally as a jar. This way verifier doesn't have to figure out the field types. Add resource that is verified. This will run the verifier.














Add external analyzing rules to verifier.



public <T extends VerifierComponent> Collection<T> getAll(VerifierComponentType type) { public <T extends VerifierComponent> T getVerifierObject(VerifierComponentType type, String path) {
public <T extends VerifierComponent> Collection<T> getAll(VerifierComponentType type) { public <T extends VerifierComponent> T getVerifierObject(VerifierComponentType type, String path) {




Adds meta data from DRL to package and rule. (non-Javadoc) @seeorg.drools.verifier.Verifier#addPackageDescr(org.kie.lang.descr. PackageDescr) (non-Javadoc) @see org.kie.verifier.Verifier#dispose() (non-Javadoc) @see org.kie.verifier.Verifier#fireAnalysis() Returns the verifier results as <code>AnalysisResult</code> object. (non-Javadoc) @see org.kie.verifier.Verifier#reloadAnalysisKnowledgeBase()








Return all the items that have given severity value.





Returns the verifier results as plain text. Returns the verifier results as XML.


















************************************************************************* This function is passed two points and calculates the angle between the line defined by these points and the x-axis. ************************************************************************ ************************************************************************* This procedure is passed the basepoint of the intersection of two lines as well as the other two endpoints of the lines and calculates the angle inscribed by these three points. ************************************************************************





{@inheritDoc } {@inheritDoc }
Defines the window name



Creates the WindowNode's memory. Returns the list of behaviors for this window node Returns the <code>FieldConstraints</code> Returns the next node Returns the previous node Sets the next node Sets the previous node
There is not reason to clone this object since it is stateless. So a clone() call will return the instance itself. (non-Javadoc) @see java.lang.Object#equals(java.lang.Object) It is not possible to declare any new variables, so always return an Empty Map {@inheritDoc } It is not possible to nest elements inside an entry point, so always return an empty list. It is not possible to declare and export any variables, so always return an empty map (non-Javadoc) @see java.lang.Object#hashCode() Not possible to resolve any declaration, so always return null.
(non-Javadoc) @see org.kie.reteoo.builder.ReteooComponentBuilder#build(org.kie.reteoo.builder.BuildContext, org.kie.reteoo.builder.BuildUtils, org.kie.rule.RuleConditionElement) (non-Javadoc) @see org.kie.reteoo.builder.ReteooComponentBuilder#requiresLeftActivation(org.kie.reteoo.builder.BuildUtils, org.kie.rule.RuleConditionElement)

















@PreUpdate





Clears the Activation Group, cancellings all its Activations Clear the Agenda. Iterates over each AgendaGroup cancalling all Activations. Clear the Agenda Group, cancelling all its Activations. Clears the RuleFlow group, cancelling all its Activations Fire all items on the agenda until empty. Fire all items on the agenda until empty or at most 'fireLimit' rules have fired Fire all items on the agenda until empty, using the given AgendaFiler Fire all items on the agenda using the given AgendaFiler until empty or at most 'fireLimit' rules have fired Returns the Agenda for this WorkingMemory. While the WorkingMemory interface is considered public, the Agenda interface is more subject to change. Retrieve the <code>FactHandle</code> associated with an Object. Retrieve a specific instance of global data by identifier Returns the current GlobalResolver Retrieve the <code>RuleBase</code> for this working memory. Retrieve the object associated with a <code>FactHandle</code>. Returns the process instance with the given id. Returns the list of process instances of this working memory. This list is unmodifiable. Retrieve the QueryResults of the specified query and arguments Returns the session clock instance associated with this session Returns the interface instance for a given entry point, so that the application can manage entry-point-scoped facts. Stops rule firing after the current rule finishes executing Returns an Iterator for the FactHandles in the Working Memory. This Iterator is not thread safe. This means that any working memory actions during iteration may invalidate the iterator. Returns an Iterator for the Objects in the Working Memory. This Iterator will filter out any objects that the ObjectFilter does not accept. This Iterator is not thread safe. This means that any working memory actions during iteration may invalidate the iterator. Returns an Iterator for the Objects in the Working Memory. This Iterator is not thread safe. This means that any working memory actions during iteration may invalidate the iterator. Returns an Iterator for the Objects in the Working Memory. This Iterator will filter out any objects that the ObjectFilter does not accept. This Iterator is not thread safe. This means that any working memory actions during iteration may invalidate the iterator. Sets the AsyncExceptionHandler to handle exceptions thrown by the Agenda Scheduler used for duration rules. Set the focus to the specified AgendaGroup Set a specific instance as a global in this working memory. Null values will return doing nothing. The global identifier and its type must be declared in the drl. Sets the GlobalResolver instance to be used when resolving globals, replaces the current GlobalResolver. Typcicaly a delegating GlobalResolver is created that first gets a reference to the current GlobalResolver, for delegating Starts a new process instance for the process with the given id. Starts a new process instance for the process with the given id.


Internal method called by the engine when the session is being disposed, so that the entry point can proceed with the necessary clean ups. Insert a fact registering JavaBean <code>PropertyChangeListeners</code> on the Object to automatically trigger <code>update</code> calls if <code>dynamic</code> is <code>true</code>.

Add an event listener. Add an event listener. Returns all event listeners. Returns all event listeners. Remove an event listener. Remove an event listener.

Clears all the events in the log. Sets the name of the file the events are logged in. No extensions should be given since .log is automatically appended to the file name. The default is an event.log file in the current working directory. This can be a path relative to the current working directory (e.g. "mydir/subDir/myLogFile"), or an absolute path (e.g. "C:/myLogFile"). Sets the maximum number of log events that are allowed in memory. If this number is reached, all events are written to file. The default is 1000. All events in the log are written to file. The log is automatically cleared afterwards.
Clears all the events in the log.


Adds the given filter to the list of filters for this event log. A log event must be accepted by all the filters to be entered in the event log.   Clears all filters of this event log. Creates a string representation of the declarations of an activation. This is a list of name-value-pairs for each of the declarations in the tuple of the activation.  The name is the identifier (=name) of the declaration, and the value is a toString of the value of the parameter, followed by the id of the fact between parentheses. This method is invoked every time a new log event is created. It filters out unwanted events. Returns a String that can be used as unique identifier for an activation.  Since the activationId is the same for all assertions that are created during a single insert, update or retract, the key of the tuple of the activation is added too (which is a set of fact handle ids). This method is invoked every time a new log event is created. Subclasses should implement this method and store the event, like for example log to a file or database.      Removes the given filter from the list of filters for this event log. If the given filter was not a filter of this event log, nothing happens.

-- then just delegate













Unnecessary as the stax driver custom anon as static definition is embedding the indentation. Unnecessary as was a tentative UTF-8 preamble output but still not working. Unnecessary as was a tentative UTF-8 preamble output but still not working.


Read a <code>RuleSet</code> from an <code>InputStream</code>. Read a <code>RuleSet</code> from a <code>Reader</code>. Read a <code>RuleSet</code> from an <code>InputSource</code>.
private String processFieldConstraint(final List list) { String descrString = ""; for ( final Iterator it = list.iterator(); it.hasNext(); ) { final Object temp = it.next(); visit( temp ); descrString += this.template; } return descrString; }  public void visitRestrictionConnectiveDescr(final RestrictionConnectiveDescr descr) { this.template = new String(); final List restrictions = descr.getRestrictions(); final String xmlTag = descr.getConnective() == RestrictionConnectiveDescr.OR ? RestrictionConnectiveHandler.OR : RestrictionConnectiveHandler.AND;  if ( restrictions != Collections.EMPTY_LIST ) { this.template = "<" + xmlTag + ">"; this.template += processDescrList( restrictions ); this.template += "</" + xmlTag + ">"; } } Replace illegal xml characters with their escaped equivalent <P>The escaped characters are : <ul> <li> < <li> > <li> & </ul> </p>
Read a <code>RuleSet</code> from an <code>InputStream</code>. Read a <code>RuleSet</code> from a <code>Reader</code>. Read a <code>RuleSet</code> from an <code>InputSource</code>.











