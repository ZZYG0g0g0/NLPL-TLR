
Copies all <tt>candidateAnnotations</tt> with retention policy {@link java.lang.annotation.RetentionPolicy#RUNTIME} and {@link java.lang.annotation.RetentionPolicy#CLASS}. <p> Annotations with {@link org.codehaus.groovy.runtime.GeneratedClosure} members are not supported for now.
Subclasses should implement this method to set the condition of the interruption statement  Subclasses should implement this method to provide good error resolution. Shortcut method which avoids duplicating code for every type of loop. Actually wraps the loopBlock of different types of loop statements. Takes a statement and wraps it into a block statement which first element is the interruption check statement.
Returns the MetaClass that this adapter adapts Sets the MetaClass adapted by this MetaClass
Performs a name resolution to see if the given name is a type from imports, aliases or newly created classes protected String resolveTypeName(String name, boolean safe) { if (name == null) { return null; } return resolveNewClassOrName(name, safe); } Extracts an identifier from the Antlr AST and then performs a name resolution to see if the given name is a type from imports, aliases or newly created classes Converts the Antlr AST to the Groovy AST Expressions ------------------------------------------------------------------------- Helper methods ------------------------------------------------------------------------- Returns true if the modifiers flags contain a visibility modifier Extracts an identifier from the Antlr AST commented out due to groovy.g non-determinisms protected Expression defaultMethodPointerExpression(AST node) { AST exprNode = node.getFirstChild(); String methodName = exprNode.toString(); MethodPointerExpression methodPointerExpression = new MethodPointerExpression(null, methodName); configureAST(methodPointerExpression, node); return methodPointerExpression; } Typically only used for map constructors I think? Top level control structures ------------------------------------------------------------------------- final Statements -------------------------------------------------------------------------
Classes but not interfaces should have ACC_SUPER set See http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.6-300-D.2-5 for what flags are allowed depending on the fact we are writing the inner class table or the class itself Classes but not interfaces should have ACC_SUPER set See http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.6-300-D.2-5 for what flags are allowed depending on the fact we are writing the inner class table or the class itself RHS instance field. should move most of the code in the BytecodeHelper  Loads either this object or if we're inside a closure then load the top level owner Generate the annotation attributes. Note: ignore it. Annotation generation needs the current visitor. return a primitive boolean value of the BooleanExpression. Implementation methods ------------------------------------------------------------------------- GroovyClassVisitor interface ------------------------------------------------------------------------- load class object on stack Generate byte code for constants GroovyCodeVisitor interface ------------------------------------------------------------------------- Statements ------------------------------------------------------------------------- Expressions ------------------------------------------------------------------------- Visits a bare (unqualified) variable expression.




compatibility method
List of field and/or property names to exclude. Must not be used if 'includes' is used. For convenience, a String with comma separated names can be used in addition to an array (using Groovy's literal list notation) of String values. If the {@code @Canonical} behavior is customised by using it in conjunction with one of the more specific related annotations (i.e. {@code @ToString}, {@code @EqualsAndHashCode} or {@code @TupleConstructor}), then the value of this attribute can be overridden within the more specific annotation. List of field and/or property names to include. Must not be used if 'excludes' is used. For convenience, a String with comma separated names can be used in addition to an array (using Groovy's literal list notation) of String values. If the {@code @Canonical} behavior is customised by using it in conjunction with one of the more specific related annotations (i.e. {@code @ToString}, {@code @EqualsAndHashCode} or {@code @TupleConstructor}), then the value of this attribute can be overridden within the more specific annotation.

Invokes the closure without any parameters, returning any value if applicable. Invokes the closure, returning any value if applicable. (non-Javadoc) @see java.lang.Object#clone() Support for Closure currying. Support for Closure currying. <p> Typical usage: <pre class="groovyTestCase"> def multiply = { a, b -> a * b } def doubler = multiply.curry(2) assert doubler(4) == 8 </pre> Note: special treatment is given to Closure vararg-style capability. If you curry a vararg parameter, you don't consume the entire vararg array but instead the first parameter of the vararg array as the following example shows: <pre class="groovyTestCase"> def a = { one, two, Object[] others -> one + two + others.sum() } assert a.parameterTypes.name == ['java.lang.Object', 'java.lang.Object', '[Ljava.lang.Object;'] assert a(1,2,3,4) == 10 def b = a.curry(1) assert b.parameterTypes.name == ['java.lang.Object', '[Ljava.lang.Object;'] assert b(2,3,4) == 10 def c = b.curry(2) assert c.parameterTypes.name == ['[Ljava.lang.Object;'] assert c(3,4) == 10 def d = c.curry(3) assert d.parameterTypes.name == ['[Ljava.lang.Object;'] assert d(4) == 10 def e = d.curry(4) assert e.parameterTypes.name == ['[Ljava.lang.Object;'] assert e() == 10 assert e(5) == 15 </pre> Returns a copy of this closure where the "owner", "delegate" and "thisObject" fields are null, allowing proper serialization when one of them is not serializable.      Gets the strategy which the closure users to resolve methods and properties Support for Closure reverse composition. <p> Typical usage: <pre> def twice = { a -> a * 2 } def thrice = { a -> a * 3 } def times6 = thrice << twice // equivalent: times6 = { a -> thrice(twice(a)) } assert times6(3) == 18 </pre> * Alias for calling a Closure for non-closure arguments. <p> Typical usage: <pre> def twice = { a -> a * 2 } def thrice = { a -> a * 3 } assert thrice << twice << 3 == 18 </pre> @param arg the argument to call the closure with @return the result of calling the Closure Creates a caching variant of the closure. Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache making subsequent calls with the same arguments fast. This variant will keep all cached values forever, i.e. till the closure gets garbage-collected. The returned function can be safely used concurrently from multiple threads, however, the implementation values high average-scenario performance and so concurrent calls on the memoized function with identical argument values may not necessarily be able to benefit from each other's cached return value. With this having been mentioned, the performance trade-off still makes concurrent use of memoized functions safe and highly recommended. The cache gets garbage-collected together with the memoized closure. Creates a caching variant of the closure with automatic cache size adjustment and lower limit on the cache size. Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache making subsequent calls with the same arguments fast. This variant allows the garbage collector to release entries from the cache and at the same time allows the user to specify how many entries should be protected from the eventual gc-initiated eviction. Cached entries exceeding the specified preservation threshold are made available for eviction based on the LRU (Last Recently Used) strategy. Given the non-deterministic nature of garbage collector, the actual cache size may grow well beyond the limits set by the user if memory is plentiful. The returned function can be safely used concurrently from multiple threads, however, the implementation values high average-scenario performance and so concurrent calls on the memoized function with identical argument values may not necessarily be able to benefit from each other's cached return value. Also the protectedCacheSize parameter might not be respected accurately in such scenarios for some periods of time. With this having been mentioned, the performance trade-off still makes concurrent use of memoized functions safe and highly recommended. The cache gets garbage-collected together with the memoized closure. Creates a caching variant of the closure with upper limit on the cache size. Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache making subsequent calls with the same arguments fast. This variant will keep all values until the upper size limit is reached. Then the values in the cache start rotating using the LRU (Last Recently Used) strategy. The returned function can be safely used concurrently from multiple threads, however, the implementation values high average-scenario performance and so concurrent calls on the memoized function with identical argument values may not necessarily be able to benefit from each other's cached return value. With this having been mentioned, the performance trade-off still makes concurrent use of memoized functions safe and highly recommended. The cache gets garbage-collected together with the memoized closure. Creates a caching variant of the closure with automatic cache size adjustment and lower and upper limits on the cache size. Whenever the closure is called, the mapping between the parameters and the return value is preserved in cache making subsequent calls with the same arguments fast. This variant allows the garbage collector to release entries from the cache and at the same time allows the user to specify how many entries should be protected from the eventual gc-initiated eviction. Cached entries exceeding the specified preservation threshold are made available for eviction based on the LRU (Last Recently Used) strategy. Given the non-deterministic nature of garbage collector, the actual cache size may grow well beyond the protected size limits set by the user, if memory is plentiful. Also, this variant will never exceed in size the upper size limit. Once the upper size limit has been reached, the values in the cache start rotating using the LRU (Last Recently Used) strategy. The returned function can be safely used concurrently from multiple threads, however, the implementation values high average-scenario performance and so concurrent calls on the memoized function with identical argument values may not necessarily be able to benefit from each other's cached return value. Also the protectedCacheSize parameter might not be respected accurately in such scenarios for some periods of time. With this having been mentioned, the performance trade-off still makes concurrent use of memoized functions safe and highly recommended. The cache gets garbage-collected together with the memoized closure. Support for Closure currying at a given index. Support for Closure currying at a given index. Parameters are supplied from index position "n". Typical usage: <pre> def caseInsensitive = { a, b -> a.toLowerCase() <=> b.toLowerCase() } as Comparator def caseSensitive = { a, b -> a <=> b } as Comparator def animals1 = ['ant', 'dog', 'BEE'] def animals2 = animals1 + ['Cat'] // curry middle param of this utility method: // Collections#binarySearch(List list, Object key, Comparator c) def catSearcher = Collections.&binarySearch.ncurry(1, "cat") [[animals1, animals2], [caseInsensitive, caseSensitive]].combinations().each{ a, c -> def idx = catSearcher(a.sort(c), c) print a.sort(c).toString().padRight(22) if (idx < 0) println "Not found but would belong in position ${-idx - 1}" else println "Found at index $idx" } // => // [ant, BEE, dog]       Not found but would belong in position 2 // [ant, BEE, Cat, dog]  Found at index 2 // [BEE, ant, dog]       Not found but would belong in position 2 // [BEE, Cat, ant, dog]  Not found but would belong in position 3 </pre> Support for Closure "right" currying. Support for Closure "right" currying. Parameters are supplied on the right rather than left as per the normal curry() method. Typical usage: <pre> def divide = { a, b -> a / b } def halver = divide.rcurry(2) assert halver(8) == 4 </pre> Returns a copy of this closure for which the delegate, owner and thisObject are replaced with the supplied parameters. Use this when you want to rehydrate a closure which has been made serializable thanks to the {@link #dehydrate()} method. Support for Closure forward composition. <p> Typical usage: <pre> def twice = { a -> a * 2 } def thrice = { a -> a * 3 } def times6 = twice >> thrice // equivalent: times6 = { a -> thrice(twice(a)) } assert times6(3) == 18 </pre> (non-Javadoc) @see java.lang.Runnable#run() Allows the delegate to be changed such as when performing markup building  Sets the strategy which the closure uses to resolve property references and methods. The default is Closure.OWNER_FIRST Builds a trampolined variant of the current closure. To prevent stack overflow due to deep recursion, functions can instead leverage the trampoline mechanism and avoid recursive calls altogether. Under trampoline, the function is supposed to perform one step of the calculation and, instead of a recursive call to itself or another function, it return back a new closure, which will be executed by the trampoline as the next step. Once a non-closure value is returned, the trampoline stops and returns the value as the final result. Builds a trampolined variant of the current closure. To prevent stack overflow due to deep recursion, functions can instead leverage the trampoline mechanism and avoid recursive calls altogether. Under trampoline, the function is supposed to perform one step of the calculation and, instead of a recursive call to itself or another function, it return back a new closure, which will be executed by the trampoline as the next step. Once a non-closure value is returned, the trampoline stops and returns the value as the final result. Here is an example: <pre> def fact fact = { n, total -> n == 0 ? total : fact.trampoline(n - 1, n * total) }.trampoline() def factorial = { n -> fact(n, 1G)} println factorial(20) // => 2432902008176640000 </pre>

This gets the code statement of the closure. You can read this method to find out what actions the closure is going to perform. This sets the code statement of the closure. You can use this method in order to add more actions during the closure execution.

Adds a ClassNode directly to the unit (ie. without source). WARNING: the source is needed for error reporting, using this method without setting a SourceUnit will cause NullPinterExceptions Adds a SourceUnit to the unit. Adds a source file to the unit. Adds a InputStream source to the unit. Adds a source file to the unit. Adds a set of source files to the unit. --------------------------------------------------------------------------- SOURCE CREATION Adds a set of file paths to the unit. A loop driver for applying operations to all primary ClassNodes in our AST.  Automatically skips units that have already been processed through the current phase. A loop driver for applying operations to all SourceUnits. Automatically skips units that have already been processed through the current phase. --------------------------------------------------------------------------- ACTIONS Synonym for compile(Phases.ALL). Compiles the compilation unit from sources. Configures its debugging mode and classloader classpath from a given compiler configuration. This cannot be done more than once due to limitations in {@link java.net.URLClassLoader URLClassLoader}. Dequeues any source units add through addSource and resets the compiler phase to initialization. <p> Note: this does not mean a file is recompiled. If a SourceUnit has already passed a phase it is skipped until a higher phase is reached. Returns the CompileUnit that roots our AST.  Convenience routine to get the named ClassNode. Get the GroovyClasses generated by compile(). Convenience routine to get the first ClassNode, for when you are sure there is only one. Get the source summaries Returns the class loader for loading AST transformations. Returns an iterator on the unit's SourceUnits. --------------------------------------------------------------------------- PHASE HANDLING Updates the phase marker on all sources. Sets a ClassgenCallback.  You can have only one, and setting it to null removes any existing setting. Sets a ProgressCallback.  You can have only one, and setting it to null removes any existing setting.



Clears the time portion of this java.sql.Date instance; useful utility where it makes sense to compare month/day/year only portions of a Date. Clears the time portion of this Calendar instance; useful utility where it makes sense to compare month/day/year only portions of a Calendar. Clears the time portion of this Date instance; useful utility where it makes sense to compare month/day/year only portions of a Date. Common code for {@link #clearTime(java.util.Calendar)} and {@link #clearTime(java.util.Date)} and {@link #clearTime(java.sql.Date)} Support creating a new Date having similar properties to an existing Date (which remains unaltered) but with some fields updated according to a Map of changes. <p> Example usage: <pre> import static java.util.Calendar.YEAR def now = Calendar.instance def nextYear = now[YEAR] + 1 def oneYearFromNow = now.copyWith(year: nextYear) println now.time println oneYearFromNow.time </pre> Support creating a new Date having similar properties to an existing Date (which remains unaltered) but with some fields updated according to a Map of changes. <p> Example usage: <pre> import static java.util.Calendar.YEAR def today = new Date() def nextYear = today[YEAR] + 1 def oneYearFromNow = today.copyWith(year: nextYear) println today println oneYearFromNow </pre> Iterates from the date represented by this calendar up to the date represented by the given calendar, inclusive, incrementing by one day each time. Iterates from this date down to the given date, inclusive, decrementing by one day each time. <p>Shortcut for {@link java.text.SimpleDateFormat} to output a String representation of this calendar instance.  This method respects the Calendar's assigned {@link java.util.TimeZone}, whereas calling <code>cal.time.format('HH:mm:ss')</code> would use the system timezone. <p>Note that Calendar equivalents of <code>date.getDateString()</code> and variants do not exist because those methods are Locale-dependent. Although a Calendar may be assigned a {@link java.util.Locale}, that information is lost and therefore cannot be used to control the default date/time formats provided by these methods.  Instead, the system Locale would always be used.  The alternative is to simply call {@link java.text.DateFormat#getDateInstance(int, java.util.Locale)} and pass the same Locale that was used for the Calendar. <p>Create a String representation of this date according to the given format pattern. <p> <p>For example, if the system timezone is GMT, <code>new Date(0).format('MM/dd/yy')</code> would return the string <code>"01/01/70"</code>. See documentation for {@link java.text.SimpleDateFormat} for format pattern use. <p> <p>Note that a new DateFormat instance is created for every invocation of this method (for thread safety). <p>Create a String representation of this date according to the given format pattern and timezone. <p> <p>For example: <code> def d = new Date(0) def tz = TimeZone.getTimeZone('GMT') println d.format('dd/MMM/yyyy', tz) </code> would return the string <code>"01/Jan/1970"</code>. See documentation for {@link java.text.SimpleDateFormat} for format pattern use. <p> <p>Note that a new DateFormat instance is created for every invocation of this method (for thread safety). Support the subscript operator for a Calendar. Support the subscript operator for a Date. <p>Return a string representation of the 'day' portion of this date according to the locale-specific {@link java.text.DateFormat#SHORT} default format. For an "en_UK" system locale, this would be <code>dd/MM/yy</code>. <p> <p>Note that a new DateFormat instance is created for every invocation of this method (for thread safety). <p>Return a string representation of the date and time time portion of this Date instance, according to the locale-specific format used by {@link java.text.DateFormat}.  This method uses the {@link java.text.DateFormat#SHORT} preset for the day portion and {@link java.text.DateFormat#MEDIUM} for the time portion of the output string. <p> <p>Note that a new DateFormat instance is created for every invocation of this method (for thread safety). <p>Return a string representation of the time portion of this date according to the locale-specific {@link java.text.DateFormat#MEDIUM} default format. For an "en_UK" system locale, this would be <code>HH:MM:ss</code>. <p> <p>Note that a new DateFormat instance is created for every invocation of this method (for thread safety). Subtract a number of days from this date and returns the new date. Subtract a number of days from this Timestamp and returns the new Timestamp object. Subtract another date from this one and return the number of days of the difference. <p> Date self = Date then + (Date self - Date then) <p> IOW, if self is before then the result is a negative value. Subtract a number of days from this date and returns the new date. Subtract another Date from this one and return the number of days of the difference. <p> Date self = Date then + (Date self - Date then) <p> IOW, if self is before then the result is a negative value. Increment a java.sql.Date by one day. Increment a Calendar by one day. Increment a Date by one day. Add a number of days to this date and returns the new date. Add number of days to this Timestamp and returns the new Timestamp object. Add a number of days to this date and returns the new date. Decrement a java.sql.Date by one day. Decrement a Calendar by one day. Decrement a Date by one day. Support the subscript operator for mutating a Calendar. Example usage: <pre> import static java.util.Calendar.* def cal = Calendar.instance cal[DAY_OF_WEEK] = MONDAY cal[MONTH] = MARCH println cal.time // A Monday in March </pre> Support the subscript operator for mutating a Date. Support mutating a Calendar with a Map. <p> The map values are the normal values provided as the second parameter to <code>java.util.Calendar#set(int, int)</code>. The keys can either be the normal fields values provided as the first parameter to that method or one of the following Strings: <table border="1" cellpadding="4"> <caption>Calendar index values</caption> <tr><td>year</td><td>Calendar.YEAR</td></tr> <tr><td>month</td><td>Calendar.MONTH</td></tr> <tr><td>date</td><td>Calendar.DATE</td></tr> <tr><td>dayOfMonth</td><td>Calendar.DATE</td></tr> <tr><td>hourOfDay</td><td>Calendar.HOUR_OF_DAY</td></tr> <tr><td>minute</td><td>Calendar.MINUTE</td></tr> <tr><td>second</td><td>Calendar.SECOND</td></tr> </table> Example usage: <pre> import static java.util.Calendar.* def cal = Calendar.instance def m = [:] m[YEAR] = 2010 m[MONTH] = DECEMBER m[DATE] = 25 cal.set(m) println cal.time // Christmas 2010 cal.set(year:2011, month:DECEMBER, date:25) println cal.time // Christmas 2010 </pre> Support mutating a Date with a Map. <p> The map values are the normal values provided as the second parameter to <code>java.util.Calendar#set(int, int)</code>. The keys can either be the normal fields values provided as the first parameter to that method or one of the following Strings: <table border="1" cellpadding="4"> <caption>Calendar index values</caption> <tr><td>year</td><td>Calendar.YEAR</td></tr> <tr><td>month</td><td>Calendar.MONTH</td></tr> <tr><td>date</td><td>Calendar.DATE</td></tr> <tr><td>dayOfMonth</td><td>Calendar.DATE</td></tr> <tr><td>hourOfDay</td><td>Calendar.HOUR_OF_DAY</td></tr> <tr><td>minute</td><td>Calendar.MINUTE</td></tr> <tr><td>second</td><td>Calendar.SECOND</td></tr> </table> Example usage: <pre> import static java.util.Calendar.YEAR def date = new Date() def nextYear = date[YEAR] + 1 date.set(year: nextYear) println date </pre> Convert a Date to a Calendar. Legacy alias for copyWith. Will be deprecated and removed in future versions of Groovy. Legacy alias for copyWith. Will be deprecated and removed in future versions of Groovy. Iterates from the date represented by this calendar up to the date represented by the given calendar, inclusive, incrementing by one day each time. Iterates from this date up to the given date, inclusive, incrementing by one day each time.
Get the absolute value Get the absolute value Get the absolute value Get the absolute value Note:  This method is NOT called if number is a BigInteger or BigDecimal because those classes implement a method with a better exact match. Adds all items from the iterable to the Collection. Modifies the collection by adding all of the elements in the specified array to the collection. The behavior of this operation is undefined if the specified array is modified while the operation is in progress. See also <code>plus</code> or the '+' operator if wanting to produce a new collection containing additional items but while leaving the original collection unchanged. Adds all items from the iterator to the Collection. Modifies this list by inserting all of the elements in the specified array into the list at the specified position.  Shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices).  The new elements will appear in this list in the order that they occur in the array. The behavior of this operation is undefined if the specified array is modified while the operation is in progress. See also <code>plus</code> for similar functionality with copy semantics, i.e. which produces a new list after adding the additional items at the specified position but leaves the original list unchanged. Allows the usage of addShutdownHook without getting the runtime first. Boolean based methods ------------------------------------------------------------------------- Logical conjunction of two boolean operators. Bitwise AND together two Numbers. Bitwise AND together two BitSets. Iterates over the contents of an iterable, and checks whether a predicate is valid for at least one element. Iterates over the elements of a collection, and checks whether at least one element is true according to the Groovy Truth. Equivalent to self.any({element -> element}) Iterates over the contents of an object or collection, and checks whether a predicate is valid for at least one element. Iterates over the contents of an iterator, and checks whether a predicate is valid for at least one element. Iterates over the entries of a map, and checks whether a predicate is valid for at least one entry. If the closure takes one parameter then it will be passed the Map.Entry otherwise if the closure takes two parameters then it will be passed the key and the value. <pre class="groovyTestCase"> assert [2:3, 4:5, 5:10].any { key, value -> key * 2 == value } assert ![2:3, 4:5, 5:10].any { entry -> entry.key == entry.value * 2 } </pre> Coerces a boolean array to a boolean value. A boolean array is false if the array is of length 0, and true otherwise. Coerces a byte array to a boolean value. A byte array is false if the array is of length 0, and true otherwise. Coerces a char array to a boolean value. A char array is false if the array is of length 0, and true otherwise. Coerces a double array to a boolean value. A double array is false if the array is of length 0, and true otherwise. Coerces a float array to a boolean value. A float array is false if the array is of length 0, and true otherwise. Coerces an int array to a boolean value. An int array is false if the array is of length 0, and true otherwise. Coerce an Boolean instance to a boolean value. Coerce a character to a boolean value. A character is coerced to false if it's character value is equal to 0, and to true otherwise. Coerce a number to a boolean value. A number is coerced to false if its double value is equal to 0, and to true otherwise, and to true otherwise. Coerce an object instance to a boolean value. An object is coerced to true if it's not null, to false if it is null. Coerce an Object array to a boolean value. An Object array is false if the array is of length 0. and to true otherwise Coerce a collection instance to a boolean value. A collection is coerced to false if it's empty, and to true otherwise. <pre class="groovyTestCase">assert [1,2].asBoolean() == true</pre> <pre class="groovyTestCase">assert [].asBoolean() == false</pre> Coerce an enumeration instance to a boolean value. An enumeration is coerced to false if there are no more elements to enumerate, and to true otherwise. Coerce an iterator instance to a boolean value. An iterator is coerced to false if there are no more elements to iterate over, and to true otherwise. Coerce a map instance to a boolean value. A map is coerced to false if it's empty, and to true otherwise. <pre class="groovyTestCase">assert [:] as Boolean == false assert [a:2] as Boolean == true</pre> Coerces a long array to a boolean value. A long array is false if the array is of length 0, and true otherwise. Coerces a short array to a boolean value. A short array is false if the array is of length 0, and true otherwise. Converts this Iterable to a Collection. Returns the original Iterable if it is already a Collection. <p> Example usage: <pre class="groovyTestCase"> assert new HashSet().asCollection() instanceof Collection </pre> A convenience method for creating an immutable Collection. <pre class="groovyTestCase">def mutable = [1,2,3] def immutable = mutable.asImmutable() mutable &lt;&lt; 4 try { immutable &lt;&lt; 4 assert false } catch (UnsupportedOperationException) { assert true }</pre> A convenience method for creating an immutable list A convenience method for creating an immutable map. A convenience method for creating an immutable list. A convenience method for creating an immutable sorted map. A convenience method for creating an immutable sorted set. Converts this Iterable to a List. Returns the original Iterable if it is already a List. <p> Example usage: <pre class="groovyTestCase"> assert new HashSet().asList() instanceof List </pre>  A convenience method for creating a synchronized Collection. A convenience method for creating a synchronized List. A convenience method for creating a synchronized Map. A convenience method for creating a synchronized Set. A convenience method for creating a synchronized SortedMap. A convenience method for creating a synchronized SortedSet. Coerces the closure to an implementation of the given class.  The class is assumed to be an interface or class with a single method definition. The closure is used as the implementation of that single method. Transform this number to a the given type, using the 'as' operator.  The following types are supported in addition to the default {@link #asType(java.lang.Object, java.lang.Class)}: <ul> <li>BigDecimal</li> <li>BigInteger</li> <li>Double</li> <li>Float</li> </ul> Converts a given object to a type. This method is used through the "as" operator and is overloadable as any other operator. Converts the given array to either a List, Set, or SortedSet.  If the given class is something else, the call is deferred to {link #asType(Object,Class)}. Converts the given collection to another type. A default concrete type is used for List, Set, or SortedSet. If the given type has a constructor taking a collection, that is used. Otherwise, the call is deferred to {link #asType(Object,Class)}.  If this collection is already of the given type, the same instance is returned. Coerces this map to the given type, using the map's keys as the public method names, and values as the implementation.  Typically the value would be a closure which behaves like the method implementation. Bitwise NEGATE a Number. Bitwise NEGATE a BitSet. internal helper method internal helper method internal helper method Collates this iterable into sub-lists of length <code>size</code>. Example: <pre class="groovyTestCase">def list = [ 1, 2, 3, 4, 5, 6, 7 ] def coll = list.collate( 3 ) assert coll == [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7 ] ]</pre> Collates this iterable into sub-lists of length <code>size</code>. Any remaining elements in the iterable after the subdivision will be dropped if <code>keepRemainder</code> is false. Example: <pre class="groovyTestCase">def list = [ 1, 2, 3, 4, 5, 6, 7 ] def coll = list.collate( 3, false ) assert coll == [ [ 1, 2, 3 ], [ 4, 5, 6 ] ]</pre> Collates this iterable into sub-lists of length <code>size</code> stepping through the code <code>step</code> elements for each subList. Example: <pre class="groovyTestCase">def list = [ 1, 2, 3, 4 ] def coll = list.collate( 3, 1 ) assert coll == [ [ 1, 2, 3 ], [ 2, 3, 4 ], [ 3, 4 ], [ 4 ] ]</pre> Collates this iterable into sub-lists of length <code>size</code> stepping through the code <code>step</code> elements for each sub-list.  Any remaining elements in the iterable after the subdivision will be dropped if <code>keepRemainder</code> is false. Example: <pre class="groovyTestCase"> def list = [ 1, 2, 3, 4 ] assert list.collate( 2, 2, true  ) == [ [ 1, 2 ], [ 3, 4 ] ] assert list.collate( 3, 1, true  ) == [ [ 1, 2, 3 ], [ 2, 3, 4 ], [ 3, 4 ], [ 4 ] ] assert list.collate( 3, 1, false ) == [ [ 1, 2, 3 ], [ 2, 3, 4 ] ] </pre>     Iterates through this aggregate Object transforming each item into a new value using Closure.IDENTITY as a transformer, basically returning a list of items copied from the original object. <pre class="groovyTestCase">assert [1,2,3] == [1,2,3].iterator().collect()</pre> Iterates through this aggregate Object transforming each item into a new value using the <code>transform</code> closure, returning a list of transformed values. Example: <pre class="groovyTestCase">def list = [1, 'a', 1.23, true ] def types = list.collect { it.class } assert types == [Integer, String, BigDecimal, Boolean]</pre> Iterates through this aggregate Object transforming each item into a new value using the <code>transform</code> closure and adding it to the supplied <code>collector</code>. Iterates through this collection transforming each entry into a new value using Closure.IDENTITY as a transformer, basically returning a list of items copied from the original collection. <pre class="groovyTestCase">assert [1,2,3] == [1,2,3].collect()</pre> Iterates through this collection transforming each entry into a new value using the <code>transform</code> closure returning a list of transformed values. <pre class="groovyTestCase">assert [2,4,6] == [1,2,3].collect { it * 2 }</pre> Iterates through this collection transforming each value into a new value using the <code>transform</code> closure and adding it to the supplied <code>collector</code>. <pre class="groovyTestCase">assert [1,2,3] as HashSet == [2,4,5,6].collect(new HashSet()) { (int)(it / 2) }</pre> Iterates through this Map transforming each map entry into a new value using the <code>transform</code> closure returning a list of transformed values. <pre class="groovyTestCase">assert [a:1, b:2].collect { key, value -> key*value } == ["a", "bb"] assert [3:20, 2:30].collect { entry -> entry.key * entry.value } == [60, 60]</pre> Iterates through this Map transforming each map entry into a new value using the <code>transform</code> closure returning the <code>collector</code> with all transformed values added to it. <pre class="groovyTestCase">assert [a:1, b:2].collect( [] as HashSet ) { key, value -> key*value } == ["a", "bb"] as Set assert [3:20, 2:30].collect( [] as HashSet ) { entry -> entry.key * entry.value } == [60] as Set</pre> Deprecated alias for collectNested Deprecated alias for collectNested A variant of collectEntries for Iterable objects using the identity closure as the transform. The source Iterable should contain a list of <code>[key, value]</code> tuples or <code>Map.Entry</code> objects. <pre class="groovyTestCase"> def nums = [1, 10, 100, 1000] def tuples = nums.collect{ [it, it.toString().size()] } assert tuples == [[1, 1], [10, 2], [100, 3], [1000, 4]] def map = tuples.collectEntries() assert map == [1:1, 10:2, 100:3, 1000:4] </pre> Iterates through this Iterable transforming each item using the <code>transform</code> closure and returning a map of the resulting transformed entries. <pre class="groovyTestCase"> def letters = "abc" // collect letters with index using list style assert (0..2).collectEntries { index -> [index, letters[index]] } == [0:'a', 1:'b', 2:'c'] // collect letters with index using map style assert (0..2).collectEntries { index -> [(index): letters[index]] } == [0:'a', 1:'b', 2:'c'] </pre> Note: When using the list-style of result, the behavior is '<code>def (key, value) = listResultFromClosure</code>'. While we strongly discourage using a list of size other than 2, Groovy's normal semantics apply in this case; throwing away elements after the second one and using null for the key or value for the case of a shortened list. A variant of collectEntries for Iterables using the identity closure as the transform and a supplied map as the destination of transformed entries. Iterates through this Iterable transforming each item using the closure as a transformer into a map entry, returning the supplied map with all of the transformed entries added to it. <pre class="groovyTestCase"> def letters = "abc" // collect letters with index assert (0..2).collectEntries( [:] ) { index -> [index, letters[index]] } == [0:'a', 1:'b', 2:'c'] assert (0..2).collectEntries( [4:'d'] ) { index -> [(index+1): letters[index]] } == [1:'a', 2:'b', 3:'c', 4:'d'] </pre> Note: When using the list-style of result, the behavior is '<code>def (key, value) = listResultFromClosure</code>'. While we strongly discourage using a list of size other than 2, Groovy's normal semantics apply in this case; throwing away elements after the second one and using null for the key or value for the case of a shortened list. If your collector Map doesn't support null keys or values, you might get a runtime error, e.g. NullPointerException or IllegalArgumentException. A variant of collectEntries using the identity closure as the transform. Iterates through this array transforming each item using the <code>transform</code> closure and returning a map of the resulting transformed entries. <pre class="groovyTestCase"> def letters = "abc" def nums = [0, 1, 2] as Integer[] // collect letters with index using list style assert nums.collectEntries { index -> [index, letters[index]] } == [0:'a', 1:'b', 2:'c'] // collect letters with index using map style assert nums.collectEntries { index -> [(index): letters[index]] } == [0:'a', 1:'b', 2:'c'] </pre> Note: When using the list-style of result, the behavior is '<code>def (key, value) = listResultFromClosure</code>'. While we strongly discourage using a list of size other than 2, Groovy's normal semantics apply in this case; throwing away elements after the second one and using null for the key or value for the case of a shortened list. A variant of collectEntries using the identity closure as the transform. Iterates through this array transforming each item using the <code>transform</code> closure and returning a map of the resulting transformed entries. <pre class="groovyTestCase"> def letters = "abc" def nums = [0, 1, 2] as Integer[] // collect letters with index assert nums.collectEntries( [:] ) { index -> [index, letters[index]] } == [0:'a', 1:'b', 2:'c'] assert nums.collectEntries( [4:'d'] ) { index -> [(index+1): letters[index]] } == [1:'a', 2:'b', 3:'c', 4:'d'] </pre> Note: When using the list-style of result, the behavior is '<code>def (key, value) = listResultFromClosure</code>'. While we strongly discourage using a list of size other than 2, Groovy's normal semantics apply in this case; throwing away elements after the second one and using null for the key or value for the case of a shortened list. If your collector Map doesn't support null keys or values, you might get a runtime error, e.g. NullPointerException or IllegalArgumentException.     A variant of collectEntries for Iterators using the identity closure as the transform. A variant of collectEntries for Iterators. A variant of collectEntries for Iterators using the identity closure as the transform and a supplied map as the destination of transformed entries. A variant of collectEntries for Iterators using a supplied map as the destination of transformed entries. Iterates through this Map transforming each entry using the <code>transform</code> closure and returning a map of the transformed entries. <pre class="groovyTestCase"> assert [a:1, b:2].collectEntries { key, value -> [value, key] } == [1:'a', 2:'b'] assert [a:1, b:2].collectEntries { key, value -> [(value*10): key.toUpperCase()] } == [10:'A', 20:'B'] </pre> Note: When using the list-style of result, the behavior is '<code>def (key, value) = listResultFromClosure</code>'. While we strongly discourage using a list of size other than 2, Groovy's normal semantics apply in this case; throwing away elements after the second one and using null for the key or value for the case of a shortened list. If your Map doesn't support null keys or values, you might get a runtime error, e.g. NullPointerException or IllegalArgumentException. Iterates through this Map transforming each map entry using the <code>transform</code> closure returning a map of the transformed entries. <pre class="groovyTestCase"> assert [a:1, b:2].collectEntries( [:] ) { k, v -> [v, k] } == [1:'a', 2:'b'] assert [a:1, b:2].collectEntries( [30:'C'] ) { key, value -> [(value*10): key.toUpperCase()] } == [10:'A', 20:'B', 30:'C'] </pre> Note: When using the list-style of result, the behavior is '<code>def (key, value) = listResultFromClosure</code>'. While we strongly discourage using a list of size other than 2, Groovy's normal semantics apply in this case; throwing away elements after the second one and using null for the key or value for the case of a shortened list. If your collector Map doesn't support null keys or values, you might get a runtime error, e.g. NullPointerException or IllegalArgumentException. Projects each item from a source Iterable to a collection and concatenates (flattens) the resulting collections into a single list. <p> <pre class="groovyTestCase"> def nums = 1..10 def squaresAndCubesOfEvens = nums.collectMany{ it % 2 ? [] : [it**2, it**3] } assert squaresAndCubesOfEvens == [4, 8, 16, 64, 36, 216, 64, 512, 100, 1000] def animals = ['CAT', 'DOG', 'ELEPHANT'] as Set def smallAnimals = animals.collectMany{ it.size() > 3 ? [] : [it.toLowerCase()] } assert smallAnimals == ['cat', 'dog'] def orig = nums as Set def origPlusIncrements = orig.collectMany{ [it, it+1] } assert origPlusIncrements.size() == orig.size() * 2 assert origPlusIncrements.unique().size() == orig.size() + 1 </pre> Projects each item from a source collection to a result collection and concatenates (flattens) the resulting collections adding them into the <code>collector</code>. <p> <pre class="groovyTestCase"> def animals = ['CAT', 'DOG', 'ELEPHANT'] as Set def smallAnimals = animals.collectMany(['ant', 'bee']){ it.size() > 3 ? [] : [it.toLowerCase()] } assert smallAnimals == ['ant', 'bee', 'cat', 'dog'] def nums = 1..5 def origPlusIncrements = nums.collectMany([] as Set){ [it, it+1] } assert origPlusIncrements.size() == nums.size() + 1 </pre> Projects each item from a source array to a collection and concatenates (flattens) the resulting collections into a single list. <p> <pre class="groovyTestCase"> def nums = [1, 2, 3, 4, 5, 6] as Object[] def squaresAndCubesOfEvens = nums.collectMany{ it % 2 ? [] : [it**2, it**3] } assert squaresAndCubesOfEvens == [4, 8, 16, 64, 36, 216] </pre>   Projects each item from a source iterator to a collection and concatenates (flattens) the resulting collections into a single list. <p> <pre class="groovyTestCase"> def numsIter = [1, 2, 3, 4, 5, 6].iterator() def squaresAndCubesOfEvens = numsIter.collectMany{ it % 2 ? [] : [it**2, it**3] } assert squaresAndCubesOfEvens == [4, 8, 16, 64, 36, 216] </pre> Projects each item from a source map to a result collection and concatenates (flattens) the resulting collections adding them into a collection. <p> <pre class="groovyTestCase"> def map = [bread:3, milk:5, butter:2] def result = map.collectMany{ k, v -> k.startsWith('b') ? k.toList() : [] } assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r'] </pre> Projects each item from a source map to a result collection and concatenates (flattens) the resulting collections adding them into the <code>collector</code>. <p> <pre class="groovyTestCase"> def map = [bread:3, milk:5, butter:2] def result = map.collectMany(['x']){ k, v -> k.startsWith('b') ? k.toList() : [] } assert result == ['x', 'b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r'] </pre> Recursively iterates through this Iterable transforming each non-Collection value into a new value using the closure as a transformer. Returns a potentially nested list of transformed values. <pre class="groovyTestCase"> assert [2,[4,6],[8],[]] == [1,[2,3],[4],[]].collectNested { it * 2 } </pre> Recursively iterates through this Iterable transforming each non-Collection value into a new value using the <code>transform</code> closure. Returns a potentially nested collection of transformed values. <pre class="groovyTestCase"> def x = [1,[2,3],[4],[]].collectNested(new Vector()) { it * 2 } assert x == [2,[4,6],[8],[]] assert x instanceof Vector </pre> Recursively iterates through this collection transforming each non-Collection value into a new value using the closure as a transformer. Returns a potentially nested list of transformed values. <pre class="groovyTestCase"> assert [2,[4,6],[8],[]] == [1,[2,3],[4],[]].collectNested { it * 2 } </pre>  Adds GroovyCollections#combinations(Iterable) as a method on Iterables. <p> Example usage: <pre class="groovyTestCase"> assert [['a', 'b'],[1, 2, 3]].combinations() == [['a', 1], ['b', 1], ['a', 2], ['b', 2], ['a', 3], ['b', 3]] </pre> Adds GroovyCollections#combinations(Iterable, Closure) as a method on collections. <p> Example usage: <pre class="groovyTestCase">assert [[2, 3],[4, 5, 6]].combinations {x,y -> x*y } == [8, 12, 10, 15, 12, 18]</pre>  Compare two Characters. The ordinal values of the Characters are compared (the ordinal value is the unicode value which for simple character sets is the ASCII value). Compare a Character and a Number. The ordinal value of the Character is used in the comparison (the ordinal value is the unicode value which for simple character sets is the ASCII value). Compare a Number and a Character. The ordinal value of the Character is used in the comparison (the ordinal value is the unicode value which for simple character sets is the ASCII value). Compare two Numbers.  Equality (==) for numbers dispatches to this. Checks whether the array contains the given value. Checks whether the array contains the given value. Checks whether the array contains the given value. Checks whether the array contains the given value. Checks whether the array contains the given value. Checks whether the array contains the given value. Returns <tt>true</tt> if this iterable contains the item. Checks whether the array contains the given value. Checks whether the array contains the given value. Checks whether the array contains the given value. Returns <tt>true</tt> if this iterable contains all of the elements in the specified array.  Counts the number of occurrences of the given value inside this array. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ). Counts the number of occurrences of the given value inside this array. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ). Counts the number of occurrences of the given value inside this array. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ). Counts the number of occurrences of the given value inside this array. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ). Counts the number of occurrences of the given value inside this array. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ). Counts the number of occurrences of the given value inside this array. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ). Counts the number of occurrences which satisfy the given closure from inside this Iterable. <p> Example usage: <pre class="groovyTestCase">assert [2,4,2,1,3,5,2,4,3].count{ it % 2 == 0 } == 5</pre> Counts the number of occurrences of the given value inside this Iterable. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ). <p> Example usage: <pre class="groovyTestCase">assert [2,4,2,1,3,5,2,4,3].count(4) == 2</pre> Counts the number of occurrences which satisfy the given closure from inside this array. Counts the number of occurrences of the given value inside this array. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ).   Counts the number of occurrences which satisfy the given closure from the items within this Iterator. The iterator will become exhausted of elements after determining the count value. <p> Example usage: <pre class="groovyTestCase">assert [2,4,2,1,3,5,2,4,3].toSet().iterator().count{ it % 2 == 0 } == 2</pre> Counts the number of occurrences of the given value from the items within this Iterator. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ). The iterator will become exhausted of elements after determining the count value. Counts the number of occurrences which satisfy the given closure from inside this map. If the closure takes one parameter then it will be passed the Map.Entry. Otherwise, the closure should take two parameters and will be passed the key and value. <p> Example usage: <pre class="groovyTestCase">assert [a:1, b:1, c:2, d:2].count{ k,v -> k == 'a' || v == 2 } == 3</pre> Counts the number of occurrences of the given value inside this array. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ). Counts the number of occurrences of the given value inside this array. Comparison is done using Groovy's == operator (using <code>compareTo(value) == 0</code> or <code>equals(value)</code> ). Sorts all collection members into groups determined by the supplied mapping closure and counts the group size.  The closure should return the key that each item should be grouped by.  The returned Map will have an entry for each distinct key returned from the closure, with each value being the frequency of items occurring for that group. <p> Example usage: <pre class="groovyTestCase">assert [0:2, 1:3] == [1,2,3,4,5].countBy { it % 2 }</pre> Sorts all array members into groups determined by the supplied mapping closure and counts the group size.  The closure should return the key that each item should be grouped by.  The returned Map will have an entry for each distinct key returned from the closure, with each value being the frequency of items occurring for that group. <p> Example usage: <pre class="groovyTestCase">assert ([1,2,2,2,3] as Object[]).countBy{ it % 2 } == [1:2, 0:3]</pre>  Sorts all iterator items into groups determined by the supplied mapping closure and counts the group size.  The closure should return the key that each item should be grouped by.  The returned Map will have an entry for each distinct key returned from the closure, with each value being the frequency of items occurring for that group. <p> Example usage: <pre class="groovyTestCase">assert [1,2,2,2,3].toSet().iterator().countBy{ it % 2 } == [1:2, 0:1]</pre> Groups the members of a map into groups determined by the supplied mapping closure and counts the frequency of the created groups. The closure will be passed a Map.Entry or key and value (depending on the number of parameters the closure accepts) and should return the key that each item should be grouped under.  The resulting map will have an entry for each 'group' key returned by the closure, with values being the frequency counts for that 'group'. <p> <pre class="groovyTestCase">def result = [a:1,b:2,c:3,d:4,e:5].countBy { it.value % 2 } assert result == [0:2, 1:3]</pre> Returns <code>true</code> if the intersection of two iterables is empty. <pre class="groovyTestCase">assert [1,2,3].disjoint([3,4,5]) == false</pre> <pre class="groovyTestCase">assert [1,2].disjoint([3,4]) == true</pre>  Divide one Character by another. The ordinal values of the Characters are used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value). Divide a Character by a Number. The ordinal value of the Character is used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value). Divide a Number by a Character. The ordinal value of the Character is used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value). Iterates from this number down to the given number, inclusive, decrementing by one each time. Iterates from this number down to the given number, inclusive, decrementing by one each time. Iterates from this number down to the given number, inclusive, decrementing by one each time. Iterates from this number down to the given number, inclusive, decrementing by one each time. Iterates from this number down to the given number, inclusive, decrementing by one each time. Iterates from this number down to the given number, inclusive, decrementing by one each time. Iterates from this number down to the given number, inclusive, decrementing by one each time.  Each number is passed to the closure. Example: <pre>10.5.downto(0) { println it }</pre> Prints numbers 10.5, 9.5 ... to 0.5. Iterates from this number down to the given number, inclusive, decrementing by one each time. Iterates from this number down to the given number, inclusive, decrementing by one each time. Drops the given number of elements from the head of this Iterable. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] assert strings.drop( 0 ) == [ 'a', 'b', 'c' ] assert strings.drop( 2 ) == [ 'c' ] assert strings.drop( 5 ) == [] class AbcIterable implements Iterable<String> { Iterator<String> iterator() { "abc".iterator() } } def abc = new AbcIterable() assert abc.drop(0) == ['a', 'b', 'c'] assert abc.drop(1) == ['b', 'c'] assert abc.drop(3) == [] assert abc.drop(5) == [] </pre> Drops the given number of elements from the head of this array if they are available. <pre class="groovyTestCase"> String[] strings = [ 'a', 'b', 'c' ] assert strings.drop( 0 ) == [ 'a', 'b', 'c' ] as String[] assert strings.drop( 2 ) == [ 'c' ] as String[] assert strings.drop( 5 ) == [] as String[] </pre> Drops the given number of elements from the head of this iterator if they are available. The original iterator is stepped along by <code>num</code> elements. <pre class="groovyTestCase"> def iteratorCompare( Iterator a, List b ) { a.collect { it } == b } def iter = [ 1, 2, 3, 4, 5 ].listIterator() assert iteratorCompare( iter.drop( 0 ), [ 1, 2, 3, 4, 5 ] ) iter = [ 1, 2, 3, 4, 5 ].listIterator() assert iteratorCompare( iter.drop( 2 ), [ 3, 4, 5 ] ) iter = [ 1, 2, 3, 4, 5 ].listIterator() assert iteratorCompare( iter.drop( 5 ), [] ) </pre> Drops the given number of elements from the head of this List. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] assert strings.drop( 0 ) == [ 'a', 'b', 'c' ] assert strings.drop( 2 ) == [ 'c' ] assert strings.drop( 5 ) == [] </pre> Drops the given number of key/value pairs from the head of this map if they are available. <pre class="groovyTestCase"> def strings = [ 'a':10, 'b':20, 'c':30 ] assert strings.drop( 0 ) == [ 'a':10, 'b':20, 'c':30 ] assert strings.drop( 2 ) == [ 'c':30 ] assert strings.drop( 5 ) == [:] </pre> If the map instance does not have ordered keys, then this function could drop a random <code>num</code> entries. Groovy by default uses LinkedHashMap, so this shouldn't be an issue in the main. Drops the given number of elements from the head of this List. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] as SortedSet assert strings.drop( 0 ) == [ 'a', 'b', 'c' ] as SortedSet assert strings.drop( 2 ) == [ 'c' ] as SortedSet assert strings.drop( 5 ) == [] as SortedSet </pre> Drops the given number of elements from the tail of this Iterable. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] assert strings.dropRight( 0 ) == [ 'a', 'b', 'c' ] assert strings.dropRight( 2 ) == [ 'a' ] assert strings.dropRight( 5 ) == [] class AbcIterable implements Iterable<String> { Iterator<String> iterator() { "abc".iterator() } } def abc = new AbcIterable() assert abc.dropRight(0) == ['a', 'b', 'c'] assert abc.dropRight(1) == ['a', 'b'] assert abc.dropRight(3) == [] assert abc.dropRight(5) == [] </pre> Drops the given number of elements from the tail of this array if they are available. <pre class="groovyTestCase"> String[] strings = [ 'a', 'b', 'c' ] assert strings.dropRight( 0 ) == [ 'a', 'b', 'c' ] as String[] assert strings.dropRight( 2 ) == [ 'a' ] as String[] assert strings.dropRight( 5 ) == [] as String[] </pre> Drops the given number of elements from the tail of this Iterator. <pre class="groovyTestCase"> def obliterator = "obliter8".iterator() assert abc.dropRight(-1) == ['o', 'b', 'l', 'i', 't', 'e', 'r', '8'] assert abc.dropRight(0) == ['o', 'b', 'l', 'i', 't', 'e', 'r', '8'] assert abc.dropRight(1) == ['o', 'b', 'l', 'i', 't', 'e', 'r'] assert abc.dropRight(4) == ['o', 'b', 'l', 'i'] assert abc.dropRight(7) == ['o'] assert abc.dropRight(8) == [] assert abc.dropRight(9) == [] </pre> Drops the given number of elements from the tail of this List. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] assert strings.dropRight( 0 ) == [ 'a', 'b', 'c' ] assert strings.dropRight( 2 ) == [ 'a' ] assert strings.dropRight( 5 ) == [] </pre> Drops the given number of elements from the tail of this SortedSet. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] as SortedSet assert strings.dropRight( 0 ) == [ 'a', 'b', 'c' ] as SortedSet assert strings.dropRight( 2 ) == [ 'a' ] as SortedSet assert strings.dropRight( 5 ) == [] as SortedSet </pre> Returns a suffix of this Iterable where elements are dropped from the front while the given closure evaluates to true. <pre class="groovyTestCase"> class HorseIterable implements Iterable<String> { Iterator<String> iterator() { "horse".iterator() } } def horse = new HorseIterable() assert horse.dropWhile{ it < 'r' } == ['r', 's', 'e'] assert horse.dropWhile{ it <= 'r' } == ['s', 'e'] </pre> Create a suffix of the given array by dropping as many elements as possible from the front of the original array such that calling the given closure condition evaluates to true when passed each of the dropped elements. <pre class="groovyTestCase"> def nums = [ 1, 3, 2 ] as Integer[] assert nums.dropWhile{ it <= 3 } == [ ] as Integer[] assert nums.dropWhile{ it < 3 } == [ 3, 2 ] as Integer[] assert nums.dropWhile{ it != 2 } == [ 2 ] as Integer[] assert nums.dropWhile{ it == 0 } == [ 1, 3, 2 ] as Integer[] </pre> Creates an Iterator that returns a suffix of the elements from an original Iterator. As many elements as possible are dropped from the front of the original Iterator such that calling the given closure condition evaluates to true when passed each of the dropped elements. <pre class="groovyTestCase"> def a = 0 def iter = [ hasNext:{ a < 10 }, next:{ a++ } ] as Iterator assert [].iterator().dropWhile{ it < 3 }.toList() == [] assert [1, 2, 3, 4, 5].iterator().dropWhile{ it < 3 }.toList() == [ 3, 4, 5 ] assert iter.dropWhile{ it < 5 }.toList() == [ 5, 6, 7, 8, 9 ] </pre> Returns a suffix of this List where elements are dropped from the front while the given Closure evaluates to true. Similar to {@link #dropWhile(Iterable, groovy.lang.Closure)} except that it attempts to preserve the type of the original list. <pre class="groovyTestCase"> def nums = [ 1, 3, 2 ] assert nums.dropWhile{ it < 4 } == [] assert nums.dropWhile{ it < 3 } == [ 3, 2 ] assert nums.dropWhile{ it != 2 } == [ 2 ] assert nums.dropWhile{ it == 0 } == [ 1, 3, 2 ] </pre> Create a suffix of the given Map by dropping as many entries as possible from the front of the original Map such that calling the given closure condition evaluates to true when passed each of the dropped entries (or key/value pairs). <pre class="groovyTestCase"> def shopping = [milk:1, bread:2, chocolate:3] assert shopping.dropWhile{ it.key.size() < 6 } == [chocolate:3] assert shopping.dropWhile{ it.value % 2 } == [bread:2, chocolate:3] assert shopping.dropWhile{ k, v -> k.size() + v <= 7 } == [chocolate:3] </pre> If the map instance does not have ordered keys, then this function could appear to drop random entries. Groovy by default uses LinkedHashMap, so this shouldn't be an issue in the main. Returns a suffix of this SortedSet where elements are dropped from the front while the given Closure evaluates to true. Similar to {@link #dropWhile(Iterable, groovy.lang.Closure)} except that it attempts to preserve the type of the original SortedSet. <pre class="groovyTestCase"> def nums = [ 1, 2, 3 ] as SortedSet assert nums.dropWhile{ it < 4 } == [] as SortedSet assert nums.dropWhile{ it < 2 } == [ 2, 3 ] as SortedSet assert nums.dropWhile{ it != 3 } == [ 3 ] as SortedSet assert nums.dropWhile{ it == 0 } == [ 1, 2, 3 ] as SortedSet </pre> Generates a detailed dump string of an object showing its class, hashCode and fields. Iterates through an Iterable, passing each item to the given closure. Iterates through an aggregate type or data structure, passing each item to the given closure.  Custom types may utilize this method by simply providing an "iterator()" method.  The items returned from the resulting iterator will be passed to the closure. Iterates through an Collection, passing each item to the given closure. Iterates through an Iterator, passing each item to the given closure. Iterates through an List, passing each item to the given closure. Allows a Map to be iterated through using a closure. If the closure takes one parameter then it will be passed the Map.Entry otherwise if the closure takes two parameters then it will be passed the key and the value. <pre class="groovyTestCase">def result = "" [a:1, b:3].each { key, value -> result += "$key$value" } assert result == "a1b3"</pre> <pre class="groovyTestCase">def result = "" [a:1, b:3].each { entry -> result += entry } assert result == "a=1b=3"</pre> In general, the order in which the map contents are processed cannot be guaranteed. In practise, specialized forms of Map, e.g. a TreeMap will have its contents processed according to the natural ordering of the map. Iterates through an Set, passing each item to the given closure. Iterates through an SortedSet, passing each item to the given closure. Traverse through each byte of this byte array. Alias for each. Traverse through each byte of this Byte array. Alias for each. Applies a function on each combination of the input lists. <p> Example usage: <pre class="groovyTestCase">[[2, 3],[4, 5, 6]].eachCombination { println "Found $it" }</pre> Iterates over all permutations of a collection, running a closure for each iteration. <p> Example usage: <pre class="groovyTestCase">def permutations = [] [1, 2, 3].eachPermutation{ permutations &lt;&lt; it } assert permutations == [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</pre>  Iterates through an iterable type, passing each item and the item's index (a counter starting at zero) to the given closure. Iterates through an aggregate type or data structure, passing each item and the item's index (a counter starting at zero) to the given closure. Iterates through an Collection, passing each item and the item's index (a counter starting at zero) to the given closure. Iterates through an iterator type, passing each item and the item's index (a counter starting at zero) to the given closure. Iterates through an List, passing each item and the item's index (a counter starting at zero) to the given closure. Allows a Map to be iterated through using a closure. If the closure takes two parameters then it will be passed the Map.Entry and the item's index (a counter starting at zero) otherwise if the closure takes three parameters then it will be passed the key, the value, and the index. <pre class="groovyTestCase">def result = "" [a:1, b:3].eachWithIndex { key, value, index -> result += "$index($key$value)" } assert result == "0(a1)1(b3)"</pre> <pre class="groovyTestCase">def result = "" [a:1, b:3].eachWithIndex { entry, index -> result += "$index($entry)" } assert result == "0(a=1)1(b=3)"</pre> Iterates through an Set, passing each item and the item's index (a counter starting at zero) to the given closure. Iterates through an SortedSet, passing each item and the item's index (a counter starting at zero) to the given closure. Compare the contents of this array to the contents of the given array. Determines if the contents of this array are equal to the contents of the given list, in the same order.  This returns <code>false</code> if either collection is <code>null</code>. Determines if the contents of this list are equal to the contents of the given array in the same order.  This returns <code>false</code> if either collection is <code>null</code>. <pre class="groovyTestCase">assert [1, "a"].equals( [ 1, "a" ] as Object[] )</pre> Compare the contents of two Lists.  Order matters. If numbers exist in the Lists, then they are compared as numbers, for example 2 == 2L. If both lists are <code>null</code>, the result is true; otherwise if either list is <code>null</code>, the result is <code>false</code>. <pre class="groovyTestCase">assert ["a", 2].equals(["a", 2]) assert ![2, "a"].equals("a", 2) assert [2.0, "a"].equals(2L, "a") // number comparison at work</pre> Compares two Maps treating coerced numerical values as identical. <p> Example usage: <pre class="groovyTestCase">assert [a:2, b:3] == [a:2L, b:3.0]</pre> Compare the contents of two Sets for equality using Groovy's coercion rules. <p> Returns <tt>true</tt> if the two sets have the same size, and every member of the specified set is contained in this set (or equivalently, every member of this set is contained in the specified set). If numbers exist in the sets, then they are compared as numbers, for example 2 == 2L.  If both sets are <code>null</code>, the result is true; otherwise if either set is <code>null</code>, the result is <code>false</code>. Example usage: <pre class="groovyTestCase"> Set s1 = ["a", 2] def s2 = [2, 'a'] as Set Set s3 = [3, 'a'] def s4 = [2.0, 'a'] as Set def s5 = [2L, 'a'] as Set assert s1.equals(s2) assert !s1.equals(s3) assert s1.equals(s4) assert s1.equals(s5)</pre> Used to determine if the given predicate closure is valid (i.e.&nsbp;returns <code>true</code> for all items in this iterable). A simple example for a list: <pre>def list = [3,4,5] def greaterThanTwo = list.every { it > 2 } </pre> Iterates over every element of a collection, and checks whether all elements are <code>true</code> according to the Groovy Truth. Equivalent to <code>self.every({element -> element})</code> Used to determine if the given predicate closure is valid (i.e.&nsbp;returns <code>true</code> for all items in this data structure). A simple example for a list: <pre>def list = [3,4,5] def greaterThanTwo = list.every { it > 2 } </pre> Used to determine if the given predicate closure is valid (i.e.&nsbp;returns <code>true</code> for all items in this iterator). A simple example for a list: <pre>def list = [3,4,5] def greaterThanTwo = list.iterator().every { it > 2 } </pre> Iterates over the entries of a map, and checks whether a predicate is valid for all entries. If the closure takes one parameter then it will be passed the Map.Entry otherwise if the closure takes two parameters then it will be passed the key and the value. <pre class="groovyTestCase">def map = [a:1, b:2.0, c:2L] assert !map.every { key, value -> value instanceof Integer } assert map.every { entry -> entry.value instanceof Number }</pre> Finds the first item matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). <p> Example: <pre class="groovyTestCase"> def items = [null, 0, 0.0, false, '', [], 42, 43] assert items.find() == 42 </pre> Finds the first value matching the closure condition Finds the first element in the array that matches the given closure condition. Example: <pre class="groovyTestCase"> def list = [1,2,3] as Integer[] assert 2 == list.find { it > 1 } assert null == list.find { it > 5 } </pre> Finds the first item matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). <p> Example: <pre class="groovyTestCase"> def items = [null, 0, 0.0, false, '', [], 42, 43] assert items.find() == 42 </pre> Finds the first value matching the closure condition.  Example: <pre class="groovyTestCase">def list = [1,2,3] assert 2 == list.find { it > 1 } </pre> Finds the first entry matching the closure condition. If the closure takes two parameters, the entry key and value are passed. If the closure takes one parameter, the Map.Entry object is passed. <pre class="groovyTestCase">assert [a:1, b:3].find { it.value == 3 }.key == "b"</pre> Finds all items matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). <p> Example: <pre class="groovyTestCase"> def items = [1, 2, 0, false, true, '', 'foo', [], [4, 5], null] assert items.findAll() == [1, 2, true, 'foo', [4, 5]] </pre> Finds all items matching the closure condition. Finds the elements of the array matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). <p> Example: <pre class="groovyTestCase"> def items = [1, 2, 0, false, true, '', 'foo', [], [4, 5], null] as Object[] assert items.findAll() == [1, 2, true, 'foo', [4, 5]] </pre> Finds all elements of the array matching the given Closure condition. <pre class="groovyTestCase"> def items = [1,2,3,4] as Integer[] assert [2,4] == items.findAll { it % 2 == 0 } </pre> Finds the items matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). <p> Example: <pre class="groovyTestCase"> def items = [1, 2, 0, false, true, '', 'foo', [], [4, 5], null] assert items.findAll() == [1, 2, true, 'foo', [4, 5]] </pre> Finds all values matching the closure condition. <pre class="groovyTestCase">assert [2,4] == [1,2,3,4].findAll { it % 2 == 0 }</pre> Finds the items matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). <p> Example: <pre class="groovyTestCase"> def items = [1, 2, 0, false, true, '', 'foo', [], [4, 5], null] assert items.findAll() == [1, 2, true, 'foo', [4, 5]] </pre> Finds all values matching the closure condition. <pre class="groovyTestCase">assert [2,4] == [1,2,3,4].findAll { it % 2 == 0 }</pre> Finds all entries matching the closure condition. If the closure takes one parameter then it will be passed the Map.Entry. Otherwise if the closure should take two parameters, which will be the key and the value. <p> If the <code>self</code> map is one of TreeMap, LinkedHashMap, Hashtable or Properties, the returned Map will preserve that type, otherwise a HashMap will be returned. <p> Example usage: <pre class="groovyTestCase"> def result = [a:1, b:2, c:4, d:5].findAll { it.value % 2 == 0 } assert result.every { it instanceof Map.Entry } assert result*.key == ["b", "c"] assert result*.value == [2, 4] </pre> Finds the items matching the IDENTITY Closure (i.e.&#160;matching Groovy truth). <p> Example: <pre class="groovyTestCase"> def items = [1, 2, 0, false, true, '', 'foo', [], [4, 5], null] as Set assert items.findAll() == [1, 2, true, 'foo', [4, 5]] as Set </pre> Finds all values matching the closure condition. <pre class="groovyTestCase">assert ([2,4] as Set) == ([1,2,3,4] as Set).findAll { it % 2 == 0 }</pre> Iterates over the elements of an iterable collection of items and returns the index of the first item that matches the condition specified in the closure. Iterates over the elements of an iterable collection of items, starting from a specified startIndex, and returns the index of the first item that matches the condition specified in the closure. Iterates over the elements of an iterable collection of items and returns the index values of the items that match the condition specified in the closure. Iterates over the elements of an iterable collection of items, starting from a specified startIndex, and returns the index values of the items that match the condition specified in the closure. Iterates over the elements of an iterable collection of items and returns the index of the last item that matches the condition specified in the closure. Iterates over the elements of an iterable collection of items, starting from a specified startIndex, and returns the index of the last item that matches the condition specified in the closure. Treats the object as iterable, iterating through the values it represents and returns the first non-null result obtained from calling the closure, otherwise returns null. Treats the object as iterable, iterating through the values it represents and returns the first non-null result obtained from calling the closure, otherwise returns the defaultResult. Iterates through the collection calling the given closure for each item but stopping once the first non-null result is found and returning that result. If all results are null, null is returned. <p> Example: <pre class="groovyTestCase"> def list = [1,2,3] assert "Found 2" == list.findResult { it > 1 ? "Found $it" : null } </pre> Iterates through the collection calling the given closure for each item but stopping once the first non-null result is found and returning that result. If all are null, the defaultResult is returned. <p> Examples: <pre class="groovyTestCase"> def list = [1,2,3] assert "Found 2" == list.findResult("default") { it > 1 ? "Found $it" : null } assert "default" == list.findResult("default") { it > 3 ? "Found $it" : null } </pre> Returns the first non-null closure result found by passing each map entry to the closure, otherwise null is returned. If the closure takes two parameters, the entry key and value are passed. If the closure takes one parameter, the Map.Entry object is passed. <pre class="groovyTestCase"> assert "Found b:3" == [a:1, b:3].findResult { if (it.value == 3) return "Found ${it.key}:${it.value}" } assert null == [a:1, b:3].findResult { if (it.value == 9) return "Found ${it.key}:${it.value}" } assert "Found a:1" == [a:1, b:3].findResult { k, v -> if (k.size() + v == 2) return "Found $k:$v" } </pre> Returns the first non-null closure result found by passing each map entry to the closure, otherwise the defaultResult is returned. If the closure takes two parameters, the entry key and value are passed. If the closure takes one parameter, the Map.Entry object is passed. <pre class="groovyTestCase"> assert "Found b:3" == [a:1, b:3].findResult("default") { if (it.value == 3) return "Found ${it.key}:${it.value}" } assert "default" == [a:1, b:3].findResult("default") { if (it.value == 9) return "Found ${it.key}:${it.value}" } assert "Found a:1" == [a:1, b:3].findResult("default") { k, v -> if (k.size() + v == 2) return "Found $k:$v" } </pre> Iterates through the Iterable transforming items using the supplied closure and collecting any non-null results. <p> Example: <pre class="groovyTestCase"> def list = [1,2,3] def result = list.findResults { it > 1 ? "Found $it" : null } assert result == ["Found 2", "Found 3"] </pre>  Iterates through the map transforming items using the supplied closure and collecting any non-null results. If the closure takes two parameters, the entry key and value are passed. If the closure takes one parameter, the Map.Entry object is passed. <p> Example: <pre class="groovyTestCase"> def map = [a:1, b:2, hi:2, cat:3, dog:2] def result = map.findResults { k, v -> k.size() == v ? "Found $k:$v" : null } assert result == ["Found a:1", "Found hi:2", "Found cat:3"] </pre> Returns the first item from the Iterable. <pre class="groovyTestCase"> def set = [3, 4, 2] as LinkedHashSet assert set.first() == 3 // check original is unaltered assert set == [3, 4, 2] as Set </pre> The first element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned. Returns the first item from the array. <pre class="groovyTestCase"> def array = [3, 4, 2].toArray() assert array.first() == 3 </pre> Returns the first item from the List. <pre class="groovyTestCase"> def list = [3, 4, 2] assert list.first() == 3 // check original is unaltered assert list == [3, 4, 2] </pre> Flatten an array.  This array and any nested arrays or collections have their contents (recursively) added to the new collection. Flatten an array.  This array and any nested arrays or collections have their contents (recursively) added to the new collection. Flatten an array.  This array and any nested arrays or collections have their contents (recursively) added to the new collection. Flatten an array.  This array and any nested arrays or collections have their contents (recursively) added to the new collection. Flatten an array.  This array and any nested arrays or collections have their contents (recursively) added to the new collection. Flatten an array.  This array and any nested arrays or collections have their contents (recursively) added to the new collection. Flatten an Iterable.  This Iterable and any nested arrays or collections have their contents (recursively) added to the new collection. <pre class="groovyTestCase">assert [1,2,3,4,5] == [1,[2,3],[[4]],[],5].flatten()</pre> Flatten an Iterable.  This Iterable and any nested arrays or collections have their contents (recursively) added to the new collection. For any non-Array, non-Collection object which represents some sort of collective type, the supplied closure should yield the contained items; otherwise, the closure should just return any element which corresponds to a leaf. Flatten an array.  This array and any nested arrays or collections have their contents (recursively) added to the new collection. Flatten a Collection.  This Collection and any nested arrays or collections have their contents (recursively) added to the new collection. <pre class="groovyTestCase">assert [1,2,3,4,5] == [1,[2,3],[[4]],[],5].flatten()</pre>  Flatten a List.  This List and any nested arrays or collections have their contents (recursively) added to the new List. <pre class="groovyTestCase">assert [1,2,3,4,5] == [1,[2,3],[[4]],[],5].flatten()</pre> Flatten a Set.  This Set and any nested arrays or collections have their contents (recursively) added to the new Set. <pre class="groovyTestCase">assert [1,2,3,4,5] as Set == ([1,[2,3],[[4]],[],5] as Set).flatten()</pre> Flatten a SortedSet.  This SortedSet and any nested arrays or collections have their contents (recursively) added to the new SortedSet. <pre class="groovyTestCase">assert [1,2,3,4,5] as SortedSet == ([1,[2,3],[[4]],[],5] as SortedSet).flatten()</pre> Flatten an array.  This array and any nested arrays or collections have their contents (recursively) added to the new collection. Flatten an array.  This array and any nested arrays or collections have their contents (recursively) added to the new collection. Looks up an item in a Map for the given key and returns the value - unless there is no entry for the given key in which case add the default value to the map and return that. <pre class="groovyTestCase">def map=[:] map.get("a", []) &lt;&lt; 5 assert map == [a:[5]]</pre> Support the range subscript operator for an eager or lazy List. <pre class="groovyTestCase">def list = [true, 1, 3.4].withDefault{ 42 } assert list[0..<0] == []</pre> Support the range subscript operator for an eager or lazy List. <pre class="groovyTestCase">def list = [].withDefault { 42 } assert list[1..2] == [null, 42]</pre> Select a List of items from an eager or lazy List using a Collection to identify the indices to be selected. <pre class="groovyTestCase">def list = [].withDefault { 42 } assert list[1,0,2] == [42, 42, 42]</pre> Support the subscript operator with an IntRange for a boolean array Support the subscript operator with an ObjectRange for a byte array Support the subscript operator with a range for a boolean array Support the subscript operator with a collection for a boolean array Support the subscript operator with an IntRange for a byte array Support the subscript operator with an ObjectRange for a byte array Primitive type array methods ------------------------------------------------------------------------- Support the subscript operator with a range for a byte array Support the subscript operator with a collection for a byte array Support the subscript operator with an IntRange for a char array Support the subscript operator with an ObjectRange for a char array Support the subscript operator with a range for a char array Support the subscript operator with a collection for a char array Support the subscript operator with an IntRange for a double array Support the subscript operator with an ObjectRange for a double array Support the subscript operator with a range for a double array Support the subscript operator with a collection for a double array Support the subscript operator with an IntRange for a float array Support the subscript operator with an ObjectRange for a float array Support the subscript operator with a range for a float array Support the subscript operator with a collection for a float array Support the subscript operator with an IntRange for an int array Support the subscript operator with an ObjectRange for an int array Support the subscript operator with a range for an int array Support the subscript operator with a collection for an int array Support the subscript operator for an Iterable. Typical usage: <pre class="groovyTestCase"> // custom Iterable example: class MyIterable implements Iterable { Iterator iterator() { [1, 2, 3].iterator() } } def myIterable = new MyIterable() assert myIterable[1] == 2 // Set example: def set = [1,2,3] as LinkedHashSet assert set[1] == 2 </pre> Allows the subscript operator to be used to lookup dynamic property values. <code>bean[somePropertyNameExpression]</code>. The normal property notation of groovy is neater and more concise but only works with compile-time known property names.    Support the range subscript operator for an Array Select a List of items from an array using a Collection to identify the indices to be selected. Support retrieving a subset of a BitSet using a Range Support the subscript operator for a Bitset Support the subscript operator for Collection. <pre class="groovyTestCase"> assert [String, Long, Integer] == ["a",5L,2]["class"] </pre> Support the subscript operator for an Iterator. The iterator will be partially exhausted up until the idx entry after returning if a +ve or 0 idx is used, or fully exhausted if a -ve idx is used or no corresponding entry was found. Typical usage: <pre class="groovyTestCase"> def iter = [2, "a", 5.3].iterator() assert iter[1] == "a" </pre> A more elaborate example: <pre class="groovyTestCase"> def items = [2, "a", 5.3] def iter = items.iterator() assert iter[-1] == 5.3 // iter exhausted, so reset iter = items.iterator() assert iter[1] == "a" // iter partially exhausted so now idx starts after "a" assert iter[0] == 5.3 </pre> Support the range subscript operator for a List. <pre class="groovyTestCase">def list = [true, 1, 3.4] assert list[0..<0] == []</pre> Support the range subscript operator for a List. <pre class="groovyTestCase">def list = [1, "a", 4.5, true] assert list[1..2] == ["a", 4.5]</pre> Support the subscript operator for a List. <pre class="groovyTestCase">def list = [2, "a", 5.3] assert list[1] == "a"</pre> Select a List of items from a List using a Collection to identify the indices to be selected. <pre class="groovyTestCase">def list = [true, 1, 3.4, false] assert list[1,0,2] == [1, true, 3.4]</pre> Support the subscript operator for a Map. <pre class="groovyTestCase">def map = [a:10] assert map["a"] == 10</pre> Support the subscript operator with an IntRange for a long array Support the subscript operator with an ObjectRange for a long array Support the subscript operator with a range for a long array Support the subscript operator with a collection for a long array Support the subscript operator with an IntRange for a short array Support the subscript operator with an ObjectRange for a short array Support the subscript operator with a range for a short array Support the subscript operator with a collection for a short array Returns indices of the array. <p> Example: <pre class="groovyTestCase"> String[] letters = ['a', 'b', 'c', 'd'] assert 0..<4 == letters.indices </pre> Returns indices of the collection. <p> Example: <pre class="groovyTestCase"> assert 0..2 == [5, 6, 7].indices </pre> Obtains a MetaClass for an object either from the registry or in the case of a GroovyObject from the object itself. Adds a "metaClass" property to all class objects so you can use the syntax <code>String.metaClass.myMethod = { println "foo" }</code> Obtains a MetaClass for an object either from the registry or in the case of a GroovyObject from the object itself. Retrieves the list of {@link groovy.lang.MetaProperty} objects for 'self' and wraps it in a list of {@link groovy.lang.PropertyValue} objects that additionally provide the value for each property of 'self'. Convenience method that calls {@link #getMetaPropertyValues(java.lang.Object)}(self) and provides the data in form of simple key/value pairs, i.e.&nsbp;without type() information. Iterates through the classloader parents until it finds a loader with a class named "org.codehaus.groovy.tools.RootLoader". If there is no such class <code>null</code> will be returned. The name is used for comparison because a direct comparison using == may fail as the class may be loaded through different classloaders. todo: remove after putAt(Splice) gets deleted Iterates over the collection of items which this Object represents and returns each item that matches using the IDENTITY Closure as a filter - effectively returning all elements which satisfy Groovy truth. <p> Example: <pre class="groovyTestCase"> def items = [1, 2, 0, false, true, '', 'foo', [], [4, 5], null] assert items.grep() == [1, 2, true, 'foo', [4, 5]] </pre> Iterates over the collection of items which this Object represents and returns each item that matches the given filter - calling the <code>{@link #isCase(java.lang.Object, java.lang.Object)}</code> method used by switch statements.  This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Example: <pre class="groovyTestCase"> def list = ['a', 'b', 'aa', 'bc', 3, 4.5] assert list.grep( ~/a+/ )  == ['a', 'aa'] assert list.grep( ~/../ )  == ['aa', 'bc'] assert list.grep( Number ) == [ 3, 4.5 ] assert list.grep{ it.toString().size() == 1 } == [ 'a', 'b', 3 ] </pre> Iterates over the array returning each element that matches using the IDENTITY Closure as a filter - effectively returning all elements which satisfy Groovy truth. <p> Example: <pre class="groovyTestCase"> def items = [1, 2, 0, false, true, '', 'foo', [], [4, 5], null] as Object[] assert items.grep() == [1, 2, true, 'foo', [4, 5]] </pre> Iterates over the array of items and returns a collection of items that match the given filter - calling the <code>{@link #isCase(java.lang.Object, java.lang.Object)}</code> method used by switch statements. This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Example: <pre class="groovyTestCase"> def items = ['a', 'b', 'aa', 'bc', 3, 4.5] as Object[] assert items.grep( ~/a+/ )  == ['a', 'aa'] assert items.grep( ~/../ )  == ['aa', 'bc'] assert items.grep( Number ) == [ 3, 4.5 ] assert items.grep{ it.toString().size() == 1 } == [ 'a', 'b', 3 ] </pre> Iterates over the collection returning each element that matches using the IDENTITY Closure as a filter - effectively returning all elements which satisfy Groovy truth. <p> Example: <pre class="groovyTestCase"> def items = [1, 2, 0, false, true, '', 'foo', [], [4, 5], null] assert items.grep() == [1, 2, true, 'foo', [4, 5]] </pre> Iterates over the collection of items and returns each item that matches the given filter - calling the <code>{@link #isCase(java.lang.Object, java.lang.Object)}</code> method used by switch statements.  This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Example: <pre class="groovyTestCase"> def list = ['a', 'b', 'aa', 'bc', 3, 4.5] assert list.grep( ~/a+/ )  == ['a', 'aa'] assert list.grep( ~/../ )  == ['aa', 'bc'] assert list.grep( Number ) == [ 3, 4.5 ] assert list.grep{ it.toString().size() == 1 } == [ 'a', 'b', 3 ] </pre> Iterates over the collection returning each element that matches using the IDENTITY Closure as a filter - effectively returning all elements which satisfy Groovy truth. <p> Example: <pre class="groovyTestCase"> def items = [1, 2, 0, false, true, '', 'foo', [], [4, 5], null] assert items.grep() == [1, 2, true, 'foo', [4, 5]] </pre> Iterates over the collection of items and returns each item that matches the given filter - calling the <code>{@link #isCase(java.lang.Object, java.lang.Object)}</code> method used by switch statements.  This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Example: <pre class="groovyTestCase"> def list = ['a', 'b', 'aa', 'bc', 3, 4.5] assert list.grep( ~/a+/ )  == ['a', 'aa'] assert list.grep( ~/../ )  == ['aa', 'bc'] assert list.grep( Number ) == [ 3, 4.5 ] assert list.grep{ it.toString().size() == 1 } == [ 'a', 'b', 3 ] </pre> Iterates over the collection returning each element that matches using the IDENTITY Closure as a filter - effectively returning all elements which satisfy Groovy truth. <p> Example: <pre class="groovyTestCase"> def items = [1, 2, 0, false, true, '', 'foo', [], [4, 5], null] as Set assert items.grep() == [1, 2, true, 'foo', [4, 5]] as Set </pre> Iterates over the collection of items and returns each item that matches the given filter - calling the <code>{@link #isCase(java.lang.Object, java.lang.Object)}</code> method used by switch statements.  This method can be used with different kinds of filters like regular expressions, classes, ranges etc. Example: <pre class="groovyTestCase"> def set = ['a', 'b', 'aa', 'bc', 3, 4.5] as Set assert set.grep( ~/a+/ )  == ['a', 'aa'] as Set assert set.grep( ~/../ )  == ['aa', 'bc'] as Set assert set.grep( Number ) == [ 3, 4.5 ] as Set assert set.grep{ it.toString().size() == 1 } == [ 'a', 'b', 3 ] as Set </pre> Groups the current element according to the value Sorts all Iterable members into groups determined by the supplied mapping closure. The closure should return the key that this item should be grouped by. The returned LinkedHashMap will have an entry for each distinct key returned from the closure, with each value being a list of items for that group. <p> Example usage: <pre class="groovyTestCase"> assert [0:[2,4,6], 1:[1,3,5]] == [1,2,3,4,5,6].groupBy { it % 2 } </pre> Sorts all Iterable members into (sub)groups determined by the supplied mapping closures. Each closure should return the key that this item should be grouped by. The returned LinkedHashMap will have an entry for each distinct 'key path' returned from the closures, with each value being a list of items for that 'group path'. Example usage: <pre class="groovyTestCase">def result = [1,2,3,4,5,6].groupBy({ it % 2 }, { it < 4 }) assert result == [1:[(true):[1, 3], (false):[5]], 0:[(true):[2], (false):[4, 6]]]</pre> Another example: <pre>def sql = groovy.sql.Sql.newInstance(/&ast; ... &ast;/) def data = sql.rows("SELECT * FROM a_table").groupBy({ it.column1 }, { it.column2 }, { it.column3 }) if (data.val1.val2.val3) { // there exists a record where: //   a_table.column1 == val1 //   a_table.column2 == val2, and //   a_table.column3 == val3 } else { // there is no such record }</pre> If an empty array of closures is supplied the IDENTITY Closure will be used. Sorts all Iterable members into (sub)groups determined by the supplied mapping closures. Each closure should return the key that this item should be grouped by. The returned LinkedHashMap will have an entry for each distinct 'key path' returned from the closures, with each value being a list of items for that 'group path'. Example usage: <pre class="groovyTestCase"> def result = [1,2,3,4,5,6].groupBy([{ it % 2 }, { it < 4 }]) assert result == [1:[(true):[1, 3], (false):[5]], 0:[(true):[2], (false):[4, 6]]] </pre> Another example: <pre> def sql = groovy.sql.Sql.newInstance(/&ast; ... &ast;/) def data = sql.rows("SELECT * FROM a_table").groupBy([{ it.column1 }, { it.column2 }, { it.column3 }]) if (data.val1.val2.val3) { // there exists a record where: //   a_table.column1 == val1 //   a_table.column2 == val2, and //   a_table.column3 == val3 } else { // there is no such record } </pre> If an empty list of closures is supplied the IDENTITY Closure will be used. Sorts all array members into groups determined by the supplied mapping closure. The closure should return the key that this item should be grouped by. The returned LinkedHashMap will have an entry for each distinct key returned from the closure, with each value being a list of items for that group. <p> Example usage: <pre class="groovyTestCase"> Integer[] items = [1,2,3,4,5,6] assert [0:[2,4,6], 1:[1,3,5]] == items.groupBy { it % 2 } </pre> Sorts all array members into (sub)groups determined by the supplied mapping closures as per the Iterable variant of this method. Sorts all array members into (sub)groups determined by the supplied mapping closures as per the list variant of this method.    Groups the members of a map into sub maps determined by the supplied mapping closure. The closure will be passed a Map.Entry or key and value (depending on the number of parameters the closure accepts) and should return the key that each item should be grouped under.  The resulting map will have an entry for each 'group' key returned by the closure, with values being the map members from the original map that belong to each group. (If instead of a map, you want a list of map entries use {code}groupEntriesBy{code}.) <p> If the <code>self</code> map is one of TreeMap, Hashtable or Properties, the returned Map will preserve that type, otherwise a LinkedHashMap will be returned. <pre class="groovyTestCase">def result = [a:1,b:2,c:3,d:4,e:5,f:6].groupBy { it.value % 2 } assert result == [0:[b:2, d:4, f:6], 1:[a:1, c:3, e:5]]</pre> Groups the members of a map into sub maps determined by the supplied mapping closures. Each closure will be passed a Map.Entry or key and value (depending on the number of parameters the closure accepts) and should return the key that each item should be grouped under. The resulting map will have an entry for each 'group path' returned by all closures, with values being the map members from the original map that belong to each such 'group path'. If the <code>self</code> map is one of TreeMap, Hashtable, or Properties, the returned Map will preserve that type, otherwise a LinkedHashMap will be returned. <pre class="groovyTestCase">def result = [a:1,b:2,c:3,d:4,e:5,f:6].groupBy({ it.value % 2 }, { it.key.next() }) assert result == [1:[b:[a:1], d:[c:3], f:[e:5]], 0:[c:[b:2], e:[d:4], g:[f:6]]]</pre> If an empty array of closures is supplied the IDENTITY Closure will be used. Groups the members of a map into sub maps determined by the supplied mapping closures. Each closure will be passed a Map.Entry or key and value (depending on the number of parameters the closure accepts) and should return the key that each item should be grouped under. The resulting map will have an entry for each 'group path' returned by all closures, with values being the map members from the original map that belong to each such 'group path'. If the <code>self</code> map is one of TreeMap, Hashtable, or Properties, the returned Map will preserve that type, otherwise a LinkedHashMap will be returned. <pre class="groovyTestCase">def result = [a:1,b:2,c:3,d:4,e:5,f:6].groupBy([{ it.value % 2 }, { it.key.next() }]) assert result == [1:[b:[a:1], d:[c:3], f:[e:5]], 0:[c:[b:2], e:[d:4], g:[f:6]]]</pre> If an empty list of closures is supplied the IDENTITY Closure will be used. Groups all map entries into groups determined by the supplied mapping closure. The closure will be passed a Map.Entry or key and value (depending on the number of parameters the closure accepts) and should return the key that each item should be grouped under.  The resulting map will have an entry for each 'group' key returned by the closure, with values being the list of map entries that belong to each group. (If instead of a list of map entries, you want an actual map use {code}groupBy{code}.) <pre class="groovyTestCase">def result = [a:1,b:2,c:3,d:4,e:5,f:6].groupEntriesBy { it.value % 2 } assert result[0]*.key == ["b", "d", "f"] assert result[1]*.value == [1, 3, 5]</pre> <p>Returns true of the implementing MetaClass has a property of the given name <p>Note that this method will only return true for realised properties and does not take into account implementation of getProperty or propertyMissing Returns the first item from the Iterable. <pre class="groovyTestCase"> def set = [3, 4, 2] as LinkedHashSet assert set.head() == 3 // check original is unaltered assert set == [3, 4, 2] as Set </pre> The first element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned. Returns the first item from the Object array. <pre class="groovyTestCase">def array = [3, 4, 2].toArray() assert array.head() == 3</pre> Returns the first item from the List. <pre class="groovyTestCase">def list = [3, 4, 2] assert list.head() == 3 assert list == [3, 4, 2]</pre> Allows the closure to be called for the object reference self. Synonym for 'with()'. Logical implication of two boolean operators Zips an Iterable with indices in (index, value) order. <p/> Example usage: <pre class="groovyTestCase"> assert [0: "a", 1: "b"] == ["a", "b"].indexed() assert ["0: a", "1: b"] == ["a", "b"].indexed().collect { idx, str -> "$idx: $str" } </pre> Zips an Iterable with indices in (index, value) order. <p/> Example usage: <pre class="groovyTestCase"> assert [5: "a", 6: "b"] == ["a", "b"].indexed(5) assert ["1: a", "2: b"] == ["a", "b"].indexed(1).collect { idx, str -> "$idx: $str" } </pre> Zips an iterator with indices in (index, value) order. <p/> Example usage: <pre class="groovyTestCase"> assert [[0, "a"], [1, "b"]] == ["a", "b"].iterator().indexed().collect{ e -> [e.key, e.value] } assert ["0: a", "1: b"] == ["a", "b"].iterator().indexed().collect { idx, str -> "$idx: $str" }.toList() </pre> Zips an iterator with indices in (index, value) order. <p/> Example usage: <pre class="groovyTestCase"> assert [[5, "a"], [6, "b"]] == ["a", "b"].iterator().indexed(5).toList() assert ["a: 1", "b: 2"] == ["a", "b"].iterator().indexed(1).collect { idx, str -> "$str: $idx" }.toList() </pre> Returns the items from the Iterable excluding the last item. Leaves the original Iterable unchanged. <pre class="groovyTestCase"> def list = [3, 4, 2] assert list.init() == [3, 4] assert list == [3, 4, 2] </pre> Returns the items from the Object array excluding the last item. <pre class="groovyTestCase"> String[] strings = ["a", "b", "c"] def result = strings.init() assert result.length == 2 assert strings.class.componentType == String </pre> Returns an Iterator containing all of the items from this iterator except the last one. <pre class="groovyTestCase"> def iter = [3, 4, 2].listIterator() def result = iter.init() assert result.toList() == [3, 4] </pre> Returns the items from the List excluding the last item. Leaves the original List unchanged. <pre class="groovyTestCase"> def list = [3, 4, 2] assert list.init() == [3, 4] assert list == [3, 4, 2] </pre> Returns the items from the SortedSet excluding the last item. Leaves the original SortedSet unchanged. <pre class="groovyTestCase"> def sortedSet = [3, 4, 2] as SortedSet assert sortedSet.init() == [3, 4] as SortedSet assert sortedSet == [3, 4, 2] as SortedSet </pre> Iterates through the given Object, passing in the first value to the closure along with the first item. The result is passed back (injected) into the closure along with the second item. The new result is injected back into the closure along with the third item and so on until further iteration of the object is not possible. Also known as foldLeft in functional parlance. Iterates through the given Object, passing in the initial value to the closure along with the first item. The result is passed back (injected) into the closure along with the second item. The new result is injected back into the closure along with the third item and so on until further iteration of the object is not possible. Also known as foldLeft in functional parlance. Iterates through the given array as with inject(Object[],initialValue,closure), but using the first element of the array as the initialValue, and then iterating the remaining elements of the array. Iterates through the given array, passing in the initial value to the closure along with the first item. The result is passed back (injected) into the closure along with the second item. The new result is injected back into the closure along with the third item and so on until all elements of the array have been used. Also known as foldLeft in functional parlance. Performs the same function as the version of inject that takes an initial value, but uses the head of the Collection as the initial value, and iterates over the tail. <pre class="groovyTestCase"> assert 1 * 2 * 3 * 4 == [ 1, 2, 3, 4 ].inject { acc, val -> acc * val } assert ['b'] == [['a','b'], ['b','c'], ['d','b']].inject { acc, val -> acc.intersect( val ) } LinkedHashSet set = [ 't', 'i', 'm' ] assert 'tim' == set.inject { a, b -> a + b } </pre> Iterates through the given Collection, passing in the initial value to the 2-arg closure along with the first item. The result is passed back (injected) into the closure along with the second item. The new result is injected back into the closure along with the third item and so on until the entire collection has been used. Also known as <tt>foldLeft</tt> or <tt>reduce</tt> in functional parlance. Examples: <pre class="groovyTestCase"> assert 1*1*2*3*4 == [1,2,3,4].inject(1) { acc, val -> acc * val } assert 0+1+2+3+4 == [1,2,3,4].inject(0) { acc, val -> acc + val } assert 'The quick brown fox' == ['quick', 'brown', 'fox'].inject('The') { acc, val -> acc + ' ' + val } assert 'bat' == ['rat', 'bat', 'cat'].inject('zzz') { min, next -> next < min ? next : min } def max = { a, b -> [a, b].max() } def animals = ['bat', 'rat', 'cat'] assert 'rat' == animals.inject('aaa', max) </pre> Visual representation of the last example above: <pre> initVal  animals[0] v        v max('aaa',   'bat')  =>  'bat'  animals[1] v       v max('bat',  'rat')  =>  'rat'  animals[2] v       v max('rat',  'cat')  =>  'rat' </pre> Iterates through the given Iterator, passing in the initial value to the closure along with the first item. The result is passed back (injected) into the closure along with the second item. The new result is injected back into the closure along with the third item and so on until the Iterator has been expired of values. Also known as foldLeft in functional parlance. Iterates through the given Map, passing in the initial value to the 2-arg Closure along with the first item (or 3-arg Closure along with the first key and value). The result is passed back (injected) into the closure along with the second item. The new result is injected back into the closure along with the third item and so on until the entire collection has been used. Also known as <tt>foldLeft</tt> or <tt>reduce</tt> in functional parlance. Examples: <pre class="groovyTestCase"> def map = [a:1, b:2, c:3] assert map.inject([]) { list, k, v -> list + [k] * v } == ['a', 'b', 'b', 'c', 'c', 'c'] </pre> Inspects returns the String that matches what would be typed into a terminal to create this object. Integer Divide two Characters. The ordinal values of the Characters are used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value). Integer Divide a Character by a Number. The ordinal value of the Character is used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value). Integer Divide a Number by a Character. The ordinal value of the Character is used in the division (the ordinal value is the unicode value which for simple character sets is the ASCII value). Integer Divide two Numbers. Create a Collection composed of the intersection of both iterables.  Any elements that exist in both iterables are added to the resultant collection. <pre class="groovyTestCase">assert [4,5] == [1,2,3,4,5].intersect([4,5,6,7,8])</pre> Create a Collection composed of the intersection of both collections.  Any elements that exist in both collections are added to the resultant collection. <pre class="groovyTestCase">assert [4,5] == [1,2,3,4,5].intersect([4,5,6,7,8])</pre> Create a List composed of the intersection of a List and an Iterable.  Any elements that exist in both iterables are added to the resultant collection. <pre class="groovyTestCase">assert [4,5] == [1,2,3,4,5].intersect([4,5,6,7,8])</pre> Create a Map composed of the intersection of both maps. Any entries that exist in both maps are added to the resultant map. <pre class="groovyTestCase">assert [4:4,5:5] == [1:1,2:2,3:3,4:4,5:5].intersect([4:4,5:5,6:6,7:7,8:8])</pre> <pre class="groovyTestCase">assert [1: 1, 2: 2, 3: 3, 4: 4].intersect( [1: 1.0, 2: 2, 5: 5] ) == [1:1, 2:2]</pre> Create a Set composed of the intersection of a Set and an Iterable.  Any elements that exist in both iterables are added to the resultant collection. <pre class="groovyTestCase">assert [4,5] as Set == ([1,2,3,4,5] as Set).intersect([4,5,6,7,8])</pre> Create a SortedSet composed of the intersection of a SortedSet and an Iterable.  Any elements that exist in both iterables are added to the resultant collection. <pre class="groovyTestCase">assert [4,5] as SortedSet == ([1,2,3,4,5] as SortedSet).intersect([4,5,6,7,8])</pre> Provide a dynamic method invocation method which can be overloaded in classes to implement dynamic proxies easily. Identity check. Since == is overridden in Groovy with the meaning of equality we need some fallback to check for object identity.  Invoke using the 'is' method, like so: <code>def same = this.is(that)</code> Special 'Case' implementation for Class, which allows testing for a certain class in a switch statement. For example: <pre>switch( obj ) { case List : // obj is a list break; case Set : // etc }</pre> Special 'case' implementation for all numbers, which delegates to the <code>compareTo()</code> method for comparing numbers of different types. isCase methods ------------------------------------------------------------------------- Method for overloading the behavior of the 'case' method in switch statements. The default implementation handles arrays types but otherwise simply delegates to Object#equals, but this may be overridden for other types. In this example: <pre> switch( a ) { case b: //some code }</pre> "some code" is called when <code>b.isCase( a )</code> returns <code>true</code>. 'Case' implementation for collections which tests if the 'switch' operand is contained in any of the 'case' values. For example: <pre class="groovyTestCase">switch( 3 ) { case [1,3,5]: assert true break default: assert false }</pre> 'Case' implementation for maps which tests the groovy truth value obtained using the 'switch' operand as key. For example: <pre class="groovyTestCase">switch( 'foo' ) { case [foo:true, bar:false]: assert true break default: assert false }</pre> Determines if a character is a digit. Synonym for 'Character.isDigit(this)'. Determines if a character is a letter. Synonym for 'Character.isLetter(this)'. Determines if a character is a letter or digit. Synonym for 'Character.isLetterOrDigit(this)'. Determine if a Character is lowercase. Synonym for 'Character.isLowerCase(this)'. Determine if a Character is uppercase. Synonym for 'Character.isUpperCase(this)'. Determines if a character is a whitespace character. Synonym for 'Character.isWhitespace(this)'. Attempts to create an Iterator for the given object by first converting it to a Collection. Attempts to create an Iterator for the given object by first converting it to a Collection. Allows an Enumeration to behave like an Iterator.  Note that the {@link java.util.Iterator#remove() remove()} method is unsupported since the underlying Enumeration does not provide a mechanism for removing items. An identity function for iterators, supporting 'duck-typing' when trying to get an iterator for each object within a collection, some of which may already be iterators. Concatenates the string representation of each items in this array, with the given String as a separator between each item. Concatenates the string representation of each items in this array, with the given String as a separator between each item. Concatenates the string representation of each items in this array, with the given String as a separator between each item. Concatenates the string representation of each items in this array, with the given String as a separator between each item. Concatenates the string representation of each items in this array, with the given String as a separator between each item. Concatenates the string representation of each items in this array, with the given String as a separator between each item. Concatenates the <code>toString()</code> representation of each item in this Iterable, with the given String as a separator between each item. <pre class="groovyTestCase">assert "1, 2, 3" == [1,2,3].join(", ")</pre> Concatenates the <code>toString()</code> representation of each items in this array, with the given String as a separator between each item.  Concatenates the <code>toString()</code> representation of each item from the iterator, with the given String as a separator between each item. The iterator will become exhausted of elements after determining the resulting conjoined value. Concatenates the string representation of each items in this array, with the given String as a separator between each item. Concatenates the string representation of each items in this array, with the given String as a separator between each item. Returns the last item from the Iterable. <pre class="groovyTestCase"> def set = [3, 4, 2] as LinkedHashSet assert set.last() == 2 // check original unaltered assert set == [3, 4, 2] as Set </pre> The first element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned. Returns the last item from the array. <pre class="groovyTestCase"> def array = [3, 4, 2].toArray() assert array.last() == 2 </pre> Returns the last item from the List. <pre class="groovyTestCase"> def list = [3, 4, 2] assert list.last() == 2 // check original is unaltered assert list == [3, 4, 2] </pre> Implementation of the left shift operator for integral types.  Non integral Number types throw UnsupportedOperationException. Overloads the left shift operator to provide an easy way to append objects to a Collection. <pre class="groovyTestCase">def list = [1,2] list &lt;&lt; 3 assert list == [1,2,3]</pre> Overloads the left shift operator to provide an easy way to append objects to a List. <pre class="groovyTestCase">def list = [1,2] list &lt;&lt; 3 assert list == [1,2,3]</pre> Overloads the left shift operator to provide an easy way to append Map.Entry values to a Map. Overloads the left shift operator to provide an easy way to put one maps entries into another map. This allows the compact syntax <code>map1 &lt;&lt; map2</code>; otherwise it's just a synonym for <code>putAll</code> though it returns the original map rather than being a <code>void</code> method. Example usage: <pre class="groovyTestCase">def map = [a:1, b:2] map &lt;&lt; [c:3, d:4] assert map == [a:1, b:2, c:3, d:4]</pre> Overloads the left shift operator to provide an easy way to append objects to a Set. <pre class="groovyTestCase">def set = [1,2] as Set set &lt;&lt; 3 assert set == [1,2,3] as Set</pre> Overloads the left shift operator to provide an easy way to append objects to a SortedSet. <pre class="groovyTestCase">def set = [1,2] as SortedSet set &lt;&lt; 3 assert set == [1,2,3] as SortedSet</pre> Overloads the left shift operator to provide an easy way to append objects to a BlockingQueue. In case of bounded queue the method will block till space in the queue become available <pre class="groovyTestCase">def list = new java.util.concurrent.LinkedBlockingQueue () list &lt;&lt; 3 &lt;&lt; 2 &lt;&lt; 1 assert list.iterator().collect{it} == [3,2,1]</pre> Adds max() method to Iterable objects. <pre class="groovyTestCase"> assert 5 == [2,3,1,5,4].max() </pre> Selects the item in the iterable which when passed as a parameter to the supplied closure returns the maximum value. A null return value represents the least possible return value, so any item for which the supplied closure returns null, won't be selected (unless all items return null). If more than one item has the maximum value, an arbitrary choice is made between the items having the maximum value. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. <pre class="groovyTestCase">assert "hello" == ["hello","hi","hey"].max { it.length() }</pre> <pre class="groovyTestCase">assert "hello" == ["hello","hi","hey"].max { a, b -> a.length() <=> b.length() }</pre> <pre class="groovyTestCase"> def pets = ['dog', 'elephant', 'anaconda'] def longestName = pets.max{ it.size() } // one of 'elephant' or 'anaconda' assert longestName.size() == 8 </pre> Selects the maximum value found in the Iterable using the given comparator. <pre class="groovyTestCase"> assert "hello" == ["hello","hi","hey"].max( { a, b -> a.length() <=> b.length() } as Comparator ) </pre> Adds max() method to Object arrays. Selects the maximum value found from the Object array using the closure to determine the correct ordering. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. Selects the maximum value found from the Object array using the given comparator.    Adds max() method to Iterator objects. The iterator will become exhausted of elements after determining the maximum value. Selects the maximum value found from the Iterator using the closure to determine the correct ordering. The iterator will become exhausted of elements after this operation. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. Selects the maximum value found from the Iterator using the given comparator. Selects an entry in the map having the maximum calculated value as determined by the supplied closure. If more than one entry has the maximum value, an arbitrary choice is made between the entries having the maximum value. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. An example: <pre class="groovyTestCase"> def zoo = [monkeys:6, lions:5, tigers:7] def mostCommonEntry = zoo.max{ it.value } assert mostCommonEntry.value == 7 def leastCommonEntry = zoo.max{ a, b -> b.value <=> a.value } // double negative! assert leastCommonEntry.value == 5 </pre> Edge case for multiple max values: <pre class="groovyTestCase"> def zoo = [monkeys:6, lions:5, tigers:7] def lengthOfNamePlusNumber = { e -> e.key.size() + e.value } def ans = zoo.max(lengthOfNamePlusNumber) // one of [monkeys:6, tigers:7] assert lengthOfNamePlusNumber(ans) == 13 </pre> Sets/updates the metaclass for a given class to a closure. Sets/updates the metaclass for a given object to a closure. Adds min() method to Collection objects. <pre class="groovyTestCase">assert 2 == [4,2,5].min()</pre> Selects the item in the iterable which when passed as a parameter to the supplied closure returns the minimum value. A null return value represents the least possible return value. If more than one item has the minimum value, an arbitrary choice is made between the items having the minimum value. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. <pre class="groovyTestCase"> assert "hi" == ["hello","hi","hey"].min { it.length() } </pre> <pre class="groovyTestCase"> def lastDigit = { a, b -> a % 10 <=> b % 10 } assert [19, 55, 91].min(lastDigit) == 91 </pre> <pre class="groovyTestCase"> def pets = ['dog', 'cat', 'anaconda'] def shortestName = pets.min{ it.size() } // one of 'dog' or 'cat' assert shortestName.size() == 3 </pre> Selects the minimum value found in the Iterable using the given comparator. <pre class="groovyTestCase">assert "hi" == ["hello","hi","hey"].min( { a, b -> a.length() <=> b.length() } as Comparator )</pre> Adds min() method to Object arrays. Selects the minimum value found from the Object array using the closure to determine the correct ordering. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. Selects the minimum value found from the Object array using the given comparator.    Adds min() method to Iterator objects. The iterator will become exhausted of elements after determining the minimum value. Selects the minimum value found from the Iterator using the closure to determine the correct ordering. The iterator will become exhausted of elements after this operation. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. Selects the minimum value found from the Iterator using the given comparator. Selects an entry in the map having the minimum calculated value as determined by the supplied closure. If more than one entry has the minimum value, an arbitrary choice is made between the entries having the minimum value. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. <pre class="groovyTestCase"> def zoo = [monkeys:6, lions:5, tigers:7] def leastCommonEntry = zoo.min{ it.value } assert leastCommonEntry.value == 5 def mostCommonEntry = zoo.min{ a, b -> b.value <=> a.value } // double negative! assert mostCommonEntry.value == 7 </pre> Edge case for multiple min values: <pre class="groovyTestCase"> def zoo = [monkeys:6, lions:5, tigers:7] def lastCharOfName = { e -> e.key[-1] } def ans = zoo.min(lastCharOfName) // some random entry assert lastCharOfName(ans) == 's' </pre> Subtract one Character from another. The ordinal values of the Characters is used in the comparison (the ordinal value is the unicode value which for simple character sets is the ASCII value). Subtract a Number from a Character. The ordinal value of the Character is used in the subtraction (the ordinal value is the unicode value which for simple character sets is the ASCII value). Create a new Collection composed of the elements of the first Iterable minus every occurrence of elements of the given Iterable. <pre class="groovyTestCase"> assert [1, "a", true, true, false, 5.3] - [true, 5.3] == [1, "a", false] </pre> Create a new Collection composed of the elements of the first Iterable minus every occurrence of the given element to remove. <pre class="groovyTestCase">assert ["a", 5, 5, true] - 5 == ["a", true]</pre> Subtract a Character from a Number. The ordinal value of the Character is used in the subtraction (the ordinal value is the unicode value which for simple character sets is the ASCII value). Create an array composed of the elements of the first array minus the elements of the given Iterable. Create a new object array composed of the elements of the first array minus the element to remove. Create an array composed of the elements of the first array minus the elements of the given array. Create a new Collection composed of the elements of the first Collection minus every occurrence of elements of the given Collection. <pre class="groovyTestCase">assert [1, "a", true, true, false, 5.3] - [true, 5.3] == [1, "a", false]</pre> Create a new List composed of the elements of the first List minus every occurrence of elements of the given Iterable. <pre class="groovyTestCase">assert [1, "a", true, true, false, 5.3] - [true, 5.3] == [1, "a", false]</pre> Create a new List composed of the elements of the first List minus every occurrence of the given element to remove. <pre class="groovyTestCase">assert ["a", 5, 5, true] - 5 == ["a", true]</pre> Create a List composed of the elements of the first list minus every occurrence of elements of the given Collection. <pre class="groovyTestCase">assert [1, "a", true, true, false, 5.3] - [true, 5.3] == [1, "a", false]</pre> Create a Map composed of the entries of the first map minus the entries of the given map. Create a Set composed of the elements of the first Set minus the elements from the given Iterable. Create a Set composed of the elements of the first Set minus the given element. Create a Set composed of the elements of the first Set minus the elements of the given Collection. Create a SortedSet composed of the elements of the first SortedSet minus the elements of the given Iterable. Create a SortedSet composed of the elements of the first SortedSet minus the given element. Create a SortedSet composed of the elements of the first SortedSet minus the elements of the given Collection. Extend class globally with category methods. Extend class globally with category methods. Extend object with category methods. All methods for given class and all super classes will be added to the object. Extend class globally with category methods. Extend class globally with category methods. Extend class globally with category methods. All methods for given class and all super classes will be added to the class. Performs a division modulus operation.  Called by the '%' operator. Multiply two Characters. The ordinal values of the Characters are used in the multiplication (the ordinal value is the unicode value which for simple character sets is the ASCII value). Multiply a Character by a Number. The ordinal value of the Character is used in the multiplication (the ordinal value is the unicode value which for simple character sets is the ASCII value). Create a Collection composed of the elements of this Iterable, repeated a certain number of times.  Note that for non-primitive elements, multiple references to the same instance will be added. <pre class="groovyTestCase">assert [1,2,3,1,2,3] == [1,2,3] * 2</pre> Note: if the Iterable happens to not support duplicates, e.g. a Set, then the method will effectively return a Collection with a single copy of the Iterable's items. Multiply a Number by a Character. The ordinal value of the Character is used in the multiplication (the ordinal value is the unicode value which for simple character sets is the ASCII value). Multiply a BigDecimal and a Double. Note: This method was added to enforce the Groovy rule of BigDecimal*Double == Double. Without this method, the multiply(BigDecimal) method in BigDecimal would respond and return a BigDecimal instead. Since BigDecimal is preferred over Number, the Number*Number method is not chosen as in older versions of Groovy. Multiply a BigDecimal and a BigInteger. Note: This method was added to enforce the Groovy rule of BigDecimal*long == long. Without this method, the multiply(BigDecimal) method in BigDecimal would respond and return a BigDecimal instead. Since BigDecimal is preferred over Number, the Number*Number method is not chosen as in older versions of Groovy. BigInteger is the fallback for all integer types in Groovy  Create a List composed of the elements of this Iterable, repeated a certain number of times.  Note that for non-primitive elements, multiple references to the same instance will be added. <pre class="groovyTestCase">assert [1,2,3,1,2,3] == [1,2,3] * 2</pre> Note: if the Iterable happens to not support duplicates, e.g. a Set, then the method will effectively return a Collection with a single copy of the Iterable's items. Convenience method to dynamically create a new instance of this class.  Calls the default constructor. Helper to construct a new instance from the given arguments. The constructor is called based on the number and types in the args array.  Use <code>newInstance(null)</code> or simply <code>newInstance()</code> for the default (no-arg) constructor. Number based methods ------------------------------------------------------------------------- Increment a Character by one. Increment a Number by one. Provides a method that compares two comparables using Groovy's default number aware comparator. Logical disjunction of two boolean operators Bitwise OR together two numbers. Bitwise OR together two BitSets.  Called when the '|' operator is used between two bit sets. Finds all permutations of an iterable. <p> Example usage: <pre class="groovyTestCase">def result = [1, 2, 3].permutations() assert result == [[3, 2, 1], [3, 1, 2], [1, 3, 2], [2, 3, 1], [2, 1, 3], [1, 2, 3]] as Set</pre> Finds all permutations of an iterable, applies a function to each permutation and collects the result into a list. <p> Example usage: <pre class="groovyTestCase">Set result = [1, 2, 3].permutations { it.collect { v -> 2*v }} assert result == [[6, 4, 2], [6, 2, 4], [2, 6, 4], [4, 6, 2], [4, 2, 6], [2, 4, 6]] as Set</pre>   Add one Character to another. The ordinal values of the Characters are used in the addition (the ordinal value is the unicode value which for simple character sets is the ASCII value). This operation will always create a new object for the result, while the operands remain unchanged. Add a Character and a Number. The ordinal value of the Character is used in the addition (the ordinal value is the unicode value which for simple character sets is the ASCII value). This operation will always create a new object for the result, while the operands remain unchanged. Create a Collection as a union of two iterables. If the left iterable is a Set, then the returned collection will be a Set otherwise a List. This operation will always create a new object for the result, while the operands remain unchanged. <pre class="groovyTestCase">assert [1,2,3,4] == [1,2] + [3,4]</pre> Create a collection as a union of an Iterable and an Object. If the iterable is a Set, then the returned collection will be a Set otherwise a List. This operation will always create a new object for the result, while the operands remain unchanged. <pre class="groovyTestCase">assert [1,2,3] == [1,2] + 3</pre> Add a Number and a Character.  The ordinal value of the Character is used in the addition (the ordinal value is the unicode value which for simple character sets is the ASCII value). Create an array containing elements from an original array plus those from an Iterable. <pre class="groovyTestCase"> class AbcIterable implements Iterable<String> { Iterator<String> iterator() { "abc".iterator() } } String[] letters = ['x', 'y', 'z'] def result = letters + new AbcIterable() assert result == ['x', 'y', 'z', 'a', 'b', 'c'] as String[] assert result.class.array </pre> Create an array containing elements from an original array plus an additional appended element. <pre class="groovyTestCase"> Integer[] a = [1, 2, 3] Integer[] result = a + 4 assert result == [1, 2, 3, 4] as Integer[] </pre> Create an array as a union of two arrays. <pre class="groovyTestCase"> Integer[] a = [1, 2, 3] Integer[] b = [4, 5, 6] assert a + b == [1, 2, 3, 4, 5, 6] as Integer[] </pre> Create an array containing elements from an original array plus those from a Collection. <pre class="groovyTestCase"> Integer[] a = [1, 2, 3] def additions = [7, 8] assert a + additions == [1, 2, 3, 7, 8] as Integer[] </pre> Create a Collection as a union of a Collection and an Iterable. If the left collection is a Set, then the returned collection will be a Set otherwise a List. This operation will always create a new object for the result, while the operands remain unchanged. Create a collection as a union of a Collection and an Object. If the collection is a Set, then the returned collection will be a Set otherwise a List. This operation will always create a new object for the result, while the operands remain unchanged. <pre class="groovyTestCase">assert [1,2,3] == [1,2] + 3</pre> Create a Collection as a union of two collections. If the left collection is a Set, then the returned collection will be a Set otherwise a List. This operation will always create a new object for the result, while the operands remain unchanged. <pre class="groovyTestCase">assert [1,2,3,4] == [1,2] + [3,4]</pre> Creates a new List by inserting all of the elements in the given Iterable to the elements from this List at the specified index. Creates a new List by inserting all of the elements in the specified array to the elements from the original List at the specified index. Shifts the element currently at that index (if any) and any subsequent elements to the right (increasing their indices). The new elements will appear in the resulting List in the order that they occur in the original array. The behavior of this operation is undefined if the list or array operands are modified while the operation is in progress. The original list and array operands remain unchanged. <pre class="groovyTestCase"> def items = [1, 2, 3] def newItems = items.plus(2, 'a'..'c' as String[]) assert newItems == [1, 2, 'a', 'b', 'c', 3] assert items == [1, 2, 3] </pre> See also <code>addAll</code> for similar functionality with modify semantics, i.e. which performs the changes on the original list itself. Creates a new List by inserting all of the elements in the given additions List to the elements from the original List at the specified index. Shifts the element currently at that index (if any) and any subsequent elements to the right (increasing their indices).  The new elements will appear in the resulting List in the order that they occur in the original lists. The behavior of this operation is undefined if the original lists are modified while the operation is in progress. The original lists remain unchanged. <pre class="groovyTestCase"> def items = [1, 2, 3] def newItems = items.plus(2, 'a'..'c') assert newItems == [1, 2, 'a', 'b', 'c', 3] assert items == [1, 2, 3] </pre> See also <code>addAll</code> for similar functionality with modify semantics, i.e. which performs the changes on the original list itself. Create a List as a union of a List and an Iterable. This operation will always create a new object for the result, while the operands remain unchanged. Create a List as a union of a List and an Object. This operation will always create a new object for the result, while the operands remain unchanged. <pre class="groovyTestCase">assert [1,2,3] == [1,2] + 3</pre> Create a List as a union of a List and an Collection. This operation will always create a new object for the result, while the operands remain unchanged. Returns a new <code>Map</code> containing all entries from <code>self</code> and <code>entries</code>, giving precedence to <code>entries</code>.  Any keys appearing in both Maps will appear in the resultant map with values from the <code>entries</code> operand. If <code>self</code> map is one of TreeMap, LinkedHashMap, Hashtable or Properties, the returned Map will preserve that type, otherwise a HashMap will be returned. Returns a new <code>Map</code> containing all entries from <code>left</code> and <code>right</code>, giving precedence to <code>right</code>.  Any keys appearing in both Maps will appear in the resultant map with values from the <code>right</code> operand. If the <code>left</code> map is one of TreeMap, LinkedHashMap, Hashtable or Properties, the returned Map will preserve that type, otherwise a HashMap will be returned. <p> Roughly equivalent to <code>Map m = new HashMap(); m.putAll(left); m.putAll(right); return m;</code> but with some additional logic to preserve the <code>left</code> Map type for common cases as described above. <pre class="groovyTestCase"> assert [a:10, b:20] + [a:5, c:7] == [a:5, b:20, c:7] </pre> Create a Set as a union of a Set and an Iterable. This operation will always create a new object for the result, while the operands remain unchanged. Create a Set as a union of a Set and an Object. This operation will always create a new object for the result, while the operands remain unchanged. <pre class="groovyTestCase">assert [1,2,3] == [1,2] + 3</pre> Create a Set as a union of a Set and an Collection. This operation will always create a new object for the result, while the operands remain unchanged. Create a SortedSet as a union of a SortedSet and an Iterable. This operation will always create a new object for the result, while the operands remain unchanged. Create a SortedSet as a union of a SortedSet and an Object. This operation will always create a new object for the result, while the operands remain unchanged. <pre class="groovyTestCase">assert [1,2,3] == [1,2] + 3</pre> Create a SortedSet as a union of a SortedSet and an Collection. This operation will always create a new object for the result, while the operands remain unchanged. Removes the last item from the List. Using add() and pop() is similar to push and pop on a Stack. <pre class="groovyTestCase">def list = ["a", false, 2] assert list.pop() == 2 assert list == ["a", false]</pre> Power of an integer to an integer certain exponent. If the exponent is positive, convert to a BigInteger and call BigInteger.pow(int) method to maintain precision. Called by the '**' operator. Power of a long to an integer certain exponent. If the exponent is positive, convert to a BigInteger and call BigInteger.pow(int) method to maintain precision. Called by the '**' operator. Power of a Number to a certain exponent. Called by the '**' operator. Power of a BigDecimal to an integer certain exponent. If the exponent is positive, call the BigDecimal.pow(int) method to maintain precision. Called by the '**' operator. Power of a BigInteger to an integer certain exponent. If the exponent is positive, call the BigInteger.pow(int) method to maintain precision. Called by the '**' operator. Power of a BigInteger to an BigInteger certain exponent. Called by the '**' operator. Decrement a Character by one. Decrement a Number by one. Implements the getAt(Range) method for primitive type arrays. Implements the getAt(int) method for primitive type arrays. Implements the getAt(Collection) method for primitive type arrays.  Each value in the collection argument is assumed to be a valid array index. The value at each index is then added to a list which is returned. Implements the setAt(int idx) method for primitive type arrays. Print a value to the standard output stream. This method delegates to the owner to execute the method. Print a value formatted Groovy style to the print stream. Print a value formatted Groovy style to the print writer. Print to a console in interactive format. Print a value formatted Groovy style to self if it is a Writer, otherwise to the standard output stream. Prints a formatted string using the specified format string and arguments. <p> Examples: <pre> printf ( "Hello, %s!\n" , [ "world" ] as String[] ) printf ( "Hello, %s!\n" , [ "Groovy" ]) printf ( "%d + %d = %d\n" , [ 1 , 2 , 1+2 ] as Integer[] ) printf ( "%d + %d = %d\n" , [ 3 , 3 , 3+3 ]) ( 1..5 ).each { printf ( "-- %d\n" , [ it ] as Integer[] ) } ( 1..5 ).each { printf ( "-- %d\n" , [ it ] as int[] ) } ( 0x41..0x45 ).each { printf ( "-- %c\n" , [ it ] as char[] ) } ( 07..011 ).each { printf ( "-- %d\n" , [ it ] as byte[] ) } ( 7..11 ).each { printf ( "-- %d\n" , [ it ] as short[] ) } ( 7..11 ).each { printf ( "-- %d\n" , [ it ] as long[] ) } ( 7..11 ).each { printf ( "-- %5.2f\n" , [ it ] as float[] ) } ( 7..11 ).each { printf ( "-- %5.2g\n" , [ it ] as double[] ) } </pre> Printf to a console. Print a linebreak to the standard output stream. This method delegates to the owner to execute the method. Print a value (followed by a newline) to the standard output stream. This method delegates to the owner to execute the method. Print a value formatted Groovy style (followed by a newline) to the print stream. Print a value formatted Groovy style (followed by a newline) to the print writer. Print a linebreak to the standard output stream. Print to a console in interactive format. Print a value formatted Groovy style (followed by a newline) to self if it is a Writer, otherwise to the standard output stream. Appends an item to the List. Synonym for add(). <pre class="groovyTestCase">def list = [3, 4, 2] list.push("x") assert list == [3, 4, 2, "x"]</pre> Provides an easy way to append multiple Map.Entry values to a Map. Allows the subscript operator to be used to set dynamically named property values. <code>bean[somePropertyNameExpression] = foo</code>. The normal property notation of groovy is neater and more concise but only works with property names which are known at compile time. public static Boolean putAt(boolean[] array, int idx, Boolean newValue) { return (Boolean) primitiveArrayPut(array, idx, newValue); }  public static Byte putAt(byte[] array, int idx, Object newValue) { if (!(newValue instanceof Byte)) { Number n = (Number) newValue; newValue = new Byte(n.byteValue()); } return (Byte) primitiveArrayPut(array, idx, newValue); }  public static Character putAt(char[] array, int idx, Object newValue) { if (newValue instanceof String) { String s = (String) newValue; if (s.length() != 1) throw new IllegalArgumentException("String of length 1 expected but got a bigger one"); char c = s.charAt(0); newValue = new Character(c); } return (Character) primitiveArrayPut(array, idx, newValue); }  public static Short putAt(short[] array, int idx, Object newValue) { if (!(newValue instanceof Short)) { Number n = (Number) newValue; newValue = new Short(n.shortValue()); } return (Short) primitiveArrayPut(array, idx, newValue); }  public static Integer putAt(int[] array, int idx, Object newValue) { if (!(newValue instanceof Integer)) { Number n = (Number) newValue; newValue = Integer.valueOf(n.intValue()); } array [normaliseIndex(idx,array.length)] = ((Integer)newValue).intValue(); return (Integer) newValue; }  public static Long putAt(long[] array, int idx, Object newValue) { if (!(newValue instanceof Long)) { Number n = (Number) newValue; newValue = new Long(n.longValue()); } return (Long) primitiveArrayPut(array, idx, newValue); }  public static Float putAt(float[] array, int idx, Object newValue) { if (!(newValue instanceof Float)) { Number n = (Number) newValue; newValue = new Float(n.floatValue()); } return (Float) primitiveArrayPut(array, idx, newValue); }  public static Double putAt(double[] array, int idx, Object newValue) { if (!(newValue instanceof Double)) { Number n = (Number) newValue; newValue = new Double(n.doubleValue()); } return (Double) primitiveArrayPut(array, idx, newValue); } Support assigning a range of values with a single assignment statement. Support subscript-style assignment for a BitSet. A helper method to allow lists to work with subscript operators. <pre class="groovyTestCase">def list = ["a", true] list[1..<1] = 5 assert list == ["a", 5, true]</pre> A helper method to allow lists to work with subscript operators. <pre class="groovyTestCase">def list = ["a", true] list[1..<1] = [4, 3, 2] assert list == ["a", 4, 3, 2, true]</pre> List subscript assignment operator when given a range as the index. Example: <pre class="groovyTestCase">def myList = [4, 3, 5, 1, 2, 8, 10] myList[3..5] = "b" assert myList == [4, 3, 5, "b", 10]</pre> Items in the given range are replaced with the operand.  The <code>value</code> operand is always treated as a single value. List subscript assignment operator when given a range as the index and the assignment operand is a collection. Example: <pre class="groovyTestCase">def myList = [4, 3, 5, 1, 2, 8, 10] myList[3..5] = ["a", true] assert myList == [4, 3, 5, "a", true, 10]</pre> Items in the given range are replaced with items from the collection. A helper method to allow lists to work with subscript operators. <pre class="groovyTestCase">def list = [2, 3] list[0] = 1 assert list == [1, 3]</pre> A helper method to allow lists to work with subscript operators. <pre class="groovyTestCase">def list = ["a", true, 42, 9.4] list[1, 3] = 5 assert list == ["a", 5, 42, 5]</pre> A helper method to allow lists to work with subscript operators. <pre class="groovyTestCase">def list = ["a", true, 42, 9.4] list[1, 4] = ["x", false] assert list == ["a", "x", 42, 9.4, false]</pre> A helper method to allow maps to work with subscript operators Modifies this collection by removing the elements that are matched according to the specified closure condition. See also <code>findAll</code> and <code>grep</code> when wanting to produce a new list containing items which don't match some criteria while leaving the original collection unchanged. Modifies this collection by removing its elements that are contained within the specified object array. See also <code>findAll</code> and <code>grep</code> when wanting to produce a new list containing items which don't match some criteria while leaving the original collection unchanged. Modifies this list by removing the element at the specified position in this list. Returns the removed element. Essentially an alias for {@link List#remove(int)} but with no ambiguity for List&lt;Integer&gt;. <p/> Example: <pre class="groovyTestCase"> def list = [1, 2, 3] list.removeAt(1) assert [1, 3] == list </pre> Modifies this collection by removing a single instance of the specified element from this collection, if it is present. Essentially an alias for {@link Collection#remove(Object)} but with no ambiguity for Collection&lt;Integer&gt;. <p/> Example: <pre class="groovyTestCase"> def list = [1, 2, 3, 2] list.removeElement(2) assert [1, 3, 2] == list </pre> <p>Returns an object satisfying Groovy truth if the implementing MetaClass responds to a method with the given name regardless of the arguments. <p>Note that this method's return value is based on realised methods and does not take into account objects or classes that implement invokeMethod or methodMissing <p>This method is "safe" in that it will always return a value and never throw an exception <p>Returns an object satisfying Groovy truth if the implementing MetaClass responds to a method with the given name and arguments types. <p>Note that this method's return value is based on realised methods and does not take into account objects or classes that implement invokeMethod or methodMissing <p>This method is "safe" in that it will always return a value and never throw an exception Modifies this collection so that it retains only its elements that are matched according to the specified closure condition.  In other words, removes from this collection all of its elements that don't match. See also <code>findAll</code> and <code>grep</code> when wanting to produce a new list containing items which match some criteria but leaving the original collection unchanged. Modifies this collection so that it retains only its elements that are contained in the specified array.  In other words, removes from this collection all of its elements that are not contained in the specified array. See also <code>grep</code> and <code>findAll</code> when wanting to produce a new list containing items which match some specified items but leaving the original collection unchanged. Creates a new array containing items which are the same as this array but in reverse order. Reverse the items in an array. If mutate is true, the original array is modified in place and returned. Otherwise, a new array containing the reversed items is produced. Reverses the iterator. The original iterator will become exhausted of elements after determining the reversed values. A new iterator for iterating through the reversed values is returned. Creates a new List with the identical contents to this list but in reverse order. <pre class="groovyTestCase"> def list = ["a", 4, false] assert list.reverse() == [false, 4, "a"] assert list == ["a", 4, false] </pre> Reverses the elements in a list. If mutate is true, the original list is modified in place and returned. Otherwise, a new list containing the reversed items is produced. <pre class="groovyTestCase"> def list = ["a", 4, false] assert list.reverse(false) == [false, 4, "a"] assert list == ["a", 4, false] assert list.reverse(true) == [false, 4, "a"] assert list == [false, 4, "a"] </pre> Iterate over each element of the array in the reverse order. Iterate over each element of the list in the reverse order. <pre class="groovyTestCase">def result = [] [1,2,3].reverseEach { result &lt;&lt; it } assert result == [3,2,1]</pre> Allows a Map to be iterated through in reverse order using a closure. In general, the order in which the map contents are processed cannot be guaranteed. In practise, specialized forms of Map, e.g. a TreeMap will have its contents processed according to the reverse of the natural ordering of the map. Implementation of the right shift operator for integral types.  Non integral Number types throw UnsupportedOperationException. Implementation of the right shift (unsigned) operator for integral types.  Non integral Number types throw UnsupportedOperationException. Round the value Round the value Round the value Round the value public static Boolean negate(Boolean left) { return Boolean.valueOf(!left.booleanValue()); } Allows a simple syntax for using timers.  This timer will execute the given closure after the given delay. Set the metaclass for a GroovyObject. Sets the metaclass for a given class. Set the metaclass for an object. Allows arrays to behave similar to collections. Allows arrays to behave similar to collections. Allows arrays to behave similar to collections. Allows arrays to behave similar to collections. Allows arrays to behave similar to collections. Allows arrays to behave similar to collections. Provide the standard Groovy <code>size()</code> method for <code>Iterable</code>. <pre class="groovyTestCase"> def items = [1, 2, 3] def iterable = { [ hasNext:{ !items.isEmpty() }, next:{ items.pop() } ] as Iterator } as Iterable assert iterable.size() == 3 </pre> Provide the standard Groovy <code>size()</code> method for an array. Provide the standard Groovy <code>size()</code> method for <code>Iterator</code>. The iterator will become exhausted of elements after determining the size value. Allows arrays to behave similar to collections. Allows arrays to behave similar to collections. Sorts the Collection. Assumes that the collection items are comparable and uses their natural ordering to determine the resulting order. If the Collection is a List, it is sorted in place and returned. Otherwise, the elements are first placed into a new list which is then sorted and returned - leaving the original Collection unchanged. <pre class="groovyTestCase">assert [1,2,3] == [3,1,2].sort()</pre> Sorts this Iterable using the given Closure to determine the correct ordering. If the Iterable is a List, it is sorted in place and returned. Otherwise, the elements are first placed into a new list which is then sorted and returned - leaving the original Iterable unchanged. <p> If the Closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. <pre class="groovyTestCase">assert ["hi","hey","hello"] == ["hello","hi","hey"].sort { it.length() }</pre> <pre class="groovyTestCase">assert ["hi","hey","hello"] == ["hello","hi","hey"].sort { a, b -> a.length() <=> b.length() }</pre> Sorts the Iterable. Assumes that the Iterable items are comparable and uses their natural ordering to determine the resulting order. If the Iterable is a List and mutate is true, it is sorted in place and returned. Otherwise, the elements are first placed into a new list which is then sorted and returned - leaving the original Iterable unchanged. <pre class="groovyTestCase">assert [1,2,3] == [3,1,2].sort()</pre> <pre class="groovyTestCase"> def orig = [1, 3, 2] def sorted = orig.sort(false) assert orig == [1, 3, 2] assert sorted == [1, 2, 3] </pre> Sorts this Iterable using the given Closure to determine the correct ordering. If the Iterable is a List and mutate is true, it is sorted in place and returned. Otherwise, the elements are first placed into a new list which is then sorted and returned - leaving the original Iterable unchanged. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. <pre class="groovyTestCase">assert ["hi","hey","hello"] == ["hello","hi","hey"].sort { it.length() }</pre> <pre class="groovyTestCase">assert ["hi","hey","hello"] == ["hello","hi","hey"].sort { a, b -> a.length() <=> b.length() }</pre> <pre class="groovyTestCase"> def orig = ["hello","hi","Hey"] def sorted = orig.sort(false) { it.toUpperCase() } assert orig == ["hello","hi","Hey"] assert sorted == ["hello","Hey","hi"] </pre> Sorts the Iterable using the given Comparator. If the Iterable is a List and mutate is true, it is sorted in place and returned. Otherwise, the elements are first placed into a new list which is then sorted and returned - leaving the original Iterable unchanged. <pre class="groovyTestCase"> assert ["hi","hey","hello"] == ["hello","hi","hey"].sort( { a, b -> a.length() <=> b.length() } as Comparator ) </pre> <pre class="groovyTestCase"> def orig = ["hello","hi","Hey"] def sorted = orig.sort(false, String.CASE_INSENSITIVE_ORDER) assert orig == ["hello","hi","Hey"] assert sorted == ["hello","Hey","hi"] </pre> Modifies this array so that its elements are in sorted order. The array items are assumed to be comparable. Sorts the elements from this array into a newly created array using the Closure to determine the correct ordering. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. Sorts the given array into sorted order. The array items are assumed to be comparable. If mutate is true, the array is sorted in place and returned. Otherwise, a new sorted array is returned and the original array remains unchanged. <pre class="groovyTestCase"> def orig = ["hello","hi","Hey"] as String[] def sorted = orig.sort(false) assert orig == ["hello","hi","Hey"] as String[] assert sorted == ["Hey","hello","hi"] as String[] orig.sort(true) assert orig == ["Hey","hello","hi"] as String[] </pre> Modifies this array so that its elements are in sorted order using the Closure to determine the correct ordering. If mutate is false, a new array is returned and the original array remains unchanged. Otherwise, the original array is sorted in place and returned. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. <pre class="groovyTestCase"> def orig = ["hello","hi","Hey"] as String[] def sorted = orig.sort(false) { it.size() } assert orig == ["hello","hi","Hey"] as String[] assert sorted == ["hi","Hey","hello"] as String[] orig.sort(true) { it.size() } assert orig == ["hi","Hey","hello"] as String[] </pre> Modifies this array so that its elements are in sorted order as determined by the given comparator. If mutate is true, the array is sorted in place and returned. Otherwise, a new sorted array is returned and the original array remains unchanged. <pre class="groovyTestCase"> def orig = ["hello","hi","Hey"] as String[] def sorted = orig.sort(false, String.CASE_INSENSITIVE_ORDER) assert orig == ["hello","hi","Hey"] as String[] assert sorted == ["hello","Hey","hi"] as String[] orig.sort(true, String.CASE_INSENSITIVE_ORDER) assert orig == ["hello","Hey","hi"] as String[] </pre> Sorts the given array into sorted order using the given comparator.       Sorts the given iterator items into a sorted iterator. The items are assumed to be comparable. The original iterator will become exhausted of elements after completing this method call. A new iterator is produced that traverses the items in sorted order. Sorts the given iterator items into a sorted iterator using the Closure to determine the correct ordering. The original iterator will be fully processed after the method call. <p> If the closure has two parameters it is used like a traditional Comparator. I.e.&#160;it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. Sorts the given iterator items into a sorted iterator using the comparator. The original iterator will become exhausted of elements after completing this method call. A new iterator is produced that traverses the items in sorted order. Sorts the elements from the given map into a new ordered Map using the natural ordering of the keys to determine the ordering. The original map is unchanged. <pre class="groovyTestCase">map = [ba:3, cz:6, ab:5].sort() assert map*.value == [5, 3, 6] </pre> Sorts the elements from the given map into a new ordered map using the closure as a comparator to determine the ordering. The original map is unchanged. <pre class="groovyTestCase">def map = [a:5, b:3, c:6, d:4].sort { a, b -> a.value <=> b.value } assert map == [b:3, d:4, a:5, c:6]</pre> Sorts the elements from the given map into a new ordered Map using the specified key comparator to determine the ordering. The original map is unchanged. <pre class="groovyTestCase">def map = [ba:3, cz:6, ab:5].sort({ a, b -> a[-1] <=> b[-1] } as Comparator) assert map*.value == [3, 5, 6]</pre> Avoids doing unnecessary work when sorting an already sorted map (i.e. an identity function for an already sorted map). Avoids doing unnecessary work when sorting an already sorted set (i.e. an identity function for an already sorted set). Splits all items into two lists based on the closure condition. The first list contains all items matching the closure expression. The second list all those that don't. Splits all items into two collections based on the closure condition. The first list contains all items which match the closure expression. The second list all those that don't. <p> Example usage: <pre class="groovyTestCase">assert [[2,4],[1,3]] == [1,2,3,4].split { it % 2 == 0 }</pre> Splits all items into two collections based on the closure condition. The first list contains all items which match the closure expression. The second list all those that don't. <p> Example usage: <pre class="groovyTestCase">assert [[2,4],[1,3]] == [1,2,3,4].split { it % 2 == 0 }</pre> Splits all items into two collections based on the closure condition. The first list contains all items which match the closure expression. The second list all those that don't. <p> Example usage: <pre class="groovyTestCase">assert [[2,4] as Set, [1,3] as Set] == ([1,2,3,4] as Set).split { it % 2 == 0 }</pre> Synonym for {@link #toSpreadMap(java.util.Map)}. Returns a formatted string using the specified format string and arguments. Sprintf to a string. Iterates from this number up to the given number using a step increment. Each intermediate number is passed to the given closure.  Example: <pre>0.step( 10, 2 ) { println it }</pre> Prints even numbers 0 through 8. Creates a sub-Map containing the given keys. This method is similar to List.subList() but uses keys rather than index ranges. The original map is unaltered. <pre class="groovyTestCase"> def orig = [1:10, 2:20, 3:30, 4:40] assert orig.subMap([1, 3] as int[]) == [1:10, 3:30] assert orig.subMap([2, 4] as Integer[]) == [2:20, 4:40] assert orig.size() == 4 </pre> Creates a sub-Map containing the given keys. This method is similar to List.subList() but uses keys rather than index ranges. <pre class="groovyTestCase">assert [1:10, 2:20, 4:40].subMap( [2, 4] ) == [2:20, 4:40]</pre> Finds all non-null subsequences of a list. <p> Example usage: <pre class="groovyTestCase">def result = [1, 2, 3].subsequences() assert result == [[1, 2, 3], [1, 3], [2, 3], [1, 2], [1], [2], [3]] as Set</pre> Sums the items in an array. <pre class="groovyTestCase">assert (1+2+3+4 as byte) == ([1,2,3,4] as byte[]).sum()</pre> Sums the items in an array, adding the result to some initial value. <pre class="groovyTestCase">assert (5+1+2+3+4 as byte) == ([1,2,3,4] as byte[]).sum(5)</pre> Sums the items in an array. <pre class="groovyTestCase">assert (1+2+3+4 as char) == ([1,2,3,4] as char[]).sum()</pre> Sums the items in an array, adding the result to some initial value. <pre class="groovyTestCase">assert (5+1+2+3+4 as char) == ([1,2,3,4] as char[]).sum(5)</pre> Sums the items in an array. <pre class="groovyTestCase">assert (1+2+3+4 as double) == ([1,2,3,4] as double[]).sum()</pre> Sums the items in an array, adding the result to some initial value. <pre class="groovyTestCase">assert (5+1+2+3+4 as double) == ([1,2,3,4] as double[]).sum(5)</pre> Sums the items in an array. <pre class="groovyTestCase">assert (1+2+3+4 as float) == ([1,2,3,4] as float[]).sum()</pre> Sums the items in an array, adding the result to some initial value. <pre class="groovyTestCase">assert (5+1+2+3+4 as float) == ([1,2,3,4] as float[]).sum(5)</pre> Sums the items in an array. <pre class="groovyTestCase">assert 1+2+3+4 == ([1,2,3,4] as int[]).sum()</pre> Sums the items in an array, adding the result to some initial value. <pre class="groovyTestCase">assert 5+1+2+3+4 == ([1,2,3,4] as int[]).sum(5)</pre> Sums the items in an Iterable.  This is equivalent to invoking the "plus" method on all items in the Iterable. <pre class="groovyTestCase">assert 1+2+3+4 == [1,2,3,4].sum()</pre> Sums the result of apply a closure to each item of an Iterable. <code>coll.sum(closure)</code> is equivalent to: <code>coll.collect(closure).sum()</code>. <pre class="groovyTestCase">assert 4+6+10+12 == [2,3,5,6].sum { it * 2 }</pre> Sums the items in an Iterable, adding the result to some initial value. <pre class="groovyTestCase"> assert 5+1+2+3+4 == [1,2,3,4].sum(5) </pre> Sums the result of applying a closure to each item of an Iterable to some initial value. <code>coll.sum(initVal, closure)</code> is equivalent to: <code>coll.collect(closure).sum(initVal)</code>. <pre class="groovyTestCase">assert 50+4+6+10+12 == [2,3,5,6].sum(50) { it * 2 }</pre> Sums the items in an array.  This is equivalent to invoking the "plus" method on all items in the array. Sums the result of apply a closure to each item of an array. <code>array.sum(closure)</code> is equivalent to: <code>array.collect(closure).sum()</code>. Sums the items in an array, adding the result to some initial value. Sums the result of applying a closure to each item of an array to some initial value. <code>array.sum(initVal, closure)</code> is equivalent to: <code>array.collect(closure).sum(initVal)</code>.     Sums the items from an Iterator.  This is equivalent to invoking the "plus" method on all items from the Iterator. The iterator will become exhausted of elements after determining the sum value. Sums the result of apply a closure to each item returned from an iterator. <code>iter.sum(closure)</code> is equivalent to: <code>iter.collect(closure).sum()</code>. The iterator will become exhausted of elements after determining the sum value. Sums the items from an Iterator, adding the result to some initial value.  This is equivalent to invoking the "plus" method on all items from the Iterator. The iterator will become exhausted of elements after determining the sum value. Sums the result of applying a closure to each item of an Iterator to some initial value. <code>iter.sum(initVal, closure)</code> is equivalent to: <code>iter.collect(closure).sum(initVal)</code>. The iterator will become exhausted of elements after determining the sum value. Sums the items in an array. <pre class="groovyTestCase">assert (1+2+3+4 as long) == ([1,2,3,4] as long[]).sum()</pre> Sums the items in an array, adding the result to some initial value. <pre class="groovyTestCase">assert (5+1+2+3+4 as long) == ([1,2,3,4] as long[]).sum(5)</pre> Sums the items in an array. <pre class="groovyTestCase">assert (1+2+3+4 as short) == ([1,2,3,4] as short[]).sum()</pre> Sums the items in an array, adding the result to some initial value. <pre class="groovyTestCase">assert (5+1+2+3+4 as short) == ([1,2,3,4] as short[]).sum(5)</pre> Swaps two elements at the specified positions. <p> Example: <pre class="groovyTestCase"> assert ([false, true, false, true] as boolean[]) == ([false, false, true, true] as boolean[]).swap(1, 2) </pre> Swaps two elements at the specified positions. <p> Example: <pre class="groovyTestCase"> assert ([1, 3, 2, 4] as byte[]) == ([1, 2, 3, 4] as byte[]).swap(1, 2) </pre> Swaps two elements at the specified positions. <p> Example: <pre class="groovyTestCase"> assert ([1, 3, 2, 4] as char[]) == ([1, 2, 3, 4] as char[]).swap(1, 2) </pre> Swaps two elements at the specified positions. <p> Example: <pre class="groovyTestCase"> assert ([1, 3, 2, 4] as double[]) == ([1, 2, 3, 4] as double[]).swap(1, 2) </pre> Swaps two elements at the specified positions. <p> Example: <pre class="groovyTestCase"> assert ([1, 3, 2, 4] as float[]) == ([1, 2, 3, 4] as float[]).swap(1, 2) </pre> Swaps two elements at the specified positions. <p> Example: <pre class="groovyTestCase"> assert ([1, 3, 2, 4] as int[]) == ([1, 2, 3, 4] as int[]).swap(1, 2) </pre> Swaps two elements at the specified positions. <p> Example: <pre class="groovyTestCase"> assert (["a", "c", "b", "d"] as String[]) == (["a", "b", "c", "d"] as String[]).swap(1, 2) </pre> Swaps two elements at the specified positions. <p> Example: <pre class="groovyTestCase"> assert [1, 3, 2, 4] == [1, 2, 3, 4].swap(1, 2) </pre> Swaps two elements at the specified positions. <p> Example: <pre class="groovyTestCase"> assert ([1, 3, 2, 4] as long[]) == ([1, 2, 3, 4] as long[]).swap(1, 2) </pre> Swaps two elements at the specified positions. <p> Example: <pre class="groovyTestCase"> assert ([1, 3, 2, 4] as short[]) == ([1, 2, 3, 4] as short[]).swap(1, 2) </pre> Returns the items from the Iterable excluding the first item. <pre class="groovyTestCase"> def list = [3, 4, 2] assert list.tail() == [4, 2] assert list == [3, 4, 2] </pre> Returns the items from the array excluding the first item. <pre class="groovyTestCase"> String[] strings = ["a", "b", "c"] def result = strings.tail() assert result.class.componentType == String String[] expected = ["b", "c"] assert result == expected </pre> Returns the original iterator after throwing away the first element. Returns the items from the List excluding the first item. <pre class="groovyTestCase"> def list = [3, 4, 2] assert list.tail() == [4, 2] assert list == [3, 4, 2] </pre> Returns the items from the SortedSet excluding the first item. <pre class="groovyTestCase"> def sortedSet = [3, 4, 2] as SortedSet assert sortedSet.tail() == [3, 4] as SortedSet assert sortedSet == [3, 4, 2] as SortedSet </pre> Returns the first <code>num</code> elements from the head of this Iterable. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] assert strings.take( 0 ) == [] assert strings.take( 2 ) == [ 'a', 'b' ] assert strings.take( 5 ) == [ 'a', 'b', 'c' ] class AbcIterable implements Iterable<String> { Iterator<String> iterator() { "abc".iterator() } } def abc = new AbcIterable() assert abc.take(0) == [] assert abc.take(1) == ['a'] assert abc.take(3) == ['a', 'b', 'c'] assert abc.take(5) == ['a', 'b', 'c'] </pre> Returns the first <code>num</code> elements from the head of this array. <pre class="groovyTestCase"> String[] strings = [ 'a', 'b', 'c' ] assert strings.take( 0 ) == [] as String[] assert strings.take( 2 ) == [ 'a', 'b' ] as String[] assert strings.take( 5 ) == [ 'a', 'b', 'c' ] as String[] </pre> Returns an iterator of up to the first <code>num</code> elements from this iterator. The original iterator is stepped along by <code>num</code> elements. <pre class="groovyTestCase"> def a = 0 def iter = [ hasNext:{ true }, next:{ a++ } ] as Iterator def iteratorCompare( Iterator a, List b ) { a.collect { it } == b } assert iteratorCompare( iter.take( 0 ), [] ) assert iteratorCompare( iter.take( 2 ), [ 0, 1 ] ) assert iteratorCompare( iter.take( 5 ), [ 2, 3, 4, 5, 6 ] ) </pre> Returns the first <code>num</code> elements from the head of this List. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] assert strings.take( 0 ) == [] assert strings.take( 2 ) == [ 'a', 'b' ] assert strings.take( 5 ) == [ 'a', 'b', 'c' ] </pre> Returns a new map containing the first <code>num</code> elements from the head of this map. If the map instance does not have ordered keys, then this function could return a random <code>num</code> entries. Groovy by default uses LinkedHashMap, so this shouldn't be an issue in the main. <pre class="groovyTestCase"> def strings = [ 'a':10, 'b':20, 'c':30 ] assert strings.take( 0 ) == [:] assert strings.take( 2 ) == [ 'a':10, 'b':20 ] assert strings.take( 5 ) == [ 'a':10, 'b':20, 'c':30 ] </pre> Returns the first <code>num</code> elements from the head of this SortedSet. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] as SortedSet assert strings.take( 0 ) == [] as SortedSet assert strings.take( 2 ) == [ 'a', 'b' ] as SortedSet assert strings.take( 5 ) == [ 'a', 'b', 'c' ] as SortedSet </pre> Returns the last <code>num</code> elements from the tail of this Iterable. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] assert strings.takeRight( 0 ) == [] assert strings.takeRight( 2 ) == [ 'b', 'c' ] assert strings.takeRight( 5 ) == [ 'a', 'b', 'c' ] class AbcIterable implements Iterable<String> { Iterator<String> iterator() { "abc".iterator() } } def abc = new AbcIterable() assert abc.takeRight(0) == [] assert abc.takeRight(1) == ['c'] assert abc.takeRight(3) == ['a', 'b', 'c'] assert abc.takeRight(5) == ['a', 'b', 'c'] </pre> Returns the last <code>num</code> elements from the tail of this array. <pre class="groovyTestCase"> String[] strings = [ 'a', 'b', 'c' ] assert strings.takeRight( 0 ) == [] as String[] assert strings.takeRight( 2 ) == [ 'b', 'c' ] as String[] assert strings.takeRight( 5 ) == [ 'a', 'b', 'c' ] as String[] </pre> Returns the last <code>num</code> elements from the tail of this List. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] assert strings.takeRight( 0 ) == [] assert strings.takeRight( 2 ) == [ 'b', 'c' ] assert strings.takeRight( 5 ) == [ 'a', 'b', 'c' ] </pre> Returns the last <code>num</code> elements from the tail of this SortedSet. <pre class="groovyTestCase"> def strings = [ 'a', 'b', 'c' ] as SortedSet assert strings.takeRight( 0 ) == [] as SortedSet assert strings.takeRight( 2 ) == [ 'b', 'c' ] as SortedSet assert strings.takeRight( 5 ) == [ 'a', 'b', 'c' ] as SortedSet </pre> Returns a Collection containing the longest prefix of the elements from this Iterable where each element passed to the given closure evaluates to true. <pre class="groovyTestCase"> class AbcIterable implements Iterable<String> { Iterator<String> iterator() { "abc".iterator() } } def abc = new AbcIterable() assert abc.takeWhile{ it < 'b' } == ['a'] assert abc.takeWhile{ it <= 'b' } == ['a', 'b'] </pre> Returns the longest prefix of this array where each element passed to the given closure evaluates to true. <pre class="groovyTestCase"> def nums = [ 1, 3, 2 ] as Integer[] assert nums.takeWhile{ it < 1 } == [] as Integer[] assert nums.takeWhile{ it < 3 } == [ 1 ] as Integer[] assert nums.takeWhile{ it < 4 } == [ 1, 3, 2 ] as Integer[] </pre> Returns the longest prefix of elements in this iterator where each element passed to the given condition closure evaluates to true. <p> <pre class="groovyTestCase"> def a = 0 def iter = [ hasNext:{ true }, next:{ a++ } ] as Iterator assert [].iterator().takeWhile{ it < 3 }.toList() == [] assert [1, 2, 3, 4, 5].iterator().takeWhile{ it < 3 }.toList() == [ 1, 2 ] assert iter.takeWhile{ it < 5 }.toList() == [ 0, 1, 2, 3, 4 ] </pre> Returns the longest prefix of this list where each element passed to the given closure condition evaluates to true. Similar to {@link #takeWhile(Iterable, groovy.lang.Closure)} except that it attempts to preserve the type of the original list. <pre class="groovyTestCase"> def nums = [ 1, 3, 2 ] assert nums.takeWhile{ it < 1 } == [] assert nums.takeWhile{ it < 3 } == [ 1 ] assert nums.takeWhile{ it < 4 } == [ 1, 3, 2 ] </pre> Returns the longest prefix of this Map where each entry (or key/value pair) when passed to the given closure evaluates to true. <pre class="groovyTestCase"> def shopping = [milk:1, bread:2, chocolate:3] assert shopping.takeWhile{ it.key.size() < 6 } == [milk:1, bread:2] assert shopping.takeWhile{ it.value % 2 } == [milk:1] assert shopping.takeWhile{ k, v -> k.size() + v <= 7 } == [milk:1, bread:2] </pre> If the map instance does not have ordered keys, then this function could appear to take random entries. Groovy by default uses LinkedHashMap, so this shouldn't be an issue in the main. Returns the longest prefix of this SortedSet where each element passed to the given closure condition evaluates to true. Similar to {@link #takeWhile(Iterable, groovy.lang.Closure)} except that it attempts to preserve the type of the original SortedSet. <pre class="groovyTestCase"> def nums = [ 1, 2, 3 ] as SortedSet assert nums.takeWhile{ it < 1 } == [] as SortedSet assert nums.takeWhile{ it < 2 } == [ 1 ] as SortedSet assert nums.takeWhile{ it < 4 } == [ 1, 2, 3 ] as SortedSet </pre> Executes the closure this many times, starting from zero.  The current index is passed to the closure each time. Example: <pre>10.times { println it }</pre> Prints the numbers 0 through 9. Returns the string representation of the given array.  The string displays the contents of the array, similar to an array literal, i.e. <code>{1, 2, "a"}</code>. Transform a Number into a BigDecimal Transform this Number into a BigInteger. Identity conversion which returns Boolean.TRUE for a true Boolean and Boolean.FALSE for a false Boolean. Transform a Number into a Double Transform a Number into a Float Transform a Number into an Integer Converts this array to a List of the same size, with each element added to the list. Converts this array to a List of the same size, with each element added to the list. Converts this array to a List of the same size, with each element added to the list. Converts this array to a List of the same size, with each element added to the list. Converts this array to a List of the same size, with each element added to the list. Converts this array to a List of the same size, with each element added to the list. Convert an Iterable to a List. The Iterable's iterator will become exhausted of elements after making this conversion. <p> Example usage: <pre class="groovyTestCase">def x = [1,2,3] as HashSet assert x.class == HashSet assert x.toList() instanceof List</pre> Allows conversion of arrays into a mutable List.  Convert an enumeration to a List. Convert an iterator to a List. The iterator will become exhausted of elements after making this conversion. Converts this array to a List of the same size, with each element added to the list. Converts this array to a List of the same size, with each element added to the list. Returns the string representation of the given list.  The string displays the contents of the list, similar to a list literal, i.e. <code>[1, 2, a]</code>. Returns the string representation of the given list.  The string displays the contents of the list, similar to a list literal, i.e. <code>[1, 2, a]</code>. Transform a Number into a Long Converts the character to lowercase. Synonym for 'Character.toLowerCase(this)'. Returns the string representation of this map.  The string displays the contents of the map, i.e. <code>[one:1, two:2, three:3]</code>. Returns the string representation of this map.  The string displays the contents of the map, i.e. <code>[one:1, two:2, three:3]</code>. Converts this array to a Set, with each unique element added to the set. Converts this array to a Set, with each unique element added to the set. Converts this array to a Set, with each unique element added to the set. Converts this array to a Set, with each unique element added to the set. Converts this array to a Set, with each unique element added to the set. Converts this array to a Set, with each unique element added to the set. Convert an Iterable to a Set. Always returns a new Set even if the Iterable is already a Set. <p> Example usage: <pre class="groovyTestCase"> def result = [1, 2, 2, 2, 3].toSet() assert result instanceof Set assert result == [1, 2, 3] as Set </pre> Convert a Collection to a Set. Always returns a new Set even if the Collection is already a Set. <p> Example usage: <pre class="groovyTestCase"> def result = [1, 2, 2, 2, 3].toSet() assert result instanceof Set assert result == [1, 2, 3] as Set </pre> Convert an enumeration to a Set. Convert an iterator to a Set. The iterator will become exhausted of elements after making this conversion. Converts this array to a Set, with each unique element added to the set. Converts this array to a Set, with each unique element added to the set. Sorts the Iterable. Assumes that the Iterable elements are comparable and uses a {@link NumberAwareComparator} to determine the resulting order. {@code NumberAwareComparator} has special treatment for numbers but otherwise uses the natural ordering of the Iterable elements. The elements are first placed into a new list which is then sorted and returned - leaving the original Iterable unchanged. <pre class="groovyTestCase"> def orig = [1, 3, 2] def sorted = orig.toSorted() assert orig == [1, 3, 2] assert sorted == [1, 2, 3] </pre> Sorts this Iterable using the given Closure to determine the correct ordering. The elements are first placed into a new list which is then sorted and returned - leaving the original Iterable unchanged. <p> If the Closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. <pre class="groovyTestCase">assert ["hi","hey","hello"] == ["hello","hi","hey"].sort { it.length() }</pre> <pre class="groovyTestCase">assert ["hi","hey","hello"] == ["hello","hi","hey"].sort { a, b -> a.length() <=> b.length() }</pre> Sorts the Iterable using the given Comparator. The elements are first placed into a new list which is then sorted and returned - leaving the original Iterable unchanged. <pre class="groovyTestCase"> def orig = ["hello","hi","Hey"] def sorted = orig.toSorted(String.CASE_INSENSITIVE_ORDER) assert orig == ["hello","hi","Hey"] assert sorted == ["hello","Hey","hi"] </pre> Returns a sorted version of the given array using the supplied comparator. Sorts the elements from this array into a newly created array using the Closure to determine the correct ordering. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. Returns a sorted version of the given array using the supplied comparator to determine the resulting order. <pre class="groovyTestCase"> def sumDigitsComparator = [compare: { num1, num2 -> num1.toString().toList()*.toInteger().sum() <=> num2.toString().toList()*.toInteger().sum() }] as Comparator Integer[] nums = [9, 44, 222, 7000] def result = nums.toSorted(sumDigitsComparator) assert result instanceof Integer[] assert result == [222, 7000, 44, 9] </pre> Sorts the Iterator. Assumes that the Iterator elements are comparable and uses a {@link NumberAwareComparator} to determine the resulting order. {@code NumberAwareComparator} has special treatment for numbers but otherwise uses the natural ordering of the Iterator elements. A new iterator is produced that traverses the items in sorted order. Sorts the given iterator items into a sorted iterator using the Closure to determine the correct ordering. The original iterator will be fully processed after the method call. <p> If the closure has two parameters it is used like a traditional Comparator. I.e.&#160;it should compare its two parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single parameter and return a Comparable (typically an Integer) which is then used for further comparison. Sorts the given iterator items using the comparator. The original iterator will become exhausted of elements after completing this method call. A new iterator is produced that traverses the items in sorted order. Sorts the elements from the given map into a new ordered map using a {@link NumberAwareComparator} on map entry values to determine the resulting order. {@code NumberAwareComparator} has special treatment for numbers but otherwise uses the natural ordering of the Iterator elements. The original map is unchanged. <pre class="groovyTestCase"> def map = [a:5L, b:3, c:6, d:4.0].toSorted() assert map.toString() == '[b:3, d:4.0, a:5, c:6]' </pre> Sorts the elements from the given map into a new ordered map using the supplied Closure condition as a comparator to determine the ordering. The original map is unchanged. <p> If the closure has two parameters it is used like a traditional Comparator. I.e. it should compare its two entry parameters for order, returning a negative integer, zero, or a positive integer when the first parameter is less than, equal to, or greater than the second respectively. Otherwise, the Closure is assumed to take a single entry parameter and return a Comparable (typically an Integer) which is then used for further comparison. <pre class="groovyTestCase"> def map = [a:5, b:3, c:6, d:4].toSorted { a, b -> a.value <=> b.value } assert map.toString() == '[b:3, d:4, a:5, c:6]' </pre> Sorts the elements from the given map into a new ordered map using the supplied comparator to determine the ordering. The original map is unchanged. <pre class="groovyTestCase"> def keyComparator = [compare: { e1, e2 -> e1.key <=> e2.key }] as Comparator def valueComparator = [compare: { e1, e2 -> e1.value <=> e2.value }] as Comparator def map1 = [a:5, b:3, d:4, c:6].toSorted(keyComparator) assert map1.toString() == '[a:5, b:3, c:6, d:4]' def map2 = [a:5, b:3, d:4, c:6].toSorted(valueComparator) assert map2.toString() == '[b:3, d:4, a:5, c:6]' </pre> Avoids doing unnecessary work when sorting an already sorted map Avoids doing unnecessary work when sorting an already sorted set Creates a spreadable map from this iterable. <p> Creates a spreadable map from this array. <p> Creates a spreadable map from this list. <p> Returns a new <code>SpreadMap</code> from this map. <p> The example below shows the various possible use cases: <pre class="groovyTestCase"> def fn(Map m) { return m.a + m.b + m.c + m.d } assert fn(a:1, b:2, c:3, d:4) == 10 assert fn(a:1, *:[b:2, c:3], d:4) == 10 assert fn([a:1, b:2, c:3, d:4].toSpreadMap()) == 10 assert fn((['a', 1, 'b', 2, 'c', 3, 'd', 4] as Object[]).toSpreadMap()) == 10 assert fn(['a', 1, 'b', 2, 'c', 3, 'd', 4].toSpreadMap()) == 10 assert fn(['abcd'.toList(), 1..4].transpose().flatten().toSpreadMap()) == 10 </pre> Note that toSpreadMap() is not normally used explicitly but under the covers by Groovy. Returns the string representation of the given array. Returns the string representation of the given array. Returns the string representation of the given array. Returns the string representation of the given array. Returns the string representation of the given array. Returns the string representation of the given array. Create a String representation of this object. Returns the string representation of this array's contents. Returns the string representation of the given collection.  The string displays the contents of the collection, i.e. <code>[1, 2, a]</code>. Returns the string representation of the given map. Returns the string representation of the given array. Returns the string representation of the given array. Returns a Collection containing the items from the Iterable but with duplicates removed using the natural ordering of the items to determine uniqueness. <p> <pre class="groovyTestCase"> String[] letters = ['c', 'a', 't', 's', 'a', 't', 'h', 'a', 't'] String[] expected = ['c', 'a', 't', 's', 'h'] assert letters.toUnique() == expected </pre> Returns a Collection containing the items from the Iterable but with duplicates removed. The items in the Iterable are compared by the given Closure condition. For each duplicate, the first member which is returned from the Iterable is retained, but all other ones are removed. <p> If the closure takes a single parameter, each element from the Iterable will be passed to the closure. The closure should return a value used for comparison (either using {@link java.lang.Comparable#compareTo(java.lang.Object)} or {@link java.lang.Object#equals(java.lang.Object)}). If the closure takes two parameters, two items from the Iterable will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique). <p> <pre class="groovyTestCase"> class Person { def fname, lname String toString() { return fname + " " + lname } } Person a = new Person(fname:"John", lname:"Taylor") Person b = new Person(fname:"Clark", lname:"Taylor") Person c = new Person(fname:"Tom", lname:"Cruz") Person d = new Person(fname:"Clark", lname:"Taylor") def list = [a, b, c, d] def list2 = list.toUnique{ p1, p2 -> p1.lname != p2.lname ? p1.lname &lt;=&gt; p2.lname : p1.fname &lt;=&gt; p2.fname } assert( list2 == [a, b, c] && list == [a, b, c, d] ) def list3 = list.toUnique{ it.toString() } assert( list3 == [a, b, c] && list == [a, b, c, d] ) </pre> Returns a Collection containing the items from the Iterable but with duplicates removed. The items in the Iterable are compared by the given Comparator. For each duplicate, the first member which is returned from the Iterable is retained, but all other ones are removed. <p> <pre class="groovyTestCase"> class Person { def fname, lname String toString() { return fname + " " + lname } } class PersonComparator implements Comparator { int compare(Object o1, Object o2) { Person p1 = (Person) o1 Person p2 = (Person) o2 if (p1.lname != p2.lname) return p1.lname.compareTo(p2.lname) else return p1.fname.compareTo(p2.fname) } boolean equals(Object obj) { return this.equals(obj) } } Person a = new Person(fname:"John", lname:"Taylor") Person b = new Person(fname:"Clark", lname:"Taylor") Person c = new Person(fname:"Tom", lname:"Cruz") Person d = new Person(fname:"Clark", lname:"Taylor") def list = [a, b, c, d] List list2 = list.toUnique(new PersonComparator()) assert( list2 == list && list == [a, b, c] ) </pre> Returns a new Array containing the items from the original Array but with duplicates removed using the natural ordering of the items in the array. <p> <pre class="groovyTestCase"> String[] letters = ['c', 'a', 't', 's', 'a', 't', 'h', 'a', 't'] String[] expected = ['c', 'a', 't', 's', 'h'] def result = letters.toUnique() assert result == expected assert result.class.componentType == String </pre> Returns a new Array containing the items from the original Array but with duplicates removed with the supplied comparator determining which items are unique. <p> <pre class="groovyTestCase"> String[] letters = ['c', 'a', 't', 's', 'A', 't', 'h', 'a', 'T'] String[] expected = ['c', 'a', 't', 's', 'h'] assert letters.toUnique{ p1, p2 -> p1.toLowerCase() <=> p2.toLowerCase() } == expected assert letters.toUnique{ it.toLowerCase() } == expected </pre> Returns a new Array containing the items from the original Array but with duplicates removed with the supplied comparator determining which items are unique. <p> <pre class="groovyTestCase"> String[] letters = ['c', 'a', 't', 's', 'A', 't', 'h', 'a', 'T'] String[] lower = ['c', 'a', 't', 's', 'h'] class LowerComparator implements Comparator { int compare(let1, let2) { let1.toLowerCase() <=> let2.toLowerCase() } } assert letters.toUnique(new LowerComparator()) == lower </pre> Returns an iterator equivalent to this iterator with all duplicated items removed by using the natural ordering of the items. Returns an iterator equivalent to this iterator but with all duplicated items removed where duplicate (equal) items are deduced by calling the supplied Closure condition. <p> If the supplied Closure takes a single parameter, the argument passed will be each element, and the closure should return a value used for comparison (either using {@link java.lang.Comparable#compareTo(java.lang.Object)} or {@link java.lang.Object#equals(java.lang.Object)}). If the closure takes two parameters, two items from the Iterator will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique). <pre class="groovyTestCase"> def items = "Hello".toList() + [null, null] + "there".toList() def toLower = { it == null ? null : it.toLowerCase() } def noDups = items.iterator().toUnique(toLower).toList() assert noDups == ['H', 'e', 'l', 'o', null, 't', 'r'] </pre> <pre class="groovyTestCase">assert [1,4] == [1,3,4,5].toUnique { it % 2 }</pre> <pre class="groovyTestCase">assert [2,3,4] == [2,3,3,4].toUnique { a, b -> a <=> b }</pre> Returns an iterator equivalent to this iterator with all duplicated items removed by using the supplied comparator. Returns a List containing the items from the List but with duplicates removed using the natural ordering of the items to determine uniqueness. <p> <pre class="groovyTestCase"> def letters = ['c', 'a', 't', 's', 'a', 't', 'h', 'a', 't'] def expected = ['c', 'a', 't', 's', 'h'] assert letters.toUnique() == expected </pre> Returns a List containing the items from the List but with duplicates removed. The items in the List are compared by the given Closure condition. For each duplicate, the first member which is returned from the Iterable is retained, but all other ones are removed. <p> If the closure takes a single parameter, each element from the Iterable will be passed to the closure. The closure should return a value used for comparison (either using {@link java.lang.Comparable#compareTo(java.lang.Object)} or {@link java.lang.Object#equals(java.lang.Object)}). If the closure takes two parameters, two items from the Iterable will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique). <p> <pre class="groovyTestCase"> class Person { def fname, lname String toString() { return fname + " " + lname } } Person a = new Person(fname:"John", lname:"Taylor") Person b = new Person(fname:"Clark", lname:"Taylor") Person c = new Person(fname:"Tom", lname:"Cruz") Person d = new Person(fname:"Clark", lname:"Taylor") def list = [a, b, c, d] def list2 = list.toUnique{ p1, p2 -> p1.lname != p2.lname ? p1.lname &lt;=&gt; p2.lname : p1.fname &lt;=&gt; p2.fname } assert( list2 == [a, b, c] && list == [a, b, c, d] ) def list3 = list.toUnique{ it.toString() } assert( list3 == [a, b, c] && list == [a, b, c, d] ) </pre> Returns a List containing the items from the List but with duplicates removed. The items in the List are compared by the given Comparator. For each duplicate, the first member which is returned from the List is retained, but all other ones are removed. <p> <pre class="groovyTestCase"> class Person { def fname, lname String toString() { return fname + " " + lname } } class PersonComparator implements Comparator { int compare(Object o1, Object o2) { Person p1 = (Person) o1 Person p2 = (Person) o2 if (p1.lname != p2.lname) return p1.lname.compareTo(p2.lname) else return p1.fname.compareTo(p2.fname) } boolean equals(Object obj) { return this.equals(obj) } } Person a = new Person(fname:"John", lname:"Taylor") Person b = new Person(fname:"Clark", lname:"Taylor") Person c = new Person(fname:"Tom", lname:"Cruz") Person d = new Person(fname:"Clark", lname:"Taylor") def list = [a, b, c, d] List list2 = list.toUnique(new PersonComparator()) assert( list2 == list && list == [a, b, c] ) </pre> Converts the character to uppercase. Synonym for 'Character.toUpperCase(this)'. Adds GroovyCollections#transpose(List) as a method on lists. A Transpose Function takes a collection of columns and returns a collection of rows. The first row consists of the first element from each column. Successive rows are constructed similarly. <p> Example usage: <pre class="groovyTestCase">def result = [['a', 'b'], [1, 2]].transpose() assert result == [['a', 1], ['b', 2]]</pre> <pre class="groovyTestCase">def result = [['a', 'b'], [1, 2], [3, 4]].transpose() assert result == [['a', 1, 3], ['b', 2, 4]]</pre> Truncate the value Truncate the value Truncate the value Truncate the value Negates the number.  Equivalent to the '-' operator when it preceeds a single operand, i.e. <code>-10</code> Returns the number, effectively being a noop for numbers. Operator overloaded form of the '+' operator when it preceeds a single operand, i.e. <code>+10</code> Modifies this collection to remove all duplicated items, using the default comparator. <pre class="groovyTestCase">assert [1,3] == [1,3,3].unique()</pre> A convenience method for making a collection unique using a Closure to determine duplicate (equal) items. <p> If the closure takes a single parameter, the argument passed will be each element, and the closure should return a value used for comparison (either using {@link java.lang.Comparable#compareTo(java.lang.Object)} or {@link java.lang.Object#equals(java.lang.Object)}). If the closure takes two parameters, two items from the collection will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique). <pre class="groovyTestCase">assert [1,4] == [1,3,4,5].unique { it % 2 }</pre> <pre class="groovyTestCase">assert [2,3,4] == [2,3,3,4].unique { a, b -> a <=> b }</pre> Remove all duplicates from a given Collection using the default comparator. If mutate is true, it works by modifying the original object (and also returning it). If mutate is false, a new collection is returned leaving the original unchanged. <pre class="groovyTestCase"> assert [1,3] == [1,3,3].unique() </pre> <pre class="groovyTestCase"> def orig = [1, 3, 2, 3] def uniq = orig.unique(false) assert orig == [1, 3, 2, 3] assert uniq == [1, 3, 2] </pre> A convenience method for making a collection unique using a Closure to determine duplicate (equal) items. If mutate is true, it works on the receiver object and returns it. If mutate is false, a new collection is returned. <p> If the closure takes a single parameter, each element from the Collection will be passed to the closure. The closure should return a value used for comparison (either using {@link java.lang.Comparable#compareTo(java.lang.Object)} or {@link java.lang.Object#equals(java.lang.Object)}). If the closure takes two parameters, two items from the collection will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique). <pre class="groovyTestCase"> def orig = [1, 3, 4, 5] def uniq = orig.unique(false) { it % 2 } assert orig == [1, 3, 4, 5] assert uniq == [1, 4] </pre> <pre class="groovyTestCase"> def orig = [2, 3, 3, 4] def uniq = orig.unique(false) { a, b -> a <=> b } assert orig == [2, 3, 3, 4] assert uniq == [2, 3, 4] </pre> Remove all duplicates from a given Collection. If mutate is true, it works on the original object (and also returns it). If mutate is false, a new collection is returned. The order of members in the Collection are compared by the given Comparator. For each duplicate, the first member which is returned by the given Collection's iterator is retained, but all other ones are removed. The given Collection's original order is preserved. <p> <pre class="groovyTestCase"> class Person { def fname, lname String toString() { return fname + " " + lname } } class PersonComparator implements Comparator { int compare(Object o1, Object o2) { Person p1 = (Person) o1 Person p2 = (Person) o2 if (p1.lname != p2.lname) return p1.lname.compareTo(p2.lname) else return p1.fname.compareTo(p2.fname) } boolean equals(Object obj) { return this.equals(obj) } } Person a = new Person(fname:"John", lname:"Taylor") Person b = new Person(fname:"Clark", lname:"Taylor") Person c = new Person(fname:"Tom", lname:"Cruz") Person d = new Person(fname:"Clark", lname:"Taylor") def list = [a, b, c, d] List list2 = list.unique(false, new PersonComparator()) assert( list2 != list && list2 == [a, b, c] ) </pre> Remove all duplicates from a given Collection. Works on the original object (and also returns it). The order of members in the Collection are compared by the given Comparator. For each duplicate, the first member which is returned by the given Collection's iterator is retained, but all other ones are removed. The given Collection's original order is preserved. <p> <pre class="groovyTestCase"> class Person { def fname, lname String toString() { return fname + " " + lname } } class PersonComparator implements Comparator { int compare(Object o1, Object o2) { Person p1 = (Person) o1 Person p2 = (Person) o2 if (p1.lname != p2.lname) return p1.lname.compareTo(p2.lname) else return p1.fname.compareTo(p2.fname) } boolean equals(Object obj) { return this.equals(obj) } } Person a = new Person(fname:"John", lname:"Taylor") Person b = new Person(fname:"Clark", lname:"Taylor") Person c = new Person(fname:"Tom", lname:"Cruz") Person d = new Person(fname:"Clark", lname:"Taylor") def list = [a, b, c, d] List list2 = list.unique(new PersonComparator()) assert( list2 == list && list == [a, b, c] ) </pre> Returns an iterator equivalent to this iterator with all duplicated items removed by using the default comparator. The original iterator will become exhausted of elements after determining the unique values. A new iterator for the unique values will be returned. Returns an iterator equivalent to this iterator but with all duplicated items removed by using a Closure to determine duplicate (equal) items. The original iterator will be fully processed after the call. <p> If the closure takes a single parameter, the argument passed will be each element, and the closure should return a value used for comparison (either using {@link java.lang.Comparable#compareTo(java.lang.Object)} or {@link java.lang.Object#equals(java.lang.Object)}). If the closure takes two parameters, two items from the Iterator will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique). Returns an iterator equivalent to this iterator with all duplicated items removed by using the supplied comparator. Modifies this List to remove all duplicated items, using the default comparator. <pre class="groovyTestCase">assert [1,3] == [1,3,3].unique()</pre> A convenience method for making a List unique using a Closure to determine duplicate (equal) items. <p> If the closure takes a single parameter, the argument passed will be each element, and the closure should return a value used for comparison (either using {@link java.lang.Comparable#compareTo(java.lang.Object)} or {@link java.lang.Object#equals(java.lang.Object)}). If the closure takes two parameters, two items from the List will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique). <pre class="groovyTestCase">assert [1,4] == [1,3,4,5].unique { it % 2 }</pre> <pre class="groovyTestCase">assert [2,3,4] == [2,3,3,4].unique { a, b -> a <=> b }</pre> Remove all duplicates from a given List using the default comparator. If mutate is true, it works by modifying the original object (and also returning it). If mutate is false, a new collection is returned leaving the original unchanged. <pre class="groovyTestCase"> assert [1,3] == [1,3,3].unique() </pre> <pre class="groovyTestCase"> def orig = [1, 3, 2, 3] def uniq = orig.unique(false) assert orig == [1, 3, 2, 3] assert uniq == [1, 3, 2] </pre> A convenience method for making a List unique using a Closure to determine duplicate (equal) items. If mutate is true, it works on the receiver object and returns it. If mutate is false, a new collection is returned. <p> If the closure takes a single parameter, each element from the List will be passed to the closure. The closure should return a value used for comparison (either using {@link java.lang.Comparable#compareTo(java.lang.Object)} or {@link java.lang.Object#equals(java.lang.Object)}). If the closure takes two parameters, two items from the collection will be passed as arguments, and the closure should return an int value (with 0 indicating the items are not unique). <pre class="groovyTestCase"> def orig = [1, 3, 4, 5] def uniq = orig.unique(false) { it % 2 } assert orig == [1, 3, 4, 5] assert uniq == [1, 4] </pre> <pre class="groovyTestCase"> def orig = [2, 3, 3, 4] def uniq = orig.unique(false) { a, b -> a <=> b } assert orig == [2, 3, 3, 4] assert uniq == [2, 3, 4] </pre> Remove all duplicates from a given List. If mutate is true, it works on the original object (and also returns it). If mutate is false, a new List is returned. The order of members in the List are compared by the given Comparator. For each duplicate, the first member which is returned by the given List's iterator is retained, but all other ones are removed. The given List's original order is preserved. <p> <pre class="groovyTestCase"> class Person { def fname, lname String toString() { return fname + " " + lname } } class PersonComparator implements Comparator { int compare(Object o1, Object o2) { Person p1 = (Person) o1 Person p2 = (Person) o2 if (p1.lname != p2.lname) return p1.lname.compareTo(p2.lname) else return p1.fname.compareTo(p2.fname) } boolean equals(Object obj) { return this.equals(obj) } } Person a = new Person(fname:"John", lname:"Taylor") Person b = new Person(fname:"Clark", lname:"Taylor") Person c = new Person(fname:"Tom", lname:"Cruz") Person d = new Person(fname:"Clark", lname:"Taylor") def list = [a, b, c, d] List list2 = list.unique(false, new PersonComparator()) assert( list2 != list && list2 == [a, b, c] ) </pre> Remove all duplicates from a given List. Works on the original object (and also returns it). The order of members in the List are compared by the given Comparator. For each duplicate, the first member which is returned by the given List's iterator is retained, but all other ones are removed. The given List's original order is preserved. <p> <pre class="groovyTestCase"> class Person { def fname, lname String toString() { return fname + " " + lname } } class PersonComparator implements Comparator { int compare(Object o1, Object o2) { Person p1 = (Person) o1 Person p2 = (Person) o2 if (p1.lname != p2.lname) return p1.lname.compareTo(p2.lname) else return p1.fname.compareTo(p2.fname) } boolean equals(Object obj) { return this.equals(obj) } } Person a = new Person(fname:"John", lname:"Taylor") Person b = new Person(fname:"Clark", lname:"Taylor") Person c = new Person(fname:"Tom", lname:"Cruz") Person d = new Person(fname:"Clark", lname:"Taylor") def list = [a, b, c, d] List list2 = list.unique(new PersonComparator()) assert( list2 == list && list == [a, b, c] ) </pre> Iterates from this number up to the given number, inclusive, incrementing by one each time. Iterates from this number up to the given number, inclusive, incrementing by one each time. Iterates from this number up to the given number, inclusive, incrementing by one each time. Iterates from this number up to the given number, inclusive, incrementing by one each time. Iterates from this number up to the given number, inclusive, incrementing by one each time. Iterates from this number up to the given number, inclusive, incrementing by one each time. Iterates from this number up to the given number, inclusive, incrementing by one each time. <pre>0.1.upto( 10 ) { println it }</pre> Prints numbers 0.1, 1.1, 2.1... to 9.1 Iterates from this number up to the given number, inclusive, incrementing by one each time.  Example: <pre>0.upto( 10 ) { println it }</pre> Prints numbers 0 to 10 Iterates from this number up to the given number, inclusive, incrementing by one each time. Scoped use method Allows you to use a list of categories, specifying the list as varargs. <code>use(CategoryClass1, CategoryClass2) { ... }</code> This method saves having to wrap the the category classes in a list. Scoped use method with list of categories. Allows the closure to be called for the object reference self. <p> Any method invoked inside the closure will first be invoked on the self reference. For instance, the following method calls to the append() method are invoked on the StringBuilder instance: <pre> def b = new StringBuilder().with { append('foo') append('bar') return it } assert b.toString() == 'foobar' </pre> This is commonly used to simplify object creation, such as this example: <pre> def p = new Person().with { firstName = 'John' lastName = 'Doe' return it } </pre> An alias for <code>withLazyDefault</code> which decorates a list allowing it to grow when called with index values outside the normal list bounds. Wraps a map using the decorator pattern with a wrapper that intercepts all calls to <code>get(key)</code>. If an unknown key is found, a default value will be stored into the Map before being returned. The default value stored will be the result of calling the supplied Closure with the key as the parameter to the Closure. Example usage: <pre class="groovyTestCase"> def map = [a:1, b:2].withDefault{ k -> k.toCharacter().isLowerCase() ? 10 : -10 } def expected = [a:1, b:2, c:10, D:-10] assert expected.every{ e -> e.value == map[e.key] } def constMap = [:].withDefault{ 42 } assert constMap.foo == 42 assert constMap.size() == 1 </pre> Decorates a list allowing it to grow when called with a non-existent index value. When called with such values, the list is grown in size and a default value is placed in the list by calling a supplied <code>init</code> Closure. Null values can be stored in the list. <p> How it works: The decorated list intercepts all calls to <code>getAt(index)</code> and <code>get(index)</code>. If an index greater than or equal to the current <code>size()</code> is used, the list will grow automatically up to the specified index. Gaps will be filled by calling the <code>init</code> Closure. If generating a default value is a costly operation consider using <code>withLazyDefault</code>. <p> Example usage: <pre class="groovyTestCase"> def list = [0, 1].withEagerDefault{ 42 } assert list[0] == 0 assert list[1] == 1 assert list[3] == 42   // default value assert list == [0, 1, 42, 42]   // gap filled with default value // illustrate using the index when generating default values def list2 = [5].withEagerDefault{ index -> index * index } assert list2[3] == 9 assert list2 == [5, 1, 4, 9] // illustrate what happens with null values list2[2] = null assert list2[2] == null assert list2 == [5, 1, null, 9] </pre> Zips an Iterable with indices in (value, index) order. <p/> Example usage: <pre class="groovyTestCase"> assert [["a", 0], ["b", 1]] == ["a", "b"].withIndex() assert ["0: a", "1: b"] == ["a", "b"].withIndex().collect { str, idx -> "$idx: $str" } </pre> Zips an Iterable with indices in (value, index) order. <p/> Example usage: <pre class="groovyTestCase"> assert [["a", 5], ["b", 6]] == ["a", "b"].withIndex(5) assert ["1: a", "2: b"] == ["a", "b"].withIndex(1).collect { str, idx -> "$idx: $str" } </pre> Zips an iterator with indices in (value, index) order. <p/> Example usage: <pre class="groovyTestCase"> assert [["a", 0], ["b", 1]] == ["a", "b"].iterator().withIndex().toList() assert ["0: a", "1: b"] == ["a", "b"].iterator().withIndex().collect { str, idx -> "$idx: $str" }.toList() </pre> Zips an iterator with indices in (value, index) order. <p/> Example usage: <pre class="groovyTestCase"> assert [["a", 5], ["b", 6]] == ["a", "b"].iterator().withIndex(5).toList() assert ["1: a", "2: b"] == ["a", "b"].iterator().withIndex(1).collect { str, idx -> "$idx: $str" }.toList() </pre> Decorates a list allowing it to grow when called with a non-existent index value. When called with such values, the list is grown in size and a default value is placed in the list by calling a supplied <code>init</code> Closure. Subsequent retrieval operations if finding a null value in the list assume it was set as null from an earlier growing operation and again call the <code>init</code> Closure to populate the retrieved value; consequently the list can't be used to store null values. <p> How it works: The decorated list intercepts all calls to <code>getAt(index)</code> and <code>get(index)</code>. If an index greater than or equal to the current <code>size()</code> is used, the list will grow automatically up to the specified index. Gaps will be filled by {@code null}. If a default value should also be used to fill gaps instead of {@code null}, use <code>withEagerDefault</code>. If <code>getAt(index)</code> or <code>get(index)</code> are called and a null value is found, it is assumed that the null value was a consequence of an earlier grow list operation and the <code>init</code> Closure is called to populate the value. <p> Example usage: <pre class="groovyTestCase"> def list = [0, 1].withLazyDefault{ 42 } assert list[0] == 0 assert list[1] == 1 assert list[3] == 42   // default value assert list == [0, 1, null, 42] // gap filled with null // illustrate using the index when generating default values def list2 = [5].withLazyDefault{ index -> index * index } assert list2[3] == 9 assert list2 == [5, null, null, 9] assert list2[2] == 4 assert list2 == [5, null, 4, 9] // illustrate what happens with null values list2[2] = null assert list2[2] == 4 </pre> Dynamically wraps an instance into something which implements the supplied trait classes. It is guaranteed that the returned object will implement the trait interfaces, but the original type of the object is lost (replaced with a proxy). Exclusive disjunction of two boolean operators Bitwise XOR together two Numbers.  Called when the '^' operator is used. Bitwise XOR together two BitSets.  Called when the '^' operator is used between two bit sets.
Close the Closeable. Ignore any problems that might occur. Close the Closeable. Logging a warning if any problems occur. This converts a possibly negative index to a real index into the array. Determines if all items of this array are of the same type. helper method for getAt and putAt helper method for getAt and putAt
Get the current time in seconds Works exactly like ResourceBundle.getBundle(String).  This is needed because the java method depends on a particular stack configuration that is not guaranteed in Groovy when calling the Java method. Works exactly like ResourceBundle.getBundle(String, Locale).  This is needed because the java method depends on a particular stack configuration that is not guaranteed in Groovy when calling the Java method. Get the last hidden matcher that the system used to do a match. Parse a String into a Date instance using the given pattern. This convenience method acts as a wrapper for {@link java.text.SimpleDateFormat}. <p> Note that a new SimpleDateFormat instance is created for every invocation of this method (for thread safety). Parse a String into a Date instance using the given pattern and TimeZone. This convenience method acts as a wrapper for {@link java.text.SimpleDateFormat}. <p> Note that a new SimpleDateFormat instance is created for every invocation of this method (for thread safety). Parse a String matching the pattern EEE MMM dd HH:mm:ss zzz yyyy containing US-locale-constants only (e.g. Sat for Saturdays). Such a string is generated by the toString method of {@link java.util.Date} <p> Note that a new SimpleDateFormat instance is created for every invocation of this method (for thread safety). Sleep for so many milliseconds, even if interrupted. Sleep for so many milliseconds, using a given closure for interrupt processing. This method is used by both sleep() methods to implement sleeping for the given time even if interrupted Start a Thread with the given closure as a Runnable instance. Start a Thread with a given name and the given closure as a Runnable instance. Start a daemon Thread with the given closure as a Runnable instance. Start a daemon Thread with a given name and the given closure as a Runnable instance.
-------------------------------------------------------- boxing methods -------------------------------------------------------- -------------------------------------------------------- unboxing methods -------------------------------------------------------- Method used for coercing an object to a boolean value, thanks to an <code>asBoolean()</code> method added on types. Compares the two objects handling nulls gracefully and performing numeric type coercion if required Determines whether the value object is a Class object representing a subclass of java.lang.Enum. Uses class name check to avoid breaking on pre-Java 5 JREs.  Allows conversion of arrays into a mutable List
Decode the String from Base64 into a byte array. Decodes a hex string to a byte array. The hex string can contain either upper case or lower case letters. Produce a Writable object which writes the Base64 encoding of the byte array. Calling toString() on the result returns the encoding as a String. For more information on Base64 encoding and chunking see <code>RFC 4648</code>. Produce a Writable object which writes the Base64 encoding of the byte array. Calling toString() on the result returns the encoding as a String. For more information on Base64 encoding and chunking see <code>RFC 4648</code>. Produce a Writable object which writes the Base64 encoding of the byte array. Calling toString() on the result returns the encoding as a String. For more information on Base64 encoding and chunking see <code>RFC 4648</code>. Produce a Writable object which writes the Base64 encoding of the byte array. Calling toString() on the result returns the encoding as a String. For more information on Base64 encoding and chunking see <code>RFC 4648</code>. Produces a Writable that writes the hex encoding of the byte[]. Calling toString() on this Writable returns the hex encoding as a String. The hex encoding includes two characters for each byte and all letters are lower case. Produces a Writable that writes the hex encoding of the Byte[]. Calling toString() on this Writable returns the hex encoding as a String. The hex encoding includes two characters for each byte and all letters are lower case.

Factory method to create a new Map used to store the expando properties map This allows equals to be overridden by a closure <i>field</i> method attached to the expando object.  This allows hashCode to be overridden by a closure <i>field</i> method attached to the expando object. This allows toString to be overridden by a closure <i>field</i> method attached to the expando object.
Call to disable the global use of ExpandoMetaClass Call to enable global use of global use of ExpandoMetaClass within the registry. This has the advantage that inheritance will function correctly, but has a higher memory usage on the JVM than normal Groovy Returns a list of expando MetaMethod instances added to this ExpandoMetaClass Returns a list of MetaBeanProperty instances added to this ExpandoMetaClass  (non-Javadoc) @see groovy.lang.GroovyObject#getMetaClass() Looks up an existing MetaProperty by name Overrides the behavior of parent getMethods() method to make MetaClass aware of added Expando methods Overrides default implementation just in case getProperty method has been overridden by ExpandoMetaClass Overrides default implementation just in case getProperty method has been overridden by ExpandoMetaClass (non-Javadoc) @see groovy.lang.GroovyObject#getProperty(java.lang.String) Returns a property name equivalent for the given getter name or null if it is not a getter Returns a property name equivalent for the given setter name or null if it is not a getter Checks whether a MetaMethod for the given name and arguments exists Returns true if the MetaClass has the given property (non-Javadoc) @see groovy.lang.MetaClassImpl#initialize() (non-Javadoc) @see groovy.lang.MetaClassImpl#invokeConstructor(java.lang.Object[]) Overrides default implementation just in case invokeMethod has been overridden by ExpandoMetaClass (non-Javadoc) @see groovy.lang.GroovyObject#invokeMethod(java.lang.String, java.lang.Object) Overrides default implementation just in case a static invoke method has been set on ExpandoMetaClass Returns true if the name of the method specified and the number of arguments make it a javabean property Checks if the meta class is initialized. Determine if this method name suffix is a legitimate bean property name. Either the first or second letter must be upperCase for that to be true. Called from ExpandoMetaClassCreationHandle in the registry if it exists to set up inheritance handling Registers a new bean property Registers a new instance method for the given method name and closure on this MetaClass Registers a new static method for the given method name and closure on this MetaClass (non-Javadoc) @see groovy.lang.GroovyObject#setMetaClass(groovy.lang.MetaClass) Overrides default implementation just in case setProperty method has been overridden by ExpandoMetaClass (non-Javadoc) @see groovy.lang.GroovyObject#setProperty(java.lang.String, java.lang.Object)
Return a copy of the expression calling the transformer on any nested expressions Transforms the list of expressions Transforms the list of expressions, and checks that all transformed expressions have the given type.
Same as main(args) except that exceptions are thrown out instead of causing the VM to exit. Same as main(args) except that exceptions are thrown out instead of causing the VM to exit and the lookup for .groovy files can be controlled Primary entry point for compiling from the command line (using the groovyc script). <p> If calling inside a process and you don't want the JVM to exit on an error call commandLineCompile(String[]), which this method simply wraps Creates a temporary directory in the default temporary directory (as specified by the system property <i>java.io.tmpdir</i>. Primary entry point for compiling from the command line (using the groovyc script). <p> If calling inside a process and you don't want the JVM to exit on an error call commandLineCompile(String[]), which this method simply wraps
Adds the annotation to the internal target list if a match is found.
Global flag to ignore checksums. By default it is set to false. This is a static access auto download enabler.  It will set the 'autoDownload' value to the passed in arguments map if not already set. If 'autoDownload' is set the value will not be adjusted. <p> This applies to the grab and resolve calls. <p> If it is set to false, only previously downloaded grapes will be used.  This may cause failure in the grape call if the library has not yet been downloaded <p> If it is set to true, then any jars not already downloaded will automatically be downloaded.  Also, any versions expressed as a range will be checked for new versions and downloaded (with dependencies) if found. <p> By default it is set to true. This is a static access kill-switch.  All of the static shortcut methods in this class will not work if this property is set to false. By default it is set to true. Set global flag to ignore checksums. By default it is set to false. This is a static access auto download enabler.  It will set the 'autoDownload' value to the passed in arguments map if not already set.  If 'autoDownload' is set the value will not be adjusted. <p> This applies to the grab and resolve calls. <p> If it is set to false, only previously downloaded grapes will be used.  This may cause failure in the grape call if the library has not yet been downloaded. <p> If it is set to true, then any jars not already downloaded will automatically be downloaded.  Also, any versions expressed as a range will be checked for new versions and downloaded (with dependencies) if found. By default it is set to true. This is a static access kill-switch.  All of the static shortcut methods in this class will not work if this property is set to false. By default it is set to true.

This method is used to pull all the new methods out of the local thread context with a particular name. Create a scope based on given categoryClass and invoke closure within that scope. Create a scope based on given categoryClasses and invoke closure within that scope.
adds a classpath to this classloader. adds a URL to the classloader. Removes all classes from the class cache. creates a ClassCollector for a new compilation. creates a new CompilationUnit. If you want to add additional phase operations to the CompilationUnit (for example to inject additional methods, variables, fields), then you should overwrite this method. This method will take a file name and try to "decode" any URL encoded characters.  For example if the file name contains any spaces this method call will take the resulting %20 encoded values and convert them to spaces. <p> This method was added specifically to fix defect:  Groovy-1787.  The defect involved a situation where two scripts were sitting in a directory with spaces in its name.  The code would fail when the class loader tried to resolve the file name and would choke on the URLEncoded space values. open up the super class define that takes raw bytes Loads the given class node returning the implementation Class. <p> WARNING: this compilation is not synchronized gets a class from the class cache. This cache contains only classes loaded through this class loader or an InnerLoader instance. If no class is stored for a specific name, then the method should return null. gets the currently used classpath. <p>Returns all Groovy classes loaded by this class loader. gets the time stamp of a given class. For groovy generated classes this usually means to return the value of the static field __timeStamp. If the parameter doesn't have such a field, then Long.MAX_VALUE is returned Indicates if a class is recompilable. Recompilable means, that the classloader will try to locate a groovy source file for this class and then compile it again, adding the resulting class as entry to the cache. Giving null as class is like a recompilation, so the method should always return true here. Only classes that are implementing GroovyObject are compilable and only if the timestamp in the class is lower than Long.MAX_VALUE. <p> NOTE: First the parent loaders will be asked and only if they don't return a class the recompilation will happen. Recompilation also only happen if the source file is newer. gets the currently set recompilation mode. null means, the compiler configuration is used. False means no recompilation and true means that recompilation will be done if needed. Decides if the given source is newer than a class. Implemented here to check package access prior to returning an already loaded class. loads a class from a file or a parent classloader. This method does call loadClass(String, boolean, boolean, boolean) with the last parameter set to false. loads a class from a file or a parent classloader. Parses the given code source into a Java class. If there is a class file for the given code source, then no parsing is done, instead the cached class is returned. Parses the given file into a Java class capable of being run  Parses the given text into a Java class capable of being run Parses the given text into a Java class capable of being run (Re)Compiles the given source. This method starts the compilation of a given source, if the source has changed since the class was created. For this isSourceNewer is called. removes a class from the class cache. sets an entry in the class cache. sets if the recompilation should be enable. There are 3 possible values for this. Any value different than null overrides the value from the compiler configuration. true means to recompile if needed false means to never recompile.
Finds all combinations of items from the given Iterable aggregate of collections. So, <code>combinations([[true, false], [true, false]])</code> is <code>[[true, true], [false, true], [true, false], [false, false]]</code> and <code>combinations([['a', 'b'],[1, 2, 3]])</code> is <code>[['a', 1], ['b', 1], ['a', 2], ['b', 2], ['a', 3], ['b', 3]]</code>. If a non-collection item is given, it is treated as a singleton collection, i.e. <code>combinations([[1, 2], 'x'])</code> is <code>[[1, 'x'], [2, 'x']]</code>. Finds all combinations of items from the given collections.  Selects the maximum value found in an Iterable. Selects the maximum value found in an array of items, so min([2, 4, 6] as Object[]) == 6.  Selects the minimum value found in an Iterable of items. Selects the minimum value found in an array of items, so min([2, 4, 6] as Object[]) == 2.  Finds all non-null subsequences of a list. E.g. <code>subsequences([1, 2, 3])</code> would be: [[1, 2, 3], [1, 3], [2, 3], [1, 2], [1], [2], [3]] Sums all the given items. Sums all the items from an array of items.  Transposes an array of lists. Transposes the given lists. So, <code>transpose([['a', 'b'], [1, 2]])</code> is <code>[['a', 1], ['b', 2]]</code> and <code>transpose([['a', 'b', 'c']])</code> is <code>[['a'], ['b'], ['c']]</code>.
Build the options parser.  Has to be synchronized because of the way Options are constructed. Get a new GroovyCodeSource for a script which may be given as a location (isScript is true) or as text (isScript is false). Get the text of the Groovy script at the given location. If the location is a file path and it does not exist as given, then {@link GroovyMain#huntForTheScriptFile(String)} is called to try with some Groovy extensions appended. This method is not used to process scripts and is retained for backward compatibility.  If you want to modify how GroovyMain processes scripts then use {@link GroovyMain#getScriptSource(boolean, String)}. Hunt for the script file by calling searchForGroovyScriptFile(String). Main CLI interface. Parse the command line. Process the users request. package-level visibility for testing purposes (just usage/errors at this stage) TODO: should we have an 'err' printstream too for ParseException? Process a single input file. Process the input files. Process the standard, single script with args. Process a script against a single input file. Process Sockets. Run the script. Search for the script file, doesn't bother if it is named precisely. Tries in this order: - actual supplied name - name.groovy - name.gvy - name.gy - name.gsh GROOVY-6771

Runs this server. There is typically no need to call this method, as the object's constructor creates a new thread and runs this object automatically.
If {@code true}, this adds a method {@code copyWith} which takes a Map of new property values and returns a new instance of the Immutable class with these values set. Example: <pre> {@code @groovy.transform.Immutable}(copyWith = true) class Person { String first, last } def tim   = new Person( 'tim', 'yates' ) def alice = tim.copyWith( first:'alice' ) assert tim.first   == 'tim' assert alice.first == 'alice' </pre> Unknown keys in the map are ignored, and if the values would not change the object, then the original object is returned. If a method called {@code copyWith} that takes a single parameter already exists in the class, then this setting is ignored, and no method is generated. Allows you to provide {@code @Immutable} with a list of classes which are deemed immutable. By supplying a class in this list, you are vouching for its immutability and {@code @Immutable} will do no further checks. Example: <pre> import groovy.transform.* {@code @Immutable}(knownImmutableClasses = [Address]) class Person { String first, last Address address } {@code @TupleConstructor} class Address { final String street } </pre> Allows you to provide {@code @Immutable} with a list of property names which are deemed immutable. By supplying a property's name in this list, you are vouching for its immutability and {@code @Immutable} will do no further checks. Example: <pre> {@code @groovy.transform.Immutable}(knownImmutables = ['address']) class Person { String first, last Address address } ... </pre>
This method exists to be binary compatible with 1.7 - 1.8.6 compiled code.

Appends an object to an Appendable using Groovy's default representation for the object. Converts the given object into an array; if its an array then just cast otherwise wrap it in an array Find the right hand regex within the left hand string and return a matcher. Returns the method pointer for the given object name Invokes the given method on the object. Find the right hand regex within the left hand string and return a matcher. This is so we don't have to reorder the stack when we call this method. At some point a better name might be in order. Sets the properties on the given object This is so we don't have to reorder the stack when we call this method. At some point a better name might be in order. This is so we don't have to reorder the stack when we call this method. At some point a better name might be in order. A helper method to return the string representation of an array of objects with brace boundaries "[" and "]". A helper method to return the string representation of an array of objects with brace boundaries "[" and "]". A helper method to return the string representation of a list with bracket boundaries "[" and "]". A helper method to return the string representation of a list with bracket boundaries "[" and "]". A helper method to return the string representation of a list with bracket boundaries "[" and "]". A helper method to return the string representation of a map with bracket boundaries "[" and "]". A helper method to return the string representation of a map with bracket boundaries "[" and "]". A helper method to format the arguments types as a comma-separated list. Writes an object to a Writer using Groovy's default representation for the object.
Performs a shallow clone Makes sure the retrieved object is moved to the head of the LRU list The eldest entry should be removed when we reached the maximum cache size The touch method can be used to renew an element and move it to the from of the LRU queue.
Closes the stream and releases any system resources associated with it. Once the stream has been closed, further read(), ready(), mark(), reset(), or skip() invocations will throw an IOException. Closing a previously closed stream has no effect. Marks the present position in the stream. Subsequent calls to reset() will attempt to reposition the stream to this point. Reads a single character. Reads characters into an array. This method will block until some input is available, an I/O error occurs, or the end of the stream is reached. Reads characters into a portion of an array. Not implemented. Reads a line of text. A line is considered to be terminated by any one of a line feed ('\n'), a carriage return ('\r'), or a carriage return followed immediately by a linefeed. Resets the stream to the most recent mark. Skips characters.


Creates a new closure delegating to the supplied one and memoizing all return values by the arguments. The supplied cache is used to store the memoized values and it is the cache's responsibility to put limits on the cache size or implement cache eviction strategy. The LRUCache, for example, allows to set the maximum cache size constraint and implements the LRU (Last Recently Used) eviction strategy. Creates a new closure delegating to the supplied one and memoizing all return values by the arguments. The memoizing closure will use SoftReferences to remember the return values allowing the garbage collector to reclaim the memory, if needed. The supplied cache is used to store the memoized values and it is the cache's responsibility to put limits on the cache size or implement cache eviction strategy. The LRUCache, for example, allows to set the maximum cache size constraint and implements the LRU (Last Recently Used) eviction strategy. If the protectedCacheSize argument is greater than 0 an optional LRU (Last Recently Used) cache of hard references is maintained to protect recently touched memoized values against eviction by the garbage collector. Creates a key to use in the memoize cache

Retrieves the value of an attribute (field). This method is to support the Groovy runtime and not for general client API usage. Obtains a reference to the original AST for the MetaClass if it is available at runtime Retrieves a list of MetaMethods held by this class Retrieves a list of Methods held by the class Retrieves a list of MetaProperty instances that the MetaClass has <p>Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object. The MetaClass will attempt to establish the method to invoke based on the name and arguments provided. <p>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly to the super class if necessary Complete the initialisation process. After this method is called no methods should be added to the meta class. Invocation of methods or access to fields/properties is forbidden unless this method is called. This method should contain any initialisation code, taking a longer time to complete. An example is the creation of the Reflector. It is suggested to synchronize this method. <p>Invokes a method on the given receiver for the specified arguments. The sender is the class that invoked the method on the object. The MetaClass will attempt to establish the method to invoke based on the name and arguments provided. <p>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly to the super class if necessary <p>Attempts to invoke the methodMissing method otherwise throws a MissingMethodException Invokes the propertyMissing method otherwise throws a MissingPropertyException Selects a method by name and argument classes. This method does not search for an exact match, it searches for a compatible method. For this the method selection mechanism is used as provided by the implementation of this MetaClass. pickMethod may or may not be used during the method selection process when invoking a method. There is no warranty for that. Internal method to support Groovy runtime. Not for client usage. Sets the value of an attribute (field). This method is to support the Groovy runtime and not for general client API usage. <p>Sets a property on the given receiver for the specified arguments. The sender is the class that is setting the property from the object. The MetaClass will attempt to establish the method to invoke based on the name and arguments provided. <p>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly to the super class if necessary
Adds a new MetaBeanProperty to this MetaClass Implementation methods ------------------------------------------------------------------------- adds a MetaMethod to this class. WARNING: this method will not do the neccessary steps for multimethod logic and using this method doesn't mean, that a method added here is replacing another method from a parent class completely. These steps are usually done by initialize, which means if you need these steps, you have to add the method before running initialize the first time. Adds an instance method to this metaclass. Adds a static method to this metaclass. Checks if the metaMethod is a method from the GroovyObject interface such as setProperty, getProperty and invokeMethod checks if the initialisation of the class id complete. This method should be called as a form of assert, it is no way to test if there is still initialisation work to be done. Such logic must be implemented in a different way. Chooses the correct method to use from a list of methods which match by name. remove all method call cache entries. This should be done if a method is added during runtime, but not by using a category. Create a CallSite Create a CallSite Create a CallSite Create a CallSite Create a CallSite Fills the method index return null if nothing valid has been found, a MetaMethod (for getter always the case if not null) or a LinkedList<MetaMethod> if there are multiple setter  Retrieves a list of additional MetaMethods held by this class Retrieves the value of an attribute (field). This method is to support the Groovy runtime and not for general client API usage. Retrieves the value of an attribute (field). This method is to support the Groovy runtime and not for general client API usage. Retrieves the value of an attribute (field). This method is to support the Groovy runtime and not for general client API usage. Returns ClasInfo for the contained Class Obtains a reference to the original AST for the MetaClass if it is available at runtime return false: add method null:  ignore method true:  replace  Retrieves the list of MetaMethods held by this class  This method should be called by CallSite only Retrieves the list of Methods held by the class Gets all instance methods available on this class for the given name Get all the properties defined for this type  <p>Retrieves a property on the given object for the specified arguments. Returns the registry for this metaclass  Returns all the normal static methods on this class for the given name Returns the cached class for this metaclass Returns the class this object this is the metaclass of. Returns version of the contained Class indicates is the meta class method invocation for non-static methods is done through a custom invoker object. indicates is the meta class method invocation for static methods is done through a custom invoker object.  Increments version of the contained Class Complete the initialisation process. After this method is called no methods should be added to the meta class. Invocation of methods or access to fields/properties is forbidden unless this method is called. This method should contain any initialisation code, taking a longer time to complete. An example is the creation of the Reflector. It is suggested to synchronize this method. <p>Invokes a method on the given receiver for the specified arguments. The sender is the class that invoked the method on the object. The MetaClass will attempt to establish the method to invoke based on the name and arguments provided. <p>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly to the super class if necessary Invoke a method on the given object with the given arguments. Invokes a method on the given receiver for the specified arguments. The MetaClass will attempt to establish the method to invoke based on the name and arguments provided. Invoke a missing method on the given object with the given arguments. Invoke a missing property on the given object with the given arguments. Hook to deal with the case of MissingProperty for static properties. The method will look attempt to look up "propertyMissing" handlers and invoke them otherwise thrown a MissingPropertyException Return wether the class represented by this metaclass instance is an instance of the GroovyObject class Returns wether this metaclassimpl has been modified. Since MetaClassImpl is not designed for modificaiton this method always returns false Selects a method by name and argument classes. This method does not search for an exact match, it searches for a compatible method. For this the method selection mechanism is used as provided by the implementation of this MetaClass. pickMethod may or may not be used during the method selection process when invoking a method. There is no warranty for that.   This is a helper method added in Groovy 2.1.0, which is used only by indy. This method is for internal use only. Constructor selection algorithm for Groovy 2.1.9+. This selection algorithm was introduced as a workaround for GROOVY-6080. Instead of generating an index between 0 and N where N is the number of super constructors at the time the class is compiled, this algorithm uses a hash of the constructor descriptor instead. This has the advantage of letting the super class add new constructors while being binary compatible. But there are still problems with this approach: <ul> <li>There's a risk of hash collision, even if it's very low (two constructors of the same class must have the same hash)</li> <li>If the super class adds a new constructor which takes as an argument a superclass of an existing constructor parameter and that this new constructor is selected at runtime, it would not find it.</li> </ul> Hopefully in the last case, the error message is much nicer now since it explains that it's a binary incompatible change. <p>Sets an attribute on the given receiver for the specified arguments. The sender is the class that is setting the attribute from the object. The MetaClass will attempt to establish the method to invoke based on the name and arguments provided. <p>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly to the super class if necessary Sets the value of an attribute (field). This method is to support the Groovy runtime and not for general client API usage. Sets a number of bean properties from the given Map where the keys are the String names of properties and the values are the values of the properties to set <p>Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object. The MetaClass will attempt to establish the method to invoke based on the name and arguments provided. <p>The useSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly to the super class if necessary <p>Sets a property on the given object for the specified arguments. This will build up the property map (Map of MetaProperty objects, keyed on property name). Returns a string representation of this metaclass
Adds a meta class change listener for constant meta classes Adds a meta class change listener for constant meta classes. This listener cannot be removed! The main function of the registry If a meta class exists then return it otherwise create one, put it in the registry and return it Retrieves the MetaClassCreationHandle that is responsible for constructing MetaClass instances Returns all registered class change listener for constant meta classes. Gets a snapshot of the current constant meta classes and returns it as Iterator. Modifications done using this Iterator will not cause a ConcurrentModificationException. If a MetaClass is removed using this Iterator, then the MetaClass will only be removed if the MetaClass was not replaced by another MetaClass in the meantime. If a MetaClass is added while using this Iterator, then it will be part of the Iteration. If a MetaClass replaces another constant meta class, then the Iteration might show two meta classes for the same class. <p> Note: This Iterator may not used with multiple threads. Removes a cached MetaClass from the registry Removes a meta class change listener for constant meta classes Adds a metaclass to the registery for the given class Sets the MetaClassCreationHandle instance that is responsible for constructing instances
Adds a listener for constant meta classes. Adds a listener for constant meta classes. This listener cannot be removed! Causes the execution of all registered listeners. This method is used mostly internal to kick of the listener notification. It can also be used by subclasses to achieve the same. Singleton of MetaClassRegistry. Gets a handle internally used to create MetaClass implementations WARNING: experimental code, likely to change soon Gets an array of of all registered ConstantMetaClassListener instances. Looks for a class called 'groovy.runtime.metaclass.CustomMetaClassCreationHandle' and if it exists uses it as the MetaClassCreationHandle otherwise uses the default Returns an iterator to iterate over all constant meta classes. This iterator can be seen as making a snapshot of the current state of the registry. The snapshot will include all meta classes that has been used unless they are already collected. Collected meta classes will be skipped automatically, so you can expect that each element of the iteration is not null. Calling this method is thread safe, the usage of the iterator is not. Removes a constant meta class listener. Registers a new MetaClass in the registry to customize the type if oldMc is null, newMc will replace whatever meta class was used before. if oldMc is not null, then newMc will be used only if he stored mc is the same as oldMc Sets a handle internally used to create MetaClass implementations. When replacing the handle with a custom version, you should reuse the old handle to keep custom logic and to use the default logic as fall back. WARNING: experimental code, likely to change soon
If c is a primitive class this method returns a boxed version otherwise c is returned. In java 1.5 this can be simplified thanks to the Type class. Compares two characters whilst ignoring case. This is a implementation of DL distance between two Object arrays instead of character streams. The objects are compared using their equals method. No objects may be null. This implementation is based on Chas Emerick's implementation of Levenshtein Distance for jakarta commons. This is a slightly modified version of the Damerau Levenshtein distance algorithm. It has a additional test to see if a character has switched case, in the original algorithm this counts as a substitution. The "cost" for a substitution is given as 10 instead of 1 in this version, this enables transpositions and case modifications to have a lower cost than substitutions. Currently the lowercase versions of t_j and s_i isn't cached, its probable that some speed could be gained from this. This version is based on Chas Emerick's implementation of Levenshtein Distance for jakarta commons. Returns a string detailing possible solutions to a missing constructor if no good solutions can be found a empty string is returned. Returns a string detailing possible solutions to a missing method if no good solutions can be found a empty string is returned. Returns a string detailing possible solutions to a missing field or property if no good solutions can be found a empty string is returned. creates a comma separated list of each of the class names. Returns a sorted(ranked) list of a selection of the constructors among candidates which most closely resembles original. Returns a sorted(ranked) list of a selection of the methods among candidates which most closely resembles original.




allow non-strict mode in scripts because parsing not complete at that point
Appends a child to the current node. Creates a new node as a child of the current node. Creates a new node as a child of the current node. Creates a new node as a child of the current node. Creates a new node as a child of the current node. Provides lookup of attributes by key. Returns a <code>Map</code> of the attributes of the node or an empty <code>Map</code> if the node does not have any attributes. Provides a collection of all the nodes in the tree using a breadth-first traversal. Returns a <code>List</code> of the nodes children. Creates a new Node with the same name, no parent, shallow cloned attributes and if the value is a NodeList, a (deep) clone of those nodes. Provides a collection of all the nodes in the tree using a depth first traversal. Provides lookup of elements by non-namespaced name Provides lookup of elements by QName. Provides lookup of elements by name. Returns an <code>Iterator</code> of the children of the node. Returns the list of any direct String nodes of this node. Returns an <code>Object</code> representing the name of the node. Returns the parent of the node. Adds sibling nodes (defined using builder-style notation via a Closure) after the current node. Writes the node to the specified <code>PrintWriter</code>. Removes a child of the current node. Replaces the current node with nodes defined using builder-style notation via a Closure. Replaces the current node with the supplied node. Extension point for subclasses to override the metaclass. The default one supports the property and @ attribute notations. Adds or replaces the parent of the node. Adds or replaces the value of the node. Returns the textual representation of the current node and all its child nodes. Returns an <code>Object</code> representing the value of the node.
Creates a new NodeList containing the same elements as the original (but cloned in the case of Nodes). Provides lookup of elements by QName. Provides lookup of elements by non-namespaced name. Returns the text value of all of the elements in the collection.
Does nothing
--------------------------------------------------------------------------- LEXING SUPPORT Returns true if the specified character is a base-10 digit. Returns true if the specified character is a base-16 digit. Returns true if the specified character is a valid type specifier for a numeric value. Returns true if the specific character is a base-8 digit. Builds a Number from the given decimal descriptor.  Uses BigDecimal, unless, Double or Float is requested. Builds a Number from the given integer descriptor.  Creates the narrowest type possible, or a specific type, if specified.
observable interface
observable interface Map interface
observable interface


Overloads the left shift operator to provide an easy way to append multiple objects as string representations to a StringBuilder. This method is called by the ++ operator for enums. It will invoke Groovy's default next behaviour for enums do not have their own next method. Appends a String to this StringBuilder. This method is called by the -- operator for enums. It will invoke Groovy's default previous behaviour for enums that do not have their own previous method. Support the range subscript operator for StringBuilder. Support the range subscript operator for StringBuilder. Index values are treated as characters within the builder. Standard Groovy size() method for StringBuilders.
--------------------------------------------------------------------------- PROCESSING Marks the current phase complete and processes any errors. Reconfigures the ProcessingUnit. Returns the class loader in use by this ProcessingUnit. Errors found during the compilation should be reported through the ErrorCollector. Returns the current phase. Returns the description for the current phase. Wraps up any pending operations for the current phase and switches to the next phase. A synonym for <code>gotoPhase( phase + 1 )</code>. Sets the class loader for use by this ProcessingUnit.
Intercepts a getXXX call and returns a result. The result is replaced by the real value if doGet() return false Intercepts a setXXX call
Creates a proxy with a delegate object. Instructs <code>ProxyGenerator</code> to dump generated Groovy source code to standard output during construction. This is useful for debugging purposes but should be turned off in production. Changes generated methods to have empty implementations. <p> Methods in generated aggregates not supplied in a closures map or base class are given 'default' implementations. The implementation will normally throw an <code>UnsupportedOperationException</code> but setting this boolean will leave it empty.
convenience factory method for the most usual case.  Interceptors the call to getProperty if a PropertyAccessInterceptor is available Call invokeConstructor on adaptee with logic like in MetaClass unless we have an Interceptor. With Interceptor the call is nested in its beforeInvoke and afterInvoke methods. The method call is suppressed if Interceptor.doInvoke() returns false. See Interceptor for details. Call invokeMethod on adaptee with logic like in MetaClass unless we have an Interceptor. With Interceptor the call is nested in its beforeInvoke and afterInvoke methods. The method call is suppressed if Interceptor.doInvoke() returns false. See Interceptor for details. Call invokeMethod on adaptee with logic like in MetaClass unless we have an Interceptor. With Interceptor the call is nested in its beforeInvoke and afterInvoke methods. The method call is suppressed if Interceptor.doInvoke() returns false. See Interceptor for details. Call invokeStaticMethod on adaptee with logic like in MetaClass unless we have an Interceptor. With Interceptor the call is nested in its beforeInvoke and afterInvoke methods. The method call is suppressed if Interceptor.doInvoke() returns false. See Interceptor for details.  Interceptors the call to a property setter if a PropertyAccessInterceptor is available Use the ProxyMetaClass for the given Closure. Cares for balanced register/unregister. Use the ProxyMetaClass for the given Closure. Cares for balanced setting/unsetting ProxyMetaClass.
Tests this QName for equality with another object. <p> If the given object is not a QName or String equivalent or is null then this method returns <tt>false</tt>. <p> For two QNames to be considered equal requires that both localPart and namespaceURI must be equal. This method uses <code>String.equals</code> to check equality of localPart and namespaceURI. Any class that extends QName is required to satisfy this equality contract. If the supplied object is a String, then it is split in two on the last colon and the first half is compared against the prefix || namespaceURI and the second half is compared against the localPart i.e.&#160;assert new QName("namespace","localPart").equals("namespace:localPart") Intended Usage: for gpath accessors, e.g.&#160;root.'urn:mynamespace:node' Warning: this equivalence is not commutative, i.e.&#160;qname.equals(string) may be true/false  but string.equals(qname) is always false <p> This method satisfies the general contract of the <code>Object.equals</code> method. Gets the Local part for this QName Gets the Namespace URI for this QName Gets the Prefix for this QName Returns the fully qualified name of this QName Returns a hash code value for this QName object. The hash code is based on both the localPart and namespaceURI parts of the QName. This method satisfies the  general contract of the <code>Object.hashCode</code> method. Tests if this QName matches another object. <p> If the given object is not a QName or String equivalent or is null then this method returns <tt>false</tt>. <p> For two QNames to be considered matching requires that both localPart and namespaceURI must be equal or one of them is a wildcard. If the supplied object is a String, then it is split in two on the last colon and the first half is matched against the prefix || namespaceURI and the second half is matched against the localPart Returns a string representation of this QName Returns a QName holding the value of the specified String. <p> The string must be in the form returned by the QName.toString() method, i.e. "{namespaceURI}localPart", with the "{namespaceURI}" part being optional. <p> This method doesn't do a full validation of the resulting QName. In particular, it doesn't check that the resulting namespace URI is a legal URI (per RFC 2396 and RFC 2732), nor that the resulting local part is a legal NCName per the XML Namespaces specification.


{@inheritDoc } {@inheritDoc } {@inheritDoc }

visitAt() ... token type 'AT' should never be visited, as annotation definitions and usage, and direct field access should have all moved this token out of the way. No test needed. one of the BAND tokens is actually replaced by TYPE_UPPER_BOUNDS (e.g. class Foo<T extends C & I> {T t} ) visitBigSuffix() ... token type BIG_SUFFIX never created/visited, NUM_BIG_INT, NUM_BIG_DECIMAL instead... visitBlock() ... token type BLOCK never created/visited, see CLOSABLE_BLOCK etc... Note: old closure syntax using BOR is deprecated, and also never creates/visits a BOR node visitClosureOp ... token type CLOSABLE_BLOCK_OP never created/visited, see CLOSABLE_BLOCK... visitColon ... token type COLON never created/visited, see LABELED_STAT, FOR_IN_ITERABLE, ASSERT, CASE, QUESTION, MAP_CONSTRUCTOR, LABELED_ARG, SPREAD_MAP_ARG visitComma ... token type COMMA never created/visited, see TYPE_ARGUMENTS, ANNOTATION, many others ... visit WS - only used by lexer visitDigit ... never created/visited visitDollar ... token type DOLLAR never created/visited, see SCOPE_ESCAPE instead visitEmptyStat ... token type EMPTY_STAT obsolete and should be removed, never visited/created visitEof ... token type EOF never visited/created visitExponent ... token type EXPONENT only used by lexer, never visited/created visitFloatSuffix ... never visited/created see NUM_DOUBLE or NUM_FLOAT instead visitForEachClause ... FOR_EACH_CLAUSE obsolete and should be removed, never visited/created visit lbrack() token type LBRACK only used inside parser, never visited/created visit lcurly() token type LCURLY only used inside parser, never visited/created visitLetter ... token type LETTER only used by lexer, never visited/created visitLiteralClass ... token type "class" only used by parser, never visited/created directly visitLiteralDef ... token type "def" only used by parser, never visited/created directly visitLiteralElse ... token type "else" only used by parser, never visited/created directly visitLiteralEnum ... token type "enum" only used by parser, never visited/created directly visitLiteralExtends token type "extends" only used by parser, never visited/created directly visitLiteralImplements token type "implements" only used by parser, never visited/created directly visitLiteralImport token type "import" only used by parser, never visited/created directly visitLiteralInterface token type "interface" only used by parser, never visited/created directly visitLiteralPackage token type "package" only used by parser, never visited/created directly deprecated public void visitLiteralWith(GroovySourceAST t,int visit) { printUpdatingTabLevel(t,visit,"with (",null,") "); } Note: old closure syntax using LOR is deprecated, and also never creates/visits a LOR node visitMlComment multi-line comments are not created on the AST currently. visitNls new lines are used by parser, but are not created on the AST, they can be implied by the source code line/column information visitNullTreeLookahead not used explicitly by parser. visitOneNl new lines are used by parser, but are not created on the AST, they can be implied by the source code line/column information visit rbrack() token type RBRACK only used inside parser, never visited/created visit rcurly() token type RCURLY only used inside parser, never visited/created visit RegexpCtorEnd visit RegexpLiteral visit RegexpSymbol token types REGEXP_CTOR_END, REGEXP_LITERAL, REGEXP_SYMBOL only used inside lexer visit rparen() token type RPAREN only used inside parser, never visited/created visit semi() SEMI only used inside parser, never visited/created (see visitForCondition(), visitForIterator()) visit ShComment() never visited/created by parser visit SlComment() never visited/created by parser visitStringch String characters only used by lexer, never visited/created directly visit TripleDot, not used in the AST visit Unused "const", "do", "goto" - unsurprisingly these are unused by the AST. a.k.a. "variable arity parameter" in the JLS visit Vocab - only used by Lexer

This method is used to add "bridge" methods for private methods of an inner/outer class, so that the outer class is capable of calling them. It does basically the same job as access$000 like methods in Java. Adds special accessors for private constants so that inner classes can retrieve them. If we are in a constructor, that is static compiled, but in a class, that is not, it may happen that init code from object initializers, fields or properties is added into the constructor code. The backend assumes a purely static contructor, so it may fail if it encounters dynamic code here. Thus we make this kind of code fail
Attempts to make a direct method call on a bridge method, if it exists.
Checks that arguments and parameter types match. Checks that arguments and parameter types match, expecting that the number of parameters is strictly greater than the number of arguments, allowing possible inclusion of default parameters. Given a parameter, builds a new parameter for which the known generics placeholders are resolved. Returns true or false depending on whether the right classnode can be assigned to the left classnode. This method should not add errors by itself: we let the caller decide what to do if an incompatible assignment is found. Given a list of candidate methods, returns the one which best matches the argument types Collects all interfaces of a class node, including those defined by the super class. Collects all interfaces of a class node, including those defined by the super class. A helper method that can be used to evaluate expressions as found in annotation parameters. For example, it will evaluate a constant, be it referenced directly as an integer or as a reference to a field. If this method throws an exception, then the expression cannot be evaluated on its own. Checks that excess arguments match the vararg signature parameter. use supplied type to make a connection from usage to declaration The method operates in two modes. * For type !instanceof target a structural compare will be done (for example Dummy<T> and List<R> to get T=R) * If type equals target, a structural match is done as well (for example Colection<U> and Collection<E> to get U=E) * otherwise we climb the hierarchy to find a case of type equals target to then execute the structural match, while applying possibly existing generics contexts on the way (for example for IntRange and Collection<E> to get E=Integer, since IntRange is an AbstractList<Integer>) Should the target not have any generics this method does nothing.     Given a variable expression, returns the ultimately accessed variable. Given a generics type representing SomeClass&lt;T,V&gt; and a resolved placeholder map, returns a new generics type for which placeholders are resolved recursively. Returns true for expressions of the form x[...] Checks if a class node is assignable to another. This is used for example in assignment checks where you want to verify that the assignment is valid. Returns true if the class node represents a the class node for the Class class and if the parametrized type is a neither a placeholder or a wildcard. For example, the class node Class&lt;Foo&gt; where Foo is a class would return true, but the class node for Class&lt;?&gt; would return false.  Returns true for operations that are of the class, that given a common type class for left and right, the operation "left op right" will have a result in the same type class In Groovy on numbers that is +,-,* as well as their variants with equals.   Returns true if a class node makes use of generic types. If the class node represents an array type, then checks if the component type is using generics. Returns true if the provided class node, when considered as a receiver of a message or as a parameter, is using a placeholder in its generics type. In this case, we're facing unchecked generics and type checking is limited (ex: void foo(Set s) { s.keySet() } Tells if a class is one of the "accept all" classes as the left hand side of an assignment. Called on method call checks in order to determine if a method call corresponds to the idiomatic o.with { ... } structure Checks if the last argument matches the vararg type. Given a receiver and a method node, parameterize the method arguments using available generic type information. Checks that the parameterized generics of an argument are compatible with the generics of the parameter.
add various getAt and setAt methods for primitive arrays A special method handling the "withTrait" call for which the type checker knows more than what the type signature is able to tell. If "withTrait" is detected, then a new class node is created representing the list of trait interfaces. This method is used to filter search results in which null means "no match", to filter out illegal access to instance members from a static context. Return null if the given member is not static, but we want to access in a static way (staticOnly=true). If we want to access in a non-static way we always return the member, since then access to static members and non-static members is allowed.  Checks that a constructor style expression is valid regarding the number of arguments and the argument types. Checks that a constructor style expression is valid regarding the number of arguments and the argument types. Given a field node, checks if we are calling a private field from an inner class. Given a method node, checks if we are calling a private method from an inner class. This method will convert a closure type to the appropriate SAM type, which will be used to infer return type generics. Given a GenericsType instance, returns a ClassNode which can be used as an inferred type. Given a binary expression corresponding to an assignment, will check that the type of the RHS matches one of the possible setters and if not, throw a type checking error. Checks whether a property exists on the receiver, or on any of the possible receiver classes (found in the temporary type information table) Given a method name and a prefix, returns the name of the property that should be looked up, following the java beans rules. For example, "getName" would return "name", while "getFullName" would return "fullName". If the prefix is not found, returns null. When instanceof checks are found in the code, we store temporary type information data in the {@link TypeCheckingContext#temporaryIfBranchTypeInformation} table. This method computes the key which must be used to store this type info. A helper method which determines which receiver class should be used in error messages when a field or attribute is not found. The returned type class depends on whether we have temporary type information availble (due to instanceof checks) and whether there is a single candidate in that case. This method returns the list of methods named against the supplied parameter that are defined on the specified receiver, but it will also add "non existing" methods that will be generated afterwards by the compiler, for example if a method is using default values and that the specified class node isn't compiled yet. resolves a Field or Property node generics by using the current class and the declaring class to extract the right meaning of the generics symbols Returns the inferred return type of a closure or a method, if stored on the AST node. This method doesn't perform any type inference by itself. In the case of a <em>Object.with { ... }</em> call, this method is supposed to retrieve the inferred closure return type. @Override Returns the list of type checking annotations class nodes. Subclasses may override this method in order to provide additional classes which must be looked up when checking if a method or a class node should be skipped. <p> The default implementation returns {@link TypeChecked}. Returns the current type checking context. The context is used internally by the type checker during type checking to store various state data. This method is responsible for performing type inference on closure argument types whenever code like this is found: <code>foo.collect { it.toUpperCase() }</code>. In this case, the type checker tries to find if the <code>collect</code> method has its {@link Closure} argument annotated with {@link groovy.transform.stc.ClosureParams}. If yes, then additional type inference can be performed and the type of <code>it</code> may be inferred. Given a loop collection type, returns the inferred type of the loop element. Used, for example, to infer the element type of a (for e in list) loop. If a method call returns a parameterized type, then we can perform additional inference on the return type, so that the type gets actual type parameters. For example, the method Arrays.asList(T...) is generified with type T which can be deduced from actual type arguments. If a method call returns a parameterized type, then we can perform additional inference on the return type, so that the type gets actual type parameters. For example, the method Arrays.asList(T...) is generified with type T which can be deduced from actual type arguments. Test if a node is an inner class node, and if it is, then checks if the enclosing method is skipped. Given an object expression (a receiver expression), generate the list of potential receiver types. wrap type in Class<> if usingClass==true Stores information about types when [objectOfInstanceof instanceof typeExpression] is visited visit a method call target, to infer the type. Don't report errors right away, that will be done by a later visitMethod call Stores the inferred return type of a closure or a method. We are using a separate key to store inferred return type because the inferred type of a closure is {@link Closure}, which is different from the inferred type of the code of the closure. Returns a wrapped type if, and only if, the provided class node is a primitive type. This method differs from {@link ClassHelper#getWrapper(org.codehaus.groovy.ast.ClassNode)} as it will return the same instance if the provided type is not a generic type.



Coerce a string (an instance of CharSequence) to a boolean value. A string is coerced to false if it is of length 0, and to true otherwise. Coerce a Matcher instance to a boolean value. Converts the GString to a File, or delegates to the default {@link org.codehaus.groovy.runtime.DefaultGroovyMethods#asType(Object, Class)} <p>Provides a method to perform custom 'dynamic' type conversion to the given class using the <code>as</code> operator. Provides a method to perform custom 'dynamic' type conversion to the given class using the <code>as</code> operator. <strong>Example:</strong> <code>'123' as Double</code> <p> By default, the following types are supported: <ul> <li>List</li> <li>BigDecimal</li> <li>BigInteger</li> <li>Long</li> <li>Integer</li> <li>Short</li> <li>Byte</li> <li>Character</li> <li>Double</li> <li>Float</li> <li>File</li> <li>Subclasses of Enum (Java 5 and above)</li> </ul> If any other type is given, the call is delegated to {@link org.codehaus.groovy.runtime.DefaultGroovyMethods#asType(Object, Class)}. Turns a CharSequence into a regular expression Pattern  Convenience method to capitalize the first letter of a CharSequence (typically the first letter of a word). Example usage: <pre class="groovyTestCase"> assert 'h'.capitalize() == 'H' assert 'hello'.capitalize() == 'Hello' assert 'hello world'.capitalize() == 'Hello world' assert 'Hello World' == 'hello world'.split(' ').collect{ it.capitalize() }.join(' ') </pre>  Pad a CharSequence to a minimum length specified by <tt>numberOfChars</tt> by adding the space character around it as many times as needed so that it remains centered. If the String is already the same size or bigger than the target <tt>numberOfChars</tt>, then the original String is returned. An example: <pre> ['A', 'BB', 'CCC', 'DDDD'].each{ println '|' + it.center(6) + '|' } </pre> will produce output like: <pre> |  A   | |  BB  | | CCC  | | DDDD | </pre> Pad a CharSequence to a minimum length specified by <tt>numberOfChars</tt>, appending the supplied padding CharSequence around the original as many times as needed keeping it centered. If the String is already the same size or bigger than the target <tt>numberOfChars</tt>, then the original String is returned. An example: <pre> ['A', 'BB', 'CCC', 'DDDD'].each{ println '|' + it.center(6, '+') + '|' } </pre> will produce output like: <pre> |++A+++| |++BB++| |+CCC++| |+DDDD+| </pre>   Iterate through this String a character at a time collecting either the original character or a transformed replacement String. The {@code transform} Closure should return {@code null} to indicate that no transformation is required for the given character. <p> <pre class="groovyTestCase"> assert "Groovy".collectReplacements{ it == 'o' ? '_O_' : null } == 'Gr_O__O_vy' assert "B&W".collectReplacements{ it == '&' ? '&amp;' : null } == 'B&amp;W' </pre> Provide an implementation of contains() like {@link java.util.Collection#contains(Object)} to make CharSequences more polymorphic.  Count the number of occurrences of a sub CharSequence.  Return a CharSequence with lines (separated by LF, CR/LF, or CR) terminated by the platform specific line separator.  A GString variant of the equivalent CharSequence method. Drops the given number of chars from the head of this CharSequence if they are available. <pre class="groovyTestCase"> def text = "Groovy" assert text.drop( 0 ) == 'Groovy' assert text.drop( 2 ) == 'oovy' assert text.drop( 7 ) == '' </pre> A GString variant of the equivalent CharSequence method. Create a suffix of the given CharSequence by dropping as many characters as possible from the front of the original CharSequence such that calling the given closure condition evaluates to true when passed each of the dropped characters. <p> <pre class="groovyTestCase"> def text = "Groovy" assert text.dropWhile{ false } == 'Groovy' assert text.dropWhile{ true } == '' assert text.dropWhile{ it < 'Z' } == 'roovy' assert text.dropWhile{ it != 'v' } == 'vy' </pre> Iterates through this CharSequence line by line.  Each line is passed to the given 1 or 2 arg closure. If a 2 arg closure is found the line count is passed as the second argument. Iterates through this CharSequence line by line.  Each line is passed to the given 1 or 2 arg closure. If a 2 arg closure is found the line count is passed as the second argument.   Process each regex group matched substring of the given CharSequence. If the closure parameter takes one argument, an array with all match groups is passed to it. If the closure takes as many arguments as there are match groups, then each parameter will be one match group. Process each regex group matched substring of the given pattern. If the closure parameter takes one argument, an array with all match groups is passed to it. If the closure takes as many arguments as there are match groups, then each parameter will be one match group. Process each regex group matched substring of the given string. If the closure parameter takes one argument, an array with all match groups is passed to it. If the closure takes as many arguments as there are match groups, then each parameter will be one match group. Process each regex group matched substring of the given pattern. If the closure parameter takes one argument, an array with all match groups is passed to it. If the closure takes as many arguments as there are match groups, then each parameter will be one match group. Expands all tabs into spaces with tabStops of size 8. Expands all tabs into spaces. If the CharSequence has multiple lines, expand each line - restarting tab stops at the start of each line.   Expands all tabs into spaces. Assumes the CharSequence represents a single line of text.  Finds the first occurrence of a regular expression String within a String. If the regex doesn't match, null will be returned. <p> For example, if the regex doesn't match the result is null: <pre> assert null == "New York, NY".find(/\d{5}/) </pre> If it does match, we get the matching string back: <pre> assert "10292" == "New York, NY 10292-0098".find(/\d{5}/) </pre> If we have capture groups in our expression, we still get back the full match <pre> assert "10292-0098" == "New York, NY 10292-0098".find(/(\d{5})-?(\d{4})/) </pre> Returns the result of calling a closure with the first occurrence of a regular expression found within a CharSequence. If the regex doesn't match, the closure will not be called and find will return null. Finds the first occurrence of a compiled regular expression Pattern within a String. If the pattern doesn't match, null will be returned. <p> For example, if the pattern doesn't match the result is null: <pre> assert null == "New York, NY".find(~/\d{5}/) </pre> If it does match, we get the matching string back: <pre> assert "10292" == "New York, NY 10292-0098".find(~/\d{5}/) </pre> If we have capture groups in our expression, the groups are ignored and we get back the full match: <pre> assert "10292-0098" == "New York, NY 10292-0098".find(~/(\d{5})-?(\d{4})/) </pre> If you need to work with capture groups, then use the closure version of this method or use Groovy's matcher operators or use <tt>eachMatch</tt>. Returns the result of calling a closure with the first occurrence of a compiled regular expression found within a String. If the regex doesn't match, the closure will not be called and find will return null. <p> For example, if the pattern doesn't match, the result is null: <pre> assert null == "New York, NY".find(~/\d{5}/) { match -> return "-$match-"} </pre> If it does match and we don't have any capture groups in our regex, there is a single parameter on the closure that the match gets passed to: <pre> assert "-10292-" == "New York, NY 10292-0098".find(~/\d{5}/) { match -> return "-$match-"} </pre> If we have capture groups in our expression, our closure has one parameter for the match, followed by one for each of the capture groups: <pre> assert "10292" == "New York, NY 10292-0098".find(~/(\d{5})-?(\d{4})/) { match, zip, plusFour -> assert match == "10292-0098" assert zip == "10292" assert plusFour == "0098" return zip } </pre> If we have capture groups in our expression, and our closure has one parameter, the closure will be passed an array with the first element corresponding to the whole match, followed by an element for each of the capture groups: <pre> assert "10292" == "New York, NY 10292-0098".find(~/(\d{5})-?(\d{4})/) { match, zip, plusFour -> assert array[0] == "10292-0098" assert array[1] == "10292" assert array[2] == "0098" return array[1] } </pre> If a capture group is optional, and doesn't match, then the corresponding value for that capture group passed to the closure will be null as illustrated here: <pre> assert "2339999" == "adsf 233-9999 adsf".find(~/(\d{3})?-?(\d{3})-(\d{4})/) { match, areaCode, exchange, stationNumber -> assert "233-9999" == match assert null == areaCode assert "233" == exchange assert "9999" == stationNumber return "$exchange$stationNumber" } </pre>     Returns a (possibly empty) list of all occurrences of a regular expression (provided as a CharSequence) found within a CharSequence. <p> For example, if the regex doesn't match, it returns an empty list: <pre> assert [] == "foo".findAll(/(\w*) Fish/) </pre> Any regular expression matches are returned in a list, and all regex capture groupings are ignored, only the full match is returned: <pre> def expected = ["One Fish", "Two Fish", "Red Fish", "Blue Fish"] assert expected == "One Fish, Two Fish, Red Fish, Blue Fish".findAll(/(\w*) Fish/) </pre> If you need to work with capture groups, then use the closure version of this method or use Groovy's matcher operators or use <tt>eachMatch</tt>. Finds all occurrences of a regular expression string within a CharSequence.   Any matches are passed to the specified closure.  The closure is expected to have the full match in the first parameter.  If there are any capture groups, they will be placed in subsequent parameters. <p> If there are no matches, the closure will not be called, and an empty List will be returned. <p> For example, if the regex doesn't match, it returns an empty list: <pre> assert [] == "foo".findAll(/(\w*) Fish/) { match, firstWord -> return firstWord } </pre> Any regular expression matches are passed to the closure, if there are no capture groups, there will be one parameter for the match: <pre> assert ["couldn't", "wouldn't"] == "I could not, would not, with a fox.".findAll(/.ould/) { match -> "${match}n't"} </pre> If there are capture groups, the first parameter will be the match followed by one parameter for each capture group: <pre> def orig = "There's a Wocket in my Pocket" assert ["W > Wocket", "P > Pocket"] == orig.findAll(/(.)ocket/) { match, firstLetter -> "$firstLetter > $match" } </pre> Returns a (possibly empty) list of all occurrences of a regular expression (in Pattern format) found within a CharSequence. <p> For example, if the pattern doesn't match, it returns an empty list: <pre> assert [] == "foo".findAll(~/(\w*) Fish/) </pre> Any regular expression matches are returned in a list, and all regex capture groupings are ignored, only the full match is returned: <pre> def expected = ["One Fish", "Two Fish", "Red Fish", "Blue Fish"] assert expected == "One Fish, Two Fish, Red Fish, Blue Fish".findAll(~/(\w*) Fish/) </pre> Finds all occurrences of a compiled regular expression Pattern within a CharSequence. Any matches are passed to the specified closure.  The closure is expected to have the full match in the first parameter.  If there are any capture groups, they will be placed in subsequent parameters. <p> If there are no matches, the closure will not be called, and an empty List will be returned. <p> For example, if the pattern doesn't match, it returns an empty list: <pre> assert [] == "foo".findAll(~/(\w*) Fish/) { match, firstWord -> return firstWord } </pre> Any regular expression matches are passed to the closure, if there are no capture groups, there will be one parameter for the match: <pre> assert ["couldn't", "wouldn't"] == "I could not, would not, with a fox.".findAll(~/.ould/) { match -> "${match}n't"} </pre> If there are capture groups, the first parameter will be the match followed by one parameter for each capture group: <pre> def orig = "There's a Wocket in my Pocket" assert ["W > Wocket", "P > Pocket"] == orig.findAll(~/(.)ocket/) { match, firstLetter -> "$firstLetter > $match" } </pre>     TODO expose this for stream based scenarios? Support the range subscript operator for GString with IntRange Support the range subscript operator for GString Support the subscript operator for GString. Support the range subscript operator for CharSequence or StringBuffer with EmptyRange Support the range subscript operator for CharSequence with IntRange Support the range subscript operator for CharSequence Support the subscript operator for CharSequence. Select a List of characters from a CharSequence using a Collection to identify the indices to be selected.  Support the range subscript operator for String with IntRange Support the range subscript operator for String Support the subscript operator for String.  Support the subscript operator, e.g.&#160;matcher[index], for a regex Matcher. <p> For an example using no group match, <pre> def p = /ab[d|f]/ def m = "abcabdabeabf" =~ p assert 2 == m.count assert 2 == m.size() // synonym for m.getCount() assert ! m.hasGroup() assert 0 == m.groupCount() def matches = ["abd", "abf"] for (i in 0..&lt;m.count) { &#160;&#160;assert m[i] == matches[i] } </pre> <p> For an example using group matches, <pre> def p = /(?:ab([c|d|e|f]))/ def m = "abcabdabeabf" =~ p assert 4 == m.count assert m.hasGroup() assert 1 == m.groupCount() def matches = [["abc", "c"], ["abd", "d"], ["abe", "e"], ["abf", "f"]] for (i in 0..&lt;m.count) { &#160;&#160;assert m[i] == matches[i] } </pre> <p> For another example using group matches, <pre> def m = "abcabdabeabfabxyzabx" =~ /(?:ab([d|x-z]+))/ assert 3 == m.count assert m.hasGroup() assert 1 == m.groupCount() def matches = [["abd", "d"], ["abxyz", "xyz"], ["abx", "x"]] for (i in 0..&lt;m.count) { &#160;&#160;assert m[i] == matches[i] } </pre> Select a List of values from a Matcher using a Collection to identify the indices to be selected. Converts the given CharSequence into an array of characters.  Find the number of Strings matched to the given Matcher. Get a replacement corresponding to the matched pattern for {@link org.codehaus.groovy.runtime.StringGroovyMethods#replaceAll(String, java.util.regex.Pattern, groovy.lang.Closure)}. The closure take parameter: <ul> <li>Whole of match if the pattern include no capturing group</li> <li>Object[] of capturing groups if the closure takes Object[] as parameter</li> <li>List of capturing groups</li> </ul> Check whether a Matcher contains a group or not. True if a CharSequence only contains whitespace characters.  Determine if a CharSequence can be parsed as a BigDecimal.  Determine if a CharSequence can be parsed as a BigInteger.   'Case' implementation for a CharSequence, which uses equals between the toString() of the caseValue and the switchValue. This allows CharSequence values to be used in switch statements. For example: <pre> switch( str ) { case 'one' : // etc... } </pre> Note that this returns <code>true</code> for the case where both the 'switch' and 'case' operand is <code>null</code>.  'Case' implementation for the {@link java.util.regex.Pattern} class, which allows testing a String against a number of regular expressions. For example: <pre>switch( str ) { case ~/one/ : // the regex 'one' matches the value of str } </pre> Note that this returns true for the case where both the pattern and the 'switch' values are <code>null</code>. Determine if a CharSequence can be parsed as a Double.  Determine if a CharSequence can be parsed as a Float.  Determine if a CharSequence can be parsed as an Integer.  Determine if a CharSequence can be parsed as a Long.  Determine if a CharSequence can be parsed as a Number. Synonym for 'isBigDecimal()'.  Returns an {@link java.util.Iterator} which traverses each match. Overloads the left shift operator to provide an easy way to append multiple objects as string representations to a CharSequence. Overloads the left shift operator to provide an easy way to append multiple objects as string representations to a String. Overloads the left shift operator to provide an easy way to append multiple objects as string representations to a StringBuffer. Overloads the left shift operator to provide syntactic sugar for appending to a StringBuilder. Tells whether or not a CharSequence matches the given compiled regular expression Pattern.  Given a matcher that matches a string against a pattern, this method returns true when the string matches the pattern or if a longer string, could match the pattern. For example: <pre class="groovyTestCase"> def emailPattern = /\w+@\w+\.\w{2,}/ def matcher = "john@doe" =~ emailPattern assert matcher.matchesPartially() matcher = "john@doe.com" =~ emailPattern assert matcher.matchesPartially() matcher = "john@@" =~ emailPattern assert !matcher.matchesPartially() </pre> Remove a part of a CharSequence by replacing the first occurrence of target within self with '' and returns the result. Remove a part of a CharSequence. This replaces the first occurrence of the pattern within self with '' and returns the result.   Repeat a CharSequence a certain number of times.  This method is called by the ++ operator for the class CharSequence. It increments the last character in the given CharSequence. If the last character in the CharSequence is Character.MAX_VALUE a Character.MIN_VALUE will be appended. The empty CharSequence is incremented to a string consisting of the character Character.MIN_VALUE.  Return a String with linefeeds and carriage returns normalized to linefeeds.  Pad a CharSequence to a minimum length specified by <tt>numberOfChars</tt> by adding the space character to the left as many times as needed. If the String is already the same size or bigger than the target <tt>numberOfChars</tt>, then the original String is returned. An example: <pre> println 'Numbers:' [1, 10, 100, 1000].each{ println it.toString().padLeft(5) } </pre> will produce output like: <pre> Numbers: 1 10 100 1000 </pre> Pad a CharSequence to a minimum length specified by <tt>numberOfChars</tt>, adding the supplied padding CharSequence as many times as needed to the left. If the CharSequence is already the same size or bigger than the target <tt>numberOfChars</tt>, then the toString() of the original CharSequence is returned. An example: <pre> println 'Numbers:' [1, 10, 100, 1000].each{ println it.toString().padLeft(5, '*') } [2, 20, 200, 2000].each{ println it.toString().padLeft(5, '*_') } </pre> will produce output like: <pre> Numbers: ****1 ***10 **100 *1000 *_*_2 *_*20 *_200 *2000 </pre>   Pad a CharSequence to a minimum length specified by <tt>numberOfChars</tt> by adding the space character to the right as many times as needed. If the CharSequence is already the same size or bigger than the target <tt>numberOfChars</tt>, then the toString() of the original CharSequence is returned. An example: <pre> ['A', 'BB', 'CCC', 'DDDD'].each{ println it.padRight(5) + it.size() } </pre> will produce output like: <pre> A    1 BB   2 CCC  3 DDDD 4 </pre> Pad a CharSequence to a minimum length specified by <tt>numberOfChars</tt>, adding the supplied padding CharSequence as many times as needed to the right. If the CharSequence is already the same size or bigger than the target <tt>numberOfChars</tt>, then the toString() of the original CharSequence is returned. An example: <pre> ['A', 'BB', 'CCC', 'DDDD'].each{ println it.padRight(5, '#') + it.size() } </pre> will produce output like: <pre> A####1 BB###2 CCC##3 DDDD#4 </pre>   Appends the String representation of the given operand to this CharSequence. Appends a String to the string representation of this number. Appends the String representation of the given operand to this string.  Appends a String to this StringBuffer. This method is called by the -- operator for the class CharSequence. It decrements the last character in the given CharSequence. If the last character in the CharSequence is Character.MIN_VALUE it will be deleted. The empty CharSequence can't be decremented.  Support the range subscript operator for StringBuffer. Support the range subscript operator for StringBuffer.  Index values are treated as characters within the buffer. Return the lines of a CharSequence as a List of String.  Replaces all occurrences of a captured group by the result of a closure on that text. <p> For examples, <pre> assert "hellO wOrld" == "hello world".replaceAll("(o)") { it[0].toUpperCase() } assert "FOOBAR-FOOBAR-" == "foobar-FooBar-".replaceAll("(([fF][oO]{2})[bB]ar)", { Object[] it -> it[0].toUpperCase() }) Here, it[0] is the global string of the matched group it[1] is the first string in the matched group it[2] is the second string in the matched group assert "FOO-FOO-" == "foobar-FooBar-".replaceAll("(([fF][oO]{2})[bB]ar)", { x, y, z -> z.toUpperCase() }) Here, x is the global string of the matched group y is the first string in the matched group z is the second string in the matched group </pre> Note that unlike String.replaceAll(String regex, String replacement), where the replacement string treats '$' and '\' specially (for group substitution), the result of the closure is converted to a string and that value is used literally for the replacement. Replaces each substring of this CharSequence that matches the given regular expression with the given replacement. Replaces all occurrences of a captured group by the result of a closure call on that text. <p> For examples, <pre> assert "hellO wOrld" == "hello world".replaceAll(~"(o)") { it[0].toUpperCase() } assert "FOOBAR-FOOBAR-" == "foobar-FooBar-".replaceAll(~"(([fF][oO]{2})[bB]ar)", { it[0].toUpperCase() }) Here, it[0] is the global string of the matched group it[1] is the first string in the matched group it[2] is the second string in the matched group assert "FOOBAR-FOOBAR-" == "foobar-FooBar-".replaceAll(~"(([fF][oO]{2})[bB]ar)", { Object[] it -> it[0].toUpperCase() }) Here, it[0] is the global string of the matched group it[1] is the first string in the matched group it[2] is the second string in the matched group assert "FOO-FOO-" == "foobar-FooBar-".replaceAll("(([fF][oO]{2})[bB]ar)", { x, y, z -> z.toUpperCase() }) Here, x is the global string of the matched group y is the first string in the matched group z is the second string in the matched group </pre> Note that unlike String.replaceAll(String regex, String replacement), where the replacement string treats '$' and '\' specially (for group substitution), the result of the closure is converted to a string and that value is used literally for the replacement. Replaces all substrings of a CharSequence that match the given compiled regular expression with the given replacement. <p> Note that backslashes (<tt>\</tt>) and dollar signs (<tt>$</tt>) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see {@link java.util.regex.Matcher#replaceAll}. Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special meaning of these characters, if desired. <p> <pre class="groovyTestCase"> assert "foo".replaceAll('o', 'X') == 'fXX' </pre>    Replaces the first occurrence of a captured group by the result of a closure call on that text. <p> For example (with some replaceAll variants thrown in for comparison purposes), <pre> assert "hellO world" == "hello world".replaceFirst("(o)") { it[0].toUpperCase() } // first match assert "hellO wOrld" == "hello world".replaceAll("(o)") { it[0].toUpperCase() }   // all matches assert '1-FISH, two fish' == "one fish, two fish".replaceFirst(/([a-z]{3})\s([a-z]{4})/) { [one:1, two:2][it[1]] + '-' + it[2].toUpperCase() } assert '1-FISH, 2-FISH' == "one fish, two fish".replaceAll(/([a-z]{3})\s([a-z]{4})/) { [one:1, two:2][it[1]] + '-' + it[2].toUpperCase() } </pre> Replaces the first substring of this CharSequence that matches the given regular expression with the given replacement. Replaces the first occurrence of a captured group by the result of a closure call on that text. <p> For example (with some replaceAll variants thrown in for comparison purposes), <pre> assert "hellO world" == "hello world".replaceFirst(~"(o)") { it[0].toUpperCase() } // first match assert "hellO wOrld" == "hello world".replaceAll(~"(o)") { it[0].toUpperCase() }   // all matches assert '1-FISH, two fish' == "one fish, two fish".replaceFirst(~/([a-z]{3})\s([a-z]{4})/) { [one:1, two:2][it[1]] + '-' + it[2].toUpperCase() } assert '1-FISH, 2-FISH' == "one fish, two fish".replaceAll(~/([a-z]{3})\s([a-z]{4})/) { [one:1, two:2][it[1]] + '-' + it[2].toUpperCase() } </pre> Replaces the first substring of a CharSequence that matches the given compiled regular expression with the given replacement. <p> Note that backslashes (<tt>\</tt>) and dollar signs (<tt>$</tt>) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string; see {@link java.util.regex.Matcher#replaceFirst}. Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special meaning of these characters, if desired. <p> <pre class="groovyTestCase"> assert "foo".replaceFirst('o', 'X') == 'fXo' </pre>    Creates a String which is the reverse (backwards) of this CharSequence  Set the position of the given Matcher to the given index. Provide the standard Groovy <code>size()</code> method for <code>CharSequence</code>. Provide the standard Groovy <code>size()</code> method for <code>String</code>. Provide the standard Groovy <code>size()</code> method for <code>StringBuffer</code>. Provide the standard Groovy <code>size()</code> method for <code>Matcher</code>.  Convenience method to split a CharSequence (with whitespace as delimiter). Similar to tokenize, but returns an Array of String instead of a List.  Iterates through the given CharSequence line by line, splitting each line using the given regex delimiter.  The list of tokens for each line is then passed to the given closure. Iterates through the given CharSequence line by line, splitting each line using the given separator Pattern.  The list of tokens for each line is then passed to the given closure.   Strip leading spaces from every line in a CharSequence. The line with the least number of leading spaces determines the number to remove. Lines only containing whitespace are ignored when calculating the number of leading spaces to strip. <pre class="groovyTestCase"> assert '  A\n B\nC' == '   A\n  B\n C'.stripIndent() </pre> Strip <tt>numChar</tt> leading characters from every line in a CharSequence. <pre class="groovyTestCase"> assert 'DEF\n456' == '''ABCDEF\n123456'''.stripIndent(3) </pre>   TODO expose this for stream based stripping? Strip leading whitespace/control characters followed by '|' from every line in a CharSequence. <pre class="groovyTestCase"> assert 'ABC\n123\n456' == '''ABC |123 |456'''.stripMargin() </pre> Strip leading whitespace/control characters followed by <tt>marginChar</tt> from every line in a CharSequence. <pre class="groovyTestCase"> assert 'ABC\n123\n456' == '''ABC *123 *456'''.stripMargin('*') </pre> Strip leading whitespace/control characters followed by <tt>marginChar</tt> from every line in a CharSequence.    TODO expose this for other usage scenarios, e.g. stream based stripping? A GString variant of the equivalent CharSequence method. Returns the first <code>num</code> elements from this CharSequence. <pre class="groovyTestCase"> def text = "Groovy" assert text.take( 0 ) == '' assert text.take( 2 ) == 'Gr' assert text.take( 7 ) == 'Groovy' </pre> A GString variant of the equivalent GString method. Returns the longest prefix of this CharSequence where each element passed to the given closure evaluates to true. <p> <pre class="groovyTestCase"> def text = "Groovy" assert text.takeWhile{ it < 'A' } == '' assert text.takeWhile{ it < 'Z' } == 'G' assert text.takeWhile{ it != 'v' } == 'Groo' assert text.takeWhile{ it < 'z' } == 'Groovy' </pre> Parse a CharSequence into a BigDecimal  Parse a CharSequence into a BigInteger  Converts the given string into a Boolean object. If the trimmed string is "true", "y" or "1" (ignoring case) then the result is true otherwise it is false. Converts the given string into a Character object using the first character in the string. Parse a CharSequence into a Double  Parse a CharSequence into a Float  Parse a CharSequence into an Integer  Converts the given CharSequence into a List of Strings of one character.  Parse a CharSequence into a Long  Converts the given CharSequence into a Set of unique String of one character.  Parse a CharSequence into a Short  Tokenize a CharSequence (with a whitespace as the delimiter). Tokenize a CharSequence based on the given CharSequence delimiter. Tokenize a CharSequence based on the given character delimiter. For example: <pre class="groovyTestCase"> char pathSep = ':' assert "/tmp:/usr".tokenize(pathSep) == ["/tmp", "/usr"] </pre>    Translates a CharSequence by replacing characters from the sourceSet with characters from replacementSet. If the first character from sourceSet appears in the CharSequence, it will be replaced with the first character from replacementSet. If the second character from sourceSet appears in the CharSequence, it will be replaced with the second character from replacementSet. and so on for all provided replacement characters. <p> Here is an example which converts the vowels in a word from lower to uppercase: <pre> assert 'hello'.tr('aeiou', 'AEIOU') == 'hEllO' </pre> A character range using regex-style syntax can also be used, e.g. here is an example which converts a word from lower to uppercase: <pre> assert 'hello'.tr('a-z', 'A-Z') == 'HELLO' </pre> Hyphens at the start or end of sourceSet or replacementSet are treated as normal hyphens and are not considered to be part of a range specification. Similarly, a hyphen immediately after an earlier range is treated as a normal hyphen. So, '-x', 'x-' have no ranges while 'a-c-e' has the range 'a-c' plus the '-' character plus the 'e' character. <p> Unlike the unix tr command, Groovy's tr command supports reverse ranges, e.g.: <pre> assert 'hello'.tr('z-a', 'Z-A') == 'HELLO' </pre> If replacementSet is smaller than sourceSet, then the last character from replacementSet is used as the replacement for all remaining source characters as shown here: <pre> assert 'Hello World!'.tr('a-z', 'A') == 'HAAAA WAAAA!' </pre> If sourceSet contains repeated characters, the last specified replacement is used as shown here: <pre> assert 'Hello World!'.tr('lloo', '1234') == 'He224 W4r2d!' </pre> The functionality provided by tr can be achieved using regular expressions but tr provides a much more compact notation and efficient implementation for certain scenarios.  Replaces sequences of whitespaces with tabs using tabStops of size 8. Replaces sequences of whitespaces with tabs.   Replaces sequences of whitespaces with tabs within a line.

Returns the underlying SyntaxException. Writes out a nicely formatted summary of the syntax error.

Creates, if necessary, a super forwarder method, for stackable traits. Creates a method to dispatch to "super traits" in a "stackable" fashion. The generated method looks like this: <p> <code>ReturnType trait$super$method(Class clazz, Arg1 arg1, Arg2 arg2, ...) { if (SomeTrait.is(A) { return SomeOtherTrait$Trait$Helper.method(this, arg1, arg2) } super.method(arg1,arg2) }</code> </p> Given a class node, if this class node implements a trait, then generate all the appropriate code which delegates calls to the trait. It is safe to call this method on a class node which does not implement a trait. An utility method which tries to find a method with default implementation (in the Java 8 semantics).
Collects all interfaces of a class node, but reverses the order of the declaration of direct interfaces of this class node. This is used to make sure a trait implementing A,B where both A and B have the same method will take the method from B (latest), aligning the behavior with categories. Collects all the self types that a type should extend or implement, given the traits is implements. Collects from interfaces and superclasses too. Collects all the self types that a type should extend or implement, given the traits is implements. Returns the name of a method without the super trait specific prefix. If the method name doesn't correspond to a super trait method call, the result will be null. Converts a class implementing some trait into a target class. If the trait is a dynamic proxy and that the target class is assignable to the target object of the proxy, then the target object is returned. Otherwise, falls back to {@link org.codehaus.groovy.runtime.DefaultGroovyMethods#asType(java.lang.Object, Class)} Reflection API to find the method corresponding to the default implementation of a trait, given a bridge method. Indicates whether a method in a trait interface has a default implementation. Indicates whether a method in a trait interface has a default implementation. Returns true if the specified class node is annotated with the {@link Trait} interface. Reflection API to indicate whether some method is a bridge method to the default implementation of a trait. Returns true if the specified class is a trait. Returns true if the specified class node is a trait.
Starts the trampoline loop and calls the wrapped closure as the first step. Starts the trampoline loop and calls the wrapped closure as the first step. Starts the trampoline loop and calls the wrapped closure as the first step. Delegates to the wrapped closure Delegates to the wrapped closure Returns itself, since it is a good enough trampolined variant of the current closure. Builds a trampolined variant of the current closure.




