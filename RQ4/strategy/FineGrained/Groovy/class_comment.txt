

Base class for AST Transformations which will automatically throw an {@link InterruptedException} when some conditions are met.
An interface for MetaClass instances that "adapt" other MetaClass instances such as a proxy or delegating MetaClass.
A parser plugin which adapts the JSR Antlr Parser to the Groovy runtime
Generates Java class versions of Groovy classes using ASM.
Handles generation of code for the @AutoClone annotation.
Intended style to use for cloning when using the {@code @}AutoClone annotation.
Handles transformation for the @BaseScript annotation.
BigDecimal NumberMath operations

Class annotation used to assist in the creation of mutable classes. <p> It allows you to write classes in this shortened form: <pre> {@code @Canonical} class Customer { String first, last int age Date since Collection favItems = ['Food'] def object } def d = new Date() def anyObject = new Object() def c1 = new Customer(first:'Tom', last:'Jones', age:21, since:d, favItems:['Books', 'Games'], object: anyObject) def c2 = new Customer('Tom', 'Jones', 21, d, ['Books', 'Games'], anyObject) assert c1 == c2 </pre> You don't need to provide all arguments in constructor calls. If using named parameters, any property names not referenced will be given their default value (as per Java's default unless an explicit initialization constant is provided when defining the property). If using a tuple constructor, parameters are supplied in the order in which the properties are defined. Supplied parameters fill the tuple from the left. Any parameters missing on the right are given their default value. <pre> def c3 = new Customer(last: 'Jones', age: 21) def c4 = new Customer('Tom', 'Jones') assert null == c3.since assert 0 == c4.age assert c3.favItems == ['Food'] && c4.favItems == ['Food'] </pre> The {@code @Canonical} annotation instructs the compiler to execute an AST transformation which adds positional constructors, equals, hashCode and a pretty print toString to your class. There are additional annotations if you only need some of the functionality: {@code @EqualsAndHashCode}, {@code @ToString} and {@code @TupleConstructor}. In addition, you can add one of the other annotations if you need to further customize the behavior of the AST transformation. <p> A class created in this way has the following characteristics: <ul> <li>A no-arg constructor is provided which allows you to set properties by name using Groovy's normal bean conventions. <li>Tuple-style constructors are provided which allow you to set properties in the same order as they are defined. <li>Default {@code equals}, {@code hashCode} and {@code toString} methods are provided based on the property values. Though not normally required, you may write your own implementations of these methods. For {@code equals} and {@code hashCode}, if you do write your own method, it is up to you to obey the general contract for {@code equals} methods and supply a corresponding matching {@code hashCode} method. If you do provide one of these methods explicitly, the default implementation will be made available in a private "underscore" variant which you can call. E.g., you could provide a (not very elegant) multi-line formatted {@code toString} method for {@code Customer} above as follows: <pre> String toString() { _toString().replaceAll(/\(/, '(\n\t').replaceAll(/\)/, '\n)').replaceAll(/, /, '\n\t') } </pre> If an "underscore" version of the respective method already exists, then no default implementation is provided. </ul> <p> If you want similar functionality to what this annotation provides but also require immutability, see the {@code @}{@link Immutable} annotation. <p> Limitations: <ul> <li>If you explicitly add your own constructors, then the transformation will not add any other constructor to the class</li> <li>Groovy's normal map-style naming conventions will not be available if the first property has type {@code LinkedHashMap} or if there is a single Map, AbstractMap or HashMap property</li> </ul>

Represents any closure object in Groovy. <p> Groovy allows instances of Closures to be called in a short form. For example: <pre> def a = 1 def c = { a } assert c() == 1 </pre> To be able to use a Closure in this way with your own subclass, you need to provide a doCall method with any signature you want to. This ensures that {@link #getMaximumNumberOfParameters()} and {@link #getParameterTypes()} will work too without any additional code. If no doCall method is provided a closure must be used in its long form like <pre> def a = 1 def c = {a} assert c.call() == 1 </pre>
A Comparator which uses a closure to compare 2 values being equal
Represents a closure expression such as { statement } or { i -> statement } or { i, x, String y ->  statement }
A meta class for closures generated by the Groovy compiler. These classes have special characteristics this MetaClass uses. One of these is that a generated Closure has only additional doCall methods, all other methods are in the Closure class as well. To use this fact this MetaClass uses a MetaClass for Closure as static field And delegates calls to this MetaClass if needed. This allows a lean implementation for this MetaClass. Multiple generated closures will then use the same MetaClass for Closure. For static dispatching this class uses the MetaClass of Class, again all instances of this class will share that MetaClass. The Class MetaClass is initialized lazy, because most operations do not need this MetaClass. <p> The Closure and Class MetaClasses are not replaceable. <p> This MetaClass is for internal usage only!
The CompilationUnit collects all compilation data as it is generated by the compiler system. You can use this object to add additional source units to the compilation, or force the compilation to be run again (to affect only the deltas). <p> You can also add PhaseOperations to this compilation using the addPhaseOperation method. This is commonly used when you want to wire a new AST Transformation into the compilation.
A wrapper for Closure to support composition. Normally used only internally through the <code>rightShift()</code> and <code>leftShift()</code> methods on <code>Closure</code>. <p> Typical usages: <pre> def twice = { a -> a * 2 } def inc = { b -> b + 1 } def f = { x -> twice(inc(x)) } // longhand def g = inc >> twice def h = twice << inc assert f(10) == 22 assert g(10) == 22 assert h(10) == 22 def s2c = { it.chars[0] } def p = Integer.&toHexString >> s2c >> Character.&toUpperCase assert p(15) == 'F' def multiply = { a, b -> a * b } def identity = { a -> [a, a] } def sq = identity >> multiply assert (1..5).collect{ sq(it) } == [1, 4, 9, 16, 25] def add3 = { a, b, c -> a + b + c } def add2plus10 = add3.curry(10) def multBoth = { a, b, c -> [a*c, b*c] } def twiceBoth = multBoth.rcurry(2) def twiceBothPlus10 = twiceBoth >> add2plus10 assert twiceBothPlus10(5, 10) == 40 </pre>
A composite of many visitors. Any call to a method from Visitor will invoke each visitor in turn, and reverse the invocation order on a closing visit. i.e. with the list of visitors = [a,b,c] composite.visitDefault() would... call on the opening visit - a.visitDefault() then b.visitDefault() then c.visitDefault() call on the closing visit - c.visitDefault() then b.visitDefault() then a.visitDefault()
A wrapper for Closure to support currying. Normally used only internally through the <code>curry()</code>, <code>rcurry()</code> or <code>ncurry()</code> methods on <code>Closure</code>. Typical usages: <pre> // normal usage def unitAdder = { first, second, unit -> "${first + second} $unit" } assert unitAdder(10, 15, "minutes") == "25 minutes" assert unitAdder.curry(60)(15, "minutes") == "75 minutes" def minuteAdder = unitAdder.rcurry("minutes") assert minuteAdder(15, 60) == "75 minutes" // explicit creation import org.codehaus.groovy.runtime.CurriedClosure assert new CurriedClosure(unitAdder, 45)(15, "minutes") == "60 minutes" assert new CurriedClosure(unitAdder, "six", "ty")("minutes") == "sixty minutes" </pre>
This class defines new groovy methods which appear on normal JDK Date and Calendar classes inside the Groovy environment.
This class defines new groovy methods which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. <code>public static String reverse(String self)</code> provides a <code>reverse()</code> method for <code>String</code>. <p> NOTE: While this class contains many 'public' static methods, it is primarily regarded as an internal class (its internal package name suggests this also). We value backwards compatibility of these methods when used within Groovy but value less backwards compatibility at the Java method call level. I.e. future versions of Groovy may remove or move a method call in this file but would normally aim to keep the method available from within Groovy.
Support methods for DefaultGroovyMethods and PluginDefaultMethods.
This class defines all the new static groovy methods which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter as the destination class.
Class providing various type conversions, coercions and boxing/unboxing operations.
This class defines all the encoding/decoding groovy methods which enhance the normal JDK classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.

Represents a dynamically expandable bean.
ExpandoMetaClass is a MetaClass that behaves like an Expando, allowing the addition or replacement of methods, properties and constructors on the fly. <p> Some examples of usage: <pre> // defines or replaces instance method: metaClass.myMethod = { args -> } // defines a new instance method metaClass.myMethod << { args -> } // creates multiple overloaded methods of the same name metaClass.myMethod << { String s -> } << { Integer i -> } // defines or replaces a static method with the 'static' qualifier metaClass.'static'.myMethod = { args ->  } // defines a new static method with the 'static' qualifier metaClass.'static'.myMethod << { args ->  } // defines a new constructor metaClass.constructor << { String arg -> } // defines or replaces a constructor metaClass.constructor = { String arg -> } // defines a new property with an initial value of "blah" metaClass.myProperty = "blah" </pre> <p> ExpandoMetaClass also supports a DSL/builder like notation to combine multiple definitions together. So instead of this: <pre> Number.metaClass.multiply = { Amount amount -> amount.times(delegate) } Number.metaClass.div =      { Amount amount -> amount.inverse().times(delegate) } </pre> You can also now do this: <pre> Number.metaClass { multiply { Amount amount -> amount.times(delegate) } div      { Amount amount -> amount.inverse().times(delegate) } } </pre> <p> ExpandoMetaClass also supports runtime mixins. While {@code @Mixin} allows you to mix in new behavior to classes you own and are designing, you can not easily mixin anything to types you didn't own, e.g. from third party libraries or from JDK library classes. Runtime mixins let you add a mixin on any type at runtime. <pre> interface Vehicle { String getName() } // Category annotation style {@code @Category}(Vehicle) class FlyingAbility { def fly() { "I'm the ${name} and I fly!" } } // traditional category style class DivingAbility { static dive(Vehicle self) { "I'm the ${self.name} and I dive!" } } // provided by a third-party, so can't augment using Mixin annotation class JamesBondVehicle implements Vehicle { String getName() { "James Bond's vehicle" } } // Can be added via metaClass, e.g.: // JamesBondVehicle.metaClass.mixin DivingAbility, FlyingAbility // Or using shorthand through DGM method on Class JamesBondVehicle.mixin DivingAbility, FlyingAbility assert new JamesBondVehicle().fly() == "I'm the James Bond's vehicle and I fly!" assert new JamesBondVehicle().dive() == "I'm the James Bond's vehicle and I dive!" </pre> As another example, consider the following class definitions: <pre> class Student { List<String> schedule = [] def addLecture(String lecture) { schedule << lecture } } class Worker { List<String> schedule = [] def addMeeting(String meeting) { schedule << meeting } } </pre> We can mimic a form of multiple inheritance as follows: <pre> class CollegeStudent { static { mixin Student, Worker } } new CollegeStudent().with { addMeeting('Performance review with Boss') addLecture('Learn about Groovy Mixins') println schedule println mixedIn[Student].schedule println mixedIn[Worker].schedule } </pre> Which outputs these lines when run: <pre> [Performance review with Boss] [Learn about Groovy Mixins] [Performance review with Boss] </pre> Perhaps some explanation is required here. The methods and properties of Student and Worker are added to CollegeStudent. Worker is added last, so for overlapping methods, its methods will be used, e.g. when calling <code>schedule</code>, it will be the schedule property (getSchedule method) from Worker that is used. The schedule property from Student will be shadowed but the <code>mixedIn</code> notation allows us to get to that too if we need as the last two lines show. <p> We can also be a little more dynamic and not require the CollegeStudent class to be defined at all, e.g.: <pre> def cs = new Object() cs.metaClass { mixin Student, Worker getSchedule { mixedIn[Student].schedule + mixedIn[Worker].schedule } } cs.with { addMeeting('Performance review with Boss') addLecture('Learn about Groovy Mixins') println schedule } </pre> Which outputs this line when run: <pre> [Learn about Groovy Mixins, Performance review with Boss] </pre> As another example, we can also define a no dup queue by mixing in some Queue and Set functionality as follows: <pre> def ndq = new Object() ndq.metaClass { mixin ArrayDeque mixin HashSet leftShift = { Object o -> if (!mixedIn[Set].contains(o)) { mixedIn[Queue].push(o) mixedIn[Set].add(o) } } } ndq << 1 ndq << 2 ndq << 1 assert ndq.size() == 2 </pre> As a final example, we sometimes need to pass such mixed in classes or objects into Java methods which require a given static type but the ExpandoMetaClass mixin approach uses a very dynamic approach based on duck typing rather than static interface definitions, so doesn't by default produce objects matching the required static type. Luckily, there is a mixins capability within ExpandoMetaClass which supports the use of Groovy's common 'as StaticType' notation to produce an object having the correct static type so that it can be passed to the Java method call in question. A slightly contrived example illustrating this feature: <pre> class CustomComparator implements Comparator { int compare(Object a, b) { return a.size() - b.size() } } class CustomCloseable implements Closeable { void close() { println 'Lights out - I am closing' } } import static mypackage.IOUtils.closeQuietly import static java.util.Collections.sort def o = new Object() o.metaClass.mixin CustomComparator, CustomCloseable def items = ['a', 'bbb', 'cc'] sort(items, o as Comparator) println items                // => [a, cc, bbb] closeQuietly(o as Closeable) // => Lights out - I am closing </pre> <p> <b>Further details</b> <p> When using the default implementations of MetaClass, methods are only allowed to be added before initialize() is called. In other words you create a new MetaClass, add some methods and then call initialize(). If you attempt to add new methods after initialize() has been called, an error will be thrown. This is to ensure that the MetaClass can operate appropriately in multi-threaded environments as it forces you to do all method additions at the beginning, before using the MetaClass. <p> ExpandoMetaClass differs here from the default in that it allows you to add methods after initialize has been called. This is done by setting the initialize flag internally to false and then add the methods. Since this is not thread safe it has to be done in a synchronized block. The methods to check for modification and initialization are therefore synchronized as well. Any method call done through this meta class will first check if the it is synchronized. Should this happen during a modification, then the method cannot be selected or called unless the modification is completed. <p>
Represents a base class for expressions which evaluate as an object
Command-line compiler (aka. <tt>groovyc</tt>).
Transformation for declarative dependency management.
Facade to GrapeEngine.


A ClassLoader which can load Groovy classes. The loaded classes are cached, classes from other classloaders should not be cached. To be able to load a script that was asked for earlier but was created later it is essential not to keep anything like a "class not found" information for that class name. This includes possible parent loaders. Classes that are not cached are always reloaded.
A Collections utility class
A Command line to execute groovy.
An exception thrown by the interpreter
Simple server that executes supplied script against a socket. <p> Typically this is used from the groovy command line agent but it can be invoked programatically. To run this program from the command line please refer to the command line documentation at <a href="http://groovy.codehaus.org/Groovy+CLI"> Groovy CLI</a>. <p> Here is an example of how to use this class to open a listening socket on the server, listen for incoming data, and then echo the data back to the client in reverse order: <pre> new GroovySocketServer( new GroovyShell(),      // evaluator false,                  // is not a file "println line.reverse()",         // script to evaluate true,                   // return result to client 1960)                   //port </pre> There are several variables in the script binding: <ul> <li>line - The data from the socket</li> <li>out - The output PrintWriter, should you need it for some reason.</li> <li>socket - The socket, should you need it for some reason.</li> </ul>
Class annotation used to assist in the creation of immutable classes. <p> It allows you to write classes in this shortened form: <pre> {@code @Immutable} class Customer { String first, last int age Date since Collection favItems } def d = new Date() def c1 = new Customer(first:'Tom', last:'Jones', age:21, since:d, favItems:['Books', 'Games']) def c2 = new Customer('Tom', 'Jones', 21, d, ['Books', 'Games']) assert c1 == c2 </pre> The {@code @Immutable} annotation instructs the compiler to execute an AST transformation which adds the necessary getters, constructors, equals, hashCode and other helper methods that are typically written when creating immutable classes with the defined properties. <p> A class created in this way has the following characteristics: <ul> <li>The class is automatically made final. <li>Properties must be of an immutable type or a type with a strategy for handling non-immutable characteristics. Specifically, the type must be one of the primitive or wrapper types, Strings, enums, other {@code @Immutable} classes or known immutables (e.g. java.awt.Color, java.net.URI, java.util.UUID). Also handled are Cloneable classes, collections, maps and arrays, and other "effectively immutable" classes with special handling (e.g. java.util.Date). <li>Properties automatically have private, final backing fields with getters. Attempts to update the property will result in a {@code ReadOnlyPropertyException}. <li>A map-based constructor is provided which allows you to set properties by name. <li>A tuple-style constructor is provided which allows you to set properties in the same order as they are defined. <li>Default {@code equals}, {@code hashCode} and {@code toString} methods are provided based on the property values. Though not normally required, you may write your own implementations of these methods. For {@code equals} and {@code hashCode}, if you do write your own method, it is up to you to obey the general contract for {@code equals} methods and supply a corresponding matching {@code hashCode} method. If you do provide one of these methods explicitly, the default implementation will be made available in a private "underscore" variant which you can call. E.g., you could provide a (not very elegant) multi-line formatted {@code toString} method for {@code Customer} above as follows: <pre> String toString() { _toString().replaceAll(/\(/, '(\n\t').replaceAll(/\)/, '\n)').replaceAll(/, /, '\n\t') } </pre> If an "underscore" version of the respective method already exists, then no default implementation is provided. <li>{@code Date}s, {@code Cloneable}s and arrays are defensively copied on the way in (constructor) and out (getters). Arrays and {@code Cloneable} objects use the {@code clone} method. For your own classes, it is up to you to define this method and use deep cloning if appropriate. <li>{@code Collection}s and {@code Map}s are wrapped by immutable wrapper classes (but not deeply cloned!). Attempts to update them will result in an {@code UnsupportedOperationException}. <li>Fields that are enums or other {@code @Immutable} classes are allowed but for an otherwise possible mutable property type, an error is thrown. <li>You don't have to follow Groovy's normal property conventions, e.g. you can create an explicit private field and then you can write explicit get and set methods. Such an approach, isn't currently prohibited (to give you some wiggle room to get around these conventions) but any fields created in this way are deemed not to be part of the significant state of the object and aren't factored into the {@code equals} or {@code hashCode} methods. Similarly, you may use static properties (though usually this is discouraged) and these too will be ignored as far as significant state is concerned. If you do break standard conventions, you do so at your own risk and your objects may no longer be immutable. It is up to you to ensure that your objects remain immutable at least to the extent expected in other parts of your program! </ul> Immutable classes are particularly useful for functional and concurrent styles of programming and for use as key values within maps. If you want similar functionality to what this annotation provides but don't need immutability then consider using {@code @Canonical}. <p> Customising behaviour: <p> You can customise the toString() method provided for you by {@code @Immutable} by also adding the {@code @ToString} annotation to your class definition. <p> Limitations: <ul> <li> As outlined above, Arrays and {@code Cloneable} objects use the {@code clone} method. For your own classes, it is up to you to define this method and use deep cloning if appropriate. </li> <li> As outlined above, {@code Collection}s and {@code Map}s are wrapped by immutable wrapper classes (but not deeply cloned!). </li> <li> Currently {@code BigInteger} and {@code BigDecimal} are deemed immutable but see: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6348370 </li> <li> {@code java.awt.Color} is treated as "effectively immutable" but is not final so while not normally used with child classes, it isn't strictly immutable. Use at your own risk. </li> <li> {@code java.util.Date} is treated as "effectively immutable" but is not final so it isn't strictly immutable. Use at your own risk. </li> <li> Groovy's normal map-style naming conventions will not be available if the first property has type {@code LinkedHashMap} or if there is a single Map, AbstractMap or HashMap property. </li> </ul>
Handles generation of code for the @Immutable annotation.
Handles generation of code for the {@code @}InheritConstructors annotation.
A static helper class to make bytecode generation easier and act as a facade over the Invoker
Protects stored resources from eviction from memory following the LRU (Last Recently Used) strategy. If the maximum size has been reached all newly added elements will cause the oldest element to be removed from the storage in order not to exceed the maximum capacity. The touch method can be used to renew an element and move it to the from the LRU queue.
The <code>LineColumnReader</code> is an extension to <code>BufferedReader</code> that keeps track of the line and column information of where the cursor is.
This class provides an AST Transformation to add a log field to a class.
A wrapper for Map which allows a default value to be specified.
Implements memoize for Closures. It is supposed to be used by the Closure class itself to implement the memoize() family of methods.
Handles generation of code for the {@link Memoized} annotation.
A MetaClass within Groovy defines the behaviour of any given Groovy or Java class. The MetaClass interface defines two parts. The client API, which is defined via the extend MetaObjectProtocol interface and the contract with the Groovy runtime system. In general the compiler and Groovy runtime engine interact with methods on this class whilst MetaClass clients interact with the method defined by the MetaObjectProtocol interface
Allows methods to be dynamically added to existing classes at runtime
A MetaClassRegistry is an object that is responsible for managing the a cache of MetaClass instances. Each java.lang.Class instance has an associated MetaClass and client code can query this interface for the MetaClass for a given associated java.lang.Class
A registry of MetaClass instances which caches introspection & reflection information and allows methods to be dynamically added to existing classes at runtime
Utility class for MissingMethodException, MissingPropertyException etc. This class contains methods assisting in ranking and listing probable intended methods/fields when a exception is thrown.
An exception occurred if a dynamic method dispatch fails with an unknown method. <p> Note that the Missing*Exception classes were named for consistency and to avoid conflicts with JDK exceptions of the same name.
An exception occurred if a dynamic property dispatch fails with an unknown property. Note that the Missing*Exception classes were named for consistency and to avoid conflicts with JDK exceptions of the same name.
A MetaMethod implementation where the underlying method is really a static helper method on some class but it appears to be an instance method on a class. This implementation is used to add new methods to the JDK writing them as normal static methods with the first parameter being the class on which the method is added.
A MetaMethod implementation where the underlying method is really a static helper method on some class. This implementation is used to add new static methods to the JDK writing them as normal static methods with the first parameter being the class on which the method is added.
Handles generation of code for the @Newify annotation.
Represents an arbitrary tree node which can be used for structured metadata or any arbitrary XML-like tree. A node can have a name, a value and an optional Map of attributes. Typically the name is a String and a value is either a String or a List of other Nodes, though the types are extensible to provide a flexible structure, e.g. you could use a QName as the name which includes a namespace URI and a local name. Or a JMX ObjectName etc. So this class can represent metadata like <code>{foo a=1 b="abc"}</code> or nested metadata like <code>{foo a=1 b="123" { bar x=12 text="hello" }}</code>
A List implementation which is returned by queries on a {@link Node} which provides some XPath like helper methods for GPath.
A NullObject pattern implementation for ProtectionStorage Doesn't protect any resources. Used when the user doesn't mind to eventually have the whole memoize cache emptied by gc.
Helper class for processing Groovy numeric literals.
List decorator that will trigger PropertyChangeEvents when a value changes.<br> An optional Closure may be specified and will work as a filter, if it returns true the property will trigger an event (if the value indeed changed), otherwise it won't. The Closure may receive 1 or 2 parameters, the single one being the value, the other one both the key and value, for example: <pre> // skip all properties whose value is a closure def map = new ObservableList( {!(it instanceof Closure)} ) // skip all properties whose name matches a regex def map = new ObservableList( { name, value -&gt; !(name =&tilde; /[A-Z+]/) } ) </pre> The current implementation will trigger specialized events in the following scenarios, you need not register a different listener as those events extend from PropertyChangeEvent <ul> <li>ObservableList.ElementAddedEvent - a new element is added to the list</li> <li>ObservableList.ElementRemovedEvent - an element is removed from the list</li> <li>ObservableList.ElementUpdatedEvent - an element changes value (same as regular PropertyChangeEvent)</li> <li>ObservableList.ElementClearedEvent - all elements have been removed from the list</li> <li>ObservableList.MultiElementAddedEvent - triggered by calling list.addAll()</li> <li>ObservableList.MultiElementRemovedEvent - triggered by calling list.removeAll()/list.retainAll()</li> </ul> <p> <strong>Bound properties</strong> <ul> <li><tt>content</tt> - read-only.</li> <li><tt>size</tt> - read-only.</li> </ul>
Map decorator that will trigger PropertyChangeEvents when a value changes.<br> An optional Closure may be specified and will work as a filter, if it returns true the property will trigger an event (if the value indeed changed), otherwise it won't. The Closure may receive 1 or 2 parameters, the single one being the value, the other one both the key and value, for example: <pre> // skip all properties whose value is a closure def map = new ObservableMap( {!(it instanceof Closure)} ) // skip all properties whose name matches a regex def map = new ObservableMap( { name, value -&gt; !(name =~ /[A-Z+]/) } ) </pre> The current implementation will trigger specialized events in the following scenarios, you need not register a different listener as those events extend from PropertyChangeEvent <ul> <li>ObservableMap.PropertyAddedEvent - a new property is added to the map</li> <li>ObservableMap.PropertyRemovedEvent - a property is removed from the map</li> <li>ObservableMap.PropertyUpdatedEvent - a property changes value (same as regular PropertyChangeEvent)</li> <li>ObservableMap.PropertyClearedEvent - all properties have been removed from the map</li> <li>ObservableMap.MultiPropertyEvent - triggered by calling map.putAll(), contains Added|Updated events</li> </ul> <p> <strong>Bound properties</strong> <ul> <li><tt>content</tt> - read-only.</li> <li><tt>size</tt> - read-only.</li> </ul>
Set decorator that will trigger PropertyChangeEvents when a value changes.<br> An optional Closure may be specified and will work as a filter, if it returns true the property will trigger an event (if the value indeed changed), otherwise it won't. The Closure may receive 1 or 2 parameters, the single one being the value, the other one both the key and value, for example: <pre> // skip all properties whose value is a closure def set = new ObservableSet( {!(it instanceof Closure)} ) &lt;p/&gt; // skip all properties whose name matches a regex def set = new ObservableSet( { name, value -&gt; !(name =&tilde; /[A-Z+]/) } ) </pre> The current implementation will trigger specialized events in the following scenarios, you need not register a different listener as those events extend from PropertyChangeEvent <ul> <li>ObservableSet.ElementAddedEvent - a new element is added to the set</li> <li>ObservableSet.ElementRemovedEvent - an element is removed from the set</li> <li>ObservableSet.ElementUpdatedEvent - an element changes value (same as regular PropertyChangeEvent)</li> <li>ObservableSet.ElementClearedEvent - all elements have been removed from the list</li> <li>ObservableSet.MultiElementAddedEvent - triggered by calling set.addAll()</li> <li>ObservableSet.MultiElementRemovedEvent - triggered by calling set.removeAll()/set.retainAll()</li> </ul> <p> <strong>Bound properties</strong> <ul> <li><tt>content</tt> - read-only.</li> <li><tt>size</tt> - read-only.</li> </ul>
A helper class for sorting objects via a closure to return the field or operation on which to sort.
Handles transformation for the @PackageScope annotation. <p> Both the deprecated groovy.lang.PackageScope and groovy.transform.PackageScope annotations are supported. The former will be removed in a future version of Groovy.
This class defines new Java 5 specific groovy methods which extend the normal JDK classes inside the Groovy environment. Static methods are used with the first parameter the destination class.
A base class for data structures that can collect messages and errors during processing.
<p>An interface that adds the ability to intercept property getters/setters
Classes to generate 'Proxy' objects which implement interfaces, maps of closures and/or extend classes/delegates.
As subclass of MetaClass, ProxyMetaClass manages calls from Groovy Objects to POJOs. It enriches MetaClass with the feature of making method invokations interceptable by an Interceptor. To this end, it acts as a decorator (decorator pattern) allowing to add or withdraw this feature at runtime. See groovy/lang/InterceptorTest.groovy for details. <p> WARNING: This implementation of ProxyMetaClass is NOT thread-safe and hence should only be used for as a per-instance MetaClass running in a single thread. Do not place this MetaClass in the MetaClassRegistry as it will result in unpredictable behaviour
<code>QName</code> class represents the value of a qualified name as specified in <a href="http://www.w3.org/TR/xmlschema-2/#QName">XML Schema Part2: Datatypes specification</a>. <p> The value of a QName contains a <b>namespaceURI</b>, a <b>localPart</b> and a <b>prefix</b>. The localPart provides the local part of the qualified name. The namespaceURI is a URI reference identifying the namespace.
Handles generation of code for the {@code @}WithReadLock and {@code @}WithWriteLock annotation.<br> This transformation adds an instance of ReentrantReadWriteLock to the class.<br> Any method annotated with {@code @}WithReadLock will obtain a read lock and release it in a finally block.<br> Any method annotated with {@code @}WithWriteLock will obtain a write lock and release it in a finally block.<br> For more information see {@link WithReadLock} and {@link WithWriteLock}

A reverse iterator over a list. Utilizes the {@link ListIterator} obtained from the provided {@link List} and converts it to an {@link Iterator} that efficiently traverses the <code>List</code> in reverse. The fail-fast semantics of this iterator are the same as the semantics of the underlying <code>ListIterator</code>.
Injects a set of Comparators and sort methods.
An antlr AST visitor that prints groovy source code for each visited node to the supplied PrintStream.
Static compilation AST node metadata keys. if a receiver is the receiver of a dynamic property (for mixed mode compilation)
This visitor is responsible for amending the AST with static compilation metadata or transform the AST so that a class or a method can be statically compiled. It may also throw errors specific to static compilation which are not considered as an error at the type check pass. For example, usage of spread operator is not allowed in statically compiled portions of code, while it may be statically checked. Static compilation relies on static type checking, which explains why this visitor extends the type checker visitor.

Static support methods for {@link StaticTypeCheckingVisitor}.
The main class code visitor responsible for static type checking. It will perform various inspections like checking assignment types, type inference, ... Eventually, class nodes may be annotated with inferred type information.
A call site writer which replaces call site caching with static calls. This means that the generated code looks more like Java code than dynamic Groovy code. Best effort is made to use JVM instructions instead of calls to helper methods.
Writer responsible for generating closure classes in statically compiled mode.
This enumeration is used by the AST transformations which rely on static type checking, either to store or to retrieve information from AST node metadata. The values of this enumeration are used as metadata keys. used to store the list of MOP methods that still have to be generated
This class defines new groovy methods which appear on String-related JDK classes (String, CharSequence, Matcher) inside the Groovy environment. Static methods are used with the first parameter being the destination class, e.g.. <code>public static String reverse(String self)</code> provides a <code>reverse()</code> method for <code>String</code>. <p> NOTE: While this class contains many 'public' static methods, it is primarily regarded as an internal class (its internal package name suggests this also). We value backwards compatibility of these methods when used within Groovy but value less backwards compatibility at the Java method call level. I.e. future versions of Groovy may remove or move a method call in this file but would normally aim to keep the method available from within Groovy.
Handles generation of code for the {@code @Synchronized} annotation.
A class for error messages produced by the parser system.
Handles generation of code for the @ToString annotation.
This class contains a static utility method {@link #doExtendTraits(org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.control.CompilationUnit)} aimed at generating code for a classnode implementing a trait.
A collection of utility methods used to deal with traits.
A TrampolineClosure wraps a closure that needs to be executed on a functional trampoline. Upon calling, a TrampolineClosure will call the original closure waiting for its result. If the outcome of the call is another instance of a TrampolineClosure, created perhaps as a result to a call to the TrampolineClosure.trampoline() method, the TrampolineClosure will again be invoked. This repetitive invocation of returned TrampolineClosure instances will continue until a value other than TrampolineClosure is returned. That value will become the final result of the trampoline.
Helper Class for Antlr AST traversal and visitation.
Handles generation of code for the @TupleConstructor annotation.
An interface for visiting a GroovySourceAST node.
A default implementation of all visitor methods. If you extend this class, any un-overridden visit methods will call visitDefault.
