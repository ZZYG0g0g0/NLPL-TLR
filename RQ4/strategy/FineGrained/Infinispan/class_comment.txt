Super hacky class that allows the client and server hello message to be modified and the corresponding hash generated at runtime.
This class is used to both read and write the ALPN protocol names in the ClientHello SSL message. If the out parameter is not null then the read function is being used, while if it present then it is rewriting the hello message to include ALPN. Even though this dual approach is not particularly clean it does remove the need to have two versions of each function, that do almost exactly the same thing.
SSLEngine wrapper that provides some super hacky ALPN support on JDK8. Even though this is a nasty hack that relies on JDK internals it is still preferable to modifying the boot class path. It is expected to work with all JDK8 versions, however this cannot be guaranteed if the SSL internals are changed in an incompatible way. This class will go away once JDK8 is no longer in use.
Super hacky class that allows the ServerHello message to be modified and the corresponding hash generated at runtime.
Hacks up ALPN support into the server hello message This has two different usage modes, one is adding a selected protocol into the extensions, the other is removing all mention of ALPN and retuning the selected protocol. This dual mode does not make for the cleanest code but removes the need to have duplicate nearly identical methods. The if the selected protocol is set then this will be added. If the selected protocol is null then ALPN will be parsed and removed. <p> We only care about TLS 1.2, as TLS 1.1 is not allowed to use ALPN. <p> Super hacky, but slightly less hacky than modifying the boot class path


AbstractAdvancedCacheAction. A helper abstract for writing {@link java.security.PrivilegedAction}s which require an {@link org.infinispan.AdvancedCache}
A bridge for passing events between Infinispan (both embedded and remote) and Spring.



This is a base class that should be used when implementing a CacheEventFilterConverter that provides default implementations for the {@link org.infinispan.notifications.cachelistener.filter.CacheEventFilter#accept(Object, Object, org.infinispan.metadata.Metadata, Object, org.infinispan.metadata.Metadata, EventType)} and {@link org.infinispan.filter.Converter#convert(Object, Object, org.infinispan.metadata.Metadata)}  methods so they just call the {@link org.infinispan.notifications.cachelistener.filter.CacheEventFilterConverter#filterAndConvert(Object, Object, org.infinispan.metadata.Metadata, Object, org.infinispan.metadata.Metadata, EventType)} method and then do the right thing.
Abstract class providing stock implementations for {@link CacheIgnoreAware} so all that is required is to extend this class.
Base {@link javax.cache.annotation.CachePut} interceptor implementation.
<p>{@link javax.cache.annotation.CacheRemoveAll} interceptor implementation. This interceptor uses the following algorithm describes in JSR-107.</p> <p>The interceptor that intercepts method annotated with {@code @CacheRemoveAll} must do the following, remove all entries associated with the cache. The removeAll occurs after the method body is executed. This can be overridden by specifying a afterInvocation attribute value of false. If afterInvocation is true and the annotated method throws an exception, the removeAll will not happen.</p>
<p>{@link javax.cache.annotation.CacheRemove} interceptor implementation.This interceptor uses the following algorithm describes in JSR-107.</p> <p>The interceptor that intercepts method annotated with {@code @CacheRemoveEntry} must do the following, generate a key based on InvocationContext using the specified {@link javax.cache.annotation.CacheKeyGenerator}, use this key to remove the entry in the cache. The remove occurs after the method body is executed. This can be overridden by specifying a afterInvocation attribute value of false. If afterInvocation is true and the annotated method throws an exception the remove will not happen.</p>
<p>{@link javax.cache.annotation.CacheResult} interceptor implementation. This interceptor uses the following algorithm describes in JSR-107.</p> <p>When a method annotated with {@link javax.cache.annotation.CacheResult} is invoked the following must occur. <ol> <li>Generate a key based on InvocationContext using the specified {@linkplain javax.cache.annotation.CacheKeyGenerator}.</li> <li>Use this key to look up the entry in the cache.</li> <li>If an entry is found return it as the result and do not call the annotated method.</li> <li>If no entry is found invoke the method.</li> <li>Use the result to populate the cache with this key/result pair.</li> </ol> There is a skipGet attribute which if set to true will cause the method body to always be invoked and the return value put into the cache. The cache is not checked for the key before method body invocation, skipping steps 2 and 3 from the list above. This can be used for annotating methods that do a cache.put() with no other consequences.</p>

Abstract stream that provides all of the common functionality required for all types of Streams including the various primitive types.
Base class for local and remote transaction. Impl note: The aggregated modification list and lookedUpEntries are not instantiated here but in subclasses. This is done in order to take advantage of the fact that, for remote transactions we already know the size of the modifications list at creation time.
Abstract collection that uses an underlying Cache instance to do various operations.  This is useful for a backing collection such as entrySet, keySet or values from the Map interface.  Implementors only need to implement individual methods such as {@link Collection#contains(Object)}, {@link Collection#remove(Object)} and {@link org.infinispan.commons.util.CloseableIteratorCollection#iterator()}.  The {@link Collection#add(Object)} by default will throw an {@link java.lang.UnsupportedOperationException}.
Abstract executor that contains code that should be shared by all


AbstractCodec.

Factory that creates components used internally within Infinispan, and also wires dependencies into the components. <p/> The {@link InternalCacheFactory} is a special subclass of this, which bootstraps the construction of other components. When this class is loaded, it maintains a static list of known default factories for known components, which it then delegates to, when actually performing the construction. <p/>
A registry where components which have been created are stored.  Components are stored as singletons, registered under a specific name. <p/> Components can be retrieved from the registry using {@link #getComponent(Class)}. <p/> Components can be registered using {@link #registerComponent(Object, Class)}, which will cause any dependencies to be wired in as well.  Components that need to be created as a result of wiring will be done using {@link #getOrCreateComponent(Class)}, which will look up the default factory for the component type (factories annotated with the appropriate {@link DefaultFactoryFor} annotation. <p/> Default factories are treated as components too and will need to be wired before being used. <p/> The registry can exist in one of several states, as defined by the {@link org.infinispan.lifecycle.ComponentStatus} enumeration. In terms of the cache, state changes in the following manner: <ul> <li>INSTANTIATED - when first constructed</li> <li>CONSTRUCTED - when created using the DefaultCacheFactory</li> <li>STARTED - when {@link org.infinispan.Cache#start()} is called</li> <li>STOPPED - when {@link org.infinispan.Cache#stop()} is called</li> </ul> <p/> Cache configuration can only be changed and will only be re-injected if the cache is not in the {@link org.infinispan.lifecycle.ComponentStatus#RUNNING} state. Thread Safety: instances of {@link GlobalComponentRegistry} can be concurrently updated so all the write operations are serialized through class intrinsic lock.
AbstractConfigurationChildBuilder.


Class to be extended to allow some control over the local topology manager when testing Infinispan. <p/> Note: create before/after method lazily when need.
Common rpc manager controls
Base counter configuration with its name, initial value and {@link Storage} mode.
Base counter configuration builder. <p> It allows to configure the counter's name, initial value and the {@link Storage} mode.
Support class for {@link CustomFailurePolicy}.


Stuff common to WriteCommands
AbstractDefaultEmbeddedCacheManagerAction. A helper abstract for writing {@link java.security.PrivilegedAction}s which require an {@link org.jboss.as.clustering.infinispan.DefaultCacheContainer}



Same as {@link AbstractDelegatingCacheCollection} except this method implements Set as well.
Delegate that forwards all the of the method calls to the underlying cache stream. This can be useful to intercept a given method call. Note that primitive stream operations are not intercepted (including those from {@link java.util.stream.BaseStream}, however defined {@link org.infinispan.BaseCacheStream} methods would be.
Delegating collection that produces closeable iterators and spliterators from the collection returned from {@link AbstractDelegatingCloseableIteratorCollection#delegate()} method.

Delegating collection that delegates all calls to the collection returned from {@link AbstractDelegatingCollection#delegate()}

Abstract Delegating handler that passes DoubleStream operations off to the underlying DoubleCacheStream but delegates {@link org.infinispan.BaseCacheStream} operations to the provided {@link CacheStream}. This allows for intercepting methods defined on <b>BaseCacheStream</b>. <p> This class is package private as it should only be created by using a map operator from another AbstractDelegating*CacheStream instance. Note that {@link AbstractDelegatingCacheStream} is public as this is the defined approach to create such a delegated stream.

Abstract cache entry set that delegates to the underlying cache for stream usage
Class to be extended to allow some control over the {@link org.infinispan.remoting.inboundhandler.PerCacheInboundInvocationHandler} in tests.
Abstract Delegating handler that passes IntStream operations off to the underlying IntCacheStream but delegates {@link org.infinispan.BaseCacheStream} operations to the provided {@link CacheStream}. This allows for intercepting methods defined on <b>BaseCacheStream</b>. <p> This class is package private as it should only be created by using a map operator from another AbstractDelegating*CacheStream instance. Note that {@link AbstractDelegatingCacheStream} is public as this is the defined approach to create such a delegated stream.
Abstract cache key set that delegates to the underlying cache for stream usage
Abstract Delegating handler that passes LongStream operations off to the underlying LongCacheStream but delegates {@link org.infinispan.BaseCacheStream} operations to the provided {@link CacheStream}. This allows for intercepting methods defined on <b>BaseCacheStream</b>. <p> This class is package private as it should only be created by using a map operator from another AbstractDelegating*CacheStream instance. Note that {@link AbstractDelegatingCacheStream} is public as this is the defined approach to create such a delegated stream.

With the introduction of global and cache marshallers, there's a need to separate marshallers but still rely on the same marshalling backend as previously. So, this class acts as a delegator for the new marshallers.

Designed to be overwrite.
Abstract class holding tests for Remote Task Execution in Distributed mode.
AbstractEmbeddedCacheManagerAction. A helper abstract for writing {@link PrivilegedAction}s which require an {@link EmbeddedCacheManager}
<p> An abstract base class for factories creating cache managers that are backed by an EmbeddedCacheManager. </p>
Hot Rod encoder for protocol version 1.1
Base class for both Sync and XAResource enlistment adapters.
Abstract class that provides a method to round up to the nearest value of 8 which is important for most jvm when doing size calculations.  This is due to the fact that most JVMs align to the nearest 8 bytes for addressing purposes. {@inheritDoc }

Base class for {@link AdvancedExternalizer} implementations that offers default implementations for some of its methods. In particular, this base class offers a default implementation for {@link org.infinispan.commons.marshall.AdvancedExternalizer#getId()} that returns null which is particularly useful for advanced externalizers whose id will be provided by XML or programmatic configuration rather than the externalizer implementation itself.

Base class for those commands that can carry flags.
Terminal rehash aware operation that handles for each where no flat map operations are defined on a {@link DoubleStream}. Note this means it is an implied map intermediate operation.
Terminal rehash aware operation that handles for each where no flat map operations are defined on a {@link IntStream}. Note this means it is an implied map intermediate operation.
Terminal rehash aware operation that handles for each where no flat map operations are defined on a {@link LongStream}. Note this means it is an implied map intermediate operation.
This is a base operation class for the use of the for each terminal operator.  This class can be used for any forEach configuration, however since it relies on generics it may not be as performant as a primitive based for each operation. This class assumes the stream is composed of {@link java.util.Map.Entry} instances where the key is typed the same as defined K type.
Abstract functional map, providing implementations for some of the shared methods.


Base class for HotRod rolling upgrade tests.
AbstractHotRodServerChildConfigurationBuilder.
<p> A base class for implementing {@link Bean}. The attributes are immutable, and collections are defensively copied on instantiation. It uses the defaults from the specification for properties if not specified. </p> <p/> <p> This class does not provide any bean lifecycle operations </p>
Infinispan implementation for Spring Session with basic functionality.
Checks that if the interceptor handles one command it handles all conceptually similar ones.
An abstract internal cache entry that is typically stored in the data container
Common features of transaction and invocation contexts
Base class for InvocationContextFactory implementations.
This is the abstract superclass of the 2 iterators. Since some of the methods have the same implementations they have been put onto a separate class.
Common parent for both embedded and standalone JBoss Marshalling-based marshallers.


Infinispan's implementation of {@link javax.cache.CacheManager}.
JCache notifications dispatcher. TODO: Deal with asynchronous listeners...
Shared behavior for the embedded and client-server implementations.




AbstractJdbcStoreConfigurationChildBuilder.
AbstractJdbcStoreConfigurationSerializer.

Parent class for top level JMX component registration.
Basic class for all hot rod operations that manipulate a key.
This is a base class that should be used when implementing a KeyValueFilterConverter that provides default implementations for the {@link org.infinispan.filter.KeyValueFilter#accept(Object, Object, org.infinispan.metadata.Metadata)} and {@link org.infinispan.filter.Converter#convert(Object, Object, org.infinispan.metadata.Metadata)} methods so they just call the {@link org.infinispan.filter.KeyValueFilterConverter#filterAndConvert(Object, Object, org.infinispan.metadata.Metadata)} method and then do the right thing.
Base class for all operations that manipulate a key and a value.
This server setup task creates a krb5.conf file and generates KeyTab files for the LDAP server and ISPN users The task also sets system properties <ul> <li>"java.security.krb5.conf" - path to the newly created krb5.conf is set</li> <li>"sun.security.krb5.debug" - true is set (Kerberos debugging for Oracle Java)</li> </ul>
Functionality common to both {@link org.infinispan.notifications.cachemanagerlistener.CacheManagerNotifierImpl} and {@link org.infinispan.notifications.cachelistener.CacheNotifierImpl}
Implements the base operations required for a local stream. stream is populated
Abstract class
Base class for various locking interceptors in this package.
Similar to the JDK's AbstractMap, this provides common functionality for custom map implementations.  Unlike JDK's AbstractMap, there is no support for null keys.
Abstract Marshaller implementation containing shared implementations.
Tests for Memcached endpoint. Subclasses must provide a way to get the list of remote infinispan servers. <p/> Subclasses may be used in Client-Server mode or Hybrid mode where Memcached server runs as a library deployed in an application server.
Tests for Memcached endpoint. Subclasses must provide a way to get the list of remote infinispan servers. <p/> Subclasses may be used in Client-Server mode or Hybrid mode where Memcached server runs as a library deployed in an application server.
Abstract class to create mixed {@link SiteStatus}. <p> Mixed {@link SiteStatus} are status in which some considers the site to be online and other to be offline.
AbstractModuleConfigurationBuilder.
A default, no-op implementation of the {@link org.infinispan.lifecycle.ModuleLifecycle} interface, designed for easy extension.
A component factory for creating components scoped per-cache.




AbstractPersistenceConfigurationChildBuilder.

A common protocol server dealing with common property parameter validation and assignment and transport lifecycle.
Helper
Tests for the REST client putAsync header.
Tests for the REST client. Subclasses must implement the addRestServer, which has to setup the RESTHelper by calling RESTHelper.addServer method.
Tests for the RESTLocal client.
Tests for HotRod client and its RemoteCache API. Subclasses must provide a way to get the list of remote HotRod servers and to assert the cache is empty. <p/> Subclasses may be used in Client-Server mode or Hybrid mode where HotRod server runs as a library deployed in an application server.
<p> An abstract base class for factories creating cache manager that are backed by an Infinispan RemoteCacheManager. </p>
Tests for HotRod client and its RemoteCacheManager API. Subclasses must provide a way to get the list of remote HotRod servers. <p/> Subclasses may be used in Client-Server mode or Hybrid mode where HotRod server runs as a library deployed in an application server.
AbstractRemoteStoreConfigurationChildBuilder.
A remote invocation request. <p>Thread-safety: This class and its sub-classes are thread-safe. They use the {@code ResponseCollector}'s monitor for synchronization, so that collectors usually don't need any explicit synchronization.</p>
AbstractRestStoreConfigurationChildBuilder.


AbstractSecurityConfigurationChildBuilder.
{@link ServerSetupTask} instance for security domain setup. It supports JSSE configuration, JASPI authentication configuration and stacks of login-modules (classic authentication), policy-modules and (role-)mapping-modules.


Abstract implementation of an externalizer for a single class.
A {@link SiteStatus} builder based on its online and offline members.




AbstractStoreSerializer.
A base strong consistent counter implementation. <p> Implementation: The value is stored in a single key and it uses the Infinispan's concurrency control and distribution to apply the write and reads. It uses the functional API. <p> Writes: The writes are performed by the functional API in order. The single key approach allows us to provide atomic properties for the counter value. <p> Reads: The reads read the value from the cache and it can go remotely. <p> Weak Reads: This implementation supports weak cached reads. It uses clustered listeners to receive the notifications of the actual value to store it locally.
{@link ServerSetupTask} instance for system properties setup.

Base class for commands that carry topology id.
Hot Rod encoder for protocol version 1.1

An abstract transaction boundary command that holds a reference to a {@link org.infinispan.transaction.xa.GlobalTransaction}

Support class for transport implementations.

Support class for {@link org.infinispan.context.impl.TxInvocationContext}.
Base class for transaction based locking interceptors.

Base class for index commands
An abstract implementation of a Visitor that delegates all visit calls to a default handler which can be overridden.


A key value filter that accepts all entries found. <p> <b>This filter should be used carefully as it may cause the operation to perform very slowly as all entries are accepted.</b>
A filter that accepts all inputs of a given type. Does not support sorting and projections.
Defines the strategy for access to entity or collection data in a Infinispan instance. <p/> The intent of this class is to encapsulate common code and serve as a delegate for {@link org.hibernate.cache.spi.access.EntityRegionAccessStrategy} and {@link org.hibernate.cache.spi.access.CollectionRegionAccessStrategy} implementations.



Comment


An action represents a step in {@link org.infinispan.remoting.inboundhandler.PerCacheInboundInvocationHandler}.
A listener that is invoked when an {@link Action} is completed.
The state used by an {@link Action}. <p/> It is shared among them.
The status for an {@link Action}.
Controls activation of cache entries that have been passivated.
Concrete implementation of activation logic manager.

The {@link BufferSizePredictor} that automatically increases and decreases the predicted buffer size on feed back. <p> It gradually increases the expected number of bytes if the previous buffer fully filled the allocated buffer.  It gradually decreases the expected number of bytes if the read operation was not able to fill a certain amount of the allocated buffer two times consecutively.  Otherwise, it keeps returning the same prediction. TODO: Object type hints could be useful at giving more type-specific predictions
Custom command to add an alias to a cache-container.
CacheManagerAddListenerAction.

The adding function to update the {@link CounterValue}.
Generic add operation step handler that delegates service installation/rollback to a {@link ResourceServiceHandler}.
Describes the common properties of a remove operation handler.




Flags which affect only administrative operations
AdminOperations
AdminOperationParameters
AdminOperationsHandler is a special {@link TaskEngine} which can handle admin tasks
Common base for admin server tasks


An advanced interface that exposes additional methods not available on {@link Cache}.
Defines functionality for advanced expiration techniques.  Note this interface allows for providing not just the key when an entry is expired.  This is important so that proper cluster wide expiration can be performed.
A specialised extension of the {@link CacheLoader} interface that allows processing parallel iteration over the existing entries.

This class is responsible to produce the {@link Cache} and {@link AdvancedCache}. This class use the <a href="http://docs.jboss.org/seam/3/solder/latest/reference/en-US/html_single/#genericbeans">Generic Beans</a> mechanism provided by Seam Solder.
Defines advanced functionality for persisting data to an external storage.

{@link AdvancedExternalizer} provides an alternative way to provide externalizers for marshalling/unmarshalling user defined classes that overcome the deficiencies of the more user-friendly externalizer definition model explained in {@link Externalizer}. The first noticeable difference is that this method does not require user classes to be annotated in anyway, so it can be used with classes for which source code is not available or that cannot be modified. The bound between the externalizer and the classes that are marshalled/unmarshalled is set by providing an implementation for {@link #getTypeClasses()} which should return the list of classes that this externalizer can marshall. Secondly, in order to save the maximum amount of space possible in the payloads generated, this externalizer method requires externalizer implementations to provide a positive identified via {@link #getId()} implementations or via XML/programmatic configuration that identifies the externalizer when unmarshalling a payload.  In order for this to work however, this externalizer method requires externalizers to be registered on cache manager creation time via XML or programmatic configuration. On the contrary, externalizers based on {@link Externalizer} and {@link SerializeWith} require no pre-registration whatsoever. Internally, Infinispan uses this advanced externalizer mechanism in order to marshall/unmarshall internal classes. Finally, {@link AbstractExternalizer} provides default implementations for some of the methods defined in this interface and so it's generally recommended that implementations extend that abstract class instead of implementing {@link AdvancedExternalizer} directly. Even though {@link AdvancedExternalizer} currently extends {@link java.io.Serializable} indirectly, there's no requirement for the advanced externalizer to be marshalled, because the pre-registration done on startup allows the marshaller to identify the externalizer from the given id.
Advanced interface for interacting with an external store in a read-write mode.


Not used anymore.
Handles errors occurred in the {@link AffinityIndexManager}.
{@link org.hibernate.search.indexes.spi.IndexManager} that splits the index into shards.
Key partitioner that maps keys to segments using information contained in {@link AffinityTaggedKey}. <p>If the segment is not defined (value -1) or the key is not an AffinityTaggedKey, will fallback to a {@link HashFunctionPartitioner}
Dynamic sharding based on the segment associated with the key

Handle index updates forwarded by the {@link AffinityIndexManager}, in exceptional cases where an index work ceases to be local to a node due to transient ownership changes.


Contains all parameters metadata for a method annotated with a cache annotation.



An aggregated property path (e.g. {@code SUM(foo.bar.baz)}) represented by {@link PropertyReference}s used with an aggregation function in the SELECT, HAVING or ORDER BY clause.
Builds a alias to another service.
Cluster executor implementation that sends a request to all available nodes
Signals that all owners of a key have been lost.
Netty's negotiator for Hacked ALPN SSL Engine.
Hacked ALPN SSL Context for Netty.

Hacked ALPN SSL Session for Netty. This class allows to grab negotiated protocols out of Hacked ALPN SSL Engine.






The base class for all New Annotated types.



<p> Class for constructing a new AnnotatedType. A new instance of builder should be used for each annotated type. </p> <p/> <p> {@link AnnotatedTypeBuilder} is not thread-safe. </p>
AnnotatedType implementation for adding beans in the BeforeBeanDiscovery event
<p> Utilities for working with {@link Annotated}s. </p> <p/> <p> Includes utilities to check the equality of and create unique id's for <code>Annotated</code> instances. </p>
Helper class used to build annotation stores
CDI extension to register additional interceptor bindings
A helper class used to hold annotations on a type or member.

A compare function for objects.

AnyServerEquivalence. Works for both objects and byte[]



Replacement for {@link org.infinispan.commands.write.ApplyDeltaCommand} and {@link org.infinispan.context.Flag#DELTA_WRITE}. Deprecated since {@link Delta}, {@link org.infinispan.atomic.DeltaAware} and {@link org.infinispan.atomic.CopyableDeltaAware} are deprecated, too. TODO: to be removed in Infinispan 10.0




Externalizers for diverse array types.
An immutable Iterator for arrays.
Base for classes that implement hash map by storing keys in one array and values in another. It assumes that all keys that are in the array are contained in the map and that values are on corresponding indices in the map. Does not support null keys nor values. Forces implementation of methods {@link #get(Object)}, {@link #put(Object, Object)}, {@link #remove(Object)}
A collection of utilities for working with Arrays that goes beyond that in the JDK.
Performs as double operation on a {@link IntStream}
Performs as double operation on a {@link LongStream}
Performs as long operation on a {@link IntStream}


AsyncCache. This interface is implemented by caches which support asynchronous variants of the various put/get/remove/clear/replace/putAll methods Note that these methods only really make sense if you are using a clustered cache.  I.e., when used in LOCAL mode, these "async" operations offer no benefit whatsoever.  These methods, such as {@link #putAsync(Object, Object)} offer the best of both worlds between a fully synchronous and a fully asynchronous cache in that a {@link CompletableFuture} is returned.  The <tt>CompletableFuture</tt> can then be ignored or thrown away for typical asynchronous behaviour, or queried for synchronous behaviour, which would block until any remote calls complete. Note that all remote calls are, as far as the transport is concerned, synchronous.  This allows you the guarantees that remote calls succeed, while not blocking your application thread unnecessarily.  For example, usage such as the following could benefit from the async operations: <pre> CompletableFuture f1 = cache.putAsync("key1", "value1"); CompletableFuture f2 = cache.putAsync("key2", "value2"); CompletableFuture f3 = cache.putAsync("key3", "value3"); f1.get(); f2.get(); f3.get(); </pre> The net result is behavior similar to synchronous RPC calls in that at the end, you have guarantees that all calls completed successfully, but you have the added benefit that the three calls could happen in parallel.  This is especially advantageous if the cache uses distribution and the three keys map to different cache instances in the cluster. <p/> Also, the use of async operations when within a transaction return your local value only, as expected.  A {@link CompletableFuture} is still returned though for API consistency. <p/>

The AsyncCacheWriter is a delegating CacheStore that buffers changes and writes them asynchronously to the underlying CacheStore. <p/> Read operations are done synchronously, taking into account the current state of buffered changes. <p/> There is no provision for exception handling for problems encountered with the underlying store during a write operation, and the exception is just logged. <p/> When configuring the loader, use the following element: <p/> <code> &lt;async enabled="true" /&gt; </code> <p/> to define whether cache loader operations are to be asynchronous. If not specified, a cache loader operation is assumed synchronous and this decorator is not applied. <p/> Write operations affecting same key are now coalesced so that only the final state is actually stored. <p/>
Defines the service contract for the Executor which we'll use in combination with the Infinispan Lucene Directory, as this provides an option to execute delete operations in background. It is important to run delete operations in background as while these are simple from a computational point of view, they will introduce a significant delay on write operations when Infinispan is running in clustered mode. This is implemented as a Service so that integrations can inject a different managed threadpool, and we can share the same executor among multiple IndexManagers.
Interface for sequential interceptors.
Interceptor chain using {@link AsyncInterceptor}s. Experimental: The ability to modify the interceptors at runtime may be removed in future versions.
Knows how to build and manage a chain of interceptors. Also in charge with invoking methods on the chain.
Configuration for the async cache store. If enabled, this provides you with asynchronous writes to the cache store, giving you 'write-behind' caching.
Configuration for the async cache store. If enabled, this provides you with asynchronous writes to the cache store, giving you 'write-behind' caching.
Builder for asynchronously started/stopped services.
This class is expected to be modified without locking, and results merged using the {@link #merge(Object)} method when committing to DC. Also, the keys are not persisted, we record only existence of this map and then upon load we retrieve the keys through {@link GetKeysInGroupCommand}. On transactional cache it is safe to execute concurrent adds/removes to this class even without the lock because we'll never prepare-commit another transaction that would modify the same key concurrently - the transaction will be synchronized on the modified key (which acquires locks properly). This is kind of piggybacking on other key's locking scheme. The only exception to that rule is when we attempt to remove this map completely - this is not safe to proceed concurrently to any other modification.
This is a special type of Map geared for use in Infinispan.  AtomicMaps have two major characteristics: <ol> <li>Atomic locking and isolation over the entire collection</li> <li>Replication of updates through deltas</li> </ol> <b><u>1.  Atomic locking and isolation over the entire collection</u></b> <p> This allows the entire AtomicMap to be locked when making changes even to certain entries within the map, and also isolates the map for safe reading (see {@link IsolationLevel} while concurrent writes may be going on. </p> <br /> <b><u>2.  Replication of updates through deltas</u></b> <p> As a performance optimization, when the map is updated the maps do not replicate all entries to other nodes but only the modifications. </p> <br /> <b><u>Usage</u></b> <p> AtomicMaps should be constructed and "registered" with Infinispan using the {@link AtomicMapLookup} helper.  This helper ensures threadsafe construction and registration of AtomicMap instances in Infinispan's data container.  E.g.: <br /> <code> AtomicMap&lt;String, Integer&gt; map = AtomicMapLookup.getAtomicMap(cache, "my_atomic_map_key"); </code> </p> <p><b><u>Referential Integrity</u></b><br /> It is important to note that concurrent readers of an AtomicMap will essentially have the same view of the contents of the underlying structure, but since AtomicMaps use internal proxies, readers are isolated from concurrent writes and {@link IsolationLevel#READ_COMMITTED} and {@link IsolationLevel#REPEATABLE_READ} semantics are guaranteed. However, this guarantee is only present if the values stored in an AtomicMap are <i>immutable</i> (e.g., Strings, primitives, and other immutable types).</p> <p>Mutable value objects which happen to be stored in an AtomicMap may be updated and, prior to being committed, or even replaced in the map, be visible to concurrent readers.  Hence, AtomicMaps are <b><i>not suitable</i></b> for use with mutable value objects.</p> </p> <br /> <p> This interface, for all practical purposes, is just a marker interface that indicates that maps of this type will be locked atomically in the cache and replicated in a fine grained manner, as it does not add any additional methods to {@link java.util.Map}. </p>
A cache wrapper that simplifies atomic map semantics.
A helper that locates or safely constructs and registers atomic maps with a given cache.  This should be the <b>only</b> way AtomicMaps are created/retrieved, to prevent concurrent creation, registration and possibly overwriting of such a map within the cache.
This is the proxy class driving access to the entry in cache using functional API. The value in cache is a map of type defined by {@link #dataClass()} which is accompanied by {@link #dataInstance()} and {@link #dataCopy(Map)}. Currently it is implemented by {@link FastCopyHashMap} as we need to create a defensive copy of the value in context. The map is expected to be used with transactional caches; upon map creation or read, the whole map is cached in the transactional context and subsequent reads are served from here. When the map is modified, the change is applied to the local copy in the context. Modifications are added in the form of functional commands to the transaction and executed opon commit. In non-transactional mode this map works correctly, but since any read results in retrieving the whole map, its use might not be very efficient. This behaviour may be addressed in the future. Collections returned by {@link #keySet()}, {@link #values()} and {@link #entrySet()} are backed by the map. Iterators work on a snapshot obtained at the moment when this iterator is created, and support the {@link Iterator#remove()} operation. This implementation does not support fine-grained locking nor fine-grained write-skew check.



AttributeCopier. Usually an attribute is copied by using the {@link Object#clone()} method. When this method is not enough, you can provide a custom attribute copier by implementing this interface
AttributeDefinition. Defines the characteristics of a configuration attribute. It is used to construct an actual {@link Attribute} holder. An attribute definition has the following characteristics: <ul> <li>A name</li> <li>A default value or a value initializer</li> <li>A type, which needs to be specified if it cannot be inferred from the default value, i.e. when it is null</li> <li>Whether an attribute is immutable or not, i.e. whether its value is constant after initialization or it can be changed</li> <li>A validator which intercepts invalid values</li> </ul>
AttributeInitializer. Provides a way to initialize an attribute's value, whenever this needs to be done at Attribute construction time. This is usually needed when the value is a mutable object.
An AttributeListener will be invoked whenever an attribute has been modified.
{@link AttributeMarshaller} utilities.
An attribute node represents a single attribute and keeps track of subscribed predicates and projections.
AttributeSet is a container for {@link Attribute}s. It is constructed by passing in a list of {@link AttributeDefinition}s. AttributeSets are initially unprotected, which means that the contained attributes can be modified. If the {@link #protect()} method is invoked then only attributes which are not {@link AttributeDefinition#isImmutable()} can be modified from then on.
AttributeValidator.
AuditContext.
AuditLogger.
AuditMessages. Messages used by the security audit

Obtains a list of SASL authentication mechanisms supported by the server
Performs a step in the challenge/response authentication operation
AuthenticationAdd.
AuthenticationConfiguration.
AuthenticationConfigurationBuilder.
Exception thrown then authentication fails.
Handler that when added will make sure authentication is applied to requests.
AuthenticationResource.
Authentication mechanism.

AuthorizationConfiguration.
AuthorizationConfigurationBuilder.
AuthorizationHelper. Some utility methods for computing access masks and verifying them against permissions
The AuthorizationManager is a cache-scoped component which verifies that the {@link Subject} associated with the current {@link AccessControlContext}, or explicitly specified, has the requested permissions.

AuthorizationManagerImpl. An implementation of the {@link AuthorizationManager} interface.
AuthorizationPermission.
AuthorizationRoleResource.
AuthorizingCallbackHandler. A {@link CallbackHandler} which allows retrieving the {@link Subject} which has been authorized wrapped in a {@link SubjectUserInfo}
Enables for automatic batching.
Component factories that implement this interface can be instantiated automatically by component registries when looking up components.  Typically, most component factories will implement this.  One known exception is the {@link org.infinispan.factories.BootstrapFactory}. <p/> Anything implementing this interface should expose a public, no-arg constructor. <p/>
Thrown when a partition happened and the key that an operation tries to access is not available.

Implementations decide what to do when the cache membership changes, either because new nodes joined, nodes left, or there was a merge. The decision is then applied by calling one of the {@link AvailabilityStrategyContext} methods. The strategy can also queue actions until the current rebalance ends, and execute them on {@link #onRebalanceEnd(AvailabilityStrategyContext)}. Method invocations are synchronized, so it's not possible to have concurrent invocations.
Contains information about the current state of the cache. Also allows {@link AvailabilityStrategy} to proceed with a rebalance, a membership update, or an availability mode change.
{@link PartitionHandlingManager} implementation when the cluster is always available.
Computes the average of {@link Number}s. The output type is always a {@link Double}. Nulls are excluded from the computation. If there are no remaining non-null values to which the aggregate function can be applied, the result of the aggregate function is {@code null}. <p> The implementation uses compensated summation in order to reduce the error bound in the numerical sum compared to a simple summation of {@code double} values similar to the way {@link java.util.DoubleSummaryStatistics} works.
Base boolean expression Node.
Boolean expression tree representation. A tree is immutable and could be shared by multiple filters.
Creates a BETree out of a BooleanExpr.
A command that represents an acknowledge sent by a backup owner to the originator. <p> The acknowledge signals a successful execution of the operation.


Exception to be used to signal failures to backup to remote sites.
Defines the possible behaviour in case of failure during x-site.

Defines the remote caches for which this cache acts as a backup.
A command that represents an acknowledge sent by a backup owner to the originator. <p> The acknowledge signals a successful execution of a multi-key command, like {@link PutMapCommand}. It contains the segments ids of the updated keys.
A command sent from the primary owner to the backup owners for a {@link PutMapCommand}. <p> This command is only visited by the backups owner and in a remote context. The command order is set by {@code segmentsAndSequences} map.
Component present on a backup site that manages the backup information and logic.
{@link org.infinispan.xsite.BackupReceiver} delegator. Mean to be overridden. For test purpose only!
Global component that holds all the {@link BackupReceiver}s within this CacheManager.
{@link org.infinispan.xsite.BackupReceiverRepository} delegator. Mean to be overridden. For test purpose only!

Represents a response from a backup replication call.
Component responsible with sending backup data to remote sites. The send operation is executed async, it's up to the caller to wait on the returned {@link BackupResponse} in the case it wants an sync call.



Cross-Site state transfer resource.
A command sent from the primary owner to the backup owners of a key with the new update. <p> This command is only visited by the backups owner and in a remote context. No locks are acquired since it is sent in FIFO order, set by {@code sequence}. It can represent a update or remove operation.
TODO Remove this class in Infinispan 10 Encodes and decodes to and from Base64 notation. <p/> <p> Change Log: </p> <ul> <li>v2.1 - Cleaned up javadoc comments and unused variables and methods. Added some convenience methods for reading and writing to and from files.</li> <li>v2.0.2 - Now specifies UTF-8 encoding in places where the code fails on systems with other encodings (like EBCDIC).</li> <li>v2.0.1 - Fixed an error when decoding a single byte, that is, when the encoded data was a single byte.</li> <li>v2.0 - I got rid of methods that used booleans to set options. Now everything is more consolidated and cleaner. The code now detects when data that's being decoded is gzip-compressed and will decompress it automatically. Generally things are cleaner. You'll probably have to change some method calls that you were making to support the new options format (<tt>int</tt>s that you "OR" together).</li> <li>v1.5.1 - Fixed bug when decompressing and decoding to a byte[] using <tt>decode( String s, boolean gzipCompressed )</tt>. Added the ability to "suspend" encoding in the Output Stream so you can turn on and off the encoding if you need to embed base64 data in an otherwise "normal" stream (like an XML file).</li> <li>v1.5 - Output stream pases on flush() command but doesn't do anything itself. This helps when using GZIP streams. Added the ability to GZip-compress objects before encoding them.</li> <li>v1.4 - Added helper methods to read/write files.</li> <li>v1.3.6 - Fixed OutputStream.flush() so that 'position' is reset.</li> <li>v1.3.5 - Added flag to turn on and off line breaks. Fixed bug in input stream where last buffer being read, if not completely full, was not returned.</li> <li>v1.3.4 - Fixed when "improperly padded stream" error was thrown at the wrong time.</li> <li>v1.3.3 - Fixed I/O streams which were totally messed up.</li> </ul> <p/> <p> I am placing this code in the Public Domain. Do with it as you will. This software comes with no guarantees or warranties but with plenty of well-wishing instead! Please visit <a href="http://iharder.net/base64">http://iharder.net/base64</a> periodically to check for updates or to contribute improvements. </p>
Base class for an interceptor in the new asynchronous invocation chain.

Common implementation logic for {@link org.infinispan.xsite.BackupReceiver}
Common logic to handle {@link org.infinispan.commands.remote.CacheRpcCommand}.
<p> A simple, woefully incomplete {@code DAO} for storing, retrieving and removing {@link org.infinispan.spring.provider.sample.entity.Book <code>Books</code>}. </p>
Interface that defines the base methods of all streams returned from a {@link Cache}.  This interface is useful to hold a reference to any of the types while still being able to invoke some methods.


Base consistent hash factory that contains a single segments
Anyone using the {@link AsyncInterceptorChain#addInterceptor(AsyncInterceptor, int)} method (or any of its overloaded forms) or registering custom interceptors via XML should extend this base class when creating their own custom interceptors. <p /> Annotations on custom interceptors, including {@link Inject}, {@link Start} and {@link Stop} will not be respected and callbacks will not be made. <p /> Instead, custom interceptor authors should extend this base class to gain access to {@link Cache} and {@link EmbeddedCacheManager}, from which other components may be accessed.  Further, lifecycle should be implemented by overriding {@link #start()} and {@link #stop()} as defined in this class.
Anyone using the {@link org.infinispan.AdvancedCache#addInterceptor(CommandInterceptor, int)} method (or any of its overloaded forms) or registering custom interceptors via XML should extend this base class when creating their own custom interceptors. <p /> As of Infinispan 5.1, annotations on custom interceptors, including {@link Inject}, {@link Start} and {@link Stop} will not be respected and callbacks will not be made. <p /> Instead, custom interceptor authors should extend this base class to gain access to {@link Cache} and {@link EmbeddedCacheManager}, from which other components may be accessed.  Further, lifecycle should be implemented by overriding {@link #start()} and {@link #stop()} as defined in this class.
Base class for distribution of entries across a cluster.
Base class for embedded-mode query implementations. Subclasses need to implement {@link #getIterator()} and {@link #getComparator()} methods and this class will take care of sorting (fully in-memory).
Common logic for the {@link ExtendedStatisticsContainer}
A base function to update an existing counter.
Support for Infinispan {@link GeneralDataRegion} implementors.


Base class for store resources which require common store attributes and JDBC store attributes

Base class for loader resources which require common loader attributes only.
Default factory for locks obtained in <code>InfinispanDirectory</code>, this factory produces instances of <code>BaseLuceneLock</code>.
A base {@link Action} implementation for locking. <p/> This contains the basic steps for lock acquisition: try to acquire, check when it is available and acquired (or not).
Inter-IndexWriter Lucene index lock based on Infinispan. This implementation is not bound to and does not need a TransactionManager, is more suited for large batch work and index optimization.
todo [anistor] make package local
Implementation with the default handling methods and utilities methods.
Provides the starting point for implementing a {@link org.infinispan.commons.marshall.Marshaller} that uses Protobuf encoding. Subclasses must implement just a single {@link #getSerializationContext} lookup method.



This is the base class for use when listening to segment completions when doing initial event retrieval.  This will handle keeping track of concurrent key updates as well as iteration by calling appropriate methods at the given time. <p> This base class provides a working set for tracking of entries as they are iterated on, assuming the {@link QueueingSegmentListener#markKeyAsProcessing(Object)} and method is invoked properly.  Also this class provides the events that caused entry creations that may not be processed yet that are returned by the {@link QueueingSegmentListener#findCreatedEntries()} method.
Support for Infinispan {@link Region}s. Handles common "utility" methods for an underlying named Cache. In other words, this implementation doesn't actually read or write data. Subclasses are expected to provide core cache interaction appropriate to the semantics needed.


Acts as a base for all RPC calls
Base class for RPC commands.
A base class for a state transfer interceptor. It contains the base code to avoid duplicating in the two current different implementations. <p/> Also, it has some utilities methods with the most common logic.
Base class for store resources which require common store attributes only.
Abstract instance that provides common code needed for all terminal operations.  Note this class doesn't extend any interface due to the fact that different terminal operations have possibly different interfaces to implement however all of them require the information stored here.
Support for Inifinispan {@link org.hibernate.cache.spi.TransactionalDataRegion} implementors.
BASIC authentication mechanism.
BasicCache provides the common building block for the two different types of caches that Infinispan provides: embedded and remote. <p/> For convenience, BasicCache extends {@link ConcurrentMap} and implements all methods accordingly, although methods like {@link ConcurrentMap#keySet()}, {@link ConcurrentMap#values()} and {@link ConcurrentMap#entrySet()} are expensive (prohibitively so when using a distributed cache) and frequent use of these methods is not recommended. <p /> Other methods such as {@link #size()} provide an approximation-only, and should not be relied on for an accurate picture as to the size of the entire, distributed cache.  Remote nodes are <i>not</i> queried and in-fly transactions are not taken into account, even if {@link #size()} is invoked from within such a transaction. <p/> Also, like many {@link ConcurrentMap} implementations, BasicCache does not support the use of <tt>null</tt> keys or values. <p/> <h3>Unsupported operations</h3> <p>{@link #containsValue(Object)}</p> Please see the <a href="http://www.jboss.org/infinispan/docs">Infinispan documentation</a> and/or the <a href="https://docs.jboss.org/author/display/ISPN/Getting+Started+Guide#GettingStartedGuide-5minutetutorial">5 Minute Usage Tutorial</a> for more details. <p/>
<tt>BasicCacheContainer</tt> defines the methods used to obtain a {@link org.infinispan.api.BasicCache}. <p/>
A basic {@link CallbackHandler}. This can be used for PLAIN and CRAM-MD mechanisms
BasicEventLogger. An event logger which doesn't do anything aside from sending events to the logger
Factory that creates {@link Log} instances.

Invoker that starts and ends a batch, if none exists.
A container for holding thread locals for batching, to be used with the {@link org.infinispan.Cache#startBatch()} and {@link org.infinispan.Cache#endBatch(boolean)} calls.

Mocks transaction coordinator when {@link org.hibernate.engine.spi.SessionImplementor} is only mocked and {@link org.infinispan.transaction.tm.BatchModeTransactionManager} is used.
Not really a transaction manager in the truest sense of the word.  Only used to batch up operations.  Proper transactional semantics of rollbacks and recovery are NOT used here.
A simple wrapper class, necessary for Transactional stores, which allows MarshalledEntries and Object keys to be passed to a store implementation in order. This class also removes repeated operations on the same key in order to prevent redundant operations on the underlying store.  For example a tx, {put(1, "Test"); remove(1);}, will be simply written to the store as {remove(1);}.

The BatchingCache is implemented by all caches which support batching

Interceptor that captures batched calls and attaches contexts.
<p> A builder class for creating immutable beans. The builder can create {@link PassivationCapable} beans, using {@link Annotateds#createTypeId(AnnotatedType)} to generate the id. </p> <p/> <p> The builder can read from an {@link AnnotatedType} and have any attribute modified. This class is not thread-safe, but the bean created by calling {@link #create()} is. </p> <p/> <p> It is advised that a new bean builder is instantiated for each bean created. </p>
BeanConventions.
<p>This class provides access to the {@link BeanManager} by registering the current {@link BeanManager} in an extension and making it available via a singleton factory for the current application.</p> <p>This is really handy if you like to access CDI functionality from places where no injection is available.</p> <p>If a simple but manual bean-lookup is needed, it's easier to use the {@link BeanProvider}.</p> <p/> <p>As soon as an application shuts down, the reference to the {@link BeanManager} will be removed.<p> <p/> <p>Usage:<p/> <pre> BeanManager bm = BeanManagerProvider.getInstance().getBeanManager(); </pre> <p><b>Attention:</b> This method is intended for being used in user code at runtime. If this method gets used during Container boot (in an Extension), non-portable behaviour results. During bootstrapping an Extension shall &#064;Inject BeanManager to get access to the underlying BeanManager (see e.g. {@link #cleanupFinalBeanManagers} ). This is the only way to guarantee to get the right BeanManager in more complex Container scenarios.</p>
Simple JavaBean manipulation helper methods
A set of utility methods for working with beans.


BeginTransactionStatement begins a transaction
Benchmarking HTTP/1.1 and HTTP/2 is always comparing apples to bananas. Those protocols are totally different and it doesn't really whether we will use the same or other clients. Unfortunately currently there is no good support for HTTP/2 with TLS/ALPN clients. The only implementation which was reasonably good in testing was Netty (even though a lot of boilerplate code had to be generated). On the other hand HTTP/1.1 is tested using Jetty client. This client unifies the API for both of them.
An expression that represents a range of Comparable values corresponding to the BETWEEN predicate. The lower and upper bound are included.



Encoder for StoreType.BINARY. For String and primitives, store unencoded. For other objects, store them marshalled.

{@link OutputPrinter} for binary values.
Builds a ManagedReferenceFactory JNDI binding.
Utility method for inserting and retrieving values from to/from a byte[]

Interceptor that allows for waiting for a command to be invoked, blocking that command and subsequently allowing that command to be released.
Replaces the LocalTopologyManager and allows it to block the phases of the state transfer: <ul> <li>Rebalance Start</li> <li>Confirm Rebalance</li> <li>Consistent Hash Update</li> </ul>
A special Runnable (for the particular case of Total Order) that is only sent to a thread when it is ready to be executed without blocking the thread <p/> Use case: - in Total Order, when the prepare is delivered, the runnable blocks waiting for the previous conflicting transactions to be finished. In a normal executor service, this will take a thread and that thread will be blocked. This way, the runnable waits on the queue and not in the Thread <p/> Used in {@code org.infinispan.util.concurrent.BlockingTaskAwareExecutorService}
Executor service that is aware of {@code BlockingRunnable} and only dispatch the runnable to a thread when it has low (or no) probability of blocking the thread. <p/> However, it is not aware of the changes in the state so you must invoke {@link #checkForReadyTasks()} to notify this that some runnable may be ready to be processed.
A special executor service that accepts a {@code BlockingRunnable}. This special runnable gives hints about the code to be running in order to avoiding put a runnable that will block the thread. In this way, only when the runnable says that is ready, it is sent to the real executor service


Book.
Expands an input filter expression composed of indexed and unindexed fields into a superset of it (matching the set of the input filter plus some more false positives), using only indexed fields. The expanded expression is computed by applying <a href="http://en.wikipedia.org/wiki/Boole%27s_expansion_theorem">Boole's expansion theorem</a> to all non-indexed fields and then ignoring the non-indexed fields from the resulting product. The resulting product is a more complex expression but it can be executed fully indexed. In some exterme cases it can become a tautology (TRUE), indicating that the filter should be executed fully non-indexed by doing a full scan.
Unary or binary boolean condition (NOT, AND, OR).

Applies some optimisations to a boolean expression. Most notably, it brings it to NNF (Negation normal form, see http://en.wikipedia.org/wiki/Negation_normal_form). Moves negation directly near the variable by repeatedly applying the De Morgan's laws (see http://en.wikipedia.org/wiki/De_Morgan%27s_laws). Eliminates double negation. Normalizes comparison operators by replacing 'greater' with 'less'. Detects sub-expressions that are boolean constants. Simplifies boolean constants by applying boolean short-circuiting. Eliminates resulting trivial conjunctions or disjunctions that have only one child. Ensures all paths from root to leafs contain an alternation of conjunction and disjunction. This is achieved by absorbing the children whenever a boolean sub-expression if of the same kind as the parent.
An expression that applies a boolean operator (OR, AND) to a list of boolean sub-expressions.
Factory for setting up bootstrap components
Near cache based on {@link BoundedConcurrentMapNearCache}
Similar to JDK {@link java.util.concurrent.Executors} except that the factory methods here allow you to specify the size of the blocking queue that backs the executor.
Data Container implementation that stores entries in native memory (off-heap) that is also bounded.  This implementation uses a simple LRU doubly linked list off-heap guarded by a single lock. <p> The link list is represented by firstAddress as the had of the list and lastAddress as the tail of the list. Each entry in the list consists of 28 bytes (3 longs and 1 int), the first long is the actual entry address, the second is a pointer to the previous element in the list, the third is the next pointer and lastly the int is the hashCode of the key to retrieve the lock. The hashCode is required to know which lock to use when trying to read the entry.
A bounded strong consistent counter. <p> When the boundaries are reached, a {@link CounterOutOfBoundsException} is thrown. Use {@link CounterOutOfBoundsException#isUpperBoundReached()} or {@link CounterOutOfBoundsException#isLowerBoundReached()} to check if upper or lower bound has been reached, respectively.
Performs boxed operation on a {@link DoubleStream}
Performs boxed operation on a {@link IntStream}
Performs boxed operation on a {@link LongStream}

A custom reader-writer-lock combined with a bounded buffer size counter. <p/> Supports multiple concurrent writers and a single exclusive reader. This ensures that no more data is being written to the current state when the AsyncStoreCoordinator thread hands the data off to the back-end store. <p/> Additionally, {@link #writeLock(int)} blocks if the buffer is full, and {@link #readLock()} blocks if no data is available. <p/> This lock implementation is <em>not</em> reentrant!
Buffer size predictor
Building context to set construction parameters of Infinispan Directory instances
Encapsulates the logic for building a service.
BuiltBy. An annotation for configuration beans to specify what builder builds them. This annotation is required on all non-core configuration classes (i.e. ones which reside in external modules)
Reads all keys. Similar to <a href="http://community.jboss.org/wiki/HotRodBulkGet-Design">BulkGet</a>, but without the entry values.
Reads more keys at a time. Specified <a href="http://community.jboss.org/wiki/HotRodBulkGet-Design">here</a>.
This class can be used to pass an argument by reference.
A compare function for unsigned byte arrays.
Wraps byte[] on a {@link WrappedByteArray} to provide equality and hashCode support, leaving other objects unchanged.
A byte buffer that exposes the internal byte array with minimal copying. To be instantiated with {@link ByteBufferFactory}.
Used for building instances of {@link ByteBuffer}.

A byte buffer that exposes the internal byte array with minimal copying
A simple class which encapsulates a byte[] representation of a String using a predefined encoding (currently UTF-8). This avoids repeated invocation of the expensive {@link ObjectOutput#writeUTF(String)} on marshalling
Array backed {@link ObjectInput} implementation. {@link #skip(long)} and {@link #skipBytes(int)} have been enhanced so that if a negative number is passed in, they skip backwards effectively providing rewind capabilities.
Array backed, expandable {@link ObjectOutput} implementation.


CLIConsoleCallback
A read-only cache loader retrieving data from another cache(s) using the Command Line Interface.
// TODO: Document this
// TODO: Document this
XML parser for CLI cache loader configuration.
// TODO: Document this
CQCreateEagerQuery. Returns the results of a node to create a eager distributed iterator.
CQCreateLazyQuery. Creates a DocumentExtractor and register it on the node QueryBox.
CQGetResultSize. Get the result size of this query on current node
CQKillLazyIterator. Close a distributed lazy iterator...
CQLazyFetcher. Fetch a new result for a lazy iterator

Qualifier for Cache1
Qualifier for Cache2
Base class for cache add handlers
CacheAuthorizationResource.
CacheAvailabilityAttributeHandler.
Interface that describes how a cache can be injected into another object.  This is useful for cases such as after an object is deserialized and you must inject a Cache into it.
Builds CacheManager given Infinispan configuration and transport file.
CacheChildResource.
A collection type that returns special Cache based streams that have additional options to tweak behavior.
A {@link CacheCollection} that allows for a different set to be mapped as a different instance with values replaced on request.  This is useful as a cache collection that is normally lazily evaluated to prevent having to pull all values into memory which can be a lot faster when checking single values and can also prevent out of memory issues.
Helper class designed to be used to create a serializable Collector for use with {@link org.infinispan.CacheStream#collect(Collector)} from a supplier of a collector.  The problem is that the standard {@link java.util.stream.Collectors} class doesn't provide Serializable Collectors and no way to extend their functionality, so this class is used instead.
The commands interpreted by the Infinispan CLI interpreter with their handlers.
Command extensions for second-level cache use case
Command factory
The {@link CacheCommand#CACHE} handler.
Command id range assigned to Hibernate second level cache: 120 - 139
Command initializer
Custom commands related to a cache
Replaces a cache component with a dynamic proxy that can interact with a {@link StateSequencer} when a method that matches a {@link InvocationMatcher} is called.
Common code for handling the following cache configuration elements {locking, transaction, eviction, expiration, state-transfer, rehashing, store, file-store, jdbc-store, remote-store}
Base class for cache add handlers
CacheChildResource.
An exception that represents an error in the configuration.  This could be a parsing error or a logical error involving clashing configuration options or missing mandatory configuration elements.
CacheConfigurationMBeanImpl.

Base class for cache resources which require common cache attributes only.

Enumerates the supported cache types.
Extends Infinispan's {@link EmbeddedCacheManager} exposing the name of the default cache.
Add operation handler for /subsystem=infinispan/cache-container=*
CacheAuthorizationResource.

Custom commands related to the cache container.


CacheContainerConfigurationsResource.
- test start, default-cache, eviction-executor, listener-executor and replication-queue-executor attributes of cache-container element - test the cache-container attribute of hotrod-connector, so that we can have different hotrod endpoints for different containers

Remove a cache container, taking care to remove any child cache resources as well.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X
CacheContainerSecurityResource.
Enumeration of service name factories for services associated with a cache container.
Factory for generating service names for services associated with a cache container.
Similar to {@link Stats} but in the scope of a single per node CacheContainer
Cache container statistics needed for admin console
A helper class for controlling Cache Control headers.
Admin operation to create a cache Parameters: <ul> <li><strong>name</strong> the name of the cache to remove</li> <li><strong>flags</strong> </li> </ul>
Invokes operations against the cache based on the state kept during decoding process
Since there are 2 Cache implementation with exactly the same implementation details - is it convenient to introduce common abstraction and delegate all the methods. This is exactly what happens here.

This annotation should be used on methods that need to be notified when cache entries are evicted. <p/> Methods annotated with this annotation should be public and take in a single parameter, a {@link org.infinispan.notifications.cachelistener.event.CacheEntriesEvictedEvent} otherwise an {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your cache listener. <p/> Locking: notification is performed WITH locks on the given key. <p/>
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.CacheEntriesEvicted}.
This event subtype is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.CacheEntriesEvicted}.
An entry that is stored in the data container
This annotation should be used on methods that need to be notified when a cache entry is activated. <p/> Methods annotated with this annotation should be public and take in a single parameter, a {@link org.infinispan.notifications.cachelistener.event.CacheEntryActivatedEvent} otherwise an {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your cache listener. Locking: notification is performed WITH locks on the given key. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryActivated}.
This event subtype is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryActivated}.
This annotation should be used on methods that need to be notified when a cache entry is created. <p/> Methods annotated with this annotation should be public and take in a single parameter, a {@link org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent} otherwise an {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your cache listener. <p/> Locking: notification is performed WITH locks on the given key. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated}.
This event subtype is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated}.
A {@link org.infinispan.container.entries.CacheEntry} delegator
A transactional event subtype that additionally expose a key as such events pertain to a specific cache entry.
This annotation should be used on methods that need to be notified when a cache entry is expired <p/> Methods annotated with this annotation should be public and take in a single parameter, a {@link org.infinispan.notifications.cachelistener.event.CacheEntryExpiredEvent} otherwise an {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your cache listener. <p/> Locking: there is no guarantee as to whether the lock is acquired for this key, however there is internal guarantees to make sure these events are not out of order <p/> It is possible yet highly unlikely to receive this event right after a remove event even though the value was previously removed.  This can happen in the case when an expired entry in a store (not present in memory) is found by the reaper thread and a remove occurs at the same time.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryExpired}.
This event subtype is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryExpired}. <p /> The {@link #getValue()} method returns the value of the entry before it expired.  Note this value may be null if the entry expired from a cache store <p> This is a post only event <p> This event can be raised multiple times in sequence for a single expiration event if concurrent reads for the same key occur on different nodes.  This should rarely happen though since this window is narrowed internally by the cache.
This annotation should be used on methods that need to be notified when a cache entry is invalidated. <p/> Methods annotated with this annotation should be public and take in a single parameter, a {@link org.infinispan.notifications.cachelistener.event.CacheEntryInvalidatedEvent} otherwise an {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your cache listener. <p/> Locking: notification is performed WITH locks on the given key. <p> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryInvalidated}.
Notifies a listener of an invalidation event. <p> Eviction has no notion of pre/post event since 4.2.0.ALPHA4.  This event is only raised once after the eviction has occurred with the pre event flag being false.
Additional listener methods specific to caches.
This annotation should be used on methods that need to be notified when a cache entry is loaded from a {@link CacheLoader}. <p/> Methods annotated with this annotation should be public and take in a single parameter, a {@link CacheEntryLoadedEvent} otherwise an {@link IncorrectListenerException} will be thrown when registering your cache listener. <p/> Locking: notification is performed WITH locks on the given key. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryLoaded}.
This event subtype is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryLoaded}.
This annotation should be used on methods that need to be notified when a cache entry has been modified. <p/> Methods annotated with this annotation should be public and take in a single parameter, a {@link org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent} otherwise an {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your cache listener. <p/> Locking: notification is performed WITH locks on the given key. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryModified}.
This event subtype is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryModified} <p /> The {@link #getValue()} method's behavior is specific to whether the callback is triggered before or after the event in question.  For example, if <tt>event.isPre()</tt> is <tt>true</tt>, then <tt>event.getValue()</tt> would return the <i>old</i> value, prior to modification.  If <tt>event.isPre()</tt> is <tt>false</tt>, then <tt>event.getValue()</tt> would return new <i>new</i> value.  If the event is creating and inserting a new entry, the old value would be <tt>null</tt>. <p />
This annotation should be used on methods that need to be notified when cache entries are passivated. <p/> Methods annotated with this annotation should accept a single parameter, a {@link org.infinispan.notifications.cachelistener.event.CacheEntryPassivatedEvent} otherwise a {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your listener. <p/> Locking: notification is performed WITH locks on the given key. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back. ensure this annotation is available at runtime. ensure that this annotation is applied to classes.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryPassivated}.
This event subtype is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryPassivated}.
This annotation should be used on methods that need to be notified when a cache entry is removed from the cache. <p/> Methods annotated with this annotation should accept a single parameter, a {@link org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent} otherwise a {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your listener. <p/> Locking: notification is performed WITH locks on the given key. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back. ensure this annotation is available at runtime. ensure that this annotation is applied to classes.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved}.
This event subtype is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved}. <p /> The {@link #getValue()} method would return the <i>old</i> value prior to deletion, if <tt>isPre()</tt> is <tt>true</tt>. If <tt>isPre()</tt> is <tt>false</tt>, {@link #getValue()} will return <tt>null</tt>.
Implementation of a size calculator that calcultes only the size of the value assuming it is an InternalCacheEntry. This delegates the calculation of the key and the value contained within the InternalCacheEntry to the provided SizeCalculator.
This annotation should be used on methods that need to be notified when a cache entry is visited. <p/> Methods annotated with this annotation should accept a single parameter, a {@link org.infinispan.notifications.cachelistener.event.CacheEntryVisitedEvent} otherwise a {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your listener. <p/> Locking: notification is performed WITHOUT locks on the given key (unless {@link org.infinispan.context.Flag#FORCE_WRITE_LOCK} is used for this call). <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back. ensure this annotation is available at runtime. ensure that this annotation is applied to classes.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryVisited}.
This event subtype is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.CacheEntryVisited}.
Bridges Infinispan with CDI events.
A converter that can be used to convert the value given for an event.  This converter allows for converting based on the previous value as well as the new updated value.  The old value and old metadata are the previous values and the new value and new metadata are the new values even for pre and post events.
Converter that is implemented by using the provided CacheEventConverter.  The provided event type will always be one that is not retried, post and of type CREATE,  The old value and old metadata in both pre and post events will be the data that was in the cache before the event occurs.  The new value and new metadata in both pre and post events will be the data that is in the cache after the event occurs.
Factory that can produce CacheEventConverters
A filter that can be used to tell if an event should be raised or not.  This filter allows for filtering based on the previous value as well as the new updated value.  The old value and old metadata are the previous values and the new value and new metadata are the new values even for pre and post events.
KeyValueFilter that is implemented by using the provided CacheEventFilter.  The provided event type will always be one that is not retried, post and of type CREATE,  The old value and old metadata in both pre and post events will be the data that was in the cache before the event occurs.  The new value and new metadata in both pre and post events will be the data that is in the cache after the event occurs.
This interface is an optimization that can be used when an event filter and converter are most efficiently used as the same object composing the filtering and conversion in the same method invocation.

Factory that can produce {@link CacheEventFilterConverter} instances.
Factory that can produce CacheEventFilters
Collects all events from observer and allows to extract them.
Thrown when operations on {@link Cache} fail unexpectedly. <p/> Specific subclasses such as {@link org.infinispan.util.concurrent.TimeoutException} and {@link org.infinispan.commons.CacheConfigurationException} have more specific uses. <p/> Transactions: if a CacheException (including any subclasses) is thrown for an operation on a JTA transaction, then the transaction is marked for rollback.
Static factory class that contains utility methods that can be used for performing proper transformations from {@link KeyValueFilter}, {@link Converter} & {@link KeyValueFilterConverter} to appropriate distributed stream instances.
Cache health information.

It holds the caches used by {@link EmbeddedCounterManager}.
Defines an interface to be used when a cache is to be ignored by a server implementation.  Any implementation should be thread safe and allow for concurrent methods to be invoked.

This handler inspects all endpoint resources to check if a one or more caches are being ignored.

The {@link javax.cache.annotation.CacheInvocationParameter} implementation.
Encapsulates logic used to invoke an operation on a cache.
If {@link org.infinispan.configuration.cache.Configuration#jmxStatistics()} is enabled, then class will register all the MBeans from cache local's ConfigurationRegistry to the MBean server.
Thrown when a cache fails to join a cluster
This class contains the information that a cache needs to supply to the coordinator when starting up.

The {@link javax.cache.annotation.CacheKeyInvocationContext} implementation.
Cache listener. <p/> Used to notify websocket clients of cache entry updates.
Wraps exceptions produced by listener implementations.
Defines the logic for loading data from an external storage. The writing of data is optional and coordinated through a {@link CacheWriter}.


An helper class providing useful methods for cache lookup.
A task that executes operations against a given cache manager.

A bootstrapping startup listener which creates and holds a cache instance
Registers all the components from global component registry to the mbean server.

Notifications for the cache manager
Global, shared notifications on the cache manager.

Handler which manages read-only access to cache runtime information (metrics)
Captures cache management statistics
A mixed {@link SiteStatus}. <p> Used per cache and it describes the nodes in which the site is online and offline.
Cache replication mode.
The {@link CommandHandler} implementation for Infinispan CLI commands which have the cache name as an argument.
The {@link CommandLineCompleter} implementation that shows all the caches name under the current cache container.

A response that signals the named cache is not running on the target node.
Public interface with all allowed notifications.
Helper class that handles all notifications to registered listeners.
{@link Cache1} and {@link Cache2} events observer.
REST Operations implementation. All operations translate {@link InfinispanRequest} into {@link InfinispanResponse}.

CachePermission.
CachePermissionCollection.
CachePrincipalPair.

{@link javax.cache.annotation.CachePut} interceptor implementation.

A cache-query is what will be returned when the getQuery() method is run on {@link org.infinispan.query.impl.SearchManagerImpl}. This object can have methods such as list, setFirstResult,setMaxResults, setFetchSize, getResultSize and setSort. <p/>
Implementation class of the CacheQuery interface. <p/>
Attribute handler for cache-container resource.
CacheRebalanceAttributeHandler.
CacheRebalancingStatusAttributeHandler.
Admin operation to reindex a cache Parameters: <ul> <li><strong>name</strong> the name of the cache to reindex</li> <li><strong>flags</strong> unused</li> </ul>
<p>{@link javax.cache.annotation.CacheRemoveAll} interceptor implementation. This interceptor uses the following algorithm describes in JSR-107.</p> <p>The interceptor that intercepts method annotated with {@code @CacheRemoveAll} must do the following, remove all entries associated with the cache. The removeAll occurs after the method body is executed. This can be overridden by specifying a afterInvocation attribute value of false. If afterInvocation is true and the annotated method throws an exception, the removeAll will not happen.</p>

<p>{@link javax.cache.annotation.CacheRemove} interceptor implementation.This interceptor uses the following algorithm describes in JSR-107.</p> <p>The interceptor that intercepts method annotated with {@code @CacheRemoveEntry} must do the following, generate a key based on InvocationContext using the specified {@link javax.cache.annotation.CacheKeyGenerator}, use this key to remove the entry in the cache. The remove occurs after the method body is executed. This can be overridden by specifying a afterInvocation attribute value of false. If afterInvocation is true and the annotated method throws an exception the remove will not happen.</p>


Admin operation to remove a cache Parameters: <ul> <li><strong>name</strong> the name of the cache to remove</li> <li><strong>flags</strong> </li> </ul>
Base class for cache resources which require common cache attributes only.
<p>{@link javax.cache.annotation.CacheResult} interceptor implementation. This interceptor uses the following algorithm describes in JSR-107.</p> <p>When a method annotated with {@link javax.cache.annotation.CacheResult} is invoked the following must occur. <ol> <li>Generate a key based on InvocationContext using the specified {@linkplain javax.cache.annotation.CacheKeyGenerator}.</li> <li>Use this key to look up the entry in the cache.</li> <li>If an entry is found return it as the result and do not call the annotated method.</li> <li>If no entry is found invoke the method.</li> <li>Use the result to populate the cache with this key/result pair.</li> </ol> There is a skipGet attribute which if set to true will cause the method body to always be invoked and the return value put into the cache. The cache is not checked for the key before method body invocation, skipping steps 2 and 3 from the list above. This can be used for annotating methods that do a cache.put() with no other consequences.</p>

CacheRoleImpl.
The {@link org.infinispan.remoting.rpc.RpcManager} only replicates commands wrapped in a {@link CacheRpcCommand}.
Externalizer in charge of marshalling cache specific commands. At read time, this marshaller is able to locate the right cache marshaller and provide it any externalizers implementations that follow.
CacheScriptBindings.
CacheSecurityResource.

Enumeration of service name factories for services associated with a cache.
Factory for generating service names for services associated with a cache.
A set that also must implement the various {@link CacheCollection} methods for streams.
A {@link CacheSet} that allows for a different set to be mapped as a different instance wtih values replaced on request.  This is useful as a cache set is normally lazily evaluated to prevent having to pull all values into memory which can be a lot faster when checking single values and can also prevent out of memory issues.
A per-cache {@link SiteStatus} builder. <p> It builds a {@link SiteStatus} based on the number of node with the site online and offline.
This annotation should be used on methods that need to be notified when a cache is started. <p/> Methods annotated with this annotation should accept a single parameter, a {@link org.infinispan.notifications.cachemanagerlistener.event.CacheStartedEvent} otherwise a {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your listener. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back.

This event is passed in to any method annotated with {@link org.infinispan.notifications.cachemanagerlistener.annotation.CacheStarted}.
CacheStatement shows the currently selected cache or selects a cache to be used as default for CLI operations
Collects and maintains all the statistics for a cache.
Manages all the statistics for a single cache. All the statistics should be added in this class.

This annotation should be used on methods that need to be notified when a cache is stopped. <p/> Methods annotated with this annotation should accept a single parameter, a {@link org.infinispan.notifications.cachemanagerlistener.event.CacheStoppedEvent} otherwise a {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your listener. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back.

This event is passed in to any method annotated with {@link org.infinispan.notifications.cachemanagerlistener.annotation.CacheStopped}.
{@link Category} tag for cache store tests.
Creates Cache Store instances. <i>Needs to be implemented when loading Cache Stores from custom locations (e.g. custom location on the disk).</i>
Registry for multiple {@link CacheStoreFactory} objects.

A {@link Stream} that has additional operations to monitor or control behavior when used from a {@link Cache}. <p>Whenever the iterator or spliterator methods are used the user <b>must</b> close the {@link Stream} that the method was invoked on after completion of its operation.  Failure to do so may cause a thread leakage if the iterator or spliterator are not fully consumed.</p> <p>When using stream that is backed by a distributed cache these operations will be performed using remote distribution controlled by the segments that each key maps to.  All intermediate operations are lazy, even the special cases described in later paragraphs and are not evaluated until a final terminal operation is invoked on the stream.  Essentially each set of intermediate operations is shipped to each remote node where they are applied to a local stream there and finally the terminal operation is completed.  If this stream is parallel the processing on remote nodes is also done using a parallel stream.</p> <p>Parallel distribution is enabled by default for all operations except for {@link CacheStream#iterator()} & {@link CacheStream#spliterator()}.  Please see {@link CacheStream#sequentialDistribution()} and {@link CacheStream#parallelDistribution()}.  With this disabled only a single node will process the operation at a time (includes locally).</p> <p>Rehash aware is enabled by default for all operations.  Any intermediate or terminal operation may be invoked multiple times during a rehash and thus you should ensure the are idempotent.  This can be problematic for {@link CacheStream#forEach(Consumer)} as it may be difficult to implement with such requirements, please see it for more information.  If you wish to disable rehash aware operations you can disable them by calling {@link CacheStream#disableRehashAware()} which should provide better performance for some operations.  The performance is most affected for the key aware operations {@link CacheStream#iterator()}, {@link CacheStream#spliterator()}, {@link CacheStream#forEach(Consumer)}.  Disabling rehash can cause incorrect results if the terminal operation is invoked and a rehash occurs before the operation completes.  If incorrect results do occur it is guaranteed that it will only be that entries were missed and no entries are duplicated.</p> <p>Any stateful intermediate operation requires pulling all information up to that point local to operate properly. Each of these methods may have slightly different behavior, so make sure you check the method you are utilizing.</p> <p>An example of such an operation is using distinct intermediate operation. What will happen is upon calling the terminal operation a remote retrieval operation will be ran using all of the intermediate operations up to the distinct operation remotely.  This retrieval is then used to fuel a local stream where all of the remaining intermediate operations are performed and then finally the terminal operation is applied as normal.  Note in this case the intermediate iterator still obeys the {@link CacheStream#distributedBatchSize(int)} setting irrespective of the terminal operator.</p>

The status of a cache from a distribution/state transfer point of view. <p/> The pending CH can be {@code null} if we don't have a state transfer in progress. <p/> The {@code topologyId} is incremented every time the topology changes (e.g. a member leaves, state transfer starts or ends). The {@code rebalanceId} is not modified when the consistent hashes are updated without requiring state transfer (e.g. when a member leaves).
A control command for all cache membership/rebalance operations. It is not a {@code CacheRpcCommand} because it needs to run on the coordinator even when the coordinator doesn't have a certain cache running.
The link between {@link LocalTopologyManager} and {@link StateTransferManager}.
Contains information about cache topology including servers and owned segments.

Defines the state a infinispan transaction should have.
Enumerates the supported cache types.

Signals a backup site was unreachable.
Intercepts the VisitableCommands to calculate the corresponding top-key values.

Allows persisting data to an external storage, as opposed to the {@link CacheLoader}.

Writes modifications back to the store on the way out: stores modifications back through the CacheLoader, either after each method call (no TXs), or at TX commit. Only used for LOCAL and INVALIDATION caches.
A key used in the global transaction table. <p> The global transaction table is a replicated cache. This key contains the cache name and the transactions' {@link XidImpl}.
Service providing extension to basic CRUD operations in order to test individual caching annotations and parameters they support.

Service providing basic CRUD operations in order to test individual JSR-107 caching annotations.


Service that provides an {@link Executor} that uses a cached thread pool.
Service providing basic create/find operations on both transactional and non-transactional caches.

Helper for dealing with Infinispan cache instances.
@author Pierre Sutra @since 7.2
{@link ContinuousQueryListener} which counts number of calls for each key.
@author Pierre Sutra @since 7.2
Always at the end of the chain, directly in front of the cache. Simply calls into the cache using reflection. If the call resulted in a modification, add the Modification to the end of the modification list keyed by the current transaction.
@author Pierre Sutra @since 7.2


A remote iterator for testing that does a callback when certain keys are reached.
Command to cancel commands executing in remote VM
CancellableCommand is a command whose execution in remote VM can be canceled (if needed)
CancellationService manages association of Thread executing CancellableCommand in a remote VM and if needed cancels command execution
CancellationServiceImpl is a default implementation of {@link CancellationService}


This is a workaround for TestNG limitation allowing only single IMethodInterceptor instance. Allows to use multiple {@link TestSelector} annotations in the test class hieararchy. Filters are executed before interceptors, and only on those classes that define them. Filters should not have any side-effect and as these only remove test methods, the order of execution is not important. The interceptors on superclasses will be executed before interceptors on subclasses, but an interceptor is executed even on a class that does not define it (because the interceptor is invoked once for the whole suite).
Handler for /subsystem=jgroups/channel=*:add() operations
Provides a channel for use by dependent services. Channels produced by this service are unconnected.
Service that connects/disconnects a channel.
Service provider interface for services that should be installed per-channel.
Factory for creating JGroups channels.
Handler responsible for dispatching requests into proper REST handlers.
Initializer for REST Handlers.
Enumerates management metrics for a channel.
Handler for reading run-time only attributes from an underlying channel service.
Handler for /subsystem=jgroups/channel=*:remove() operations
Definition for /subsystem=jgroups/channel=* resources

Factory for creating service names for channel-based services
Custom {@link JGroupsTransport} that uses a provided channel.
Channel Utilities.
Represents Charset. <p> Charsets are technically an optional part of a {@link MediaType}. </p>
Behaves more or less like a map of {@link java.util.concurrent.Semaphore}s. One thread will wait for an event via {@code await(...)} or {@code awaitStrict(...)}, and one or more other threads will trigger the event via {@code trigger(...)} or {@code triggerForever(...)}.
An {@link Action} implementation that checks if the command topology id is valid. <p/> The command topology id is valid when it is higher or equal thant the first topology as member for this node.
A classloader where the classes that are included, excluded or not found can individually configured to suit a particular test in a cherry pick fashion.
Used as a key to distinguish file chunk in cache.


Find infinispan classes utility

Identifiers for marshalling class name itself; this comes handy when marshalling arrays and the array component type is interface (and therefore it does not have its AdvancedExternalizer). This identifiers don't clash with {@link org.infinispan.commons.marshall.Ids} and therefore it can use the same range.

Interface that enhances {@link FilteringListenable} with the possibility of specifying the {@link ClassLoader} which should be set as the context class loader for the invoked listener method
Interface that enhances {@link Listenable} with the possibility of specifying the {@link ClassLoader} which should be set as the context class loader for the invoked listener method
An efficient identity object map whose keys are {@link Class} objects and whose values are {@link AdvancedExternalizer} instances.
Indicates that test cleanup happens after every test method.


ClearCacheAction.
Used in {@link org.infinispan.context.impl.ClearInvocationContext} to process the {@link org.infinispan.commands.write.ClearCommand}.
ClearCacheStatement.

Implementation of {@link org.infinispan.context.InvocationContext} used by the {@link org.infinispan.commands.write.ClearCommand}.
Corresponds to clear operation as defined by <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
A simple command buffer to buffer the Infinispan CLI batches and transactions before sending them to the server.
Basis for all CLI commands
The {@link java.lang.Exception} thrown when the Infinispan CLI interpreter returns an error message. The error message is set in the {@code Exception} message.
CLI operation handler. This is registered in {@link org.infinispan.manager.CacheContainer} and it forwards the commands to the CLI interpreter.
A {@link Address} implementation for a client transaction. <p> The {@code localAddress} is the address of the node in which the transaction was replayed.

Client side cache entry created events provide information on the created key, and the version of the entry. This version can be used to invoke conditional operations on the server, such as {@link org.infinispan.client.hotrod.RemoteCache#replaceWithVersion(Object, Object, long)} or {@link org.infinispan.client.hotrod.RemoteCache#removeWithVersion(Object, long)}
The events generated by default contain just enough information to make the event relevant but they avoid cramming too much information in order to reduce the cost of sending them. Optionally, the information shipped in the events can be customised in order to contain more information, such as values, or to contain even less information. This customization is done with {@link org.infinispan.filter.Converter} instances generated by a {@link org.infinispan.filter.ConverterFactory}. As a result of this conversion, custom events are reprenseted by this class, and are expected in methods annotation with either {@link org.infinispan.client.hotrod.annotation.ClientCacheEntryCreated}, {@link org.infinispan.client.hotrod.annotation.ClientCacheEntryModified} or, {@link org.infinispan.client.hotrod.annotation.ClientCacheEntryRemoved}. The event parameter for any of these callbacks is always a {@link ClientCacheEntryCustomEvent}, and if needed, the event's {@link org.infinispan.client.hotrod.event.ClientCacheEntryCustomEvent#getType()} can be queried to find out whether the originating event was the result of create, modified or removed.

Client side cache entry expired events provide information on the expired key.

Client side cache entry modified events provide information on the modified key, and the version of the entry after the modification. This version can be used to invoke conditional operations on the server, such as {@link org.infinispan.client.hotrod.RemoteCache#replaceWithVersion(Object, Object, long)} or {@link org.infinispan.client.hotrod.RemoteCache#removeWithVersion(Object, long)}

Client side cache entry removed events provide information on the removed key.

Event received when the registered listener fails over to a different node. Receiving this event indicates that a failure happened in the node where the listener was registered in and another server has been selected for installing the listener in. As a result of this failover, some events might have been missed, hence, this event can be used to clear locally cached data. After this failover event is received, the entire cache contents will be iterated over and the client receives events on these contents, which can be used to rebuild any locally built cache.
Client Certificate authentication mechanism.
{@link Category} tag for clustered client tests.


ClientIntelligence specifies the level of intelligence used by the client. <ul> <li><b>BASIC</b> means that the client doesn't handle server topology changes and therefore will only used the list of servers supplied at configuration time</li> <li><b>TOPOLOGY_AWARE</b> means that the client wants to receive topology updates from the servers so that it can deal with added / removed servers dynamically. Requests will go to the servers using a round-robin approach</li> <li><b>HASH_DISTRIBUTION_AWARE</b> like <i>TOPOLOGY_AWARE</i> but with the additional advantage that each request involving keys will be routed to the server who is the primary owner which improves performance greatly. This is the default</li> </ul>
Annotation that marks a class to receive remote events from Hot Rod caches. Classes with this annotation are expected to have at least one callback annotated with one of the events it can receive: {@link org.infinispan.client.hotrod.annotation.ClientCacheEntryCreated}, {@link org.infinispan.client.hotrod.annotation.ClientCacheEntryModified}, {@link org.infinispan.client.hotrod.annotation.ClientCacheEntryRemoved}, {@link org.infinispan.client.hotrod.annotation.ClientCacheFailover}


{@link Category} tag for single-node client tests.
Interface that provides semantics of a {@link Iterable} and {@link AutoCloseable} interfaces.  This is useful when you have data that must be iterated on and may hold resources in the underlying implementation that must be closed. <p>The close method will close any existing iterators that may be open to free resources</p>
Interface that provides semantics of a {@link Iterator} and {@link AutoCloseable} interfaces.  This is useful when you have data that must be iterated on and may hold resources in the underlying implementation that must be closed. <p>Some implementations may close resources automatically when the iterator is finished being iterated on however this is an implementation detail and all callers should call {@link AutoCloseable#close()} method to be sure all resources are freed properly.</p>
A collection that defines an iterator method that returns a {@link CloseableIterator} instead of a non closeable one.  This is needed so that iterators can be properly cleaned up.  All other methods will internally clean up any iterators created and don't have other side effects.
Adapts {@link java.util.Collection} to {@link CloseableIteratorCollection}
A iterator that maps each value to the output of the Function.  Note that the remove is supported if the iterator originally supported remove.
A set that defines an iterator method that returns a {@link org.infinispan.commons.util.CloseableIterator} instead of a non closeable one.  This is needed so that iterators can be properly cleaned up.  All other methods will internally clean up any iterators created and don't have other side effects.
Adapts {@link Set} to {@link CloseableIteratorSet}
Interface that provides semantics of a {@link Spliterator} and {@link AutoCloseable} interfaces.  This is useful when you have data that can be splitted and may hold resources in the underlying implementation that must be closed. <p>A spliterator split from this is not closeable.  Only the original {@link CloseableSpliterator} is required to be closed</p> <p>Some implementations may close resources automatically when the spliterator is exhausted however this is an implementation detail and all callers should call {@link AutoCloseable#close()} method to be sure all resources are freed properly.</p>
A spliterator that maps each value to the output of the Function that is also closeable.


This class consists exclusively of static methods that operate on or return closeable interfaces.  This is helpful when wanting to change a given interface to an appropriate closeable interface.
ClusterAwareRegionFactory.
This interface describes methods required for a cluster listener to be able to be bootstrapped and properly notified when a new event has been raised from the cluster.
Similar to {@link Stats} but cluster wide.
ClusterCacheStatsFactory is a default factory class for {@link ClusterCacheStats}. <p> This is an internal class, not intended to be used by clients.

Keeps track of a cache's status: members, current/pending consistent hashes, and rebalance status


Cluster wide container statistics


This is an event designed for use with cluster listeners solely.  This is the event that is serialized across the wire when sending the event back to the node where the cluster listener is registered.  You should only create a ClusterEvent through the use of the {@link ClusterEvent#fromEvent(CacheEntryEvent)} method.
This DistributedCallable is used to invoke a raised notification on the cluster listener that registered to listen for this event.

Constructs the data container

ClusterExecutionPolicy controls how which nodes commands submitted via {@link ClusterExecutor}. That is the user can ensure that a command goes or doesn't go to a specific physical location such as on the existing machine, rack or site. <p> ClusterExecutionPolicy effectively scopes execution of commands to a subset of nodes. For example, someone might want to exclusively execute commands on a local network site instead of a backup remote network centre as well. Others might, for example, use only a dedicated subset of a certain Infinispan rack nodes for specific task execution.
A cluster executor that can be used to invoke a given command across the cluster.  Note this executor is not tied to any cache. <p> This executor also implements {@link Executor} so that it may be used with methods such as {@link CompletableFuture#runAsync(Runnable, Executor)} or {@link CompletableFuture#supplyAsync(Supplier, Executor)}. Unfortunately though these invocations do not have explicitly defined Serializable {@link Runnable} or {@link Supplier} arguments and manual casting is required when using a lambda. Something like the following: {@code CompletableFuture.runAsync((Serializable && Runnable)() -> doSomething(), clusterExecutor)}.  Although note that the {@link ClusterExecutor#submit(SerializableRunnable)} does this automatically for you. <p> Any method that returns a value should make sure the returned value is properly serializable or else it will be replaced with a {@link org.infinispan.commons.marshall.NotSerializableException}
Static factory methods to construct a ClusterExecutor
Allows for cluster based expirations to occur.  This provides guarantees that when an entry is expired that it will expire that entry across the entire cluster at once.  This requires obtaining the lock for said entry before expiration is performed.  Since expiration can occur without holding onto the lock it is possible for an expiration to occur immediately after a value has been updated.  This can cause a premature expiration to occur.  Attempts are made to prevent this by using the expired entry's value and lifespan to limit this expiration so it only happens in a smaller amount of cases. <p> Cache stores however do not supply the value or metadata information which means if an entry is purged from the cache store that it will forcibly remove the value even if a concurrent write updated it just before.  This will be addressed by future SPI changes to the cache store.
Cluster health information.

This DistributedCallable is used to remove registered {@link RemoteClusterListener} on each of the various nodes when a cluster listener is unregistered from the cache.
This DistributedCallable is used to install a {@link RemoteClusterListener} on the resulting node.  This class also has checks to ensure that if the listener is attempted to be installed from more than 1 source only 1 will be installed as well if a node goes down while installing will also remove the listener.
Cache loader that consults other members in the cluster for values. A <code>remoteCallTimeout</code> property is required, a <code>long</code> that specifies in milliseconds how long to wait for results before returning a null.
ClusterLoaderConfiguration.


RebalancingAttributeHandler.
ClusterRoleMapper.


Manages distribution of various stream operations that are sent to remote nodes.  Note usage of any operations should <b>always</b> be accompanied with a subsequent call to {@link ClusterStreamManager#forgetOperation(Object)} so that the operation is fully released.  This is important especially for early terminating operations.
Cluster stream manager that sends all requests using the {@link RpcManager} to do the underlying communications.
Maintains the topology for all the caches in the cluster.
Factory for ClusterTopologyManager implementations
The {@code ClusterTopologyManager} implementation.
Information about the JGroups cluster.
Keys for cluster wide stats.
Base class for clustered cache add operations
ClusteredCacheAuthExternalIT test authentication and authorization with distributed cache and state transfer. Test scenario is as follows: 1. Start ISPN server 2. Start second ISPN server and form cluster 3. Authenticate via HR client to the first server via SSL and EXTERNAL SASL auth 4. Shut down first server 5. Do operation on remote cache via HR and verify it authorization works as expected. This remote operation happens on the second server.
ClusteredCacheAuthMd5IT test authentication and authorization with distributed cache and state transfer. Test scenario is as follows: 1. Start ISPN server 2. Start second ISPN server and form cluster 3. Authenticate via HR client to the first server 4. Shut down first server 5. Do operation on remote cache via HR and verify it authorization works as expected. This remote operation happens on the second server.
{@link org.infinispan.xsite.BackupReceiver} implementation for clustered caches.
Base class for clustered cache configuration add operations
Test queue-size, queue-flush-interval, remote-timeout and owners attributes of a cache. Please note that the queue related attributes are only aplicable to replicated-cache and remote-timeout only for SYNC mode. Using hotrod client except for the queue-flush-interval, where it's more convenient to use memcached.
Base class for cache resources which require common cache attributes and clustered cache attributes.
CacheFactory useful to create clustered caches on-demand in several tests. The same thread is used to actually create each cache, making it possible to create several connected caches even though the testing suite in Infinispan isolates different threads.
The same as a regular cache loader interceptor, except that it contains additional logic to force loading from the cache loader if needed on a remote node, in certain conditions.
Handler which manages read-only access to clustered cache runtime information (metrics)
A extension of CacheQueryImpl used for distributed queries.
Base class for cache resources which require common cache attributes and clustered cache attributes.

ClusteredDoc. Interface to encapsulate a score doc of a distributed query. NodeUUID it's the node that has the value. And getIndex must return the index of the scoreDoc.
Issues a remote getAll call.  This is not a {@link org.infinispan.commands.VisitableCommand} and hence not passed up the interceptor chain.
Issues a remote get call.  This is not a {@link org.infinispan.commands.VisitableCommand} and hence not passed up the interceptor chain. <p/>
A filter that tests the validity of {@link org.infinispan.commands.remote.ClusteredGetCommand}s. JGroups calls our handler while holding a lock, so we don't need any synchronization.
Encapsulates all rpc calls for distributed queries actions
Types of ClusteredQueryCommandWorker. Each type defines a different behavior for a ClusteredQueryCommand...
ClusteredQueryCommandWorker. Add specific behavior for ClusteredQueryCommand. Each ClusteredQueryCommandType links to a ClusteredQueryCommandWorker
Invoke a ClusteredQueryCommand on the cluster, including on own node.
ClusteredScoreDoc. A scoreDoc with his index and the uuid of the node who has the value.
Manages the current state of being a "master" node or a node delegating index update operations to other nodes. In a static cluster this would have been a boolean state, but a state machine is modelled here to cope with transitions between: Initialization of a node - still not having enough information on the cluster Becoming a master because of previous master failure / shutdown Forfaiting the master role (useful for cluster merges) The transition to become a master goes via different phases, and at each state the process is reversible. So for example if operations have been put on hold while the node is being upgraded, but then the master election is moved to a different node quickly (cluster startup scenario), the buffered operations will be forwarded to the last backend. A node being forwarded update operations but not being the master anymore, will re-forward the payload to the new master: stability by induction. The solution is rather poor at managing cluster Merge operations, but we need to build on upcoming functionality from Infinispan core for that; for example the index content wouldn't be consistent either so one would likely need to wipe the index and rebuild it. Also we're dealing with the inherent limitation of a "cluster wide lock" concept not being compatible with sub-groups of nodes in which a new lead might be elected and a lock per group might have been created. A lock cleanup is not too aggressive: in case a stale lock is detected, scheduled work is postponed. This implies that in such situations in which a stale lock needs to be cleaned up, index operations might not be visible to the transaction committer. I've chosen for this option as the lesser evil vs. blocking incoming RPCs, although if the buffer for postponed operations gets filled too quickly, we'll both speed up the lock acquisition and apply backpressure to the clients.
Timestamp cache region for clustered environments.
ClusteredTopDocs. A TopDocs with UUID and address of node who has the doc.

A {@link TransactionOriginatorChecker} implementation for clustered caches. <p> It uses the current topology to fetch the live members to check if the transaction's originator is alive.
Defines clustered characteristics of the cache.
Defines clustered characteristics of the cache.

Abstractization for logic related to different clustering modes: replicated or distributed. This implements the <a href="http://en.wikipedia.org/wiki/Bridge_pattern">Bridge</a> pattern as described by the GoF: this plays the role of the <b>Implementor</b> and various LockingInterceptors are the <b>Abstraction</b>.
A {@link org.infinispan.interceptors.locking.ClusteringDependentLogic} delegator
Base class for distribution interceptors.

A Hot Rod protocol encoder/decoder.
A Hot Rod encoder/decoder for version 1.0 of the protocol.
A Hot Rod encoder/decoder for version 1.1 of the protocol.
A Hot Rod encoder/decoder for version 1.2 of the protocol.
A Hot Rod encoder/decoder for version 1.3 of the protocol.
A Hot Rod encoder/decoder for version 2.0 of the protocol.







CodecException.
Codec factory.
CodecRegistry.

Collection region access for Infinispan.
CollectionAttributeCopier. This {@link AttributeCopier} can handle a handful of "known" collection types ( {@link HashSet}, {@link HashMap} )

A factory for ConcurrentMaps.
Filter based on accepting/rejecting the keys that are present in a supplied collection.
A collection that maps another one to a new one of a possibly different type.  Note this collection is read only and doesn't accept write operations. <p> Some operations such as {@link Collection#contains(Object)} and {@link Collection#containsAll(Collection)} may be more expensive then normal since they cannot utilize lookups into the original collection.
Collection region implementation
An helper class providing useful methods to work with JDK collections.
Represents the ack collector for a write operation in triangle algorithm.


An acknowledge collector for Triangle algorithm used in non-transactional caches for write operations. <p> Acknowledges are used between the owners and the originator. They signal the completion of a write operation. The operation can complete successfully or not. <p> The acknowledges are valid on the same cache topology id. So, each acknowledge is tagged with the command topology id. Acknowledges from previous topology id are discarded. <p> The acknowledges from the primary owner carry the return value of the operation.


Class copied from JBoss Fuse project and modified.
Remote commands factory implementation
Initializes query module remote commands
This is the base class for all interceptors to extend, and implements the {@link Visitor} interface allowing it to intercept invocations on {@link VisitableCommand}s. <p/> Commands are either created by the {@link CacheImpl} (for invocations on the {@link Cache} public interface), or by the {@link org.infinispan.remoting.inboundhandler.InboundInvocationHandler} for remotely originating invocations, and are passed up the interceptor chain by using the {@link InterceptorChain} helper class. <p/> When writing interceptors, authors can either override a specific visitXXX() method (such as {@link #visitGetKeyValueCommand(InvocationContext, GetKeyValueCommand)}) or the more generic {@link #handleDefault(InvocationContext, VisitableCommand)} which is the default behaviour of any visit method, as defined in {@link AbstractVisitor#handleDefault(InvocationContext, VisitableCommand)}. <p/> The preferred approach is to override the specific visitXXX() methods that are of interest rather than to override {@link #handleDefault(InvocationContext, VisitableCommand)} and then write a series of if statements or a switch block, if command-specific behaviour is needed. <p/>
Represents an unique identified for non-transaction write commands. <p> It is used to lock the key for a specific command. <p> This class is final to prevent issues as it is usually not marshalled as polymorphic object but directly using {@link #writeTo(ObjectOutput, CommandInvocationId)} and {@link #readFrom(ObjectInput)}.
Matches {@link ReplicableCommand}s.
Builds {@link CommandMatcher}s.

A factory to build commands, initializing and injecting dependencies accordingly.  Commands built for a specific, named cache instance cannot be reused on a different cache instance since most commands contain the cache name it was built for along with references to other named-cache scoped components.


Command corresponding to the 2nd phase of 2PC.
Keeps track of the keys updated by normal operation and state transfer. Since the command processing happens concurrently with the state transfer, it needs to keep track of the keys updated by normal command in order to reject the updates from the state transfer. It assumes that the keys from normal operations are most recent thant the ones received by state transfer.
A decode context that handle a commit request from a client.
CommitTransactionStatement commits a running transaction
CommonConnectorResource.

CommonNameRoleMapper. A simple mapper which extracts the Common Name (CN) from an LDAP-style Distinguished Name (DN) and returns it as the role.
Component keeping the data about log file usage - as soon as entries from some file are overwritten so that the file becomes cluttered with old records, the valid records are moved to another file and the old ones are dropped. Expired records are moved as tombstones without values (records of entry removal).


The compare-and-set function to update the {@link CounterValue}. <p> If the value is different from {@code expect}, it returns {@code null}. <p> For a bounded counter, if the {@code value} is outside the bounds, it returns {@link CounterState#LOWER_BOUND_REACHED} or {@link CounterState#UPPER_BOUND_REACHED} if the lower bound or upper bound is violated. <p> If the compare-and-set is successful, it returns  {@link CounterState#VALID}.
An expression that represents a comparison of Comparable values.
Encoder that read/write marshalled content and store them unmarshalled.
Compatibility cache factory taking care of construction and destruction of caches, servers and clients for each of the endpoints being tested.
CompatibilityConfigurationResource.
Interceptor installed when compatiblity is enabled.
Compatibility mode configuration
Compatibility mode configuration builder
A per {@link EmbeddedCacheManager} marshaller that should be used as compatibility mode marshaller (see {@link org.infinispan.interceptors.compat.TypeConverterInterceptor}) in server. An instance cannot be shared between multiple cache managers.

A sub-class of ReflectionMatcher that is able to lookup classes by their protobuf type name and can work when compatibility mode is used.
Utility methods connecting {@link CompletableFuture} futures.
Command used by the recovery tooling for forcing transaction completion .

Builds a service that provides the configuration of a component.
This class contains all of the metadata and implications expressed via the {@link Scope}, {@link SurvivesRestarts}, {@link DefaultFactoryFor}, {@link ComponentName}, {@link Inject}, {@link Start} and {@link Stop} annotations.  Instead of scanning for these annotations and working out dependency chains at runtime "on-demand", since Infinispan 5.1, this process now happens offline, at build-time. <p /> When compiling Infinispan, components and their dependency chains are inspected and the information expressed by the annotations above are denormalized and a series of {@link ComponentMetadata} objects are created and persisted in the Infinispan jar. <p /> This metadata is then read in by the {@link ComponentMetadataRepo} at runtime, and used by the {@link ComponentRegistry} and other factory-like classes to bootstrap an Infinispan node. <p /> Also see {@link ManageableComponentMetadata} for components that also expose JMX information.
A utility class used by the Infinispan build process to scan metadata and persist it.  Should be used by all Infinispan modules that define components decorated with {@link Inject}, {@link Start}, {@link Stop}, etc.
This is a repository of component metadata, which is populated when the Infinispan core jar is loaded up.  Actual metadata is analyzed and persisted into the jar at build-time, taking it off the critical path.
Mechanism for specifying the name of components to retrieve
Named cache specific components

Component registry utilities
Different states a component may be in.
Registers a set of components on an MBean server.
A {@link ReadyAction} implementation that delegates it logic to a collection of other {@link ReadyAction}.
Allows AND-composing several cache event filters.
Allows AND-composing several filters.
Allows AND-composing several key/value filters.
Allows to composite a KeyValueFilter and a Converter together to form a KeyValueFilterConverter.  There are no performance gains by doing this though since the {@link org.infinispan.filter.CompositeKeyValueFilterConverter#filterAndConvert(Object, Object, org.infinispan.metadata.Metadata)} just composes of calling the filter and then converter as needed completely invalidating it's usage.  This is more for testing where performance is not of a concern.
CompressedFile Appender.
Manages actual File I/O for the CompressedFileAppender.



Thrown when the version of entry has changed between loading the entry to the context and committing new value.
Thread safe cache statistics that allows multiple writers and reader at the same time.
A simple Set implementation backed by a {@link java.util.concurrent.ConcurrentHashMap} to deal with the fact that the JDK does not have a proper concurrent Set implementation that uses efficient lock striping. <p/> Note that values are stored as keys in the underlying Map, with a static dummy object as value.
A concurrent-map-based near cache implementation. It does not provide eviction capabilities.
An alternative weak-key {@link ConcurrentMap} which is similar to {@link java.util.concurrent.ConcurrentHashMap}.

Configures two default caches - we will use both caches to check that events for one don't spill over to the other.
ConfigImpl.
Configuration.

ConfigurationBuilder used to generate immutable {@link Configuration} objects to pass to the {@link RemoteCacheManager#RemoteCacheManager(Configuration)} constructor.

ConfigurationChildBuilder.
ConfigurationConverter.
ConfigurationFor. Indicates the class that this object is a configuration for

ConfigurationHolder.
It manages all the configuration for a specific container. <p> It manages the {@link GlobalConfiguration}, the default {@link Configuration} and all the defined named caches {@link Configuration}.
Stores the {@link CounterConfiguration} with the {@link org.infinispan.counter.impl.entries.CounterValue}. <p> The metadata is static and doesn't change. It is sent when initializing a counter and it is kept locally in all the nodes. This avoids transfer information about the counter in every operation (e.g. boundaries/reset).
Provides functionality for dealing with configuration values.
ConfigurationParser.
Encapsulate all config properties here
<p> Provides a mechanism to override selected configuration properties using explicit setters for each configuration setting. </p>

ConfigurationUtils. Contains utility methods used in configuration
Helper configuration methods.
This annotation is used to define a cache {@link Configuration}.
Defines the configuration used to configure the given class instances

A {@link ConflictManager} factory for cache instances.


Defines the functionality a connection factory should implement.
Contains configuration elements for a {@link ConnectionFactory}.
ConnectionFactoryConfiguration.

A simple interface that must be implemented by ConnectionPool wrapper classes.
ConnectionPoolConfiguration.
ConnectionPoolConfigurationBuilder. Specifies connection pooling properties for the HotRod client.
Connector.
Abstraction for the used consistent hash.
Factory for {@link org.infinispan.client.hotrod.impl.consistenthash.ConsistentHash} function. It will try to look into the configuration for consistent hash definitions as follows: consistent-hash.[version]=[fully qualified class implementing ConsistentHash] e.g. <code>infinispan.client.hotrod.hash_function_impl.3=org.infinispan.client.hotrod.impl.consistenthash.SegmentConsistentHash</code> or if using the {@link Configuration} API, <code>configuration.consistentHashImpl(3, org.infinispan.client.hotrod.impl.consistenthash.SegmentConsistentHash.class);</code> <p/> <p>The defaults are:</p> <ol> <li>N/A (No longer used.)</li> <li>org.infinispan.client.hotrod.impl.ConsistentHashV2</li> <li>org.infinispan.client.hotrod.impl.SegmentConsistentHash</li> </ol>
Constants used as keys within a persisted consistent hash
Version 2 of the ConsistentHash function.  Uses MurmurHash3.

A constant boolean expression (tautology or contradiction).
A {@link CommonTree} representing a constant literal.
A constant comparable value, to be used as right or left side in a comparison expression.

Entity that has a many-to-one relationship to a Customer

{@link CommandHandler} implementation with the {@code container} command logic. <p/> The {@code container} command changes the container in which the Infinispan CLI command are executed against. The command is only executed in the client.
{@link FactoryBean} for creating a {@link CacheManager} for a pre-defined {@link org.infinispan.manager.CacheContainer}. <p/> Useful when the cache container is defined outside the application (e.g. provided by the application server)
A mixed {@link SiteStatus}. Used per container and it describes the caches in which the site is online, offline and mixed.
{@link FactoryBean} for creating a {@link CacheManager} for a pre-defined {@link org.infinispan.manager.CacheContainer}. <p/> Useful when the cache container is defined outside the application (e.g. provided by the application server)

A per-container {@link SiteStatus} builder. <p> It builds a {@link SiteStatus} based on the caches which have the site online, offline or mixed status.


Serializable function used by {@link org.infinispan.multimap.impl.EmbeddedMultimapCache#containsKey(Object)} and {@link org.infinispan.multimap.impl.EmbeddedMultimapCache#containsEntry(Object, Object)}.
Implements "containsKey" operation as described in <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.

Context.
Checks if context passed by {@link InfinispanRequest} is correct.
Handler that performs actual cache operations.  Note this handler should be on a separate executor group than the decoder.
ContextImpl.
ContextInputCache keeps track of {@link Input} cache to be injected into Callables from {@link DistributedExecutorService} using CDI mechanism. The cache injected will be the cache used to construct {@link DistributedExecutorService}
Callbacks used by {@link BeanBuilder} and {@link ImmutableBean} to allow control of the creation and destruction of a custom bean.
Represents a non-contextual instance
A container of continuous query listeners for a cache. <p> Implementations are not expected to be threadsafe.
A container of continuous query listeners for a cache. <p>This class is not threadsafe.
Listener for continuous query events.

A 'remote' ContinuousQueryResult needs jboss-marshalling serializability between nodes when running in compat mode. It will only be marshalled using protobuf before passing it to the remote client.
An helper class providing useful assertion methods.
A control byte used by each write operation to flag if the key was read or not, or if the write operation is a remove operation

ConsistentHashFactory implementation that allows the user to control who the owners are.


TimeService that allows for wall clock time to be adjust manually.
Controlled {@link org.infinispan.remoting.transport.Transport} that allows to configure commands to block before or after the real invocation or to fail.
Converter that can be used to transform a given entry to a different value.  This is especially useful to reduce overall payload of given data that is sent for the given event when a notification is send to a cluster listener as this will have to be serialized and sent across the network when the cluster listener is not local to the node who owns the given key.

This interface extended the {@link org.infinispan.atomic.DeltaAware}. The copy allows to use Copy-On-Write semantic needed to ensure the correct transaction isolation.
Factory for generating immutable type wrappers for core types.
Counts the encountered values and returns a {@code Long} greater or equal than 0. Null values are not counted. If there are no non-null values to which COUNT can be applied, the result of the aggregate function is 0.


A counter configuration used to define counters cluster wide via {@link CounterManager#defineCounter(String, CounterConfiguration)}. <p> The configuration must be built using {@link CounterConfiguration#builder(CounterType)}. Only {@link CounterType} is required.
Base counter configuration builder. <p> It allows to configure the name, initial value and the {@link Storage} mode. The counter's name is required.
Signals a missing configuration or an invalid configuration.
Interceptor for the counters configuration cache. <p> Since the state transfer doesn't know about the {@link Flag#SKIP_CACHE_STORE} and {@link Flag#SKIP_CACHE_LOAD} flags, all  the configuration are persisted. However, we only want the {@link Storage#PERSISTENT} configurations to be persisted. <p> This interceptor checks the configuration's {@link Storage} and sets the {@link Flag#SKIP_CACHE_LOAD} and {@link Flag#SKIP_CACHE_STORE} flags.
Counters configuration parser
Counters configuration serializer.
The event used by {@link CounterListener}.
A interface to generate {@link CounterEvent} from the current {@link CounterValue}.
The {@link CounterEvent} implementation.
A {@link RuntimeException} related to counters.
Interceptor for the counters cache. <p> Since the state transfer doesn't know about the {@link Flag#SKIP_CACHE_STORE} and {@link Flag#SKIP_CACHE_LOAD} flags, all the counters are persisted. However, we only want the {@link Storage#PERSISTENT} configurations to be persisted. <p> This interceptor checks the configuration's {@link Storage} and sets the {@link Flag#SKIP_CACHE_LOAD} and {@link Flag#SKIP_CACHE_STORE} flags.
Interface that represents the key stored in the cache.
A {@link KeyFilter} to produce events for all counters in the cache.
A listener interface to listen to {@link StrongCounter} changes. <p> The events received will have the previous/current value and its previous/current state.
The {@link CounterManager} creates, defines and returns counters. <p> It is thread-safe in the way that multiples threads can retrieve/create counters concurrently. If it is the first time a counter is created, other concurrent threads may block until it is properly initialized. <p> A counter can be defined using {@link CounterManager#defineCounter(String, CounterConfiguration)} and {@link CounterManager#isDefined(String)} returns if the counter is defined or not. <p> The counter can be retrieved/created using the {@link CounterManager#getStrongCounter(String)} or {@link CounterManager#getWeakCounter(String)} to return an (un)bounded strong counter or weak counter. The operation will fail if the counter is defined with a different type. For example, define a strong counter {@code "test"} and try to retrieve using the {@code getWeakCounter("test"}.
The {@link org.infinispan.counter.api.CounterManager} configuration. <p> It configures the number of owners (number of copies in the cluster) of a counter and the {@link Reliability} mode.
The {@link org.infinispan.counter.api.CounterManager} configuration builder. <p> It configures the number of owner and the {@link Reliability} mode. It allow to configure the default counter available on startup.
It manages all the caches events and handles them. Also, it handles the user-specific {@link CounterListener}. <p> When a particular key is updated, its update is send to the counter, via {@link CounterEventGenerator#generate(CounterKey, CounterValue)}, and the result {@link CounterEvent} is used to notify the users {@link CounterListener}. <p> Also listens to topology changes in the cache to update the {@link WeakCounter} preferred keys, via {@link TopologyChangeListener#topologyChanged()}. <p> An user's {@link CounterListener} is invoked in sequence (i.e. only the next update is invoked when the previous one is handled) but it can be invoked in different thread.

It register a {@link EmbeddedCounterManager} to each {@link EmbeddedCacheManager} started and starts the cache on it.
A {@link CounterException} signalling that the {@link StrongCounter} has reached its bounds.
The possible states for a counter value.
The counter types.
Stores the counter's value and {@link CounterState}. <p> If the counter isn't bounded, the state is always {@link CounterState#VALID}.

Dispatcher that counts actually ongoing unicast RPCs. Its purpose is to isolate RPCs started before {@link #advanceGenerationAndAwait(long, TimeUnit)} and those afterwards. It can handle staggered calls as well.
Use the {@link CountingRpcManager#replaceRpcManager(org.infinispan.Cache)}.

Listener that detects crashed or stopped members and removes them from the address cache. Use a separate thread to avoid blocking the view handler thread

Command to create/start a cache on a subset of Infinispan cluster nodes
The {@link CacheCommand#CREATE} handler.
CreateStatement creates a new cache based on the configuration of an existing cache.






Simple implementation of {@link org.springframework.cache.interceptor.CacheResolver} interface. It returns a single instance of {@link org.springframework.cache.Cache} with name 'custom'.

Tests Deployeable Cache Stores which are placed into server deployments directory.



JGroupsChannelLookup implementation that returns an existing channel.

Custom DataContainer for testing the configuration converter.


Used for implementing custom policies in case of communication failures with a remote site. The handle methods are allowed to throw instances of {@link BackupFailureException} to signal that they want the intra-site operation to fail as well. If handle methods don't throw any exception then the operation will succeed in the local cluster. For convenience, there is a support implementation of this class: {@link AbstractCustomFailurePolicy} <p/> Lifecycle: the same instance is invoked during the lifecycle of a cache so it is allowed to hold state between invocations. <p/> Threadsafety: instances of this class might be invoked from different threads and they should be synchronized.

Configures custom interceptors to be added to the cache.
Configures custom interceptors to be added to the cache.




Custom runner to work around https://issues.apache.org/jira/browse/SUREFIRE-1374



Custom commands from the Query module should implement this interface to fetch needed components.









Custom Transport class for testing the transport tag parsing.
Company customer
Thrown when a cyclic dependency exist

Interface for async interceptors using double-dispatch.
Test for DSL queries when using the wildfly modules
Commands of this type manipulate data in the cache.
The main internal data structure which stores entries
Controls the data container for the cache.
Controls the data container for the cache.
Constructs the data container
This is an iterator that will iterate upon the data container.  A cache is also provided to be used when the remove method on the iterator is invoked.  Note that this means it will take part of any ongoing transaction if there is one.
Handle conversions for Keys or values.

Used to determine whether a key is mapped to a local node.  Uncertainty indicates a rehash is in progress and the locality of key in question may be in flux.
This annotation should be used on methods that need to be notified when a rehash starts or ends. A "rehash" (or "rebalance") is the interval during which nodes are transferring data between each other. When the event with {@code pre = false} is fired all nodes have received all data; Some nodes can still keep old data, though - old data cleanup is executed after this event is fired. <p/> Methods annotated with this annotation should accept a single parameter, a {@link DataRehashedEvent} otherwise a {@link IncorrectListenerException} will be thrown when registering your listener. <p/> Note that methods marked with this annotation will be fired <i>before</i> and <i>after</i> rehashing takes place, i.e., your method will be called twice, with {@link Event#isPre()} being set to <tt>true</tt> as well as <tt>false</tt>. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back. ensure this annotation is available at runtime. ensure that this annotation is applied to classes.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.DataRehashed}.
An event passed in to methods annotated with {@link DataRehashed}. <p>The result of the {@link #getNewTopologyId()} method is not guaranteed to be the same for the "pre" and the "post" notification, either. However, the "post" value is guaranteed to be greater than or equal to the "pre" value.</p>
Required by JBoss Transactions for DataSource resolving.


Mixes features from DataCommand and WriteCommand
Supported database dialects for the JDBC cache stores
An adapter class that enables users to call all important methods from {@link MultipleCacheManagersTest}, {@link AbstractCacheTest} and {@link AbstractInfinispanTest}, changing their visibility to public. Usage of this class is in infinispan-arquillian-container project which enables injecting of this class into a test case and forming a cluster of cache managers/caches. A few methods from super-classes changed their names, mostly because they cannot be overridden. All such methods have comments on them which say "name change".



An interface to implement the deadlock algorithm.
Exception signaling detected deadlocks.
Configures deadlock detection.
Configures deadlock detection.
HotRod protocol decoder specific for specification version 1.0.
HotRod protocol decoder specific for specification version 2.0.
A decorator to a cache, which can be built with a specific set of {@link Flag}s.  This set of {@link Flag}s will be applied to all cache invocations made via this decorator. <p/> In addition to cleaner and more readable code, this approach offers a performance benefit to using {@link AdvancedCache#withFlags(org.infinispan.context.Flag...)} API, thanks to internal optimizations that can be made when the {@link Flag} set is unchanging. <p/> Note that {@link DecoratedCache} must be the closest Delegate to the actual Cache implementation. All others must delegate to this DecoratedCache.
DecoratedEventLogger. Provides a way to decorate an EventLog with additional information.
DecoratedServerEventLogger. Provides a way to decorate an EventLog with additional information.
A shared service used among all InfinispanDirectoryProvider instances to delete segments asynchronously.
Default implementation for {@link org.infinispan.commons.executors.ExecutorFactory} based on an {@link ThreadPoolExecutor}.
EmbeddedCacheManager decorator that overrides the default cache semantics of a cache manager.
Default {@link javax.cache.annotation.GeneratedCacheKey} implementation.
Default {@link javax.cache.annotation.CacheKeyGenerator} implementation. By default all key parameters of the intercepted method compose the {@link javax.cache.annotation.CacheKey}.
A <tt>CacheManager</tt> is the primary mechanism for retrieving a {@link Cache} instance, and is often used as a starting point to using the {@link Cache}. <p/> <tt>CacheManager</tt>s are heavyweight objects, and we foresee no more than one <tt>CacheManager</tt> being used per JVM (unless specific configuration requirements require more than one; but either way, this would be a minimal and finite number of instances). <p/> Constructing a <tt>CacheManager</tt> is done via one of its constructors, which optionally take in a {@link org.infinispan.configuration.cache.Configuration} or a path or URL to a configuration XML file. <p/> Lifecycle - <tt>CacheManager</tt>s have a lifecycle (it implements {@link Lifecycle}) and the default constructors also call {@link #start()}. Overloaded versions of the constructors are available, that do not start the <tt>CacheManager</tt>, although it must be kept in mind that <tt>CacheManager</tt>s need to be started before they can be used to create <tt>Cache</tt> instances. <p/> Once constructed, <tt>CacheManager</tt>s should be made available to any component that requires a <tt>Cache</tt>, via JNDI or via some other mechanism such as an IoC container. <p/> You obtain <tt>Cache</tt> instances from the <tt>CacheManager</tt> by using one of the overloaded <tt>getCache()</tt>, methods. Note that with <tt>getCache()</tt>, there is no guarantee that the instance you get is brand-new and empty, since caches are named and shared. Because of this, the <tt>CacheManager</tt> also acts as a repository of <tt>Cache</tt>s, and is an effective mechanism of looking up or creating <tt>Cache</tt>s on demand. <p/> When the system shuts down, it should call {@link #stop()} on the <tt>CacheManager</tt>. This will ensure all caches within its scope are properly stopped as well. <p/> Sample usage: <pre><code> CacheManager manager = CacheManager.getInstance("my-config-file.xml"); Cache&lt;String, Person&gt; entityCache = manager.getCache("myEntityCache"); entityCache.put("aPerson", new Person()); ConfigurationBuilder confBuilder = new ConfigurationBuilder(); confBuilder.clustering().cacheMode(CacheMode.REPL_SYNC); manager.defineConfiguration("myReplicatedCache", confBuilder.build()); Cache&lt;String, String&gt; replicatedCache = manager.getCache("myReplicatedCache"); </code></pre>
Provides access to Infinispan's CacheManager; one CacheManager is needed for all caches, it can be taken via JNDI or started by this ServiceProvider; in this case it will also be stopped when no longer needed.
Default {@link javax.cache.annotation.CacheResolver} implementation for standalone environments, where no Cache/CacheManagers are injected via CDI.
Generic {@link CommandMatcher} implementation that can use both {@link CacheRpcCommand} criteria (cache name, origin) and {@link DataCommand} criteria (key).

Default {@link ConsistentHash} implementation. This object is immutable. Every segment must have a primary owner.
Default implementation of {@link ConsistentHashFactory}. All methods except {@link #union(DefaultConsistentHash, DefaultConsistentHash)} return a consistent hash with floor(numOwners*numSegments/numNodes) <= segments per owner <= ceil(numOwners*numSegments/numNodes).
This class refines <code>ContextClassLoader</code> to add a default class loader. The context class loader is only used when the default is <code>null</code>.
DefaultDataContainer is both eviction and non-eviction based data container.

Default executor factory that creates executors using the JDK Executors service.
Infinispan's implementation of an {@link ExecutorService} and {@link DistributedExecutorService}. This ExecutorService provides methods to submit tasks for an execution on a cluster of Infinispan nodes. <p> Note that due to potential task migration to another nodes every {@link Callable}, {@link Runnable} and/or {@link DistributedCallable} submitted must be either {@link Serializable} or {@link Externalizable}. Also the value returned from a callable must be {@link Serializable} or {@link Externalizable}. Unfortunately if the value returned is not serializable then a {@link NotSerializableException} will be thrown.
An annotation that is used internally, for defining a DEFAULT factory to be used when constructing components.  This annotation allows you to define which components can be constructed by the annotated factory.
Default {@link InvocationMatcher} implementation.


The default {@link LockManager} implementation for transactional and non-transactional caches.

The default implementation for {@link PendingLockManager}. <p> In transactional caches, a transaction would wait for transaction originated in a older topology id. It can happen when topology changes and a backup owner becomes the primary owner.
A list of {@link Action} to be executed to check when it is ready. <p/> If an {@link Action} is canceled, then the remaining {@link Action} are not invoked.
The default response generator for most cache modes
Creates scheduled executors using the JDK Executors service

Thread factory based on JBoss Thread's JBossThreadFactory.
The default implementation of {@link TimeService}. It does not perform any optimization and relies on {@link System#currentTimeMillis()} and {@link System#nanoTime()}.
The default {@link Runnable} for the remote commands receives. <p/> It checks the command topology and ensures that the topology higher or equal is installed in this node.
WARNING, slow as a senile dog, uses Java Serialization and base64 encoding to get a String representation of an Object. It is highly recommended that you provide your own implementation of {@link org.infinispan.query.Transformer}.
Default implementation for {@link TwoWayKey2StringMapper} that knows how to handle all primitive wrapper keys and Strings.
A maven plugin to extract default values from various AtributeDefinitions, output them to a specified properties/asciidoc file and process xsd files so that placeholders are replaced with the extracted defaults.
Interface used by {@link org.infinispan.plugins.maven.defaults.DefaultsExtractorMojo} to extract default default values from AttributeDefinitions.
Implemented by objects with a definition.
DefineConfigurationAction.

A wrapper around a {@link CacheEntryListenerInvocation} that keeps a reference to the {@link FilterIndexingServiceProvider} instance that handles this invocation. All methods are delegated to the wrapped invocation except {@link CacheEntryListenerInvocation#invoke(EventWrapper, boolean)} and {@link CacheEntryListenerInvocation#invoke(Object)}. FilterIndexingServiceProvider implementors must extends this class and implement its abstract {@link #unregister} method.


An implementation of {@link ContextualLifecycle} that is backed by an {@link InjectionTarget}.

Class that extends {@link InputStream} and implements {@link ObjectInput}. <p> All the methods delegates to a {@link ObjectInput} implementation.
Class that extends {@link OutputStream} and implements {@link ObjectOutput}. <p> All the methods delegates to a {@link ObjectOutput} implementation.







Used in RPC, it defines how the messages are delivered to the nodes.
Represents changes made to a {@link DeltaAware} implementation.  Implementations should be efficiently {@link java.io.Externalizable} rather than just {@link java.io.Serializable}.
This interface allows the extraction of {@link Delta}s. <br/> Implementations would be closely coupled to a corresponding {@link Delta} implementation, since {@link Delta#merge(DeltaAware)}  would need to know how to recreate this instance of DeltaAware if needed. <br/> Implementations of DeltaAware automatically gain the ability to perform fine-grained replication in Infinispan, since Infinispan's data container is able to detect these types and only serialize and transport Deltas around the network rather than the entire, serialized object. <br /> Using DeltaAware makes sense if your custom object is large in size and often only sees small portions of the object being updated in a transaction.  Implementations would need to be able to track these changes during the course of a transaction though, to be able to produce a {@link Delta} instance, so this too is a consideration for implementations. <br />
DeltaCompositeKey is the key guarding access to a specific entry in DeltaAware

DemoActions does some basic operations on the Lucene index, to be used by DemoDriver to show base operations on Lucene.
DemoDriver is a console hello-world application to show the Lucene clustering capabilities. This class parses the user input and drives the actions implemented in DemoActions. As always when running JGroups to run a demo cluster of multiple applications running on the same host, set these JVM options: -Djava.net.preferIPv4Stack=true -Djgroups.bind_addr=127.0.0.1

The {@link CacheCommand#DENY} handler.
DenyStatement removes a role mapping from a user
Encapsulates logic for registering a service dependency.
Graph to track dependencies between objects
Cache Store factory designed for deployed instances.
Service wrapper for {@link org.jboss.as.clustering.infinispan.cs.factory.DeployedCacheStoreFactory}.
Metadata for deployed Cache Store
Configuration which operates only on class names instead of class objects.
StoreConfigurationBuilder used for stores/loaders that don't have a configuration builder
Create deployments for JMS Master/Slave configuration integration tests storing the index in Infinispan. Make sure to test for a secured JMS environment.
Create deployments for JMS Master/Slave configuration integration tests using infinispan as index storage. Make sure to test for a secured JMS environment. This test does NOT override the versions of Hibernate ORM and Hibernate Search: this is intentional, to test integration with the versions normally used by the application server.
Arquillian deployment utility class.


DirectJMXRemotingUrl connects through plain (non-http-upgrade-enabled) ports
Builder class to create instances of the {@link org.apache.lucene.store.Directory} implementation which stored data in the data grid.

Some additional methods we add to our Directory implementations, mostly for reporting and testing reasons.
Common code for different Directory implementations.
DirectoryIntegrityCheck contains helpers to assert assumptions we make on the structure of an index as stored in an Infinispan cache.
Contains the low-level logic to map the cache structure the the "native" Lucene format for a single Directory instance.
Directory implementation for Apache Lucene. Meant to be compatible with versions 5.0+
Test the Hibernate Search module in Wildfly (slot "main") combined with the Infinispan directory provider

Handles the disconnect

Cache store interceptor specific for the distribution and replication cache modes. <p> <p>If the cache store is shared, only the primary owner of the key writes to the cache store.</p> <p>If the cache store is not shared, every owner of a key writes to the cache store.</p> <p>In non-tx caches, if the originator is an owner, the command is executed there twice. The first time, ({@code isOriginLocal() == true}) we don't write anything to the cache store; the second time, the normal rules apply.</p> <p>For clear operations, either only the originator of the command clears the cache store (if it is shared), or every node clears its cache store (if it is not shared). Note that in non-tx caches, this happens without holding a lock on the primary owner of all the keys.</p>
Performs distinct operation on a {@link DoubleStream}
Performs distinct operation on a {@link IntStream}

Performs distinct operation on a {@link LongStream}
Performs distinct operation on a regular {@link Stream}
Server task working in Dist mode for specified role.
Tests in distributed mode the server task execution in case if authentication is required.


Resource description for the addressable resource /subsystem=infinispan/cache-container=X/distributed-cache=*
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/distributed-cache=*
Implementation of {@link CacheStream} that provides support for lazily distributing stream methods to appropriate nodes
Task verifying that the marshaller is passed properly and the value is properly put into the cache.
A task that returns a result and may throw an exception capable of being executed in another JVM. <p>
Implementation of {@link DoubleStream} that utilizes a lazily evaluated distributed back end execution.  Note this class is only able to be created using {@link org.infinispan.CacheStream#mapToDouble(ToDoubleFunction)} or similar methods from the {@link org.infinispan.CacheStream} interface.
DistributedExecuteCommand is used to migrate Callable and execute it in remote JVM.
A {@link CompletionService} that uses a supplied {@link DistributedExecutorService} to execute tasks. This class arranges that submitted tasks are, upon completion, placed on a queue accessible using <tt>take</tt>. The class is lightweight enough to be suitable for transient use when processing groups of tasks. <p> This class must be used instead of a {@link ExecutorCompletionService} provided from java.util.concurrent package. The {@link ExecutorCompletionService} may not be used since it requires the use of a non serializable RunnableFuture object.

An ExecutorService that provides methods to submit tasks for execution on a cluster of Infinispan nodes. <p> Every DistributedExecutorService is bound to one particular cache. Tasks submitted will have access to key/value pairs from that particular cache if and only if the task submitted is an instance of {@link DistributedCallable}. Also note that there is nothing preventing a user from submitting a familiar {@link Runnable} or {@link Callable} just like to any other {@link ExecutorService}. However, DistributedExecutorService, as it name implies, will likely migrate submitted Callable or Runnable to another JVM in Infinispan cluster, execute it and return a result to task invoker. <p> Note that due to potential task migration to other nodes every {@link Callable}, {@link Runnable} and/or {@link DistributedCallable} submitted must be either {@link Serializable} or {@link Externalizable}. Also the value returned from a callable must be {@link Serializable} or {@link Externalizable}. Unfortunately if the value returned is not serializable then a {@link NotSerializableException} will be thrown. <p> All {@link CompletableFuture} returned to the caller may be cancelled, however if interruption is desired, (ie. <b>mayInterruptIfRunning == true</b>), it will only be performed if done on the original <b>CompletableFuture</b> returned via one of the various submit methods.  Any chained futures from the original will only attempt to cancel the task result.  If interruption is needed and this task was found to be operating on a remote node it will send a cancellation command to the remote node in an attempt to stop it early using standard java {@link Thread#interrupt()} on the thread processing that task.
Implementation of {@link IntStream} that utilizes a lazily evaluated distributed back end execution.  Note this class is only able to be created using {@link org.infinispan.CacheStream#mapToInt(ToIntFunction)} or similar methods from the {@link org.infinispan.CacheStream} interface.
DistributedIterator. Iterates on a distributed query.
Server task for executing script over infinispan.
DistributedLazyIterator. Lazily iterates on a distributed query
Implementation of {@link LongStream} that utilizes a lazily evaluated distributed back end execution.  Note this class is only able to be created using {@link org.infinispan.CacheStream#mapToInt(ToIntFunction)} or similar methods from the {@link org.infinispan.CacheStream} interface.
MapReduce task for executing on cluster.
This handler is to be used with a clustered distributed cache.  This handler does special optimizations to alllow for queueing to occur per segment.  This way we don't retain all new events in memory unlike {@link QueueingAllSegmentListener} until the iteration is complete.
DistributedRunner.
DistributedScript.
<p>DistributedSegmentReadLocker stores reference counters in the cache to keep track of the number of clients still needing to be able to read a segment. It makes extensive usage of Infinispan's atomic operations.</p> <p>Locks stored this way are not optimally performing as it might spin on remote invocations, and might fail to cleanup some garbage in case a node is disconnected without having released the readlock.</p>
Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/28/16 Time: 1:49 PM
Testing the jar task deployment/undeploy.
Tests running the remote task execution tests in Domain mode.

Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/28/16 Time: 9:36 AM
DistributedTask describes all relevant attributes of a distributed task, most importantly its execution policy, fail over policy and its timeout.
DistributedTaskBuilder is a factory interface for DistributedTask
DistributedTaskExecutionPolicy allows task to specify its custom task execution policy across Infinispan cluster. <p> DistributedTaskExecutionPolicy effectively scopes execution of tasks to a subset of nodes. For example, someone might want to exclusively execute tasks on a local network site instead of a backup remote network centre as well. Others might, for example, use only a dedicated subset of a certain Infinispan rack nodes for specific task execution. DistributedTaskExecutionPolicy is set per instance of DistributedTask.
DistributedTaskFailoverPolicy allows pluggable fail over target selection for a failed remotely executed distributed task.


Interceptor that handles bulk entrySet and keySet commands when using in a distributed/replicated environment. This interceptor produces backing collections for either method and a distributed stream for either which leverages distributed processing through the cluster.

A component that manages the distribution of elements across a cache cluster

The default distribution manager implementation
This class is used when deadlock detection is enabled.


A {@link DoubleStream} that has additional methods to allow for Serializable instances.  Please see {@link CacheStream} for additional details about various methods.
A builder for creating a range validator for {@link ModelType#DOUBLE} parameters.
Computes the sum and average of doubles. The implementation uses compensated summation in order to reduce the error bound in the numerical sum compared to a simple summation of {@code double} values, similar to the way {@link java.util.DoubleSummaryStatistics} works.
Externalizer used for {@link DoubleSummaryStatistics}.  Note this assumes given fields have specific names to use through reflection.
A {@link ConnectionProvider} implementation adding JTA-style transactionality around the returned connections using the {@link DualNodeJtaTransactionManagerImpl}.

SimpleJtaTransactionImpl variant that works with DualNodeTransactionManagerImpl. TODO: Merge with single node transaction manager
Variant of SimpleJtaTransactionManagerImpl that doesn't use a VM-singleton, but rather a set of impls keyed by a node id. TODO: Merge with single node transaction manager as much as possible



A Dummy cache store which stores objects in memory. Instance of the store can be shared amongst multiple caches by utilising the same `storeName` for each store instance.



Injection target implementation that does nothing

Xid to be used when no XAResource enlistment takes place. This is more efficient both creation and memory wise than {@link DummyXid}.







Simple transaction manager implementation that maintains transaction state in memory only.
Returns an instance of {@link org.infinispan.transaction.tm.DummyTransactionManager}.

Implementation of Xid.

Tests whether {@link DefaultCacheManager} sets custom Cache name to avoid JMX name collision.



This is the implementation class for the interface ResultIterator. It is what is returned when the {@link org.infinispan.query.CacheQuery#iterator()} using a {@link org.infinispan.query.FetchOptions.FetchMode#EAGER}. <p/>



@since 9.0




A bridge between Infinispan Embedded events and Spring.
A simple {@link TransactionManager} implementation. <p> It provides the basic to handle {@link Transaction}s and supports any {@link javax.transaction.xa.XAResource}. <p> Implementation notes: <ul> <li>The state is kept in memory only.</li> <li>Does not support recover.</li> <li>Does not support multi-thread transactions. Although it is possible to execute the transactions in multiple threads, this transaction manager does not wait for them to complete. It is the application responsibility to wait before invoking {@link #commit()} or {@link #rollback()}</li> <li>The transaction should not block. It is no possible to {@link #setTransactionTimeout(int)} and this transaction manager won't rollback the transaction if it takes too long.</li> </ul> <p> If you need any of the requirements above, please consider use another implementation. <p> Also, it does not implement any 1-phase-commit optimization.
EmbeddedCacheManager is an CacheManager that runs in the same JVM as the client. <p/> Constructing a <tt>EmbeddedCacheManager</tt> is done via one of its constructors, which optionally take in a {@link org.infinispan.configuration.cache.Configuration} or a path or URL to a configuration XML file: see {@link org.infinispan.manager.DefaultCacheManager}. <p/> Lifecycle - <tt>EmbeddedCacheManager</tt>s have a lifecycle (it implements {@link Lifecycle}) and the default constructors also call {@link #start()}.  Overloaded versions of the constructors are available, that do not start the <tt>CacheManager</tt>, although it must be kept in mind that <tt>CacheManager</tt>s need to be started before they can be used to readWriteMap <tt>Cache</tt> instances. <p/> Once constructed, <tt>EmbeddedCacheManager</tt>s should be made available to any component that requires a <tt>Cache</tt>, via <a href="http://en.wikipedia.org/wiki/Java_Naming_and_Directory_Interface">JNDI</a> or via some other mechanism such as an <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> framework. <p/>

An exception to encapsulate an error when starting up a cache manager

A {@link CounterManager} implementation for embedded cache manager.
A {@link CounterManager} factory for embedded cached.

The JBoss Logging interface which defined the logging methods for the CDI integration. The id range for the CDI integration is 17001-18000
A query implementation based on Lucene.
Metadata class for embedded caches.

Embedded implementation of {@link MultimapCache}
Embedded implementation of {@link MultimapCacheManager}
A {@link MultimapCache} factory for embedded cached.
Multimap Cache module implementation of {@link ModuleMetadataFileFinder}
Non-indexed embedded-mode query.



EmbeddedServerAdminOperationHandler is a simple implementation of {@link AdminOperationsHandler} which uses a {@link org.infinispan.manager.ClusterExecutor} to perform operations on all of the cluster. The approach is quite fragile since new joiners will not be in sync with any caches created here.
A {@link Transaction} implementation used by {@link EmbeddedBaseTransactionManager}. <p> See {@link EmbeddedBaseTransactionManager} for more details.
Simple transaction manager implementation that maintains transaction state in memory only. <p> See {@link EmbeddedBaseTransactionManager} for details about which features are supported.
Returns an instance of {@link org.infinispan.transaction.tm.EmbeddedTransactionManager}.


A {@link UserTransaction} implementation that uses {@link EmbeddedTransactionManager}. <p> This implementation does not support transaction timeout and it does not cancel long running transactions. <p> See {@link EmbeddedBaseTransactionManager} for more details about its implementation.
Implementation of {@link Xid} used by {@link EmbeddedTransactionManager}.


Factory for building global-scope components which have default empty constructors
Simple factory that just uses reflection and an empty constructor of the component type.
EmptyResult. A result returned by operations which do not produce any output
A query that does not return any results because the query filter is a boolean contradiction.
Add this annotation to a {@code @Configuration} class to expose the SessionRepositoryFilter as a bean named "springSessionRepositoryFilter" and backed on Infinispan. <p> The configuration requires creating a {@link org.infinispan.spring.provider.SpringCache} (for either remote or embedded configuration). Here's an example: <pre> <code> {@literal @Configuration} {@literal @EnableInfinispanEmbeddednHttpSession} public class InfinispanConfiguration { {@literal @Bean} public SpringEmbeddedCacheManagerFactoryBean springCache() { return new SpringEmbeddedCacheManagerFactoryBean(); } } </code> </pre> Configuring advanced features requires putting everything together manually or extending {@link InfinispanEmbeddedHttpSessionConfiguration}.
Add this annotation to a {@code @Configuration} class to expose the SessionRepositoryFilter as a bean named "springSessionRepositoryFilter" and backed on Infinispan. <p> The configuration requires creating a {@link org.infinispan.spring.provider.SpringCache} (for either remote or embedded configuration). Here's an example: <pre> <code> {@literal @Configuration} {@literal @EnableInfinispanRemoteHttpSession} public class InfinispanConfiguration { {@literal @Bean} public SpringRemoteCacheManagerFactoryBean springCache() { return new SpringRemoteCacheManagerFactoryBean(); } } </code> </pre> Configuring advanced features requires putting everything together manually or extending {@link InfinispanRemoteHttpSessionConfiguration}.
Used to convert data between read/write format and storage format.

Cache decoration that makes use of the {@link Encoder} and {@link Wrapper} to convert between storage value and read/write value.
{@link java.util.function.Function} that uses an encoder to converter entries from the configured storage format to the requested format.

{@link java.util.function.Function} that uses a keyEncoder to converter keys from the configured storage format to the requested format.
Manages existent {@link Encoder} and {@link Wrapper} instances.
Factory for {@link EncoderRegistryImpl} objects.

{@link java.util.function.Function} that uses a valueEncoder to converter values from the configured storage format to the requested format.

The {@link CacheCommand#ENCODING} handler.

EncodingStatement selects a codec to use for encoding/decoding keys/values from the cli to the cache and viceversa
Utilities to encode/decode keys and values from caches.
Test JGroups' ENCRYPT protocol. Only proper registration of the protocol is tested, making sure that the server can work with ENCRYPT protocol. This test does NOT check whether the communication between nodes is really encrypted. Command used to generate the certificate for ENCRYPT protocol: keytool -genseckey -alias memcached -keypass secret -storepass secret -keyalg DESede -keysize 168 -keystore server_jceks.keystore -storetype  JCEKS Command used to inspect the certificate: keytool -list -v -keystore server_jceks.keystore  -storetype JCEKS



EncryptionAdd.
EncryptionResource.

EndBatchStatement ends a running batch statement
Sent in commit phase (after DB commit) to remote nodes in order to stop invalidating putFromLoads.


EndpointServerAuthenticationProvider.

The parser for the data grid endpoint subsystem configuration.
The root resource of the Endpoint subsystem.
The XML writer for the endpoint subsystem configuration.





A {@link CommonTree} representing an entity name.
Entity region implementation


A factory for constructing {@link org.infinispan.container.entries.MVCCEntry} instances for use in the {@link org.infinispan.context.InvocationContext}. Implementations of this interface would typically wrap an internal {@link org.infinispan.container.entries.CacheEntry} with an {@link org.infinispan.container.entries.MVCCEntry}. <h3>Expected wrapping patterns</h3> {@link EntryWrappingInterceptor} checks {@link CacheTopology#getReadConsistentHash()} and if this node is an owner of the key, it loads the entry from {@link DataContainer}. On the way back through interceptor stack, the entry is committed from {@link EntryWrappingInterceptor} through {@link ClusteringDependentLogic} which checks {@link CacheTopology#getWriteConsistentHash()}. <p> Entry being wrapped is a prerequisite for the command to run and therefore commit the entry, but it's not up to {@link EntryWrappingInterceptor} to make sure the entry is always wrapped - all the interceptors below can expect is <em>(key is in readCH) => (entry is wrapped)</em>. The entry may be wrapped by EWI or other interceptors later, e.g. (but not limited to) when: <ul> <li>entry is in L1 <li>entry is fetched from remote node <li>the cache is transactional and command should be executed on origin (but it does not need previous value - it is then wrapped as null entry) </ul> It is the distribution interceptor that enforces that (entry is read/written by command) => (entry is wrapped), by fetching the remote value, limiting the set of keys in given command (narrowing it) or not executing the command locally at all. <p> If the entry should be read locally but it's not found in DC, the entry will be wrapped by {@link EntryWrappingInterceptor} (either as {@link NullCacheEntry} for reads or other appropriate type for writes). Such entry returns <code>false</code> on {@link CacheEntry#skipLookup()} as it's value is unsure (subsequent interceptors can retrieve the new value from the cache store or remote node and call {@link EntryFactory#wrapExternalEntry} to update the context. <p> With repeatable reads, the value that is context must not be overwritten by value out of the transaction (only commands in this transaction can change the context entry. That's why {@link EntryWrappingInterceptor} calls {@link CacheEntry#setSkipLookup} from the return handler for every command. <p> When a command is retried and repeatable reads are not used, the entry is removed from the context completely and wrapped again by {@link EntryWrappingInterceptor}. When repeatable reads are in use, {@link org.infinispan.container.entries.RepeatableReadEntry} entry keeps the value before the command was executed and the context is reset to this value. <p> This summarizes expected behaviour of interceptors loading from persistence layer: <ul> <li>entry == null:             don't load the entry because this node is not a read owner <li>entry.skipLookup == false: attempt to load the entry <li>entry.skipLookup == true:  don't load the entry because it was already published </ul> Distribution interceptor should behave as follows: <ul> <li>entry == null: If this is a write command, check writeCH and if this node is <ul> <li>primary owner: that should not happen as command.topologyId is outdated (the topology is checked before executing the command and {@link org.infinispan.statetransfer.OutdatedTopologyException} is thrown) <li>backup owner and {@link VisitableCommand#loadType()} is {@link org.infinispan.commands.VisitableCommand.LoadType#OWNER OWNER}: retrieve the value from remote node <li>backup owner that does not need previous value: wrap null <li>non-owner: don't execute the command (or narrow the set of keys in it) </ul> If this is a read-only command: <ul> <li>If this is the origin, fetch the entry from remote node <li>If this is not the origin, the command must have different topologyId and we retry </ul> <li>entry != null: don't do any remote retrieval because the value is known </ul> <p> In local mode, the data can be always read and written, so there is no risk that a command won't have the entry wrapped.
{@link EntryFactory} implementation to be used for optimistic locking scheme.


Interface that can look up MVCC wrapped entries.


File-offset pair
Helper for reading/writing entries into file.
Command implementation for {@link java.util.Map#entrySet()} functionality.

Stream supplier that is to be used when the underlying stream is composed by {@link CacheEntry} instances.  This supplier will do the proper filtering by key based on the CacheEntry key.
A version is used to compare entries against one another.  Versions do not guarantee contiguity, but do guarantee to be comparable.  However this comparability is not the same as the JDK's {@link Comparable} interface.  It is richer in that {@link Comparable} doesn't differentiate between instances that are the same versus instances that are equal-but-different.

Entry views expose cached entry information to the user. Depending on the type of entry view, different operations are available. Currently, three type of entry views are supported: <ul> <il>{@link ReadEntryView}: read-only entry view</il> <il>{@link WriteEntryView}: write-only entry view</il> <il>{@link ReadWriteEntryView}: read-write entry view</il> </ul>
Entry views implementation class holder.
Wrapper for CacheEntry(s) that can be used to update the cache when it's value is set.
Interceptor in charge with wrapping entries and add them in caller's context.
{@link EnumSet} externalizer.
Utilities method to Enums.
An Enumeration -> List adaptor
EnvironmentAware.


An interface that allows custom implementations for objects that are comparable based on equality, hash code calculations, or according to {@link Comparable} rules, but where the behaviour provided by the JDK, or external libraries, cannot be modified, for example: arrays. The interface is marked to be {@link Serializable} because multiple collection extensions within the Infinispan code base contain references to them, and since these are potentially {@link Serializable}, they might be persisted somehow.

Custom hash-based map which accepts no null keys nor null values, where equality and hash code calculations are done based on passed {@link org.infinispan.commons.equivalence.Equivalence} function implementations for keys and values, as opposed to relying on their own equals/hashCode/toString implementations. This is handy when using key/values whose mentioned methods cannot be overriden, i.e. arrays, and in situations where users want to avoid using wrapper objects. This hash map implementation is optimised for store/retrieval rather than iteration. Internal node entries are not linked, so responsibility to link them falls on the iterators.
Custom hash-based set which accepts no null values, where equality and hash code calculations are done based on passed {@link org.infinispan.commons.equivalence.Equivalence} function implementations for values, as opposed to relying on their own equals/hashCode/toString implementations. This is handy when using key/values whose mentioned methods cannot be overriden, i.e. arrays, and in situations where users want to avoid using wrapper objects.
Custom hash-based linked list map which accepts no null keys nor null values, where equality and hash code calculations are done based on passed {@link org.infinispan.commons.equivalence.Equivalence} function implementations for keys and values, as opposed to relying on their own equals/hashCode/toString implementations. This is handy when using key/values whose mentioned methods cannot be overriden, i.e. arrays, and in situations where users want to avoid using wrapper objects. In order to provide linked list behaviour, entries are linked with each other in a predictable order.


An interface that defines common characteristics of events
Basic implementation of an event that covers all event types.
EventLog describes an event log's attributes.
EventLogCategory.
EventLogLevel.

EventLogManager. This is the entry point to the event logger.
EventLogManagerImpl. The implementation of the EventLogManager. By default this returns
EventLogger provides an interface for logging event messages.
Enum that provides information to allow for an event to know which type and if this event was generated due to a retry usually caused by a topology change while replicating.
Simple wrapper that keeps the original key along with the converted event.  The original key is required for things such as key tracking.



Evict all command

EvictStatement evicts an entry from the cache
Controls the eviction settings for the cache.
Controls the eviction settings for the cache.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/eviction=EVICTION
Basic integration tests for eviction on server
Eviction listener that is notified when entries are evicted from the underlying container due to the given eviction policy.
Central component that deals with eviction of cache entries. <p /> This manager only controls notifications of when entries are evicted. <p />

Tests for eviction storage configurations
Supported eviction strategies
Supported eviction thread policy
Supported eviction type
Tests for example configurations.
A command that represents an exception acknowledge sent by any owner. <p> The acknowledge represents an unsuccessful execution of the operation.
Custom assertion for testing exceptions.
A response that encapsulates an exception
Exception laundering utility class.
Generic interface for some object capable of execution.
ExecuteOperation.
ScriptExecutionMode.
Exectues given tasks in provided executor.
Used to configure and create executors
ExecutorFactoryConfiguration.
Configures executor factory.
Enumeration for whenExhaustedAction. Order is important, as the underlying commons-pool uses a byte to represent values ExhaustedAction. GenericKeyedObjectPool.WHEN_EXHAUSTED_GROW
A byte stream that can be written to and expanded on the fly, not dissimilar to {@link ExposedByteArrayOutputStream} but with the benefit of not having to allocate unnecessary byte arrays by not extending {@link java.io.ByteArrayOutputStream}.

An experimental user-facing API. Elements annotated with this annotation are experimental and may get removed from the distribution at any time.
Utility class for expiration calculations.
Controls the default expiration settings for entries in the cache.
Controls the default expiration settings for entries in the cache.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/expiration=EXPIRATION
ExpirationData holds optional expiration information as specified in cli commands
Test for expiration configuration. Tested with REST (verifies JBPAPP-6928) and HotRod. Memcached cache cannot be configured to use expiration, see https://bugzilla.redhat.com/show_bug.cgi?id=909177#c5 . Tests when individual requests use expiration are also in client tests, here we're testing that they override the global configuration.
Central component that deals with expiration of cache entries. <p /> Typically, {@link #processExpiration()} is called periodically by the expiration thread (which can be configured using {@link ExpirationConfigurationBuilder#wakeUpInterval(long)} and {@link GlobalConfigurationBuilder#expirationThreadPool()}). <p /> If the expiration thread is disabled - by setting {@link ExpirationConfigurationBuilder#wakeUpInterval(long)} to <tt>0</tt> - then this method could be called directly, perhaps by any other maintenance thread that runs periodically in the application. <p />
Constructs the expiration manager


Provide utility methods for dealing with expiration of cache entries.
Implements /subsystem=jgroups/stack=X/export-native-configuration() operation.
Extends ByteArrayOutputStream, but exposes the internal buffer. Using this, callers don't need to call toByteArray() which copies the internal buffer. <p> Also overrides the superclass' behavior of always doubling the size of the internal buffer any time more capacity is needed.  This class doubles the size until the internal buffer reaches a configurable max size (default is 4MB), after which it begins growing the buffer in 25% increments.  This is intended to help prevent an OutOfMemoryError during a resize of a large buffer. </p> <p> A version of this class was originally created by Bela Ban as part of the JGroups library. </p> This class is not threadsafe as it will not support concurrent readers and writers. <p/>
A pass-through, zero transformation {@link Visitor} implementation. Comes handy when you want to implement a {@link Visitor} but do not want to cover all the cases.

Builder for the creation of WHERE/HAVING clause filters targeting a single entity. <p/> Implemented as a stack of {@link LazyBooleanExpr}s which allows to add elements to the constructed query in a uniform manner while traversing through the original query parse tree.
Decorates {@link org.hibernate.search.backend.impl.batch.DefaultBatchBackend} adding capacity of doing synchronous purges and flushes.

Utilities to read from a {@link ByteBuf}

An extended {@link LockPromise} interface that allows a better control over it.
{@link RiverMarshaller} extension that allows Infinispan code to directly create instances of it.
An extended {@link RiverUnmarshaller} that allows to track lifecycle of unmarshaller so that pools can be notified when not in use any more.
Add extra methods.
The available extended statistics
Take the statistics about relevant visitable commands.
Takes statistic about lock acquisition.

Takes statistics about the RPC invocations.
Contains the statistic's values and allows to perform modifications on them.




Marker interface for those pojos that are allowed to be marshalled externally. One such example are pojos used in testing, but not limited to.


Basic interface for interacting with an external store in a read-write mode.

Externalizer for Externalizable objects.
One of the key aspects of Infinispan is that it often needs to marshall or unmarshall objects in order to provide some of its functionality.  For example, if it needs to store objects in a write-through or write-behind cache store, the objects stored need marshalling.  If a cluster of Infinispan nodes is formed, objects shipped around need marshalling.  Even if you enable storing as binary, objects need to marshalled so that they can be lazily unmarshalled with the correct classloader. Using standard JDK serialization is slow and produces payloads that are too big and can affect bandwidth usage.  On top of that, JDK serialization does not work well with objects that are supposed to be immutable.  In order to avoid these issues, Infinispan uses JBoss Marshalling for marshalling/unmarshalling objects.  JBoss Marshalling is fast, provides very space efficient payloads, and on top of that, allows users to construct objects themselves during unmarshalling, hence allowing objects to carry on being immutable. Starting with 5.0, users of Infinispan can now benefit from this marshalling framework as well.  In the simplest possible form, users just need to provide an {@link Externalizer} implementation for the type that they want to marshall/unmarshall, and then annotate the marshalled type class with {@link SerializeWith} indicating the externalizer class to use and that's all about it.  At runtime JBoss Marshaller will inspect the object and discover that's marshallable thanks to the annotation and so marshall it using the externalizer class passed. It's common practice to include externalizer implementations within the classes that they marshall/unmarshall as <code>public static classes</code>. To make externalizer implementations easier to code and more typesafe, make sure you define type <T> as the type of object that's being marshalled/unmarshalled. Even though this way of defining externalizers is very user friendly, it has some disadvantages: <ul> <li>Due to several constraints of the model, such as support different versions of the same class or the need to marshall the Externalizer class, the payload sizes generated via this method are not the most efficient.</li> <li>This model requires for the marshalled class to be annoated with {@link SerializeWith} but a user might need to provide an Externalizer for a class for which source code is not available, or for any other constraints, it cannot be modified.</li> <li>The use of annotations by this model might be limiting for framework developers or service providers that try to abstract lower level details, such as the marshalling layer, away from the user.</li> </ul> If you're affected by any of these disadvantages, an alternative mechanism to provide externalizers is available via {@link AdvancedExternalizer}. More details can be found in this interface's javadoc. Please note that even though Externalizer is marked as {@link Serializable}, the need to marshall the externalizer is only really needed when developing user friendly externalizers (using {@link SerializeWith}). {@link AdvancedExternalizer} instances do not require the externalizer to be serializable since the externalizer itself is not marshalled. Even though it's not strictly necessary, to avoid breaking compatibility with old clients, {@link Externalizer} implements {@link Serializable} but this requirement is only needed for those user friendly externalizers. There's a chance that in future major releases {@link Externalizer} won't extend {@link Serializable} any more, hence we strongly recommend that any user-friendly externalizer users mark their externalizer implementations as either {@link Serializable} or {@link java.io.Externalizable}.
Identifiers used by the Marshaller to delegate to specialized Externalizers. For details, read http://infinispan.org/docs/9.0.x/user_guide/user_guide.html#_preassigned_externalizer_id_ranges The range reserved for the Infinispan Query module is from 1600 to 1699.
The externalizer table maintains information necessary to be able to map a particular type with the corresponding {@link org.infinispan.commons.marshall.AdvancedExternalizer} implementation that it marshall, and it also keeps information of which {@link org.infinispan.commons.marshall.AdvancedExternalizer} should be used to read data from a buffer given a particular {@link org.infinispan.commons.marshall.AdvancedExternalizer} identifier. <p> These tables govern how either internal Infinispan classes, or user defined classes, are marshalled to a given output, or how these are unmarshalled from a given input.
JBMAR externalizers for QueryRequest/Response objects.
As much as possible, Infinispan consumers should provide {@link org.infinispan.commons.marshall.Externalizer} or {@link org.infinispan.commons.marshall.AdvancedExternalizer} instances for the types being marshalled, so that these types can be marshalled as efficiently as possible. Sometimes however, Infinispan consumers might rely on the fact that a certain type implements Java's standard {@link Serializable} or {@link java.io.Externalizable}. This class acts a test barrier which controls, provided assertions have been enabled, which types can be externally marshalled using JBoss Marshalling. The plan is for external marshalling is be morphed into user type marshalling, at which point this class won't be used any more.
Interceptor that can selectively fail or skip executing commands. The executor is controlled through a series of {@code Action}s. Each action represents a number of executions, skips or failures for a given command type. The interceptor will match the actions in order, so if the first action has a count of {@code Integer.MAX_VALUE} the rest of the actions will practically never match.
Cluster Executor that submits to a single node at a time, but allows for automatic failover up to a certain number of times. The subsequent node where the retry is chosen at random. <p> This executor currently only functions properly when using a single submission cluster executor such as {@link LocalClusterExecutor} and {@link SingleClusterExecutor}
As {@link DistributedTask} might potentially fail on subset of executing nodes FailureContext provides details of such task failure. FailureContext has a scope of a node where the task failed.


Failure entry processor result wrapper.

A HashMap that is optimized for fast shallow copies. <p/> Null keys are <i>not</i> supported.
A fault tolerant ping operation that can survive to node failures.

An accumulator is a stateless object that operates on row data.
A mapping from an object field to an index field and the flags that enable indexing, storage and analysis.
Used as a key for file headers in a cache
The goal is to test that the file-store is really preserving data after server kills/shutdowns. The path configuration and expiration is tested in ExampleConfigs (we can't test there the server restarts because all the caches in the example configuration have purge=true).
Takes care of properly storing and retrieving file chunks from/to cache. Each chunk's key is composed of the file path and the chunk's number. The value is a byte array, which is either chunkSize bytes long or less than that in the case of the last chunk.
Cache key for a list with current files in cache
Maintains a Set of filenames contained in the index. Does not implement Set for simplicity, and does internal locking to provide a safe Externalizer.
Collects operations on the existing fileList, stored as a Set<String> having key of type FileListCacheKey(indexName).


Header for Lucene files. Store only basic info about file. File data is divided into byte[] chunks and stored under {@link org.infinispan.lucene.ChunkCacheKey}
Provides resource management for files - only limited amount of files may be opened in one moment, and opened file should not be deleted. Also allows to generate file indexes.
Lucene's index segment files are chunked, for safe deletion of elements a read lock is implemented so that all chunks are deleted only after the usage counter is decremented to zero. FileReadLockKey is used as a key for the reference counters; a special purpose key was needed to make atomic operation possible.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/store=STORE
A single-method callback that is specified when registering a filter with a Matcher. The {@link #onFilterResult} method is notified of all instances that were presented to {@link Matcher#match} and successfully matched the filter associated with this callback. The callback will receive the instance being matched, the projected fields (optional, if specified) and the 'order by' projections (optional, if specified). The 'order by' projection is an array of {@link java.lang.Comparable} that can be compared using the {@link java.util.Comparator} provided by {@link FilterSubscription#getComparator()}. <p/> Implementations of this interface are provided by the subscriber and must written is such a way that they can be invoked from multiple threads simultaneously.
The beginning context of an incomplete condition. It exposes methods for specifying the left hand side of the condition.
The context of a complete filter. Provides operations to allow connecting multiple filters together with boolean operators.

The context that ends a condition. Here we are expected to specify the right hand side of the filter condition, the operator and the operand, in order to complete the filter.


Performs filter operation on a {@link DoubleStream}


A service provider for filter indexing services. This is supposed to perform the filtering operation in a more efficient way than directly executing the filter by calling the {@link org.infinispan.notifications.cachelistener.filter.CacheEventFilterConverter#filterAndConvert(Object, Object, Metadata, Object, Metadata, EventType)} method. Implementations are discovered via the {@link java.util.ServiceLoader} or {@link org.infinispan.commons.util.ServiceFinder} mechanism. Implementations may have their dependencies injected using the {@link org.infinispan.factories.annotations.Inject} annotation.
Performs filter operation on a {@link IntStream}
Performs filter operation on a {@link LongStream}
Response collector supporting {@link JGroupsTransport#invokeRemotelyAsync(Collection, ReplicableCommand, ResponseMode, long, ResponseFilter, DeliverOrder, boolean)}. <p>This class is not thread-safe by itself. It expects an {@link org.infinispan.remoting.transport.AbstractRequest} to handle synchronization.</p>

Performs filter operation on a regular {@link Stream}

A registry for filters on the same type of entity.

A 'remote' FilterResult needs jboss-marshalling serializability between nodes when running in compat mode. It will only be marshalled using protobuf before passing it to the remote client.

A subscription for match notifications.

A Listable that can also filter events based on key

FineGrainedAtomicMap is a special type of Map geared for use in Infinispan. In addition to the properties of {@link AtomicMap}, locking and isolation is applied on keys rather than entire map itself. <b><u>Usage</u></b> <p> FineGrainedAtomicMap should be constructed and "registered" with Infinispan using the {@link AtomicMapLookup} helper.  This helper ensures thread safe construction and registration of AtomicMap instances in Infinispan's data container.  E.g.: <br /> <code> FineGrainedAtomicMap&lt;String, Integer&gt; map = AtomicMapLookup.getFineGrainedAtomicMap(cache, "my_atomic_map_key"); </code> </p> <p> This interface, for all practical purposes, is just a marker interface that indicates that maps of this type will be locked atomically in the cache and replicated in a fine grained manner, as it does not add any additional methods to {@link java.util.Map}. </p>
Implementation of {@link FineGrainedAtomicMap} that uses {@link org.infinispan.distribution.group Grouping API} to co-locate subkeys on the same node. Therefore the entries in this map are held as regular cache entries, but in order to prevent the need for iterating all data in the owning node we also keep a set of keys under the map's key. <p> The implementation requires to be executed on a transactional cache with grouping API enabled. Neither null keys nor null values are supported. <p> This cached set implemented by {@link AtomicKeySetImpl} is accessed using functional API and can be modified without acquiring its lock as long as we modify the same keys in that transaction. <p> Once the map is created or fully read ({@link #size(), {@link #keySet()}, {@link #values()} or {@link #entrySet()}), the whole map (both keys and values) is loaded into context to guarantee repeatable reads semantics. {@link #clear()} removes only those keys that are known - if the map is read, and another transaction adds a key afterwards, such key may not be removed from the map. <p> The map cannot be safely removed (using {@link org.infinispan.atomic.AtomicMapLookup#removeAtomicMap(Cache, Object)} concurrently to another modifications - such operation may result in leaked entries, map being cleared but not removed, failures during commit phase or other undefined behaviour.
{@link ShardDistribution} that maintain a fixed number of index shards. The minimum number of shards is 1 and the maximum is the number of segments.
Defines all the flags available in the Hot Rod client that can influence the behavior of operations. <p /> Available flags: <ul> <li>{@link #FORCE_RETURN_VALUE} - By default, previously existing values for {@link java.util.Map} operations are not returned. E.g. {@link RemoteCache#put(Object, Object)} does <i>not</i> return the previous value associated with the key.  By applying this flag, this default behavior is overridden for the scope of a single invocation, and the previous existing value is returned.</li> <li>{@link #DEFAULT_LIFESPAN}     This flag can either be used as a request flag during a put operation to mean that the default server lifespan should be applied or as a response flag meaning that the return entry has a default lifespan value</li> <li>{@link #DEFAULT_MAXIDLE}      This flag can either be used as a request flag during a put operation to mean that the default server maxIdle should be applied or as a response flag meaning that the return entry has a default maxIdle value</li> <li>{@link #SKIP_CACHE_LOAD}      Skips loading an entry from any configured {@link org.infinispan.persistence.spi.CacheLoader}s.</li> <li>{@link #SKIP_INDEXING}        Used by the Query module only, it will prevent the indexes to be updated as a result of the current operations. </ul>
Flags modify behavior of command such as whether or not to invoke certain commands remotely, check cache store etc.
Implemented by stores that can skip writes based on certain flags present in the invocation.
Pre-computed bitsets containing each flag.
Performs flat map operation on a {@link DoubleStream}
Performs flat map operation on a {@link IntStream}
Terminal rehash aware operation that handles an iterator when a flat map intermediate operation was performed on the stream.  This is important due to the fact that we need to track what keys have been processed for the iterator. Since flat map can produce multiple values for the same key we need to handle that special so we can guarantee we are returning the keys properly and a rehash wouldn't lose some. This class assumes the stream is composed of {@link java.util.Map.Entry} instances where the key is typed the same as defined K type.
Performs flat map operation on a {@link LongStream}
Performs flat map operation on a regular {@link Stream}
Performs flat map to double operation on a regular {@link Stream}
Performs flat map to int operation on a regular {@link Stream}
Performs flat map to long operation on a regular {@link Stream}
FlushCacheAction.

Terminal operation that handles for each where no map operations are defined
Terminal rehash aware operation that handles for each where no flat map operations are defined on a {@link DoubleStream}. Note this means it is an implied map intermediate operation.
Terminal rehash aware operation that handles for each where flat map operation is performed on a {@link DoubleStream}.
Terminal rehash aware operation that handles for each where flat map operation is performed on a {@link IntStream}.
Terminal rehash aware operation that handles for each where flat map operation is performed on a {@link LongStream}.
Terminal rehash aware operation that handles for each where flat map operation is performed on a {@link DoubleStream}.
Terminal rehash aware operation that handles for each where flat map operation is performed on a {@link IntStream}.
Terminal rehash aware operation that handles for each where flat map operation is performed on a {@link LongStream}.
Terminal rehash aware operation that handles for each where no flat map operations are defined on a {@link IntStream}. Note this means it is an implied map intermediate operation.
Terminal rehash aware operation that handles for each where no flat map operations are defined on a {@link LongStream}. Note this means it is an implied map intermediate operation.
Terminal rehash aware operation that handles for each where no flat map operations are defined on a {@link DoubleStream}. Note this means it is an implied map intermediate operation.
Terminal rehash aware operation that handles for each where no flat map operations are defined on a {@link IntStream}. Note this means it is an implied map intermediate operation.
Terminal rehash aware operation that handles for each where no flat map operations are defined on a {@link LongStream}. Note this means it is an implied map intermediate operation.
Terminal operation that handles for each where no map operations are defined
Add operation handler for fork resources.
Factory for creating forked channels.
Builder for a service that provides a {@link ChannelFactory} for creating fork channels.
Add operation handler for fork-specific protocol resources.
Fork-specific protocol resource definition.
Operation handler for registration of fork protocol runtime resources.
Remove operation handler for fork resources.
Definition of a fork resource.
A {@link CacheRpcCommand} implementation to forward the commit request from a client to the member that run the transaction.
A {@link CacheRpcCommand} implementation to forward the rollback request from a client to the member that run the transaction.
An implementation of {@link Bean} that forwards all calls to the {@link #delegate()}.
A class designed to forward all method invocations for a CacheEntry to the provided delegate.  This class is useful to extend when you want to only modify
A list which forwards all its method calls to another list. Subclasses should override one or more methods to modify the behavior of the backing list as desired per the <a href="http://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a>. <p> This class does not implement {@link java.util.RandomAccess}. If the delegate supports random access, the {@code ForwardingList} subclass should implement the {@code RandomAccess} interface.
An implementation of {@link ObserverMethod} that forwards all calls to {@link #delegate()}.
A Fully Qualified Name (Fqn) is a list of names (typically Strings but can be any Object), which represent a path to a particular {@link Node} in a {@link TreeCache}. <p/> This name can be absolute (i.e., relative from the root node - {@link #ROOT}), or relative to any node in the cache. Reading the documentation on each API call that makes use of {@link Fqn}s will tell you whether the API expects a relative or absolute Fqn. <p/> For instance, using this class to fetch a particular node might look like this.  (Here data on "Joe" is kept under the "Smith" surname node, under the "people" tree.) <pre> Fqn<String> abc = Fqn.fromString("/people/Smith/Joe/"); Node joesmith = Cache.getRoot().getChild(abc); </pre> Alternatively, the same Fqn could be constructed using a List<Object> or varargs: <pre> Fqn<String> abc = Fqn.fromElements("people", "Smith", "Joe"); </pre> This is a bit more efficient to construct. <p/> Note that<br> <p/> <code>Fqn<String> f = Fqn.fromElements("/a/b/c");</code> <p/> is <b>not</b> the same as <p/> <code>Fqn<String> f = Fqn.fromString("/a/b/c");</code> <p/> The former will result in a single Fqn, called "/a/b/c" which hangs directly under Fqn.ROOT. <p/> The latter will result in 3 Fqns, called "a", "b" and "c", where "c" is a child of "b", "b" is a child of "a", and "a" hangs off Fqn.ROOT. <p/> Another way to look at it is that the "/" separarator is only parsed when it forms part of a String passed in to Fqn.fromString() and not otherwise. <p/> <B>Best practices</B>: Always creating Fqns - even when using some factory methods - can be expensive in the long run, and as far as possible we recommend that client code holds on to their Fqn references and reuse them.  E.g.: <code> // BAD!! for (int i=0; i<someBigNumber; i++) { cache.get(Fqn.fromString("/a/b/c"), "key" + i); } </code> instead, do: <code> // Much better Fqn f = Fqn.fromString("/a/b/c"); for (int i=0; i<someBigNumber; i++) { cache.get(f, "key" + i); } </code>
Compares the order of two FQN. Sorts by name, then by depth, e.g. <pre> aaa/bbb xxx xxx/ccc </pre>
Helper class that will generate fqn's.





Checks if there are any full-text predicates in a query.


A command that carries operation rather than final value.
A {@link ConcurrentMap} implementation that uses the operations exposed by {@link ReadOnlyMap}, {@link WriteOnlyMap} and {@link ReadWriteMap}, and validates their usefulness.
A {@link Cache} implementation that uses the operations exposed by {@link ReadOnlyMap}, {@link WriteOnlyMap} and {@link ReadWriteMap}, and validates their usefulness.


Top level functional map interface offering common functionality for the read-only, read-write, and write-only operations that can be run against a functional map asynchronously. <p>Lambdas passed in as parameters to functional map methods define the type of operation that is executed, but since lambdas are transparent to the internal logic, it was decided to separate the API into three types of operation: read-only, write-only, and read-write. This separation helps the user understand the group of functions and their possibilities. <p>This conscious decision to separate read-only, write-only and read-write interfaces helps type safety. So, if a user gets a read-only map, it can't write to it by mistake since no such APIs are exposed. The same happens with write-only maps, the user can only write and cannot make the mistake of reading from the entry view because read operations are not exposed. <p>Lambdas passed in to read-write and write-only operations, when running in a cluster, must be marshallable. One option to do so is to mark them as being {@link java.io.Serializable} but this is expensive in terms of payload size. Alternatively, you can provide an Infinispan {@link org.infinispan.commons.marshall.Externalizer} for it which drastically reduces the payload size. Marshallable lambdas for some of the most popular lambda functions used by {@link ConcurrentMap} and javax.cache.Cache are available via the {@link MarshallableFunctions} helper class. <p>Being an asynchronous API, all methods that return a single result, return a {@link CompletableFuture} which wraps the result. To avoid blocking, it offers the possibility to receive callbacks when the {@link CompletableFuture} has completed, or it can be chained or composes with other {@link CompletableFuture} instances. <p>For those operations that return multiple results, the API returns instances of a {@link Traversable} interface which offers a lazy pullstyle API for working with multiple results. Although pushstyle interfaces for handling multiple results, such as RxJava, are fully asynchronous, they're harder to use from a users perspective. {@link Traversable}, being a lazy pullstyle API, can still be asynchronous underneath since the user can decide to work on the {@link Traversable} at a later stage, and the implementation itself can decide when to compute those results.
Functional map implementation.
Listener notifier.

Request to update the tombstone, coming from insert/update/remove operation. This object should *not* be stored in cache.



A marshaller that makes use of <a href="http://www.jboss.org/jbossmarshalling">JBoss Marshalling</a> to serialize and deserialize objects. This marshaller is oriented at external, non-core Infinispan use, such as the Java Hot Rod client.


A transaction manager lookup class that attempts to locate a TransactionManager. A variety of different classes and JNDI locations are tried, for servers such as: <ul> <li> JBoss <li> JRun4 <li> Resin <li> Orion <li> JOnAS <li> BEA Weblogic <li> Websphere 4.0, 5.0, 5.1, 6.0 <li> Sun, Glassfish </ul> If a transaction manager is not found, returns an {@link org.infinispan.transaction.tm.EmbeddedTransactionManager}.
Transaction manager lookup for testing purposes. Use this lookup class to verify that Infinispan works correctly with Geronimo Transaction Manager. In order to use this TM lookup, run tests with -Dinfinispan.test.jta.tm=geronimotm

Retrieves multiple entries at once. TODO: revise the command hierarchy, e.g. this should not implement MetadataAwareCommand
Implements "getAll" as defined by  <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.

GetCacheAction.
GetCacheAuthorizationManagerAction.
GetCacheAvailabilityAction.
GetCacheComponentRegistryAction.
GetCacheConfigurationAction.
GetCacheDistributionManagerAction.
GetCacheEntryAction.
Used to fetch a full CacheEntry rather than just the value. This functionality was originally incorporated into GetKeyValueCommand.
GetCacheGlobalComponentRegistryAction.
GetCacheInterceptorChainAction.
GetCacheLockManagerAction.
GetCacheManagerAddress.
GetCacheManagerClusterAvailabilityAction.
GetCacheManagerClusterNameAction.
GetCacheManagerCoordinatorAddress.
GetCacheManagerIsCoordinatorAction.
GetCacheManagerStatusAction.
GetCacheRpcManagerAction.
GetCacheStatusAction.
GetCacheVersionAction.
GetCreatedCacheCountAction.
GetDefaultExecutorServiceAction.
GetDefinedCacheCountAction.
GetDefinedCacheNamesAction.
Serializable function used by {@link org.infinispan.multimap.impl.EmbeddedMultimapCache#get(Object)} to get a key's value.
GetGlobalComponentRegistryAction.
Cache "get" operation handler.
Rpc to obtain all in-doubt prepared transactions stored on remote nodes. A transaction is in doubt if it is prepared and the node where it started has crashed.
Command used by the recovery tooling for obtaining the list of in-doubt transactions from a node.
Implements functionality defined by {@link org.infinispan.Cache#get(Object)} and {@link org.infinispan.Cache#containsKey(Object)} operations
{@link org.infinispan.commands.VisitableCommand} that fetches the keys belonging to a group.
GetMembersAction.
Implements "get" operation as described by <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
Handler to get the errors messages attached to a protobuf schema file (by name).
Handler to get the contents of a protobuf schema file by name.
Handler to get the names of the registered protobuf schemas.
Handler to get the names of the registered protobuf schemas that have errors (syntactic or semantic).
GetRunningCacheCountAction.
GetSearchManagerAction.

Implementation of the "get" statement
Streaming Get operation
GetSystemPropertyAction.
Wrapper for {@code Boolean.getBoolean(propertyName)}
Wrapper for {@code Integer.getInteger(propertyName, defaultValue)}.
Corresponds to getWithMetadata operation as described by <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
Corresponds to getWithVersion operation as described by <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
GlobalAuthorizationConfiguration.
GlobalAuthorizationConfigurationBuilder.
A global component registry where shared components are stored.
Replaces a global component with a dynamic proxy that can interact with a {@link StateSequencer} when a method that matches a {@link InvocationMatcher} is called.
<p> Configuration component that exposes the global configuration. </p>


{@link org.infinispan.remoting.inboundhandler.InboundInvocationHandler} implementation that handles all the {@link org.infinispan.commands.ReplicableCommand}. <p/> This component handles the {@link org.infinispan.commands.ReplicableCommand} from local and remote site. The remote site {@link org.infinispan.commands.ReplicableCommand} are sent to the {@link org.infinispan.xsite.BackupReceiver} to be handled. <p/> Also, the non-{@link org.infinispan.commands.remote.CacheRpcCommand} are processed directly and the {@link org.infinispan.commands.remote.CacheRpcCommand} are processed in the cache's {@link org.infinispan.remoting.inboundhandler.PerCacheInboundInvocationHandler} implementation.

Configures whether global statistics are gathered and reported via JMX for all caches under this cache manager.
A globally-scoped marshaller. This is needed so that the transport layer can unmarshall requests even before it's known which cache's marshaller can do the job.
Encoder that uses the GlobalMarshaller to encode/decode data.
GlobalRoleConfigurationBuilder.

GlobalSecurityConfiguration.
GlobalSecurityConfigurationBuilder.
GlobalSecurityConfigurationChildBuilder.
GlobalSecurityManager.
Factory for GlobalSecurityManager implementations
GlobalSecurityManagerImpl. Initialize the global ACL cache.
GlobalStateConfiguration.
GlobalStateConfigurationBuilder. Configures filesystem paths where global state is stored.
GlobalStateLocationConfigurationBuilder.
GlobalStateManager.
GlobalStateManagerFactory.
GlobalStateManagerImpl. This global component manages persistent state across restarts. The information is stored in a Properties file. On a graceful shutdown it persists the following information: version = full version (e.g. major.minor.micro.qualifier) timestamp = timestamp using ISO-8601 as well as any additional information contributed by registered {@link GlobalStateProvider}s
GlobalStateProvider. Implementors who need to register with the {@link GlobalStateManager} because they contribute to/are interested in the contents of the global persistent state.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/global-state=GLOBAL_STATE
Uniquely identifies a transaction that spans all JVMs in a cluster. This is used when replicating all modifications in a transaction; the PREPARE and COMMIT (or ROLLBACK) messages have to have a unique identifier to associate the changes with<br>. GlobalTransaction should be instantiated thorough {@link TransactionFactory} class, as their type depends on the runtime configuration.
A per-container (cache manager) cross-site admin operations. <p> All the operations invoked in this class will be applied to all caches which remotely backups its data.

The {@link CacheCommand#GRANT} handler.
GrantStatement adds a role mapping to a user
A custom mojo which is used while remote server task execution.
<p>The greeting cache qualifier.</p> <p>This qualifier will be associated to the greeting cache in the {@link Config} class.</p>
<p>The greeting cache manager.</p> <p>This manager is used to collect informations on the greeting cache and to clear it's content if needed.</p>

ServerTask getting a custom mojo as parameter and processing it.
<p>This is the Greeting Service class.</p> <p>Each call to the {@link GreetingService#greet(String)} method will be cached in the greeting-cache (in this case the {@linkplain javax.cache.annotation.CacheKey CacheKey} will be the name). If this method has been already called with the same name the cached value will be returned and this method will not be called.</p>

Subclass of File to iterate through directories and files in a grid
Entry point for GridFile and GridInputStream / GridOutputStream




<p> Identifies the key for a group. </p> <p> <code>@Group</code> should be used when you have control over the key class. For example: </p> <pre> class User { ... String office; ... int hashCode() { // Defines the hash for the key, normally used to determine location ... } // Override the location by specifying a group, all keys in the same // group end up with the same owner
A key filter that accepts keys which belongs to the group.
Control's key grouping.



Groups rows by their grouping fields and computes aggregates.
An interceptor that keeps track of the keys added/removed during the processing of a {@link GetKeysInGroupCommand}
Key partitioner that uses {@link org.infinispan.distribution.group.Group} annotations to map grouped keys to the same segment.
Configuration for various grouper definitions. See the user guide for more information.
Configuration for various grouper definitions. See the user guide for more information.




{@link OutputPrinter} for HTML values.
As a return of {@link StrongCounter#addListener(CounterListener)}, it is used to un-register the {@link CounterListener}.
Interface that governs implementations
Allows fine-tuning of rehashing characteristics. Must only used with 'distributed' cache mode.
Allows fine-tuning of rehashing characteristics. Must only used with 'distributed' cache mode.
Key partitioner that computes a key's segment based on a hash function.
Hot Rod request header parameters
Use a simple CheckStyle rule to make sure no copyright templates are being used: Infinispan uses a single copyright file which can be found in the root of the project.
An entry point for checking health status.

A Contract for exposing Health API over the JMX.
A JMX exposer (or adapter) for Health API.
Attaches HealCheck API as DMR Metrics.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/health=HEALTH
General Health status.

Uses the Hibernate Search metadata to resolve property paths. This relies on the Hibernate Search annotations. If resolution fails (due to not annotated fields) the we delegate the process to the base class which works exclusively with java-bean like reflection without relying on annotations. <p> Stateless and inherently threadsafe.
Hibernate transaction manager lookup class for Infinispan, so that Hibernate's transaction manager can be hooked onto Infinispan.
Utility class for resolving all bean types from a given type.

Lookup on a table without collisions will require only single access, if there are collisions it will be limited to (number of collisions to particular bin + 1) and all those will lie in proximity (32 * reference size). Inserts can be O(n) in the worst case when we have to rehash whole table or search through close-to-full for an empty spot. <p> Not thread safe (though, look-ups are safe when there are no concurrent modifications).
Information about the host.

Logging handler for hotrod to log what requests have come into the server
HotRod specific channel initializer
A very simple Hot Rod client for testing purposes. It's a quick and dirty client implementation. As a result, it might not be very readable, particularly for readers not used to scala. <p> Reasons why this should not really be a trait: Storing var instances in a trait cause issues with TestNG, see: http://thread.gmane.org/gmane.comp.lang.scala.user/24317 public TestPutStreamResponse putStream(byte[] k, int lifespan, int maxIdle, byte[] v, long dataVersion) { PutStreamOp op = new PutStreamOp(0xA0, protocolVersion, defaultCacheName, (byte) 1, 0, k, lifespan, maxIdle, v, dataVersion); writeOp(op); // Get the handler instance to retrieve the answer. ClientHandler handler = (ClientHandler) ch.pipeline().last(); return (TestPutStreamResponse) handler.getResponse(op.id); }
Base class for exceptions reported by the hot rod client.
Test the Infinispan AS remote client module integration
{@link Category} tag for clustered hot rod tests.
{@link Category} tag for clustered hot rod tests in domain mode.
HotRodCodec.
A {@link ModuleCommandFactory} that builds {@link CacheRpcCommand} used by this module.
A {@link ModuleCommandInitializer} implementation to initialize the {@link CacheRpcCommand} used by this module.
HotRodConnectorResource.
Defines constants defined by Hot Rod specifications.
Tests for the HotRod client receiving events serialized with a custom marshaller.
Tests for remote iteration using a custom filter with custom classes marshalled with a custom Protobuf based marshaller. ISPN-8001
Decoder that will decode hotrod messages and then send a {@link CacheDecodeContext} down the pipeline.
Protocol decoding state
HotRodDigestMd5AuthIT tests DIGEST-MD5 SASL authentication of HotRod client against distributed cache.
HotRodDigestMd5AuthLocalIT tests DIGEST-MD5 SASL authentication of HotRod client against local cache.
HotRodDigestMd5AuthWithQopIT tests DIGEST-MD5 SASL authentication of HotRod client with an encrypted connection as specified by the SASL mechanism.
Hot Rod specific encoder.
HotRodEntryMarshaller.
Handler that will transform various exceptions into responses to send back to the client.



{@link org.infinispan.distribution.MagicKey} equivalent for HotRod

It register the {@link HotRodCommandFactory} and {@link HotRodCommandInitializer} to handle the {@link CacheRpcCommand} used by this module.
Generic Hot Rod operation. It is aware of {@link org.infinispan.client.hotrod.Flag}s and it is targeted against a cache name. This base class encapsulates the knowledge of writing and reading a header, as described in the <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>
Hot Rod ({@link RemoteCache} ) authorization tests
HotRodPlainAuthIT tests PLAIN SASL authentication of HotRod client against distributed cache.


HotRodPlainAuthLocalIT tests PLAIN SASL authentication of HotRod client against local cache.
Test remote query.
Tests for remote iteration in compat mode with primitive values and default (JBoss) marshalling.
Tests for the HotRod client RemoteCache class in domain mode. TODO: Run this in local mode too (by adding HotRodSingleNodeDomain.class category) Currently blocked by https://issues.jboss.org/browse/ISPN-6321
Tests for the HotRod client RemoteCache class in standalone mode.
Tests for the HotRod client RemoteCacheManager class in domain mode.
Tests for the HotRod client RemoteCacheManager class in standalone mode.
The basic set of tests for Streaming API over HottRod client
Tests for rolling upgrades functionality, distribution mode.
Tests for rolling upgrades functionality.

Configuration builder for Hot Rod.
{@link org.infinispan.server.router.MultiTenantRouter}'s configuration for Hot Rod.
Hot Rod server, in charge of defining its encoder/decoder and, if clustered, update the topology information on startup and shutdown. <p> TODO: It's too late for 5.1.1 series. In 5.2, split class into: local and cluster hot rod servers This should safe some memory for the local case and the code should be cleaner
HotRodServerChildConfigurationBuilder.

HotRodServerConfigurationBuilder.
{@link Category} tag for local hot rod tests.
{@link Category} tag for local hot rod tests in domain mode.
An implementation of Migrator, that understands the Hot Rod key and value formats.
Test for using SSL for client server communication encryption.
Test for using SSL with SNI. The test uses 2 security realms - one for "sni" host names with proper authentication details and the other one (for everything else) with no authorized hosts. <p> Since this test is pretty slow (requires booting up full server with Arquillian), it contains only high level tests. For more complicated scenarios, see {@link HotRodSniFunctionalTest}. </p>



Signals an remote timeout(due to locking) in the infinispan server.

HotrodServerLifecycleBean.
Generates HTML documents
Netty REST handler for HTTP/1.1
Handler responsible for TLS/ALPN negotiation as well as HTTP/1.1 Upgrade header handling
This benchmark checks how faster is HTTP/2 compared to HTTP/1.1
Netty REST handler for HTTP/2.0
HTTP/2 client based on Netty. <p> Unfortunately it is very hard to get a good HTTP/2 client with ALPN support. All major implementations require using Jetty Java Agent (which needs to be applied into bootclasspath. This is very inconvenient. Thankfully Netty can use OpenSSL but the downside is that it contains lots and lots of bolerplate code. It might be a good idea to replace this implementation once JDK9 is mainstream and use something better. </p>
Configures the client pipeline to support HTTP/2 frames.
Reads the first {@link Http2Settings} object and notifies a {@link io.netty.channel.ChannelPromise}

HttpJMXRemotingUrl connects through HTTP ports
Process {@link io.netty.handler.codec.http.FullHttpResponse} translated from HTTP/2 frames

HttpsJMXRemotingUrl connects through HTTPS ports

A non-indexed query performed on top of the results returned by another query (usually a Lucene based query). This mechanism is used to implement hybrid two-stage queries that perform an index query using a partial query using only the indexed fields and then filter the result again in memory with the full filter.

Adapter for {@link IckleProtobufFilterAndConverter} that produces binary values as a result of filter/conversion.







A filter implementation that is both a KeyValueFilter and a converter. The implementation relies on the Matcher and a JPA query string.





A subclass of JPAFilterAndConverter that is able to deal with binary values wrapped in a ProtobufValueWrapper.
Factory for a {@link KeyValueFilterConverter} that operates on binary parameters and produces binary results.

IdentityAttributeCopier. This {@link AttributeCopier} does not copy the source attribute, but returns it, so that the same instance can be shared across multiple configurations. Since this can only be safely done with threadsafe objects which store no state, be very careful when using it.
Encoder that does not change the content.
{@link org.infinispan.commons.equivalence.Equivalence} implementation that uses the {@link java.lang.System#identityHashCode(Object)} as hash code function.
IdentityRoleMapper. A very simple role which simply returns the principal's name as the role name.
A Netty channel handler that allows idle channels to be closed.
The ids of the {@link ReplicableCommand} used by this module. <p> range: 140-141
A filter that only expects responses from an initial set of targets. Useful when sending a command to {@code null} to ensure we don't wait for responses from cluster members that weren't properly started when the command was sent. JGroups calls our handler while holding a lock, so we don't need any synchronization.
A simple CheckStyle checker to verify specific import statements are not being used.
This exception is thrown when the cache or cache manager does not have the right lifecycle state for operations to be called on it. Situations like this include when the cache is stopping or is stopped, when the cache manager is stopped...etc.
A cache entry that is immortal/cannot expire
An immortal cache value, to correspond with {@link org.infinispan.container.entries.ImmortalCacheEntry}
<p> A base class for implementing {@link Bean}. The attributes are immutable, and collections are defensively copied on instantiation. It uses the defaults from the specification for properties if not specified. </p> <p/> <p> This bean delegates it's lifecycle to the callbacks on the provided {@link ContextualLifecycle}. </p>
This context is a non-context for operations such as eviction which are not related to the method invocation which caused them.
<p> A base class for implementing {@link InjectionPoint}. The attributes are immutable, and collections are defensively copied on instantiation. </p>
A lightweight, read-only copy of a List.  Typically used in place of the common idiom: <code> return Collections.unmodifiableList(new ArrayList( myInternalList )); </code> <p/> a it is far more efficient than making a defensive copy and then wrapping the defensive copy in a read-only wrapper. <p/> Also used whenever a read-only reference List is needed. <p/>

A byte stream that is immutable.  Bytes are captured during construction and cannot be written to thereafter.
<p> A base class for implementing a {@link PassivationCapable} {@link Bean}. The attributes are immutable, and collections are defensively copied on instantiation. It uses the defaults from the specification for properties if not specified. </p> <p/> <p> This bean delegates it's lifecycle to the callbacks on the provided {@link ContextualLifecycle}. </p>
Factory for generating immutable type wrappers.
Mark which cache modes should the test be executed upon. This will be used to fill in {@link org.infinispan.test.MultipleCacheManagersTest#cacheMode} for each of the modes.

// TODO: Document this


Interface to invoke when the {@link org.infinispan.remoting.transport.Transport} receives a command from other node or site.
Factory class that creates instances of {@link org.infinispan.remoting.inboundhandler.PerCacheInboundInvocationHandler}.
Replaces the {@link org.infinispan.remoting.inboundhandler.PerCacheInboundInvocationHandler} with a wrapper that can interact with a {@link StateSequencer} when a command that matches a {@link CommandMatcher} is invoked.
Inbound state transfer task. Fetches multiple data segments from a remote source node and applies them to local cache. Instances of InboundTransferTask are created and managed by StateTransferManagerImpl. StateTransferManagerImpl must have zero or one such task for each segment.


Thrown when an incorrectly annotated class is added as a cache listener using the {@link org.infinispan.notifications.Listenable#addListener(Object)} API.
An interface indicating that a version of this type can be incremented.
Keeps the entry positions persisted in a file. It consists of couple of segments, each for one modulo-range of key's hashcodes (according to DataContainer's key equivalence configuration) - writes to each index segment are performed by single thread, having multiple segments spreads the load between them.

Interface to control the Lucene index's write lock.
Used to control and override the ownership of the Lucene index lock. <p> Rather than wrapping the Directory or the LockManager directly, we need to wrap the IndexManager as the Directory initialization is deferred.
Defines for which events the Query Interceptor will generate indexing events.
The recursive index structure. References to children are held in soft references, which allows JVM-handled caching and reduces the amount of reads required while evading OOMs if the index gets too big.
Holds default configurations about indexing
Extract useful information from indexing configuration
Splits the requests into several subqueues according to request.key.hashCode(). If the request has no key, inserts countdown into the request and puts it into all subqueues - the thread that retrieves such element should call countDown() and upon true handle the request (this preserves the FIFO ordering).
Request for some change to be persisted in the Index or operation executed by index updater thread.
Mostly used for internal abstraction: common type for all keys which need name scoping for different indexes.
Custom RPC command containing an index update request for the Master IndexManager of a specific cache & index.
Execute a stream operation
Handle batch updates to an index.
Base class for mass indexer tasks.

A marker interface for filters that can be handled efficiently by a {@link FilterIndexingServiceProvider}. Such filters can still be executed by calling the {@link #filterAndConvert} method but a {@link FilterIndexingServiceProvider} could take advantage of this specific filter and execute it more efficiently by using an alternative approach.
Used to configure indexing of entries in the cache for searching.
The main IndexingBackend implementations are the one forwarding to another node, and the one applying to the local node. We when defined a set of additional implementations to handle intermediate transitionaly behaviour, each such implementation respects this contract.
Configures indexing of entries in the cache for searching.
Configures indexing of entries in the cache for searching.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/indexing=INDEXING
All fields of Protobuf types are indexed and stored by default if no indexing annotations are present. This behaviour exists only for compatibility with first release of remote query; it is deprecated and will be removed in Infinispan 10.0 (the lack of annotations on your message/field definition will imply no indexing support in this future release, but you will still be able to perform unindexed query). Indexing all fields is sometimes acceptable but it can become a performance problem if there are many or very large fields. To avoid such problems Infinispan allows and encourages you to specify which fields to index and store by means of two annotations ({@literal @}Indexed and {@literal @}Field) that behave very similarly to the identically named Hibernate Search annotations and which can be directly added to your Protobuf schema files in the documentation comments of your message type definitions as demonstrated in the example below: <p/> <b>Example:</b> <p/> <pre> /** * This message type is indexed, but not all of its fields are. *{@literal @}Indexed *{@literal /} message Note { /** * This field is indexed and analyzed but not stored. It can be full-text queried but cannot be used for projections. *{@literal @}Field(index=Index.YES, store=Store.NO, analyze=Analyze.YES) *{@literal /} optional string text = 1; /** * A field that is both indexed and stored but not analyzed (the defaults - if no attributes are specified). It can be * queried with relational operators but not with full-text operators (since it is not analyzed). *{@literal @}Field *{@literal /} optional string author = 2; /** @Field(index=Index.NO, store=Store.YES) *{@literal /} optional bool isRead = 3; /** This field is not annotated, so it is neither indexed nor stored. *{@literal /} optional int32 priority = 4; } </pre> <p> Documentation annotations can be added after the human-readable text on the last lines of the documentation comment that precedes the element to be annotated (a message type definition or a field definition). The syntax for defining these pseudo-annotations is identical to the one use by the Java language. <p> The '{@literal @}Indexed' annotation applies to message types only, has a boolean value that defaults to 'true', so '{@literal @}Indexed' is equivalent to '{@literal @}Indexed(true)'. The presence of this annotation indicates the type is to be indexed and we intend to selectively specify which of the fields of this message type are to be indexed. '@Indexed(false)' turns off indexing for this type so the eventual '@Field' annotations present at field level will be ignored. The usage of '@Indexed(false)' is temporarily allowed, it is currently deprecated, and will no longer be supported in Infinispan 10.0 in which the only official way to turn off indexing for a type will be to not annotate it at all. The {@literal @}Indexed annotation also has an optional 'index' attribute which allow you to specify the name of the index for this message type. If left unspecified it defaults to the fully qualified type name. <p> The '{@literal @}Field' annotation applies to fields only and has three attributes, 'index', 'store' and 'analyze', which default to {@literal @}Field(index=Index.YES, store=Store.NO, analyze=Analyze.NO). The 'index' attribute indicates whether the field will be indexed, so it can be used for indexed queries, while the 'store' attribute indicates whether the field value is to be stored in the index too, so it becomes useable for projections. The analyze attribute control analysis. Analyzing must be turned on in order to use the field in full-text searches. <p> The '{@literal @}Analyzer' annotation applies to messages and fields and allows you to specify which analyzer to use if analysis was enabled. If has a single attribute name 'definition' which must contain a valid analyzer definition name specified as a String. <p> <b>NOTE:</b> <ul> <li>1. The {@literal @}Field and {@literal @}Analyzer annotations have effect only if the containing message type was annotated as '{@literal @}Indexed' or '{@literal @}Indexed(true)', otherwise they are ignored. </li> <li>2. Unindexed fields can still be queried in non-indexed mode or with hybrid queries.</li> <ul/>
todo [anistor] Should be able to have multiple mappings per field like in Hibernate Search, ie. have a @Fields plural annotation {@link AnnotationMetadataCreator} for {@code @Indexed} ProtoStream annotation placed at message type level. Also handles {@code @Field} and {@code @SortableField} and {@code @Analyzer} annotations placed at field level.
Extracts and indexes all tags (fields) from a protobuf encoded message.
Versions can be compared to each other to result in one version being before, after or at the same time as another version.  This is different from the JDK's {@link Comparable} interface, which is much more simplistic in that it doesn't differentiate between something that is the same versus equal-but-different.
InetAddressPrincipal.

Adaptor to implement the Hibernate Search contract of a BackendQueueProcessor while delegating to the cluster-aware components of Infinispan Query.
Factory for creating JNDI bindings.
Static helpers for Infinispan-specific collections
The Infinispan configuration is ClassLoader sensitive, this wrapper around the standard Parser is used to allow it to find resources in a modular classloading environment.

Test the Infinispan AS module integration
<p> A {@link org.springframework.beans.factory.FactoryBean <code>FactoryBean</code>} for creating a native <em>default</em> Infinispan {@link org.infinispan.Cache <code>org.infinispan.Cache</code>} , delegating to a {@link #setInfinispanCacheContainer(CacheContainer) <code>configurable</code>} {@link org.infinispan.manager.CacheContainer <code>org.infinispan.manager.CacheContainer</code>}. A default <code>Cache</code> is a <code>Cache</code> that uses its <code>CacheContainer</code>'s default settings. This is contrary to a <em>named</em> <code>Cache</code> where select settings from a <code>CacheContainer</code>'s default configuration may be overridden with settings specific to that <code>Cache</code>. </p> <p> In addition to creating a <code>Cache</code> this <code>FactoryBean</code> does also control that <code>Cache</code>'s {@link org.infinispan.commons.api.Lifecycle lifecycle} by shutting it down when the enclosing Spring application context is closed. It is therefore advisable to <em>always</em> use this <code>FactoryBean</code> when creating a <code>Cache</code>. </p>
{@link DefaultsResolver} implementation that extracts default values from ISPN {@link AttributeDefinition}s
Run it with -Djgroups.bind_addr=127.0.0.1 -Djava.net.preferIPv4Stack=true
A DirectoryProvider using Infinispan to store the Index. This depends on the CacheManagerServiceProvider to get a reference to the Infinispan {@link EmbeddedCacheManager}.

<p> A {@link org.springframework.beans.factory.FactoryBean <code>FactoryBean</code>} for creating an {@link org.infinispan.manager.EmbeddedCacheManager <code>Infinispan EmbeddedCacheManager</code>} instance. The location of the Infinispan configuration file used to provide the default {@link org.infinispan.configuration.cache.Configuration configuration} for the <code>EmbeddedCacheManager</code> instance created by this <code>FactoryBean</code> is {@link #setConfigurationFileLocation(org.springframework.core.io.Resource) configurable}. </p> <p> If no configuration file location is set the <code>EmbeddedCacheManager</code> instance created by this <code>FactoryBean</code> will use Infinispan's default settings. See Infinispan's <a href="http://www.jboss.org/infinispan/docs">documentation</a> for what those default settings are. </p> <p> A user may further customize the <code>EmbeddedCacheManager</code>'s configuration using explicit setters on this <code>FactoryBean</code>. The properties thus defined will be applied either to the configuration loaded from Infinispan's configuration file in case one has been specified, or to a configuration initialized with Infinispan's default settings. Either way, the net effect is that explicitly set configuration properties take precedence over both those loaded from a configuration file as well as INFNISPAN's default settings. </p> <p> In addition to creating an <code>EmbeddedCacheManager</code> this <code>FactoryBean</code> does also control that <code>EmbeddedCacheManagers</code>'s {@link org.infinispan.commons.api.Lifecycle lifecycle} by shutting it down when the enclosing Spring application context is closed. It is therefore advisable to <em>always</em> use this <code>FactoryBean</code> when creating an <code>EmbeddedCacheManager</code>. </p>


Session Repository for Infinispan in Embedded mode.
Defines the Infinispan subsystem and its addressable resources.
The Infinispan CDI extension for embedded caches
Test the infinispan extension can be loaded in WFLY

Responsible for reading from <code>InfinispanDirectory</code>
A custom IndexManager to store indexes in the grid itself.
Responsible for writing to a <code>Directory</code>
Configuration constants for the Infinispan integration
Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/22/16 Time: 2:21 PM

A special lock for Infinispan cache. <p/> The main different with the traditional {@link java.util.concurrent.locks.Lock} is allowing to use any object as lock owner. It is possible to use a {@link Thread} as lock owner that makes similar to {@link java.util.concurrent.locks.Lock}. <p/> In addition, it has an asynchronous interface. {@link #acquire(Object, long, TimeUnit)}  will not acquire the lock immediately (except if it is free) but will return a {@link ExtendedLockPromise}. This promise allow to test if the lock is acquired asynchronously and cancel the lock acquisition, without any blocking.
InfinispanLogger
Simple wrapper to make the Cache ComponentRegistry and the CacheManager available to the services managed by Hibernate Search.
Test infinispan-lucene-directory server module
The jboss-logging {@link MessageLogger} for the hibernate-infinispan module.  It reserves message ids ranging from 25001 to 30000 inclusively.
InfinispanMessages
Test the Hibernate Search *upstream* module combined with an Infinispan Directory usage. N.B. this should not use the Hibernate Search version used by Infinispan Query, but should exercise the latest Hibernate Search version as meant for packaing into WildFly: the one used in combination with Hibernate ORM (indexing objects from a different database). Often this will match with the version of Hibernate Search included in the latest WildFly, but when this is getting old we might test with a later version, essentially using the Hibernate Search WildFly modules released from the Hibernate Search project.
<p> A {@link org.springframework.beans.factory.FactoryBean <code>FactoryBean</code>} for creating a native {@link #setCacheName(String) named} Infinispan {@link org.infinispan.Cache <code>org.infinispan.Cache</code>}, delegating to a {@link #setInfinispanEmbeddedCacheManager(EmbeddedCacheManager) <code>configurable</code>} {@link org.infinispan.manager.EmbeddedCacheManager <code>org.infinispan.manager.EmbeddedCacheManager</code>}. If no cache name is explicitly set, this <code>FactoryBean</code>'s {@link #setBeanName(String) <code>beanName</code>} will be used instead. </p> <p> Beyond merely creating named <code>Cache</code> instances, this <code>FactoryBean</code> offers great flexibility in configuring those <code>Caches</code>. It has setters for all non-global configuration settings, i.e. all settings that are specific to a single <code>Cache</code>. The configuration settings thus defined override those settings obtained from the <code>EmbeddedCacheManager</code>. </p> <p> There are different configuration {@link #setConfigurationTemplateMode(String) <code>modes</code>} that control with what <code>Configuration</code> to start before further customizing it as described above: <ul> <li> <code>NONE</code>: Configuration starts with a new <code>Configuration</code> instance. Note that this mode may only be used if no named configuration having the same name as the <code>Cache</code> to be created already exists. It is therefore illegal to use this mode to create a <code>Cache</code> named, say, &quot;cacheName&quot; if the configuration file used to configure the <code>EmbeddedCacheManager</code> contains a configuration section named &quot;cacheName&quot;.</li> <li> <code>DEFAULT</code>: Configuration starts with the <code>EmbeddedCacheManager</code>'s <em>default</em> <code>Configuration</code> instance, i.e. the configuration settings defined in its configuration file's default section. Note that this mode may only be used if no named configuration having the same name as the <code>Cache</code> to be created already exists. It is therefore illegal to use this mode to create a <code>Cache</code> named, say, &quot;cacheName&quot; if the configuration file used to configure the <code>EmbeddedCacheManager</code> contains a configuration section named &quot;cacheName&quot;.</li> <li> <code>CUSTOM</code>: This is where a user will provide a custom-built <code>ConfigurationBuilder</code> object which will be used to configure a <code>Cache</code> instance. If a {@link #setCacheName(String)} has already been called, then that name will be used. </li> <li> <code>NAMED</code>: Configuration starts with the <code>EmbeddedCacheManager</code>'s <code>Configuration</code> instance having the same name as the <code>Cache</code> to be created. For a <code>Cache</code> named, say, &quot;cacheName&quot; this is the configuration section named &quot;cacheName&quot; as defined in the <code>EmbeddedCacheManager</code>'s configuration file. Note that this mode is only useful if such a named configuration section does indeed exist. Otherwise, it is equivalent to using <code>DEFAULT</code>.</li> </ul> </p> <p> In addition to creating a named <code>Cache</code> this <code>FactoryBean</code> does also control that <code>Cache</code>' {@link org.infinispan.commons.api.Lifecycle lifecycle} by shutting it down when the enclosing Spring application context is closed. It is therefore advisable to <em>always</em> use this <code>FactoryBean</code> when creating a named <code>Cache</code>. </p>
<p> A {@link org.springframework.beans.factory.FactoryBean <code>FactoryBean</code>} for creating a native {@link #setCacheName(String) named} Infinispan {@link org.infinispan.Cache <code>org.infinispan.Cache</code>}, delegating to a {@link #setInfinispanRemoteCacheManager(RemoteCacheManager) <code>configurable</code>} {@link org.infinispan.client.hotrod.RemoteCacheManager <code>oorg.infinispan.client.hotrod.RemoteCacheManagerr</code>}. If no cache name is explicitly set, this <code>FactoryBean</code>'s {@link #setBeanName(String) <code>beanName</code>} will be used instead. </p>
{@link org.springframework.beans.factory.xml.NamespaceHandler} for Infinispan-based caches.

Test the Infinispan AS module integration
This MBean exposes the query statistics from the Hibernate Search statistics object.
MBean interface as required by JMX rules. It duplicates org.hibernate.search.jmx.StatisticsInfoMBean just to be in the same package as org.infinispan.query.impl.InfinispanQueryStatisticsInfo.
A {@link RegionFactory} for <a href="http://www.jboss.org/infinispan">Infinispan</a>-backed cache regions.

<p> A {@link org.springframework.beans.factory.FactoryBean <code>FactoryBean</code>} for creating an {@link org.infinispan.client.hotrod.RemoteCacheManager <code>Infinispan RemoteCacheManager</code>} instance. </p> <strong>Configuration</strong><br/> <p> A <code>RemoteCacheManager</code> is configured through a {@link java.util.Properties <code>Properties</code>} object. For an exhaustive list of valid properties to be used see <code>RemoteCacheManager</code>'s {@link org.infinispan.client.hotrod.RemoteCacheManager javadocs}. This <code>FactoryBean</code> provides means to either {@link #setConfigurationProperties(Properties) inject} a user-defined <code>Properties</code> instance or to {@link #setConfigurationPropertiesFileLocation(org.springframework.core.io.Resource) set} the location of a properties file to load those properties from. Note that it is <em>illegal</em> to use both mechanisms simultaneously. </p> <p> Alternatively or in combination with {@link #setConfigurationPropertiesFileLocation(org.springframework.core.io.Resource) setting} the location of a <code>Properties</code> file to load the configuration from, this <code>FactoryBean</code> provides (typed) setters for all configuration settings. Settings thus defined take precedence over those defined in the injected <code>Properties</code> instance. This flexibility enables users to use e.g. a company-wide <code>Properties</code> file containing default settings while simultaneously overriding select settings whenever special requirements warrant this.<br/> Note that it is illegal to use setters in conjunction with {@link #setConfigurationProperties(Properties) injecting} a <code>Properties</code> instance. </p> <p> In addition to creating a <code>RemoteCacheManager</code> this <code>FactoryBean</code> does also control that <code>RemoteCacheManagers</code>'s lifecycle by shutting it down when the enclosing Spring application context is closed. It is therefore advisable to <em>always</em> use this <code>FactoryBean</code> when creating a <code>RemoteCacheManager</code>. </p>

Session Repository for Infinispan in client/server mode.
Tests for querying using 'org.infinispan.remote' aggregator module.
Representation of a HTTP request tailed for Infinispan-specific requests.
Custom resource description resolver to handle resources structured in a class hierarchy which need to share resource name definitions.
Representation of a HTTP response tailed for Infinispan-specific responses.
Handles calls to  {@link org.jboss.arquillian.container.test.api.ContainerController#kill(String)}

Test the Infinispan JDBC CacheStore AS module integration
Test the Infinispan JPA CacheStore AS module integration
Test the Infinispan RocksDB CacheStore AS module integration


Initializer for subsystem dependencies
The root resource of the Infinispan subsystem.
Infinispan subsystem parsing code.
XML writer for current Infinispan subsystem schema version.
Test the Infinispan AS module integration
Some utility methods.

InfoStatement shows configuration information about the specified cache or about the active cache manager
Aggregates the initialisation state needed by either a {@link CacheLoader} or a {@link CacheWriter}.

Function that initializes the {@link CounterValue} and {@link ConfigurationMetadata} if they don't exists.
Used to annotate a method as one that is used to inject a registered component into another component.  The component to be constructed must be built using the {@link AbstractComponentFactory#construct(Class)} method, or if your object that needs components injected into it already exists, it can be built using the {@link ComponentRegistry#wireDependencies(Object)} method. <p/> Usage example: <pre> public class MyClass { private TransactionManager tm; private BuddyManager bm; private Notifier n; <p/> &amp;Inject public void setTransactionManager(TransactionManager tm) { this.tm = tm; } <p/> &amp;Inject public void injectMoreStuff(BuddyManager bm, Notifier n) { this.bm = bm; this.n = n; } } <p/> </pre> and an instance of this class can be constructed and wired using <pre> MyClass myClass = componentFactory.construct(MyClass.class); // instance will have dependencies injected. </pre> Methods annotated with this Inject annotation should *only* set class fields. They should do nothing else. If you need to do some work to prepare the component for use, do it in a {@link @Start} method since this is only called once when a component starts. ensure this annotation is available at runtime. only applies to fields.

<p> Allows an {@link AnnotatedMethod} to be injected using the CDI type safe resolution rules. </p> <p/> <p> {@link ParameterValueRedefiner} allows the default value to be overridden by the caller of {@link #invoke(Object, CreationalContext, ParameterValueRedefiner)}. </p>
CachePutInterceptor for environments where the cache manager is injected in a managed environment, e.g. application server.
CacheRemoveAllInterceptor for environments where the cache manager is injected in a managed environment, e.g. application server.
CacheRemoveEntryInterceptor for environments where the cache manager is injected in a managed environment, e.g. application server.
Injected cache resolver for situations where caches and/or cache managers are injected into the CDI beans. In these situations, bridging is required in order to bridge between the Infinispan based caches and the JCache cache instances which is what it's expected by the specification cache resolver.
CacheResultInterceptor for environments where the cache manager is injected in a managed environment, e.g. application server.
Service dependency whose provided value is made available via injection.
This is a marker interface to be used with {@link Function} which signals to some implementors that the function returns distinct values.  This can be helpful because when a function is applied to data is ambiguous if the resulting data produced is distinct or not.  This allows some callers of this method to apply additional performance optimizations taking this into account. <p> If a <b>function</b> is implemented with this and it doesn't produce distinct values, the operation of the consumer of this function may be undefined.
Service dependency requiring an injector.
Qualifier indicating the injected Cache should be the input Cache used to create {@link DefaultExecutorService}
Annotation literal for {@link Input}
An advanced externalizer that when implemented will allow for child instances that also extend this class to use object instances instead of serializing a brand new object.
A {@link IntStream} that has additional methods to allow for Serializable instances.  Please see {@link CacheStream} for additional details about various methods.

Externalizer used for {@link IntSummaryStatistics}.  Note this assumes given fields have specific names to use through reflection.
Knows how to build and manage an chain of interceptors. Also in charge with invoking methods on the chain.
Factory class that builds an interceptor chain based on cache configuration. For backwards compatibility, the factory will register both a {@link AsyncInterceptorChain} and a {@link InterceptorChain} before initializing the interceptors.
Describes a custom interceptor
This builder defines details of a specific custom interceptor.

Checks that if the interceptor handles one read command it handles all of them.
Replaces an {@link AsyncInterceptor} with a wrapper that can interact with a {@link StateSequencer} when a command that matches a {@link CommandMatcher} is visited.
An intermediate cache stream used when an intermediate operation that requires both a remote and local portion
Stream supplier that is used when a local intermediate operation is invoked, requiring a combined remote and local operation stream.
An intermediate double cache stream used when an intermediate operation that requires both a remote and local portion
An intermediate int cache stream used when an intermediate operation that requires both a remote and local portion
An intermediate long cache stream used when an intermediate operation that requires both a remote and local portion
Intermediate operation that can be applied to a stream to change its processing.
Externalizer to be used for serializing the various intermediate operations
The various intermediate types.  Note that the local intermediate operation can be a type other than the resulting stream, so we have to keep track of what it was to avoid {@link ClassCastException} issues.
Interface for internal cache entries that expose whether an entry has expired.
An internal factory for constructing Caches.  Used by the {@link DefaultCacheManager}, this is not intended as public API. <p/> This is a special instance of a {@link AbstractComponentFactory} which contains bootstrap information for the {@link ComponentRegistry}. <p/>
InternalCacheRegistry. Components which create caches for internal use should use this class to create/retrieve them
InternalCacheRegistryImpl.
A representation of an InternalCacheEntry that does not have a reference to the key.  This should be used if the key is either not needed or available elsewhere as it is more efficient to marshall and unmarshall.  Probably most useful in cache stores. <p/> Note that this should not be used to optimize memory overhead, since the saving of an additional reference to a key (a single object reference) does not warrant the cost of constructing an InternalCacheValue, where an existing InternalCacheEntry is already referenced. <p/> Use of this interface <i>only</i> makes sense when marshalling is involved, since the cost of marshalling the key again can be sidestepped using an InternalCacheValue if the key is already known/marshalled. <p/>

A factory for {@link InternalCacheEntry} and {@link InternalCacheValue} instances.
An implementation that generates non-versioned entries



RemoteCacheManager that exposes internal components such as transportFactory. This class serves testing purposes and is NOT part of public API.


Represents an interval of values of type K. K is not restricted to be a Comparable type here, but the IntervalTree must be able to compare values of type K using its Comparator.

A predicate attached to an attribute. It comes in two flavors: condition predicate or interval predicate. An interval predicate represents a range of values (possibly infinite at one end but not both). It requires that the attribute domain is Comparable, otherwise the notion of interval is meaningless. A condition predicate on the other hand can have any arbitrary condition and does not require the attribute value to be Comparable.
An Interval tree is an ordered tree data structure to hold Intervals. Specifically, it allows one to efficiently find all Intervals that contain any given value in O(log n) time (see http://en.wikipedia.org/wiki/Interval_tree). <p/> The implementation is based on red-black trees (http://en.wikipedia.org/wiki/Redblack_tree). Additions and removals are efficient and require only minimal rebalancing of the tree as opposed to other implementation approaches that perform a full rebuild after insertion. Duplicate intervals are not stored but are coped for.
Thrown when client makes cache usage errors. Situations like this include when clients invoke operations on the cache that are not allowed.
Thrown when a lock is in a unexpected state.
An invalid response
Signals an internal protocol error.
Thrown if an operation is to be performed on an invalid transaction context.
Removes an entry from memory.
Invalidates an entry in a L1 cache (used with DIST mode)
Must be {@link VisitableCommand} as we want to catch it in persistence handling etc.
Near {@link org.infinispan.client.hotrod.RemoteCache} implementation enabling




Resource description for the addressable resource /subsystem=infinispan/cache-container=X/invalidation-cache=*
This interceptor acts as a replacement to the replication interceptor when the CacheImpl is configured with ClusteredSyncMode as INVALIDATE. <p/> The idea is that rather than replicating changes to all caches in a cluster when write methods are called, simply broadcast an {@link InvalidateCommand} on the remote caches containing all keys modified.  This allows the remote cache to look up the value in a shared cache loader which would have been updated with the changes.
Synchronization that should release the locks after invalidation is complete.



Base interface for all callbacks used by {@link BaseAsyncInterceptor} and {@link InvocationStage} methods.
A context that contains information pertaining to a given invocation.  These contexts typically have the lifespan of a single invocation.
Manages the association between an {@link org.infinispan.context.InvocationContext} and the calling thread.
Factory for {@link InvocationContext} objects.

Callback interface for {@link BaseAsyncInterceptor#invokeNextAndExceptionally(InvocationContext, VisitableCommand, InvocationExceptionFunction)}.
Callback interface for {@link BaseAsyncInterceptor#invokeNextAndFinally(InvocationContext, VisitableCommand, InvocationFinallyAction)}.
Callback interface for {@link BaseAsyncInterceptor#invokeNextAndHandle(InvocationContext, VisitableCommand, InvocationFinallyFunction)}.
Matches method invocations by name, parameters and/or target.
Creates {@link InvocationMatcher}s.

Callback interface for {@link BaseAsyncInterceptor#invokeNextThenAccept(InvocationContext, VisitableCommand, InvocationSuccessAction)}.
Callback interface for {@link BaseAsyncInterceptor#invokeNextThenApply(InvocationContext, VisitableCommand, InvocationSuccessFunction)}.
Interceptor to verify whether parameters passed into cache are marshallables or not. <p>This is handy when marshalling happens in a separate thread and marshalling failures might be swallowed. Currently, this only happens when we have an asynchronous store.</p>



Various transaction isolation levels as an enumerated class.  Note that Infinispan supports only {@link #READ_COMMITTED} and {@link #REPEATABLE_READ}, upgrading where possible. <p/> Also note that Infinispan defaults to {@link #READ_COMMITTED}. <p/>

Infinispan allows a different JMX operation name than the actual method name that gets invoked (see {@link org.infinispan.jmx.annotations.ManagedOperation#name()}. This class extends {@link MBeanOperationInfo} adding support for the operation name.











A Spliterator using the provided iterator for supplying values. Splits occur start at the batch size.  Each split gets subsequently bigger by increasing by the original split size.  The batch size will never become higher than the configured max batch size
A iterator that maps each value to the output of the Function.  Note that the remove is supported if the iterator originally supported remove.

MBeanServer lookup implementation to locate the JBoss MBeanServer.
A JBoss Marshalling based marshaller that is oriented at internal, embedded, Infinispan usage. It uses of a custom object table for Infinispan based Externalizer instances that are either internal or user defined. <p /> The reason why this is implemented specially in Infinispan rather than resorting to Java serialization or even the more efficient JBoss serialization is that a lot of efficiency can be gained when a majority of the serialization that occurs has to do with a small set of known types such as {@link org.infinispan.transaction.xa.GlobalTransaction} or {@link org.infinispan.commands.ReplicableCommand}, and class type information can be replaced with simple magic numbers. <p/> Unknown types (typically user data) falls back to Java serialization.
A JBoss Marshalling factory class for retrieving marshaller/unmarshaller instances. The aim of this factory is to allow Infinispan to provide its own JBoss Marshalling marshaller/unmarshaller extensions.
JTA standalone TM lookup.

Simple class using basic jsr107 annotations.
Custom implementation of {@link javax.cache.annotation.CacheKeyGenerator}. Compatible with methods providing one key parameter.
Infinispan implementation of {@link javax.cache.Cache.Entry<K, V>}.
An adapter to provide {@link Iterable}s over Cache Entries, those of which are filtered using a {@link CacheEntryEventFilter}.
A adapter to {@link Iterator}s to allow filtering of {@link CacheEntryEvent}s
Tests for failover of JCache remote listeners
Metadata for entries stored via JCache API




// TODO: Document this
Test for issues related to ISPN-6574 Test check whether JCache API is aware of caches defined in Infinispan server configuration Three tested functionalities are not yet implemented (not part of the original ticket), fix pending in <b>ISPN-7095</b> Calling getCache on a cache will refresh that cache inside CacheManager, making the other functionality work ok for that particular cache (hence the separate caches for each test)



Infinispan's SPI hook up to {@link javax.cache.spi.CachingProvider} for the client-server mode.
Factory for creating fork-able channels.
Builder for a service that provides a {@link ChannelFactory} for creating channels.

An encapsulation of a JGroups Address
Cache JGroupsAddress instances


A hook to pass in a JGroups channel.  Implementations need to provide a public no-arg constructor as instances are created via reflection.
This class owns the logic of associating network resources(i.e. ports) with threads, in order to make sure that there won't be any clashes between multiple clusters running in parallel on same host. Used for parallel test suite.
Registers the JGroups subsystem.

Enumerates the supported model versions.
Description resolver for JGroups subsystem resources.
Enumeration of the supported subsystem xml schemas.
Handler for JGroups subsystem add operations.
Initializer for the JGroups subsystem.
Handler for JGroups subsystem remove operations.
The root resource of the JGroups subsystem.
XML reader for the JGroups subsystem.

An encapsulation of a JGroups {@link ExtendedUUID} with a site id, a rack id, and a machine id.
An encapsulation of a JGroups transport. JGroups transports can be configured using a variety of methods, usually by passing in one of the following properties: <ul> <li><tt>configurationString</tt> - a JGroups configuration String</li> <li><tt>configurationXml</tt> - JGroups configuration XML as a String</li> <li><tt>configurationFile</tt> - String pointing to a JGroups XML configuration file</li> <li><tt>channelLookup</tt> - Fully qualified class name of a {@link JGroupsChannelLookup} instance</li> </ul> These are normally passed in as Properties in {@link TransportConfigurationBuilder#withProperties(Properties)} or in the Infinispan XML configuration file.




Determines whether statistics are gather and reported.
Determines whether statistics are gather and reported.

Helper class for creating an JNDI {@code InitialContext}.

Server Task executing JavaScript script.
{@link OutputPrinter} for JSON values.


Encoder that uses the default java serialization to store objects unmarshalled.
Log abstraction for the Memcached server module. For this module, message ids ranging from 11001 to 12000 inclusively have been reserved.
Encoder based on the default java serialization.
Standard Java serialization marshaller.
<p> {@link org.infinispan.spring.provider.sample.dao.BaseBookDao <code>BookDao</code>} implementation that fronts a relational database, using {@code JDBC} to store and retrieve {@link org.infinispan.spring.provider.sample.entity.Book <code>books</code>}. Serves as an example of how to use <a href="http://www.springframework.org">Spring</a>'s {@link org.springframework.cache.annotation.Cacheable <code>@Cacheable</code>} and {@link org.springframework.cache.annotation.CacheEvict <code>@CacheEvict</code>}. </p>

JdbcStoreConfigurationChildBuilder.
JDBC cache store configuration parser.
JdbcStoreConfigurationParser60.

{@link org.infinispan.persistence.spi.AdvancedCacheLoader} implementation that stores the entries in a database. In contrast to the {@link org.infinispan.persistence.jdbc.binary.JdbcBinaryStore}, this cache store will store each entry within a row in the table (rather than grouping multiple entries into an row). This assures a finer grained granularity for all operation, and better performance. In order to be able to store non-string keys, it relies on an {@link org.infinispan.persistence.keymappers.Key2StringMapper}. <p/> Note that only the keys are stored as strings, the values are still saved as binary data. Using a character data type for the value column will result in unmarshalling errors. <p/> The actual storage table is defined through configuration {@link org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfiguration}. The table can be created/dropped on-the-fly, at deployment time. For more details consult javadoc for {@link org.infinispan.persistence.jdbc.configuration.JdbcStringBasedStoreConfiguration}. <p/> It is recommended to use {@link JdbcStringBasedStore}} over {@link org.infinispan.persistence.jdbc.binary.JdbcBinaryStore}} whenever it is possible, as is has a better performance. One scenario in which this is not possible to use it though, is when you can't write an {@link org.infinispan.persistence.keymappers.Key2StringMapper}} to map the keys to to string objects (e.g. when you don't have control over the types of the keys, for whatever reason). <p/> <b>Preload</b>.In order to support preload functionality the store needs to read the string keys from the database and transform them into the corresponding key objects. {@link org.infinispan.persistence.keymappers.Key2StringMapper} only supports key to string transformation(one way); in order to be able to use preload one needs to specify an {@link org.infinispan.persistence.keymappers.TwoWayKey2StringMapper}, which extends {@link org.infinispan.persistence.keymappers.Key2StringMapper} and allows bidirectional transformation. <p/> <b>Rehashing</b>. When a node leaves/joins, Infinispan moves around persistent state as part of rehashing process. For this it needs access to the underlaying key objects, so if distribution is used, the mapper needs to be an {@link org.infinispan.persistence.keymappers.TwoWayKey2StringMapper} otherwise the cache won't start (same constraint as with preloading).

JdbcStringBasedStoreConfigurationBuilder.
JdbcStringBasedStoreConfigurationSerializer.
Contains common methods used by JDBC CacheStores.
Persistable and cacheable metadata for JMX attributes
A JMX Component
A Doclet that generates a guide to all JMX components exposed by Infinispan


Test that JMX statistics/operations are available for an Infinispan server instance. <p/> TODO: operations/attributes of Transactions MBean  - Transactions are only available in embedded mode (to be impl. for HotRod later: ISPN-375) <p/> operations/attributes of RecoveryAdmin MBean - the same as above
Persistable and cacheable metadata for JMX operations
JmxOperationParameter stores metadata information about MBean operation parameters which is then used at runtime to build the relevant {@link MBeanParameterInfo}
Interface containing common cache management operations
Base class for all the interceptors exposing management statistics.
Class containing JMX related utility methods.
A {@link org.hibernate.cache.spi.RegionFactory} for <a href="http://www.jboss.org/infinispan">Infinispan</a>-backed cache regions that finds its cache manager in JNDI rather than creating one itself.
Factory methods for creating a JndiName.
Represents a canonical join type. <p/> Note that currently HQL really only supports inner and left outer joins (though cross joins can also be achieved).  This is because joins in HQL are always defined in relation to a mapped association.  However, when we start allowing users to specify ad-hoc joins this may need to change to allow the full spectrum of join types.  Thus the others are provided here currently just for completeness and for future expansion.

JpaStoreConfiguration.



JpaStoreConfigurationSerializer.


Occurs if there is a problem while converting from String to JSON.
Json Object implementation. This is the only link between POJOs and particular JSON library implementation.
Custom assertion for easier testing OpHandlers
JsonResult. Returns the data formatted as JSON.

A simple grouper which groups String based keys using a pattern for kX keys
Annotation processor for creating LDAP and Kerberos servers.

Defines the logic of mapping a key object to a String. This is required by certain cache stores, in order to map each key to a String which the underlying store is capable of handling. It should generate a unique String based on the supplied key.
Defines a service that generates keys to be mapped to specific nodes in a distributed(vs. replicated) cluster. The service is instantiated through through one of the factory methods from {@link org.infinispan.affinity.KeyAffinityServiceFactory}. <p/> Sample usage: <p/> <pre><code> Cache&lt;String, Long&gt; cache = getDistributedCache(); KeyAffinityService&lt;String&gt; service = KeyAffinityServiceFactory.newKeyAffinityService(cache, 100); ... String sessionId = sessionObject.getId(); String newCollocatedSession = service.getCollocatedKey(sessionId); //this will reside on the same node in the cluster cache.put(newCollocatedSession, someInfo); </code></pre> <p/> Uniqueness: the service does not guarantee that the generated keys are unique. It relies on an {@link org.infinispan.affinity.KeyGenerator} for obtaining and distributing the generated keys. If key uniqueness is needed that should be enforced in the generator. <p/> The service might also drop key generated through the {@link org.infinispan.affinity.KeyGenerator}.
Factory for creating a key affinity service.
Key affinity service factory that will only generates keys for use by the local node. Returns a trivial implementation if the specified cache is not distributed.

A listener for {@link KeyAwareLockPromise}. <p> This event contains the key that the lock owner is try to acquire.
An extension of {@link LockPromise} that contains a key associated to the lock.
The {@link CommandHandler} implementation which has a key as an argument.

A filter for keys.  This class is complemented by the {@link org.infinispan.filter.KeyValueFilter} class.  This class is useful for cases when it may be more beneficial to not have the values available.  This would include cache loaders since many implementations it may incur additional performance costs just to resurrect the values in addition to any keys.
CacheEventFilter that implements it's filtering solely on the use of the provided KeyFilter
KeyValueFilter that implements it's filtering solely on the use of the provided KeyFilter
Used for generating keys; used by {@link org.infinispan.affinity.KeyAffinityService} to generate the affinity keys. It offers the possibility to generate keys in a particular format.
Map keys to segments.
Key partitioner factory that uses the hash function defined in the configuration. In the future, we will probably remove the hash function from the configuration and leave only the key partitioner.
Command implementation for {@link java.util.Map#keySet()} functionality.
Stream supplier that is to be used when the underlying stream is composed by key instances.  This supplier will do the proper filtering by assuming each element is the key itself.


A terminal operation for a {@link org.infinispan.CacheStream} that allows tracking keys during a rehash event.
This transforms arbitrary keys to a String which can be used by Lucene as a document identifier, and vice versa. <p/> There are 2 approaches to doing so; one for SimpleKeys: Java primitives (and their object wrappers), byte[] and Strings, and one for custom, user-defined types that could be used as keys. <p/> For SimpleKeys, users don't need to do anything, these keys are automatically transformed by this class. <p/> For user-defined keys, two options are supported. Types annotated with @Transformable, and declaring an appropriate {@link org.infinispan.query.Transformer} implementation; and types for which a {@link org.infinispan.query.Transformer} has been explicitly registered through KeyTransformationHandler.registerTransformer().

A filter for keys with their values.  This class is complemented by the {@link org.infinispan.filter.KeyFilter} class.  This filter should be used in most cases over {@link org.infinispan.filter.KeyFilter} since it allows for more control of the filtering since it provides the ability to filter on the value and metadata in addition to the key.
CacheEventFilter that implements it's filtering solely on the use of the provided KeyValueFilter
This is a KeyFilter that utilizes the given {@link org.infinispan.filter.KeyValueFilter} to determine if to filter the key.  Note this filter will be passed null for both the value and metadata on every pass.
This interface is an optimization that can be used when a filter and converter are most efficiently used as the same object composing the filtering and conversion in the same method invocation.

Factory for {@link org.infinispan.filter.KeyValueFilterConverter} instances
Holds logically related key-value pairs or binary tuples.




Externalizer for KeyValueWithPreviousEventConverter

All objects being used as keys to store entries by the Lucene Directory implement {@link IndexScopedKey} which enforces visitability with a {@link KeyVisitor<T>}. Various components use this to visit each key.
The {@link CommandHandler} implementation which has a key and the codec as arguments.
Holder for known named component names.  To be used with {@link org.infinispan.factories.annotations.ComponentName} annotation.




Tests for L1 caching.
Configures the L1 cache behavior in 'distributed' caches instances. In any other cache modes, this element is ignored.
Configures the L1 cache behavior in 'distributed' caches instances. In any other cache modes, this element is ignored.
A {@link org.infinispan.container.entries.InternalCacheEntry} implementation to store a L1 entry.
L1 based interceptor that flushes the L1 cache at the end after a transaction/entry is committed to the data container but before the lock has been released.  This is here to asynchronously clear any L1 cached values that were retrieved between when the data was updated, causing a L1 invalidation, and when the data was put into the data container
Manages the L1 Cache, in particular recording anyone who is going to cache an a command that a node responds to so that a unicast invalidation can be sent later if needed.

{@link org.infinispan.metadata.Metadata} implementation that must be passed to the {@link org.infinispan.container.DataContainer#put(Object, Object, org.infinispan.metadata.Metadata)} when the entry to store is a L1 entry.
A {@link org.infinispan.container.entries.InternalCacheEntry} implementation to store a L1 entry.
Interceptor that handles L1 logic for non-transactional caches.
Interceptor that handles L1 logic for transactional caches.
A write synchronizer that allows for a single thread to run the L1 update while others can block until it is completed.  Also allows for someone to attempt to cancel the write to the L1.  If they are unable to, they should really wait until the L1 write has completed so they can guarantee their update will be ordered properly.
A lambda {@link AdvancedExternalizer}.

Some SwitchingBackend implementations need to expose additional transition methods.
This backend only triggers initialization of a different backend when incoming indexing operations trigger it, then transfers the incoming operations to the new backend. Which backed is being selected depends on the cluster state.
A delegating executor that lazily constructs and initializes the underlying executor.
A delegating executor that lazily constructs and initializes the underlying executor, since unused JDK executors are expensive.
A delegating scheduled executor that lazily constructs and initializes the underlying scheduled executor, since unused JDK executors are expensive.
Implementation for {@link org.infinispan.query.ResultIterator}. This loads the results only when required and hence differs from {@link EagerIterator} which is the other implementation of ResultIterator.

Legacy Ids used in Infinispan 8 to map {@link org.infinispan.commons.marshall.Externalizer} implementations. Indexes for object types. These are currently limited to being unsigned ints, so valid values are considered those in the range of 0 to 254. Please note that the use of 255 is forbidden since this is reserved for foreign, or user defined, externalizers.
A JBossMarshaller implementation used exclusively for reading byte arrays marshalled by Infinispan 8.
A wrapper around system properties that supports legacy keys
LegacyVersionAwareMarshaller that is used to read bytes marshalled using Infinispan 8.x. This is useful for providing a migration path between 8.x and 9.x stores.
A backwards-compatible LevelDBStore backed by the RocksDBStore


LevelDB XML Configuration Parser

LevelDBStoreConfigurationSerializer.
Lifecycle interface that defines the lifecycle of components

Lifecycle of the Query module: initializes the Hibernate Search engine and shuts it down at cache stop.
A condition that matches String values using a pattern containing the well known '%' and '_' wildcards.


Performs limit operation on a {@link DoubleStream}
Performs limit operation on a {@link IntStream}
Performs limit operation on a {@link LongStream}
Performs limit operation on a regular {@link Stream}
Executes tasks in the given executor, but never has more than {@code maxConcurrentTasks} tasks running at the same time. <p>A task can finish running without allowing another task to run in its stead, with {@link #executeAsync(Supplier)}. A new task will only start after the {@code CompletableFuture} returned by the task has completed.</p> <p><em>Blocking mode.</em> If the executor is a {@link WithinThreadExecutor}, tasks will run in the thread that submitted them. If there are no available permits, the caller thread will block until a permit becomes available.</p>
{@link java.util.LinkedHashMap} based near cache implementation. Concurrent access is controlled by a reentrant RW lock.
List externalizer dealing with ArrayList and LinkedList implementations.
Interface that denotes that the implementation can have listeners attached to it.
Class-level annotation used to annotate an object as being a valid cache listener.  Used with the {@link org.infinispan.Cache#addListener(Object)} and related APIs. <p/> Note that even if a class is annotated with this annotation, it still needs method-level annotation (such as {@link org.infinispan.notifications.cachemanagerlistener.annotation.CacheStarted}) to actually receive notifications. <p/> Objects annotated with this annotation - listeners - can be attached to a running {@link org.infinispan.Cache} so users can be notified of {@link org.infinispan.Cache} events. <p/> <p/> There can be multiple methods that are annotated to receive the same event, and a method may receive multiple events by using a super type. </p> <p/> <h4>Delivery Semantics</h4> <p/> An event is delivered immediately after the respective operation, but before the underlying cache call returns. For this reason it is important to keep listener processing logic short-lived. If a long running task needs to be performed, it's recommended to use another thread. </p> <p/> <h4>Transactional Semantics</h4> <p/> Since the event is delivered during the actual cache call, the transactional outcome is not yet known. For this reason, <i>events are always delivered, even if the changes they represent are discarded by their containing transaction</i>. For applications that must only process events that represent changes in a completed transaction, {@link org.infinispan.notifications.cachelistener.event.TransactionalEvent#getGlobalTransaction()} can be used, along with {@link org.infinispan.notifications.cachelistener.event.TransactionCompletedEvent#isTransactionSuccessful()} to record events and later process them once the transaction has been successfully committed. Example 4 demonstrates this. </p> <p/> <h4>Threading Semantics</h4> <p/> A listener implementation must be capable of handling concurrent invocations. Local notifications reuse the calling thread; remote notifications reuse the network thread. </p> <p/> Since notifications reuse the calling or network thread, it is important to realise that if your listener implementation blocks or performs a long-running task, the original caller which triggered the cache event may block until the listener callback completes.  It is therefore a good idea to use the listener to be notified of an event but to perform any long running tasks in a separate thread so as not to block the original caller. </p> <p/> In addition, any locks acquired for the operation being performed will still be held for the callback.  This needs to be kept in mind as locks may be held longer than necessary or intended to and may cause deadlocking in certain situations.  See above paragraph on long-running tasks that should be run in a separate thread. </p> <b>Note</b>: The <tt>sync</tt> parameter on this annotation defaults to <tt>true</tt> which provides the above semantics.  Alternatively, if you set <tt>sync</tt> to <tt>false</tt>, then invocations are made in a <i>separate</i> thread, which will not cause any blocking on the caller or network thread.  The separate thread is taken from a pool, which can be configured using {@link org.infinispan.config.GlobalConfiguration#setAsyncListenerExecutorProperties(java.util.Properties)} and {@link org.infinispan.config.GlobalConfiguration#setAsyncListenerExecutorFactoryClass(String)}. <p/> <b>Summary of Notification Annotations</b> <table border="1" cellpadding="1" cellspacing="1" summary="Summary of notification annotations"> <tr> <th bgcolor="#CCCCFF" align="left">Annotation</th> <th bgcolor="#CCCCFF" align="left">Event</th> <th bgcolor="#CCCCFF" align="left">Description</th> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachemanagerlistener.annotation.CacheStarted}</td> <td valign="top">{@link org.infinispan.notifications.cachemanagerlistener.event.CacheStartedEvent}</td> <td valign="top">A cache was started</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachemanagerlistener.annotation.CacheStopped}</td> <td valign="top">{@link org.infinispan.notifications.cachemanagerlistener.event.CacheStoppedEvent}</td> <td valign="top">A cache was stopped</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.CacheEntryModified}</td> <td valign="top">{@link org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent}</td> <td valign="top">A cache entry was modified</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated}</td> <td valign="top">{@link org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent}</td> <td valign="top">A cache entry was created</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved}</td> <td valign="top">{@link org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent}</td> <td valign="top">A cache entry was removed</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.CacheEntryVisited}</td> <td valign="top">{@link org.infinispan.notifications.cachelistener.event.CacheEntryVisitedEvent}</td> <td valign="top">A cache entry was visited</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.CacheEntryLoaded}</td> <td valign="top">{@link org.infinispan.notifications.cachelistener.event.CacheEntryLoadedEvent}</td> <td valign="top">A cache entry was loaded</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.CacheEntriesEvicted}</td> <td valign="top">{@link org.infinispan.notifications.cachelistener.event.CacheEntriesEvictedEvent}</td> <td valign="top">A cache entries were evicted</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.CacheEntryActivated}</td> <td valign="top">{@link org.infinispan.notifications.cachelistener.event.CacheEntryActivatedEvent}</td> <td valign="top">A cache entry was activated</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.CacheEntryPassivated}</td> <td valign="top">{@link org.infinispan.notifications.cachelistener.event.CacheEntryPassivatedEvent}</td> <td valign="top">One or more cache entries were passivated</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachemanagerlistener.annotation.ViewChanged}</td> <td valign="top">{@link org.infinispan.notifications.cachemanagerlistener.event.ViewChangedEvent}</td> <td valign="top">A view change event was detected</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.TransactionRegistered}</td> <td valign@="top">{@link org.infinispan.notifications.cachelistener.event.TransactionRegisteredEvent}</td> <td valign="top">The cache has started to participate in a transaction</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.TransactionCompleted}</td> <td valign=@"top">{@link org.infinispan.notifications.cachelistener.event.TransactionCompletedEvent}</td> <td valign="top">The cache has completed its participation in a transaction</td> </tr> <tr> <td valign="top">{@link org.infinispan.notifications.cachelistener.annotation.CacheEntryInvalidated}</td> <td valign=@"top">{@link org.infinispan.notifications.cachelistener.event.CacheEntryInvalidatedEvent}</td> <td valign="top">A cache entry was invalidated by a remote cache.  Only if cache mode is INVALIDATION_SYNC or INVALIDATION_ASYNC.</td> </tr> <p/> </table> <p/> <h4>Example 1 - Method receiving a single event</h4> <pre> &#064;Listener public class SingleEventListener { &#064;CacheStarted public void doSomething(Event event) { System.out.println(&quot;Cache started.  Details = &quot; + event); } } </pre> <p/> <h4>Example 2 - Method receiving multiple events</h4> <pre> &#064;Listener public class MultipleEventListener { &#064;CacheStarted &#064;CacheStopped public void doSomething(Event event) { if (event.getType() == Event.Type.CACHE_STARTED) System.out.println(&quot;Cache started.  Details = &quot; + event); else if (event.getType() == Event.Type.CACHE_STOPPED) System.out.println(&quot;Cache stopped.  Details = &quot; + event); } } </pre> <p/> <h4>Example 3 - Multiple methods receiving the same event</h4> <pre> &#064;Listener public class SingleEventListener { &#064;CacheStarted public void handleStart(Event event) { System.out.println(&quot;Cache started&quot;); } <p/> &#064;CacheStarted &#064;CacheStopped &#064;CacheBlocked &#064;CacheUnblocked &#064;ViewChanged public void logEvent(Event event) { logSystem.logEvent(event.getType()); } } </pre> <p/> <p/> <b>Example 4 - Processing only events with a committed transaction.</b> <p/> <pre> &#064;Listener public class EventHandler { private ConcurrentMap&lt;GlobalTransaction, Queue&lt;Event&gt;&gt; map = new ConcurrentHashMap&lt;GlobalTransaction, Queue&lt;Event&gt;&gt;(); &#064;TransactionRegistered public void startTransaction(TransactionRegisteredEvent event) { map.put(event.getGlobalTransaction(), new ConcurrentLinkedQueue&lt;Event&gt;()); } &#064;CacheEntryCreated &#064;CacheEntryModified &#064;CacheEntryRemoved public void addEvent(TransactionalEvent event) { map.get(event.getGlobalTransaction()).add(event); } &#064;TransactionCompleted public void endTransaction(TransactionCompletedEvent event) { Queue&lt;Event&gt; events = map.get(event.getGlobalTransaction()); map.remove(event.getGlobalTransaction()); System.out.println("Ended transaction " + event.getGlobalTransaction().getId()); if(event.isTransactionSuccessful()) { for(Event e : events) { System.out.println("Event " + e); } } } } </pre>

Defines simple listener invocation.
Used for registering various cache notifications.
Holder class for functional listener definitions.
LoaderConfigurationBuilder is an interface which should be implemented by all cache loader builders
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/loader=LOADER

Tests in local mode the server task execution in case if authentication is required.
Used to postpone creation of Local only IndexingBackend instances.
LocalCacheAdd handler
{@link org.infinispan.xsite.BackupReceiver} implementation for local caches.
LocalCacheAdd handler
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/local-cache=*
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/local-cache=*
CacheStream that is to be used locally.  This allows for full functionality of a regular stream but also has options to filter by keys and other functionality.
Default implementation, which uses Local class loader. No external class loading is allowed.

This is a marker interface to indicate that such commands will never be replicated and hence will not return any valid command IDs.
Handler that performs actual cache operations.  Note this handler should be on a separate executor group than the decoder.
DoubleStream that wraps a given stream to allow for additional functionality such as injection of values into various operations
Server task which throws exception intentionally.
Container for the statistics corresponding to local originated transactions. It only knows how to merge from others {@link LocalExtendedStatisticsContainer}
The IndexingBackend which directly couples to the Hibernate Search WorkspaceHolder. Normally this will be the "lucene" backend, writing to the index.
IntStream that wraps a given stream to allow for additional functionality such as injection of values into various operations
Simulates a remote invocation on the local node. This is needed because the transport does not redirect to itself the replicable commands.
LocalLockMergingSegmentReadLocker decorates the {@link DistributedSegmentReadLocker} to minimize remote operations in case several IndexReaders are opened on the same Infinispan based {@link org.apache.lucene.store.Directory}. It keeps track of locks which where already acquired for a specific filename from another request on the same node and merges the request so that the different clients share the same remote lock.
LongStream that wraps a given stream to allow for additional functionality such as injection of values into various operations
MapReduce Server task to run in local mode.
Represents the local node's address.
{@link ShardDistribution} for non-clustered indexes, all shardsIdentifiers are associated with a single server.
Alternative implementation to the ClusteredSwitchingBackend, meant to be used for non-clustered caches: much simpler as we have no states nor transitions to manage.
Marker interface for cache loaders that should only load values on the originating nodes. An example of a loader that uses this interface is {@link org.infinispan.persistence.cluster.ClusterLoader}.
LocalRunner.
Runs JS script on off-heap cache.

Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/28/16 Time: 9:36 AM
Statistics which reflect only cache interactions done though the javax.cache API by the local client.
Stream manager that is invoked on a local node.  This is normally called due to a {@link ClusterStreamManager} from another node requiring some operation to be performed
Local stream manager implementation that handles injection of the stream supplier, invoking the operation and subsequently notifying the operation if a rehash has changed one of its segments.
Runs on every node and handles the communication with the {@link ClusterTopologyManager}.
Factory for ClusterTopologyManager implementations
The {@code LocalTopologyManager} implementation.
Object that holds transaction's state on the node where it originated; as opposed to {@link RemoteTransaction}.
Represents the statistics collected for a local transaction
Invocation context to be used for locally originated transactions.
{@link LocalTransaction} implementation to be used with {@link TransactionXaAdapter}.
Extends {@link CacheTopology} with information about keys owned by the local node.

LocateStatement locates an entry in the cluster
Transitionally backend used when we receive indexing operation to be applied to the (local) IndexWriter, but the index lock is not available yet. We will try again to look for the lock to be made available at each incoming operation, and buffer writes for later consumption if the lock is still not available. Such checks are synchronized, so this will cause some backpressure. The buffer containing postponed write operations is also bounded and will trigger more backpressure when it's filled (although filling it should not be possible as the current implementation steals the locks aggressively).
An {@link Action} implementation that acquire the locks. <p/> It returns {@link ActionStatus#READY} when the locks are available to acquired or the acquisition failed (timeout or deadlock).
Helper class to assert lock status in MVCC
A container for locks
Factory class that creates instances of {@link LockContainer}.
LockControlCommand is a command that enables distributed locking across infinispan nodes. <p/> For more details refer to: https://jira.jboss.org/jira/browse/ISPN-70 https://jira.jboss.org/jira/browse/ISPN-48
The listener for {@link LockPromise}.
An interface to deal with all aspects of acquiring and releasing locks for cache entries.
Factory class that creates instances of {@link LockManager}.

A promise returned by {@link org.infinispan.util.concurrent.locks.impl.InfinispanLock}. <p> This promise does not means that the lock is acquired. The lock is acquired when the {@link #lock()}  method is invoked. It contains the basic method to check it state (when it is available or not) and it allows adding listeners to it.
The {@link org.infinispan.util.concurrent.locks.impl.InfinispanLock} possible states. <p> Used in listener to notify when the state changes.
Stream that allows for operation upon data solely with side effects by using {@link LockedStream#forEach(BiConsumer)} where the <b>BiConsumer</b> is invoked while guaranteeing that the entry being passed is properly locked for the entire duration of the invocation. <p> An attempt is made to acquire the lock for an entry using the default {@link LockingConfiguration#lockAcquisitionTimeout()} before invoking any operations on it. </p>
Lock Stream implementation that locks a key using the {@link LockManager} before and after executing the various code. <p> This implementation doesn't work properly when using an optimistic transactional cache. Care should be made to prevent that usage if possible.
Defines the local, in-VM locking and concurrency characteristics of the cache.
Defines the local, in-VM locking and concurrency characteristics of the cache.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/configurations=CONFIGURATION/cache-configuration=Y/locking=LOCKING
With regular {@link org.infinispan.interceptors.locking.NonTransactionalLockingInterceptor}, async replication does not work in combination with synchronous replication: sync replication relies on locking to order writes on backup while async replication relies on FIFO-ordering from primary to backup. If these two combine, there's a possibility that on backup two modifications modifications will proceed concurrently. Similar issue threatens consistency when the command has {@link org.infinispan.context.Flag#CACHE_MODE_LOCAL} - these commands don't acquire locks either. Therefore, this interceptor locks the entry all the time. {@link UnorderedDistributionInterceptor} does not forward the message from non-origin to any other node, and the distribution interceptor won't block on RPC but will return {@link CompletableFuture} and we'll wait for it here.
Defines the locking modes that are available for transactional caches: <a href="http://community.jboss.org/wiki/OptimisticLockingInInfinispan"></a>optimistic</a> or pessimistic.
Log abstraction for the hot rod client. For this module, message ids ranging from 4001 to 5000 inclusively have been reserved.
This component has the only thread that polls the queue with requests to write some entry into the cache store. It writes the records to append-only log files, inserts the entry position into TemporaryTable and queues the position to be persisted in Index.
Factory that creates {@link Log} instances.
Request to persist entry in log file or request executed by the log appender thread.
Factory for obtaining {@link Logger} instances.
LoggingAuditLogger. A simple {@link AuditLogger} which send audit messages to a named logger "org.infinispan.AUDIT"
Very simple handler that sole purpose is to put the decode context into the channel

A {@link LongStream} that has additional methods to allow for Serializable instances.  Please see {@link CacheStream} for additional details about various methods.

Externalizer used for {@link LongSummaryStatistics}.  Note this assumes given fields have specific names to use through reflection.






A CacheLoader meant to load Lucene index(es) from filesystem based Lucene index(es). This is exclusively suitable for keys being used by the Directory, any other key will be ignored. The InfinispanDirectory requires indexes to be named; this CacheLoader needs to be configured with the path of the root directory containing the indexes, and expects index names to match directory names under this common root path.

To configure a JdbcStringBasedCacheStoreConfig for the Lucene Directory, use this Key2StringMapper implementation.
Configuration bean for the {@link org.infinispan.lucene.cacheloader.LuceneCacheLoader}.
{@link org.infinispan.configuration.cache.ConfigurationBuilder} bean for the {@link LuceneLoaderConfiguration}


An *Expr {@link Visitor} that transforms a {@link IckleParsingResult} into a {@link LuceneQueryParsingResult}. <p> NOTE: This is not stateless, not threadsafe, so it can only be used for a single transformation at a time.

LuceneReaderThread is going to perform searches on the Directory until it's interrupted. Good for performance comparisons and stress tests. It needs a SharedState object to be shared with other readers and writers on the same directory to be able to throw exceptions in case it's able to detect an illegal state.

Collects common LuceneSettings for all tests; especially define the backwards compatibility.

WARNING: this Externalizer implementation drops some state associated to the SortField instance. A CUSTOM Sort Type is unsupported, and it is also not possible to use a custom Field Parser or options related to missing value sorting.

WARNING: this Externalizer implementation drops some state associated to the TermQuery instance. A TermQuery is potentially connected to many open resources whose reference will be severed by this externalizer, and also supports advanced options to set additional state which will not be taken into consideration at this stage.


LuceneUserThread: base class to perform activities on the index, as searching, adding to index and deleting.
Utilities to read and write Lucene indexes

Manages conversions of {@link org.hibernate.search.backend.LuceneWork}.
Dispatches {@link LuceneWork} locally (to other shard in the same node) or remotely.

The serialized form of LuceneWork needs to be adjusted after deserialization to apply our custom keyTransformers. LuceneWork instances are immutable, so we have to replace them with new instances iff an id transformation is needed.
Similar to LuceneWriterThread, except the IndexWriter isn't being closed in each loop iteration but is being reused. This simulates the configuration option exclusive_index_use as applied by Hibernate Search and Infinispan Query.
LuceneWriterThread is going to perform searches on the Directory until it's interrupted. Good for performance comparisons and stress tests. It needs a SharedState object to be shared with other readers and writers on the same directory to be able to throw exceptions in case it's able to detect an illegal state.
Classes annotated with this will be exposed as MBeans. If you are looking for more fined grained way of exposing JMX attributes/operations, take a look at {@link org.infinispan.jmx.annotations.ManagedAttribute} and {@link org.infinispan.jmx.annotations.ManagedOperation}
An MBean attribute
* An MBean component
An MBean operation
Implementors of this should return an MBeanServer to which MBeans will be registered.

Wrapper object for entries that arrive via RESTful PUT/POST interface.
An entry that can be safely copied when updates are made, to provide MVCC semantics
A special type of key that if passed a cache in its constructor, will ensure it will always be assigned to that cache (plus however many additional caches in the hash space). Note that this only works if all the caches have joined a single cluster before creating the key. If the cluster membership changes then the keys may move to other servers.
The CLI Shell
A very simple and incomplete converter from troff-style man macro syntax to ansi
A specialization of {@link ComponentMetadata}, this version also includes JMX related metadata, as expressed by {@link MBean}, {@link ManagedAttribute} and {@link ManagedOperation} annotations.
Indicates that a public method or a field (any visibility) in an MBean class defines an MBean attribute. This annotation can be applied to either a field or a public setter and/or getter method of a public class that is itself is optionally annotated with an @MBean annotation, or inherits such an annotation from a superclass.
Connection factory that can be used when on managed environments, like application servers. It knows how to look into the JNDI tree at a certain location (configurable) and delegate connection management to the DataSource. In order to enable it one should set the following two properties in any Jdbc cache store: <pre> <property name="connectionFactoryClass" value="ManagedConnectionFactory"/> <property name="datasourceJndiLocation" value="java:/ManagedConnectionFactoryTest/DS"/> </pre>
ManagedConnectionFactoryConfiguration.
ManagedConnectionFactoryConfigurationBuilder.
ExecutorService decorator whose shutdown methods are no-ops.
An executor that emulates the behaviour of an EE ManagedServiceExecutor, i.e. one which returns {@link IllegalStateException} on all lifecycle methods according to the spec
Indicates that a method in an MBean class defines an MBean operation. @ManagedOperation annotation can be applied to a public method of a public class that is itself optionally annotated with an @MBean annotation, or inherits such an annotation from a superclass.
ScheduledExecutorService decorator that records recurring tasks and cancels them on shutdown.
Manages registration of all JGroups sockets with a {@link SocketBindingManager}.
The client connects to a running WildFly/EAP server and performs operations on DMR using a helper project Creaper (https://github.com/wildfly-extras/creaper/). The operations include adding and removing caches, endpoints, sockets-bindings etc.


Manifest based implementation of a {@link UberJarDuplicatedJarsWarner}. <p> Incorrect combinations: <ul> <li>Commons + any of the Uber Jars</li> <li>Embedded + Remote Uber Jar</li> <li>Commons + Embedded + Remote Uber Jar</li> </ul> </p>
Tests manual indexing in server.
Performs map operation on a {@link DoubleStream}
Map externalizer for all map implementations except immutable maps and singleton maps, i.e. FastCopyHashMap, HashMap, TreeMap.
Performs map operation on a {@link IntStream}
Terminal rehash aware operation that handles an iterator when a map intermediate operation was performed on the stream.  This is important due to the fact that we need to figure out the keys that map to each entry still. This class assumes the stream is composed of {@link java.util.Map.Entry} instances where the key is typed the same as defined K type.
Performs map operation on a {@link LongStream}
Performs map to operation on a regular {@link Stream}
Performs map to double operation on a {@link IntStream}
Performs map to double operation on a {@link LongStream}
Performs map to double operation on a regular {@link Stream}
Performs map to int operation on a {@link DoubleStream}
Performs map to int operation on a {@link LongStream}
Performs map to int operation on a regular {@link Stream}
Performs map to long operation on a {@link DoubleStream}
Performs map to long operation on a {@link IntStream}
Performs map to long operation on a regular {@link Stream}
Performs boxed operation on a {@link DoubleStream}
Performs map to object operation on a {@link IntStream}
Performs map to object operation on a {@link LongStream}
MarshallUtil.


Class providing hints about marshallable types, such as whether a particular type is marshallable or not, or an accurate approach to the serialized size of a particular type.
Defines an externally persisted entry. External stores that keep the data in serialised form should return an MarshalledEntry that contains the data in binary form (ByteBuffer) and unmarshall it lazily when getKey/Value/Metadata are invoked. This approach avoids unnecessary object (de)serialization e.g when the entries are fetched from the external store for the sole purpose of being sent over the wire to another requestor node.
Factory for {@link MarshalledEntry}.


A stream of bytes which can be written to, and the underlying byte array can be directly accessed. By implementing {@link org.jboss.marshalling.ByteOutput} we avoid the need for the byte stream to be wrapped by {@link org.jboss.marshalling.Marshalling#createByteOutput(OutputStream)}
A marshaller is a class that is able to marshall and unmarshall objects efficiently. <p/> This interface is used to marshall {@link org.infinispan.commands.ReplicableCommand}s, their parameters and their response values, as well as any other arbitraty Object <--> byte[] conversions, such as those used in client/server communications. <p/> A single instance of any implementation is shared by multiple threads, so implementations <i>need</i> to be threadsafe, and preferably immutable.

Encoder that uses a {@link StreamingMarshaller} to convert objects to byte[] and back.

MarshallerFactory.
Tests the marshaller is picked correctly when a cache is restarted.



MarshallingTwoWayKey2StringMapper.
Execution plan of a MassIndexer

Component to rebuild the indexes from the existing data. This process starts by removing all existing indexes, and then a distributed task is executed to rebuild the indexes. This task can take a long time to run, depending on data size, used stores, indexing complexity. <p> While reindexing is being performed queries should not be executed as they will very likely miss many or all results.
{@link org.infinispan.test.concurrent.CommandMatcher} implementation that can match a single invocation (e.g. the 2nd invocation that matches the other conditions).
An object matcher able to test a given object against multiple registered filters specified either as Ickle queries (a JP-QL subset with full-text support) or using the query DSL (see {@link org.infinispan.query.dsl}). The matching filters are notified via a callback supplied when registering the filter. The filter will have to specify the fully qualified type name of the matching entity type because simple names cannot be easily resolved as it would happen in the case of an {@link javax.persistence.EntityManager} which has knowledge of all types in advance and is able to translate simple names to fully qualified names unambiguously. <p> Full-text predicates are not supported at the moment. <p> This is a low-level interface which should not be directly used by Infinispan users.
Stores processing state during the matching process of all filters registered with a Matcher.

An accumulator that returns the greatest of the values it encounters. Values must be {@link Comparable}. The return has the same type as the field to which it is applied. {@code Null} values are ignored. If there are no remaining non-null values to compute then the result of the aggregate function is {@code null}.

Represents Media Type with attached {@link OutputPrinter}.



A simple cache to store some information about a newly registered member.
A Really simple Memcached client/helper.
{@link Category} tag for clustered Memcached tests.
{@link Category} tag for clustered Memcached tests.
Tests for the Memcached client. Clustered test cases. The servers are running in domain mode.
Tests for the Memcached client. Clustered test cases. The servers are running in standalone mode.
MemcachedCodec.

MemcachedConnectorResource.
A Memcached protocol specific decoder private class DelayedFlushAll(cache: AdvancedCache[String, Array[Byte]], flushFunction: AdvancedCache[String, Array[Byte]] => Unit) extends Runnable { override def run() { flushFunction(cache.getAdvancedCache) } }
Protocol decoding state

Memcached metadata information.

Memcached operations.
Memcached server defining its decoder/encoder settings. In fact, Memcached does not use an encoder since there's no really common headers between protocol operations.
MemcachedServerConfiguration.
MemcachedServerConfigurationBuilder.
{@link Category} tag for local Memcached tests.
{@link Category} tag for local Memcached tests in domain mode.
Tests for the Memcached client. The server is running in domain mode.
Tests for the Memcached client. Single node test cases. The server is running standalone mode.



Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/memory=MEMORY-BINARY
Controls the memory storage configuration for the cache.
Controls the data container for the cache.

Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/memory=MEMORY-OBJECT
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/memory=MEMORY-OFF-HEAP

This event is passed in to any method annotated with {@link org.infinispan.notifications.cachemanagerlistener.annotation.Merged}.

This interface is <strong>not</strong> a public API. <p>A value implementing this interface is merged with the actual value when storing into {@link org.infinispan.container.DataContainer}. As the merge operation is synchronized externally, the implementation of this interface does not need to be thread-safe. Note that the value in context (last written value) needs to implement {@link MergeOnStore}, if the cache already containing such instance is overwritten by a non-implementor, the merge does not happen. <p>The intended use is when executing a command with {@link org.infinispan.context.Flag#SKIP_LOCKING}; in that case we may have two different instances in context at one moment and the writes may be applied in any order, even in a different order on different owners. Therefore it's strongly recommended that all operations on such entry are commutative (order-independent). <p>As the atomicity of load & store into persistence layer cannot be guaranteed, it is recommended to use such values only with {@link org.infinispan.context.Flag#SKIP_CACHE_LOAD} and {@link org.infinispan.context.Flag#SKIP_CACHE_STORE} or implementing a custom externalizer that will deal with this.

This annotation should be used on methods that need to be notified when the cache is used in a cluster and the cluster topology experiences a merge event after a cluster split. <p/> Methods annotated with this annotation should accept a single parameter, a {@link org.infinispan.notifications.cachemanagerlistener.event.MergeEvent} otherwise a {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your listener. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back. ensure this annotation is available at runtime. ensure that this annotation is applied to classes.

Informational CLI messages. These start from 19500 so as not to overlap with the logging messages defined in {@link Log} Messages.
An easily extensible metadata parameter that's stored along with the value in the the functional map. <p>Some metadata parameters can be provided by the user in which case they need to implement {@link MetaParam.Writable}. Examples of writable metadata parameters are version information, lifespan of the cached value...etc. <p>Those metadata parameters not extending {@link MetaParam.Writable} are created by internal logic and hence can only be queried, for example: time when value was added into the functional map, or last time value was accessed or modified. <p>What makes {@link MetaParam} different from {@link Param} is that {@link MetaParam} values are designed to be stored along with key/value pairs in the functional map, to provide extra information. On the other hand, {@link Param} instances merely act as ways to tweak how operations are executed, and their contents are never stored permanently. <p>This interface replaces Infinispan's Metadata interface providing a more flexible way to add new metadata parameters to be stored with the cached entries. <p>{@link MetaParam} design has been geared towards making a clear separation between the metadata that can be provided by the user on per-entry basis, e.g. lifespan, maxIdle, version...etc, as opposed to metadata that's produced by the internal logic that cannot be modified directly by the user, e.g. cache entry created time, last time cache entry was modified or accessed ...etc.

Represents a {@link MetaParam} collection. <p>In {@link Params}, the internal array where each parameter was stored is indexed by an integer. This worked fine because the available parameters are exclusively controlled by the Infinispan. This is not the case with {@link MetaParam} instances where users are expected to add their own types. So, for {@link MetaParams}, an array is still used but the lookup is done sequentially comparing the type of the {@link MetaParam} looked for against the each individual {@link MetaParam} instance stored in {@link MetaParams}. <p>Having sequential {@link MetaParam} lookups over an array is O(n), but this is not problematic since the number of {@link MetaParam} to be stored with each cached entry is expected to be small, less than 10 per {@link MetaParams} collection. So, the performance impact is quite small. <p>Storing {@link MetaParam} instances in an array adds the least amount of overhead to keeping a collection of {@link MetaParam} in memory along with each cached entry, while retaining flexibility to add or remove {@link MetaParam} instances. <p>This {@link MetaParams} collection is not thread safe because it is expected that any updates will be done having acquired write locks on the entire {@link org.infinispan.container.entries.CacheEntry} which references the {@link MetaParams} collection. Hence, any updates could be done without the need to keep {@link MetaParams} concurrently safe. Also, although users can retrieve or update individual {@link MetaParam} instances, they cannot act on the globally at the {@link MetaParams} level, and hence there is no risk of users misusing {@link MetaParams}. This class should not be accessible from user code, therefore it is package-protected.
Metadata parameters backed internal metadata representation.
Represents metadata about an entry, such as creation and access times and expiration information. Time values are server time representations as returned by {@link org.infinispan.util.TimeService#wallClockTime}
A generic representation of some of the aspects of type metadata. This is meant to ensure decoupling from the underlying metadata representation (Class, Protobuf descriptor, etc).
Marker interface for metadata aware cache entry.
A command that contains metadata information.
Entity which should hold serialized metadata
Embedded entity which serves as primary key for metadata. Bytes representing the key are hashed via SHA-256.
MetadataHelper
A form of {@link org.infinispan.container.entries.ImmortalCacheEntry} that is {@link org.infinispan.container.entries.metadata.MetadataAware}
A form of {@link org.infinispan.container.entries.ImmortalCacheValue} that is {@link org.infinispan.container.entries.metadata.MetadataAware}
A cache entry that is mortal and is {@link MetadataAware}
A mortal cache value, to correspond with {@link org.infinispan.container.entries.metadata.MetadataMortalCacheEntry}
A cache entry that is transient, i.e., it can be considered expired after a period of not being used, and {@link org.infinispan.container.entries.metadata.MetadataAware}
A transient cache value, to correspond with {@link org.infinispan.container.entries.TransientCacheEntry} which is {@link org.infinispan.container.entries.metadata.MetadataAware}
A form of {@link org.infinispan.container.entries.TransientMortalCacheEntry} that is {@link org.infinispan.container.entries.versioned.Versioned}
A form of {@link org.infinispan.container.entries.TransientMortalCacheValue} that is {@link org.infinispan.container.entries.versioned.Versioned}
Besides the value, also contains a version and expiration information. Time values are server time representations as returned by {@link org.infinispan.util.TimeService#wallClockTime}
MetadataValueImpl.
Utility method for Metadata classes.
Metadata associated to a method annotated with a cache annotation.
Interface to be implemented by metric enumerations.
Encapsulates the execution of a runtime metric.
Generic {@link org.jboss.as.controller.OperationStepHandler} for runtime metrics.

MigrationMarshaller. Uses the Remote Store classloader so that appropriate backwards-compatibility classes are loaded.


Metadata for MIME data stored in REST servers.
Build for mime metadata

An accumulator that returns the smallest of the values it encounters. Values must be {@link Comparable}. The return has the same type as the field to which it is applied. {@code Null} values are ignored. If there are no remaining non-null values to compute then the result of the aggregate function is {@code null}.
Exception thrown when a named factory is chosen that doesn't exist

Mock Server channel for testing.
Mock Server Handler Context.
Mock client for testing.



Utility methods for dealing with Mockito mocks.






Utility methods for extracting values from a {@link ModelNode}.
An interface that defines a {@link org.infinispan.persistence.spi.CacheWriter} modification
ModificationsList contains a List<Modification>
For compatibility
Module command extensions
Modules which wish to implement their own commands and visitors must also provide an implementation of this interface and declare it in their <tt>infinispan-module.properties</tt> file under key <tt>infinispan.module.command.factory</tt>. <p /> Implementations <b>must</b> be public classes with a public, no-arg constructor for instantiation. <p /> Note that this is a {@link Scopes#GLOBAL} component and as such cannot have {@link Inject} methods referring to {@link Scopes#NAMED_CACHE} scoped components.  For such components, use a corresponding {@link Scopes#NAMED_CACHE}-scoped {@link ModuleCommandInitializer}. <p />
The Query module is using custom RPC commands; to make sure the used command ids are unique all numbers are defined here, and should stay in the range 100-119 which is the reserved range for this module.
Modules which wish to implement their own commands and visitors must also provide an implementation of this interface and declare it in their <tt>infinispan-module.properties</tt> file under key <tt>infinispan.module.command.initializer</tt>. <p /> Implementations <b>must</b> be public classes with a public, no-arg constructor for instantiation. <p />

ModuleLifecycle is an internal API hook for delegating lifecycle events to Infinispan sub-modules. <p> For example, the 'tree' module needs to register specific types with the StreamingMarshaller. The 'query' module needs to register an interceptor with the Cache if the Cache has enabled querying etc etc. <p /> To use this hook, you would need to implement this interface (or extend {@link AbstractModuleLifecycle}) and then create a file called <tt>infinispan-module.properties</tt> in the root of your module's JAR. When using Maven, for example, <tt>infinispan-module.properties</tt> would typically be in the module's <tt>src/main/resources</tt> directory so it gets packaged appropriately. <p /> <u>infinispan-module.properties</u> <p /> Currently, the following properties are supported: <ul> <li><tt>infinispan.module.name</tt> - the name of the module.  The aim of this property is to identify each individual module, so the contents can be any valid String as long as it does not clash with the module name of another module's life cycle properties. </li> <li><tt>infinispan.module.lifecycle</tt> - the name of the class implementing {@link ModuleLifecycle}. This implementation would typically reside in the module's codebase.</li> </ul> Modules who also have their own configuration (see {@see org.infinispan.configuration}), can access their configuration beans via {@link Configuration#module(Class)}
This interface should be implemented by all Infinispan modules that expect to have components using {@link Inject}, {@link Start} or {@link Stop} annotations.  The metadata file is generated at build time and packaged in the module's corresponding jar file (see Infinispan's <pre>core</pre> module <pre>pom.xml</pre> for an example of this). <p /> Module component metadata is usually generated in a file titled <pre>${module-name}-component-metadata.dat</pre> and typically resides in the root of the module's jar file. <p /> For example, Infinispan's Query Module would implement this interface to return <pre>infinispan-query-component-metadata.dat</pre>. <p /> Implementations of this interface are discovered using the JDK's {@link java.util.ServiceLoader} utility.  Which means modules would also have to package a file called <pre>org.infinispan.factories.components.ModuleMetadataFileFinder</pre> in the <pre>META-INF/services/</pre> folder in their jar, and this file would contain the fully qualified class name of the module's implementation of this interface. <p /> Please see Infinispan's query module for an example of this.
The <code>ModuleProperties</code> class represents Infinispan's module service extensions
A cache entry that is mortal.  I.e., has a lifespan.
A mortal cache value, to correspond with {@link org.infinispan.container.entries.MortalCacheEntry}
A task that executes operations against a group of cache managers.
This DistributedCallable is used to invoke a raised notification on the cluster listener that registered to listen for this event.
Invoke a sequence of sub-commands.
Request implementation that waits for responses from multiple target nodes.


Multi tenant router configuration builder.
The main entry point for the router.
Global {@link org.infinispan.server.router.MultiTenantRouter}'s configuration.
Multi tenant router configuration builder.
Multi tenant router service
MultimapCache provides the common building block for the two different types of multimap caches that Infinispan provides: embedded and remote. <p> Please see the <a href="http://infinispan.org/documentation/">Infinispan documentation</a> and/or the <a href="http://infinispan.org/docs/dev/getting_started/getting_started.html">5 Minute Usage Tutorial</a> for more details on Infinispan. <p/> <p> MutimapCache is a type of Infinispan Cache that maps keys to values, similar to {@link org.infinispan.commons.api.AsyncCache} in which each key can contain multiple values. <pre> foo -> 1 bar -> 3, 4, 5 </pre> <p> <h2>Example</h2> <pre> multimapCache.put("k", "v1").join(); multimapCache.put("k", "v2").join(); multimapCache.put("k", "v3").join(); Collection<String> results = multimapCache.get("k").join(); </pre> <p> <h2>Eviction</h2> <p> Eviction works per key. This means all the values associated on a key will be evicted. </p> <p> <h2>Views</h2> <p> The returned collections when calling "get" are views of the values on the key. Any change on these collections won't affect the cache values on the key. <p> <h2>Null values</h2> Null values are not supported. The multimap cache won't have a null key or any null value. <p> Example <pre> multimapCache.put(null, "v1").join() -> fails multimapCache.put("k", null).join() -> fails multimapCache.put("k", "v1").join() -> works and add's v1 multimapCache.containsKey("k").join() -> true multimapCache.remove("k", "v1").join() -> works, removes v1 and as the remaining collection is empty, the key is removed multimapCache.containsKey("k").join() -> false </pre> <p> <p> <h2>Duplicates</h2> The current implementation does not support duplicate values on keys. {@link Object#equals(Object)} method is used to check if a value is already present in the key. This means that the following code <pre> multimapCache.put("k", "v1").join(); multimapCache.put("k", "v2").join(); multimapCache.put("k", "v2").join(); multimapCache.put("k", "v2").join(); multimapCache.get("k").thenAccept(values -> System.out.println(values.size())); </pre> prints the value 2. "k" -> ["v1", "v"] <p> Future implementations might evolve to support duplicated values. <p> <h2>Transactions</h2> MultimapCache supports implicit transactions without blocking. The following methods block when they are called in a explicit transaction context. This limitation could be improved in the following versions if technically possible. <p> <ul> <li>{@link MultimapCache#size()} <li>{@link MultimapCache#containsEntry(Object, Object)} <li>{@link MultimapCache#remove(Predicate)} </ul> <p> More about transactions in : <a href="http://infinispan.org/docs/dev/user_guide/user_guide.html#transactions">the Infinispan Documentation</a>.

MultimapModuleLifecycle is necessary for the Multimap Cache module. Registers advanced externalizers.
Tests Multi-tenancy feature. HotRod client performs write operation and read goes through REST. Note, that compatibility mode is a must here. <p> Since this test is pretty slow (requires booting up full server with Arquillian), it contains only high level tests. For more complicated scenarios, see tests from {@link org.infinispan.server.router.integration}. </p>
MurmurHash3 implementation in Java, based on Austin Appleby's <a href= "https://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp" >original in C</a> Only implementing x64 version, because this should always be faster on 64 bit native processors, even 64 bit being ran with a 32 bit OS; this should also be as fast or faster than the x86 version on some modern 32 bit processors.
MurmurHash3 implementation in Java, based on Austin Appleby's <a href= "https://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp" >original in C</a> Only implementing x64 version, because this should always be faster on 64 bit native processors, even 64 bit being ran with a 32 bit OS; this should also be as fast or faster than the x86 version on some modern 32 bit processors.
Infinispan implementation of {@link MutableEntry} designed to be passed as parameter to {@link javax.cache.processor.EntryProcessor#process(javax.cache.processor.MutableEntry, Object...)}.
Simplified version of functional command used for read-only operations after transactional modifications.
Helper class for marshalling, also hiding implementations of {@link Mutation} from the interface.


Test cache store, which never store/loads anything (= returns null for all keys).
Test configuration for MyCustomCacheStore. Copy of ClusterLoaderConfiguration with a new customProperty.




MyModuleConfigurationBuilder. A builder for {@link MyModuleConfiguration}
MyParserExtension. This is a simple extension parser which parses modules in the "urn:infinispan:config:mymodule" namespace


Test class with incorrectly defined equals and hashCode.
Thrown when a named cache cannot be found.
A specialized type of component factory that knows how to create named components, identified with the {@link org.infinispan.factories.annotations.ComponentName} annotation on the classes requested in {@link org.infinispan.factories.annotations.Inject} annotated methods.
A factory that specifically knows how to create named executors.


NamespaceMappingParser. This interface defines methods exposed by a namespace-mapping-aware parser (such as {@link ParserRegistry}
Namespaces. An annotation which allows specifying multiple {@link Namespace}s recognized by an implementation of a {@link ConfigurationParser}
Test case for NaturalId annotation - ANN-750
Natural ID cache region
Near cache contract.


Decides how client-side near caching should work.
Near cache service, manages the lifecycle of the near cache.
Pipeline factory for Netty based channels. For each pipeline created, a new decoder is created which means that each incoming connection deals with a unique decoder instance. Since the encoder does not maintain any state, a single encoder instance is shared by all incoming connections, if and only if, the protocol mandates an encoder.




A Netty based transport.
It represents the no-arg Infinispan CLI command. It should be used as a base class for other commands with arguments Infinispan CLI command. <p/> The Infinispan CLI command is only available when connected and the prefix contains the {@code cache-container}. <p/> The commands are sent to the Infinispan interpreted to be processed and the result is printed.



Terminal rehash aware operation that handles an iterator when no flat map or map intermediate operation was performed on the stream.  This is important due to the fact that we can just return the entries as is and the client can sort out what is the key and what isn't.



An {@link PendingLockManager} implementation that does nothing.

An externalizer that writes no state. It simply marshalls class information.
A Node is a {@link Fqn named} logical grouping of data in the {@link TreeCache} API of JBoss {@link Cache}. A node should be used to contain data for a single data record, for example information about a particular person or account. <p/> One purpose of grouping cache data into separate nodes is to minimize transaction locking interference, and increase concurrency.  So for example, when multiple threads or possibly distributed caches are accessing different accounts simultaneously. <p/> A node has references to its children, parent (each node except the root - defined by {@link Fqn#ROOT} - has a single parent) and data contained within the node (as key/value pairs).  The data access methods are similar to the collections {@link Map} interface, but some are read-only or return copies of the underlying data. <p/>
Load balancing strategy which always sends to node0.
Load balancing strategy which always sends to node0
Tests properties based auth callback handler, which is build-in in JGroups. Handler checks provided auth information against configured properties file. For test is used SASL MD5 authentication.





Defines the environment for a node.
Implementation backed by an {@link AtomicMap}
A class that represents the key to a node

Thrown when an operation is attempted on a non-existing node in the cache
Thrown whenever operations are attempted on a node that is no longer valid.  See {@link Node#isValid()} for details.
NodeTopDocs. <p> A TopDocs with an array with keys of each result.
Non serializable key for testing DefaultTransformer.

Access delegate that relaxes the consistency a bit: stale reads are prohibited only after the transaction commits. This should also be able to work with async caches, and that would allow the replication delay even after the commit.
A {@link org.infinispan.remoting.inboundhandler.PerCacheInboundInvocationHandler} implementation for non-total order caches.
A {@link PerCacheInboundInvocationHandler} implementation for non-total order caches.
Handles x-site data backups for non-transactional caches.
Invocation Context container to be used for non-transactional caches.
Locking interceptor to be used for non-transactional caches.
Non-transactional interceptor used by distributed caches that support concurrent writes. It is implemented based on lock forwarding. E.g. - 'k' is written on node A, owners(k)={B,C} - A forwards the given command to B - B acquires a lock on 'k' then it forwards it to the remaining owners: C - C applies the change and returns to B (no lock acquisition is needed) - B applies the result as well, releases the lock and returns the result of the operation to A. <p> Note that even though this introduces an additional RPC (the forwarding), it behaves very well in conjunction with consistent-hash aware hotrod clients which connect directly to the lock owner.
Delegate for non-transactional caches
This interceptor should completely replace default InvalidationInterceptor. We need to send custom invalidation commands with transaction identifier (as the invalidation) since we have to do a two-phase invalidation (releasing the locks as JTA synchronization), although the cache itself is non-transactional.
Context to be used for non transactional calls, both remote and local.
Non-transactional counterpart of {@link TxPutFromLoadInterceptor}. Invokes {@link PutFromLoadValidator#beginInvalidatingKey(Object, Object)} for each invalidation from remote node ({@link BeginInvalidationCommand} and sends {@link EndInvalidationCommand} after the transaction is complete, with help of {@link InvalidationSynchronization};
NoneCodec. This codec leaves keys/values as is without applying any transformation It is the default codec.
NoopSegmentReadLocker ignores requests to apply a readlock, but also ignores requests to delete files. It might be a good choice for read-only indexes, or cases in which leaving unused segments in the index is not considered a problem.




A test value having a non-standard constructor, no setter and not indexed
An exception that hides inner stacktrace lines for non serializable exceptions.
The interceptor in charge of firing off notifications to cache listeners
A latch that can be open and close. It allows the notification when the some thread is blocking in it.
Handler for the "notify" and "unnotify" operations.

NullAuditLogger. A simple {@link AuditLogger} which drops all audit messages

An iterator wrapper that filters out (skips over) any null values returned by the wrapped iterator.

NullRunner.
A placeholder value for storing {@literal null} in a cache.
A new additional entity type for testing Infinispan Querying.
Numeric version
Generates unique numeric versions for both local and clustered environments. When used on clustered caches, node information is used to guarantee versions are unique cluster-wide. If the cache is configured to be local, the version generated is based around an atomic counter. On the contrary, if the cache is clustered, the generated version is composed of: [view id (2 bytes)][rank (2 bytes)][version counter (4 bytes)], where rank refers to the position of this node within the view.
A helper that efficiently duplicates known object types.
A filter that tests if an object matches a pre-defined condition and returns either the original instance or the projection, depending on how the filter was created. The projection is represented as an Object[]. If the given instance does not match the filter will just return null.


Provides property metadata when dealing with entities.
Observer custom assertion.
Common interface between Lock implementations having an obtain method, as it was supported in older Lucene versions and currently still useful for our design.
Basic off-heap tests
Data Container implementation that stores entries in native memory (off-heap).
Factory that can create {@link InternalCacheEntry} objects that use off-heap heap memory.  These are stored by a long to symbolize the memory address.
Factory that can create CacheEntry instances from off-heap memory.
Accessors for the fields of a native LRU list node.
Simple wrapper around Unsafe to provide for trace messages for method calls.
Allows for allocation of memory outside of the heap as well additional functionality surrounding it if necessary.
{@link SiteStatus} implementation for offline sites. This class is a singleton and its instance is accessible via {@link #getInstance()}.
Keeps state needed for knowing when a site needs to be taken offline. <p/> Thread safety: This class is updated from multiple threads so the access to it is synchronized by object's intrinsic lock. <p/> Impl detail: As this class's state changes constantly, the equals and hashCode haven't been overridden. This shouldn't affect performance significantly as the number of site backups should be relatively small (1-3).
{@link SiteStatus} implementation for online sites. This class is a singleton and its instance is accessible via {@link #getInstance()}.

Websocket cache operation handler.
Interface to be implemented by operation enumerations.
Encapsulates the execution of a runtime operation.
Generic {@link org.jboss.as.controller.OperationStepHandler} for runtime operations.
Hot Rod operation possible status outcomes.
Utility methods for creating/manipulating management operations.
Factory for {@link org.infinispan.client.hotrod.impl.operations.HotRodOperation} objects.

Handles x-site data backups for optimistic transactional caches.
Locking interceptor to be used by optimistic transactional caches.

CLI Command option







{@link org.junit.experimental.categories.Category} tag for tests in OSGi (Karaf)


Replaces the {@link RpcManager} with a wrapper that can interact with a {@link StateSequencer} when a command that matches a {@link CommandMatcher} is invoked remotely.
Outbound state transfer task. Pushes data segments to another cluster member on request. Instances of OutboundTransferTask are created and managed by StateTransferManagerImpl. There should be at most one such task per destination at any time.
An exception signalling that a command should be retried because it was executed with an outdated topology. <p> This can happen for non-tx caches, if the primary owner doesn't respond (either because it left the cluster or because this particular cache is no longer running).
Converts binary array from {@link org.infinispan.Cache} into output format. <p> In order to avoid unnecessary conversion steps, all methods need to return a byte array. This way Netty doesn't need to do any conversion - it just wraps it into a {@link io.netty.buffer.ByteBuf}. </p>

This class holds statistics about a consistent hash. It counts how many segments are owned or primary-owned by each member.
This class should be in a package that is different from the test so that the test and entity that uses this class for its primary key does not have access to private field.

An HotRod operation that span across multiple remote nodes concurrently (like getAll / putAll).

An easily extensible parameter that allows functional map operations to be tweaked. Examples would include local-only parameter, skip-cache-store parameter and others. <p>What makes {@link Param} different from {@link MetaParam} is that {@link Param} values are never stored in the functional map. They merely act as ways to tweak how operations are executed. <p>Since {@link Param} instances control how the internals work, only {@link Param} implementations by Infinispan will be supported. <p>This interface is equivalent to Infinispan's Flag, but it's more powerful because it allows to pass a flag along with a value. Infinispan's Flag are enum based which means no values can be passed along with value. <p>Since each param is an independent entity, it's easy to create public versus private parameter distinction. When parameters are stored in enums, it's more difficult to make such distinction.
Parameter identifiers.
Factory for {@link org.infinispan.filter.KeyValueFilterConverter} instances supporting parameters.



Contains the metadata for a parameter of a method annotated with A JCACHE annotation.

Provides the ability to redefine the value of a parameter on an {@link InjectableMethod} via the {@link #redefineParameterValue(ParameterValue)} callback.

Internal class that encapsulates collection of parameters used to tweak functional map operations. <p>Internally, parameters are stored in an array which is indexed by a parameter's {@link Param#id()} <p>All parameters have default values which are stored in a static array field in {@link Params} class, which are used to as base collection when adding or overriding parameters.



This class implements the parser for Infinispan/AS7/EAP/JDG schema files
This class implements the parser for 6.0 schema files
This class just acts as a bridge to the unified {@link Parser} for external cache stores. All uses of it should be removed in favour of that.
Base class for the generated parser. This class is stateful, so it should not be reused for parsing multiple statements.
ParserContext. By using the methods declared in this interface, parsers can register listeners which will be invoked when the parsing completes successfully. This is useful when configuration can be completed only when the whole file has been parsed (e.g. because of the use of named references)
ParserContextListener. An interface which should be implemented by listeners who wish to be notified when a file has been successfully parsed. See {@link ParserContext}
ParserRegistry is a namespace-mapping-aware meta-parser which provides a way to delegate the parsing of multi-namespace XML files to appropriate parsers, defined by the {@link ConfigurationParser} interface. A registry of available parsers is built using the {@link ServiceLoader} system. Implementations of {@link ConfigurationParser} should include a META-INF/services/org.infinispan.configuration.parsing.ConfigurationParser file containing a list of available parsers.
ParserScope indicates the configuration parser scope.

Thrown in case of syntax errors during parsing or during the processing of the parse tree.
Cluster stream manager that also pays attention to partition status and properly closes iterators and throws exceptions when the availability mode changes.

Controls how the cache handles partitioning and/or multiple node failures.
Controls how the cache handles partitioning and/or multiple node failures.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/partition-handling=PARTITION_HANDLING




This annotation should be used on methods that need to be notified when the {@link org.infinispan.partitionhandling.AvailabilityMode} in use by the {@link org.infinispan.partitionhandling.impl.PartitionHandlingManager} changes due to a change in cluster topology. This is only fired in a {@link CacheMode#DIST_SYNC}, {@link CacheMode#DIST_ASYNC}, {@link CacheMode#REPL_SYNC} or {@link CacheMode#REPL_ASYNC} configured cache. <p/> Methods annotated with this annotation should accept a single parameter, a {@link org.infinispan.notifications.cachelistener.event.PartitionStatusChangedEvent} otherwise a {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your listener. <p/> Note that methods marked with this annotation will be fired <i>before</i> and <i>after</i> the updated {@link org.infinispan.partitionhandling.AvailabilityMode} is updated, i.e., your method will be called twice, with {@link org.infinispan.notifications.cachelistener.event.Event#isPre()} being set to <tt>true</tt> as well as <tt>false</tt>. <p/> ensure this annotation is available at runtime. ensure that this annotation is applied to classes.
The event passed in to methods annotated with {@link org.infinispan.notifications.cachelistener.annotation.PartitionStatusChanged}.
{@link ConsistentHash} wrapper that uses a {@link KeyPartitioner} instead of a {@link Hash}.
A passivation manager


Handles store write operations when passivation enabled that don't entail reading the entry first
Receive responses from multiple nodes, without checking that the responses are valid.
RPC to a single node, without any validity checks.
A credential object to store the username and password in the Subject after the JAAS authentication.
PathAddressUtils.
Represents the path of a field, including the aggregation function if any.


Performs peek operation on a {@link DoubleStream}
Performs peek operation on a {@link IntStream}
Performs peek operation on a {@link LongStream}
Performs peek operation on a regular {@link Stream}

A listener that is invoked when {@link PendingLockPromise} is ready.
A manager that checks and waits for older topology transaction with conflicting keys.
A promise returned by {@link PendingLockManager}. <p> When a transaction need to wait for older topology transaction, this class allows it to check the state. If the transaction does not need to wait, or all older transactions have finished or have timed out, the {@link #isReady()} method returns {@code true}. Also, it allows the caller to add listeners to be notified when it is ready.
An {@link Action} implementation that check for older topology transactions. <p/> This action is ready when no older topology transactions exists or is canceled when the timeout occurs.
Utility class that can be used for writing tests that need to access a cache instance from multiple threads.
Interface to invoke when a {@link org.infinispan.commands.remote.CacheRpcCommand} is received from other node in the local site.
A lock container that creates and maintains a new lock per entry.
Allocates one index shard per Infinispan segment, with the shard identifier equals to the segment.
Creates an MBeanServer on each thread.
Percentile statistic for the transaction execution time.
Configuration for stores.
Configuration for cache stores.

An exception thrown by a {@link CacheLoader} or a {@link CacheWriter} implementation if there are problems reading from a loader.
Defines the logic for interacting with the chain of external storage.
A closeable supplier that provides a way to supply cache entries from a given persistence manager.  On the first call to get this class will submit a task to collect all of the entries from the loader (or optionally a subset provided a given {@link org.infinispan.filter.KeyFilter}).  A timeout value is required so that if a get blocks for the given timeout it will throw a {@link TimeoutException}.


Util class that mocks {@link org.infinispan.AdvancedCache} and {@link org.infinispan.persistence.spi.InitializationContext} for {@link org.infinispan.persistence.spi.CacheWriter} and {@link org.infinispan.persistence.spi.CacheLoader}

PersistentUUID. A special {@link Address} UUID whose purpose is to remain unchanged across node restarts when using global state.
PersistentUUIDManager maintains a mapping of {@link PersistentUUID}s present in the cluster
Implementation of the {@link PersistentUUIDManager} interface

A filter factory producing a filter for Person. Filters by age. The main purpose of this filter is to work together with other filters and test applying more than one filter.
Filter for using in full text search. Filters persons by the blurb.
Used for testing jdbc cache stores.

Handles x-site data backups for pessimistic transactional caches.
Locking interceptor to be used by pessimistic caches. Design note: when a lock "k" needs to be acquired (e.g. cache.put("k", "v")), if the lock owner is the local node, no remote call is performed to migrate locking logic to the other (numOwners - 1) lock owners. This is a good optimisation for  in-vm transactions: if the local node crashes before prepare then the replicated lock information would be useless as the tx is rolled back. OTOH for remote hotrod/transactions this additional RPC makes sense because there's no such thing as transaction originator node, so this might become a configuration option when HotRod tx are in place. Implementation note: current implementation acquires locks remotely first and then locally. This is required by the deadlock detection logic, but might not be optimal: acquiring locks locally first might help to fail fast the in the case of keys being locked.



Infinispan distributed executors demo using pi approximation.

Corresponds to the "ping" operation as defined in <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
PingStatement.
Default implementation for {@link MBeanServerLookup}, will return the platform MBean server. <p/> Note: to enable platform MBeanServer the following system property should be passed to the Sun JVM: <b>-Dcom.sun.management.jmxremote</b>.
A test pojo with references to variables that are marshalled in different ways, including: primitives, objects that are marshalled with internal externalizers, objects that are {@link java.io.Externalizable} and objects that are {@link java.io.Serializable}
A test pojo that is marshalled using JBoss Marshalling's {@link org.jboss.marshalling.Externalizer} which is annotated with {@link Externalize}
A test pojo that is marshalled using Infinispan's {@link org.infinispan.commons.marshall.Externalizer} which is annotated with {@link SerializeWith}
A JUnit XML report generator for Polarion based on the JUnitXMLReporter
Pooled connection factory that uses HikariCP by default. In order to utilise the legacy connection pool, C3P0, users must pass the system property <tt>infinispan.jdbc.c3p0.force</tt> with the value true. HikariCP property files can be specified by explicitly stating its path or name (if the file is on the classpath) via PooledConnectionFactoryConfiguration.propertyFile field.  Or by ensuring that a <tt>hikari.properties</tt> file is on the classpath. Note, that the file specified by <tt>propertyField</tt> takes precedence over <tt>hikari.properties</tt>. For a complete configuration reference for C3P0 look <a href="http://www.mchange.com/projects/c3p0/index.html#configuration">here</a>. The connection pool can be configured n various ways, as described <a href="http://www.mchange.com/projects/c3p0/index.html#configuration_files">here</a>. The simplest way is by having an <tt>c3p0.properties</tt> file in the classpath. If no properties files are found for either HikariCP or C3PO then the default values of these connection pools are utilised.

PooledConnectionFactoryConfigurationBuilder.
A Filter that only allows post events to be accepted.
Method level annotation that indicates a (no-param) method to be called on a component after the {@link org.infinispan.factories.ComponentRegistry} has been fully initialized <p/>

This interceptor adds pre and post processing to each <tt>visitXXX()</tt> method. <p/> For each <tt>visitXXX()</tt> method invoked, it will first call {@link #doBeforeCall(InvocationContext, VisitableCommand)} and if this method returns true, it will proceed to invoking a <tt>handleXXX()</tt> method and lastly, {@link #doAfterCall(InvocationContext, VisitableCommand)} in a <tt>finally</tt> block.  Note that the <tt>doAfterCall()</tt> method is still invoked even if <tt>doBeforeCall()</tt> returns <tt>false</tt>. <p/> Instead of overriding <tt>visitXXX()</tt> methods, implementations should override their <tt>handleXXX()</tt> counterparts defined in this class instead, as well as the {@link #doAfterCall(InvocationContext ,VisitableCommand)} method and optionally {@link #doBeforeCall(InvocationContext, VisitableCommand)}. <p/>

A predicate attached to an attribute. It comes in two flavors: condition predicate or interval predicate. An interval predicate represents a range of values (possibly infinite at one end but not both). It requires that the attribute domain is Comparable, otherwise the notion of interval is meaningless. A condition predicate on the other hand can have any arbitrary condition and does not require the attribute value to be Comparable.
Keeps track of all predicates and all projections from all filters of an entity type and determines efficiently which predicates match a given entity instance. There is a single instance at most of this for class per each entity type. The predicates are stored in an index-like structure to allow fast matching and are reference counted in order to allow sharing of predicates between filters rather than duplicating them.
A PredicateNode is a leaf node in a BETree that holds a Predicate instance. A PredicateNode instance is never reused inside the same BETree or shared between multiple BETrees, but an entire BETree could be shared by multiple filters. Multiple PredicateNodes could share the same Predicate instance.

Holds all predicates that are subscribed for a certain attribute. This class is not thread safe and leaves this responsibility to the caller.




PrefixAdd.
PrefixResource.

Command corresponding to the 1st phase of 2PC.
A decode context to handle prepare request from a client.
Default implementation for RecoveryIterator.


A {@link Collector} implementation that only waits for the primary owner.

Entry Size calculator that returns an approximation of how much various primitives, primitive wrappers, Strings, and arrays

Extracts Principal Name from Session. This needs to be done separately since Spring Session is not aware of any authentication mechanism (it is application developer's responsibility to implement it).
PrincipalRoleMapper.
PrincipalRoleMapperContext.
PrincipalRoleMapperContextImpl.
An internal configuration. <p> This is an internal configuration to be used by Infinispan modules when some advanced or ergonomic configuration is needed.
A {@link Builder} implementation of {@link PrivateGlobalConfiguration}.
A {@link ConfigurationSerializer} implementation for {@link PrivateGlobalConfiguration}. <p> The {@link PrivateGlobalConfiguration} is only to be used internally so this implementation is a no-op.

JUnit category for profiling tests.
An advanced SPI to be implemented by Infinispan modules that want to customize the {@link SearchMapping} object before the bootstrap of the {@link org.hibernate.search.SearchFactory} belonging to an indexed {@link Cache}. The {@link SearchMapping} object provided via the "hibernate.search.model_mapping" config property is used as a starting point if it was present, otherwise an empty {@link SearchMapping} is used. <p> Please note that in case multiple providers are found the order of invocation is not predictable so implementations must be careful not to step on each others toes.


Converts between Infinispan and HSearch projection fields.

The projections of an attribute across multiple filters.

Extracts the configuration into flat key-value property structure by reflection.
A property path (e.g. {@code foo.bar.baz}) represented by a {@link List} of {@link PropertyReference}s, used in a SELECT, GROUP BY, ORDER BY, WHERE or HAVING clause.
A {@link CommonTree} representing one property path.
Resource description for the addressable resources: /subsystem=jgroups/stack=X/transport=TRANSPORT/property=Z /subsystem=jgroups/stack=X/protocol=Y/property=Z
A property reference expression.

A marshaller that uses Protocol Buffers.


Tests if a field is indexed by examining the Protobuf metadata.


A clustered repository of protobuf definition files. All protobuf types and their marshallers must be registered with this repository before being used.
Constants used by the Protobuf metadata cache.
Exercise all DMR ops exposed for ProtobufMetadataManager.

Intercepts updates to the protobuf schema file caches and updates the SerializationContext accordingly.
MBean interface for ProtobufMetadataManager, suitable for building invocation proxies with one of the {@link javax.management.JMX#newMBeanProxy} methods.

This is used to wrap binary values encoded with Protocol Buffers. {@link ProtobufValueWrapperFieldBridge} is used as a class bridge to allow indexing of the binary payload.


Defines the configuration of a JGroups protocol.


Service that provides protocol property defaults per protocol type.

A generic handler for protocol metrics based on reflection.
Resource description for /subsystem=jgroups/stack=X/protocol=Y

Represents a protocol compliant server.
ServerConfiguration.

ProtocolServerConfigurationChildBuilder.


The service that configures and starts the endpoints supported by data grid.

Defines the configuration of a JGroups protocol stack.

Factory for creating service names for stack-based services
Enumeration of supported Hot Rod client protocol versions.

Wraps byte[] in a {@link ProtobufValueWrapper} in order to make the payload indexable by Hibernate Search.



Proxies is a collection of useful dynamic profixes. Internal use only.


Implements "putAll" as defined by  <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.

The {@link CacheCommand#PUT} handler.
Encapsulates logic to allow a {@link InvalidationCacheAccessDelegate} to determine whether a {@link InvalidationCacheAccessDelegate#putFromLoad(org.hibernate.engine.spi.SessionImplementor, Object, Object, long, Object, boolean)} call should be allowed to update the cache. A <code>putFromLoad</code> has the potential to store stale data, since the data may have been removed from the database and the cache between the time when the data was read from the database and the actual call to <code>putFromLoad</code>. <p> The expected usage of this class by a thread that read the cache and did not find data is: <p/> <ol> <li> Call {@link #registerPendingPut(SessionImplementor, Object, long)}</li> <li> Read the database</li> <li> Call {@link #acquirePutFromLoadLock(SessionImplementor, Object, long)} <li> if above returns <code>null</code>, the thread should not cache the data; only if above returns instance of <code>AcquiredLock</code>, put data in the cache and...</li> <li> then call {@link #releasePutFromLoadLock(Object, Lock)}</li> </ol> </p> <p/> <p> The expected usage by a thread that is taking an action such that any pending <code>putFromLoad</code> may have stale data and should not cache it is to either call <p/> <ul> <li> {@link #beginInvalidatingKey(Object, Object)} (for a single key invalidation)</li> <li>or {@link #beginInvalidatingRegion()} followed by {@link #endInvalidatingRegion()} (for a general invalidation all pending puts)</li> </ul> After transaction commit (when the DB is updated) {@link #endInvalidatingKey(Object, Object)} should be called in order to allow further attempts to cache entry. </p> <p/> <p> This class also supports the concept of "naked puts", which are calls to {@link #acquirePutFromLoadLock(SessionImplementor, Object, long)} without a preceding {@link #registerPendingPut(SessionImplementor, Object, long)}. Besides not acquiring lock in {@link #registerPendingPut(SessionImplementor, Object, long)} this can happen when collection elements are loaded after the collection has not been found in the cache, where the elements don't have their own table but can be listed as 'select ... from Element where collection_id = ...'. Naked puts are handled according to txTimestamp obtained by calling {@link RegionFactory#nextTimestamp()} before the transaction is started. The timestamp is compared with timestamp of last invalidation end time and the write to the cache is denied if it is lower or equal. </p>
Serializable function used by {@link org.infinispan.multimap.impl.EmbeddedMultimapCache#put(Object, Object)} to add a key/value pair.
Cache "get" operation handler.
Implements "putIfAbsent" operation as described in  <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
Implements functionality defined by {@link org.infinispan.Cache#put(Object, Object)}


Implements "put" as defined by  <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
PutStatement puts an entry in the cache
Streaming put operation
{@link org.junit.experimental.categories.Category} tag for tests running with the arquillian "queries" group.
An immutable object representing both the query and the result. The result is obtained lazily when one of the methods in this interface is executed first time. The query is executed only once. Further calls will just return the previously cached results. If you intend to re-execute the query to obtain fresh data you need to build another instance using a {@link QueryBuilder}. todo [anistor] also add long getStartOffset() ?
Each node in the cluster has a QueryBox instance. The QueryBox keep the active lazy iterators (actually it keeps the DocumentExtractor of the searches) on the cluster, so it can return values for the queries in a "lazy" way. When a DistributedLazyIterator is created, every nodes creates a DocumentExtractor and register it in your own QueryBox. So, the LazyIterator can fetch the values in a lazy way. EVICTION: Currently the QueryBox keeps the last BOX_LIMIT DocumentExtractor used... probably there is a better way.
A builder for {@link Query} objects. An instance of this class can be obtained from {@link QueryFactory}.
A local cache for 'parsed' queries. Each cache manager has at most one QueryCache which is backed by a lazily created Cache.
Producer for a CacheManager able to use distributed Query

QueryExtractorUtil. Utility to extract the cache key of a DocumentExtractor.
Query facade
A query facade implementation for both Lucene based queries and non-indexed in-memory queries. All work is delegated to {@link RemoteQueryEngine}.
Factory for query DSL objects. Query construction starts here, usually by invoking the {@link #from} method which returns a {@link QueryBuilder} capable of constructing {@link Query} objects. The other methods are use for creating sub-conditions.
This interceptor will be created when the System Property "infinispan.query.indexLocalOnly" is "false" <p/> This type of interceptor will allow the indexing of data even when it comes from other caches within a cluster. <p/> However, if the a cache would not be putting the data locally, the interceptor will not index it.
TODO [anistor] This class must be removed in 10.0 after we remove autodetection. Stores all entity classes known to query module in a replicated cache. The entry value is a boolean which indicates if the type is indexable. The key is a KeyValuePair composed of the cache name and the class. This cache is 'append only'. <p> Write operations are expected to happen only exceptionally, therefore this code is heavily optimized for reads (at cost of writes). Also we're assuming all entries are small: there is no size limit nor cleanup strategy. <p> This is not caching the fact that some key is not defined: that would be tricky to get right and is not needed for our use case.



A parser for Ickle queries. Parsing comprises these steps: <ul> <li>lexing the query</li> <li>parsing the query, building up an AST while doing so</li> <li>transforming the resulting parse tree using a QueryResolverDelegate and QueryRendererDelegate</li> </ul>
Defines hooks for implementing custom logic when walking the parse tree of a JPQL query.
Transform the parsed tree into a {@link IckleParsingResult} containing the {@link org.infinispan.objectfilter.impl.syntax.BooleanExpr}s representing the WHERE and HAVING clauses of the query.

Defines hooks for implementing custom logic when walking the parse tree of a JPQL query.

QueryResponse. A response of a request to create a new distributed lazy iterator

Region for caching query results.
Generates an Ickle query to satisfy the condition created with the builder.

Invocation stage representing a computation that may or may not be done yet. <p>It stores handler objects in a queue instead of creating a new instance every time a handler is added. The queue may be frozen based on internal conditions, like executing the last handler or reaching the capacity of the queue, and adding a handler will create a new instance. The queue will also be frozen when {@link #toCompletableFuture()} is invoked, to make that future behave like a regular {@link CompletableFuture}. </p> <p>When the queue is not frozen, adding a handler will change the result of the current stage. When the queue is frozen, adding a handler may actually execute the handler synchronously.</p>
This handler is to be used when all the events must be queued until the iteration process is complete. This is required for any local listener or non distributed caches.  The local is required since we could have other events that are interrelated such as tx start/stop that all must be queued together in the order they were provided.
This interface describes methods needed for a segment listener that is used when iterating over the current events and be able to queue them properly


Test asynchronous REST operations through a custom REST client. The servers are running in domain mode.
Test asynchronous REST operations through a custom REST client. The servers are running in standalone mode.
Tests BASIC security for REST endpoint as is configured via "auth-method" attribute on "rest-connector" element in datagrid subsystem.
Tests CLIENT-CERT security for REST endpoint as is configured via "auth-method" attribute on "rest-connector" element in datagrid subsystem. <p/> In order to configure CLIENT-CERT security, we add a new security-domain in the security subsystem and a new https connector in the web subsystem. This is done via XSL transformations. <p/> Client authenticates himself with client.keystore file. Server contains ca.jks file in security subsystem as a truststore and keystore_server.jks file in the REST connector as a certificate file. How to create and inspect those files is described e.g. at http://docs.oracle.com/javase/6/docs/technotes/guides/security/jsse/JSSERefGuide.html <p/> Password for all the files is the same: "secret" The user is allowed to connect to the secured REST endpoint with "client1" alias cos the server has this alias registered in its truststore. There's also another alias "test2" which is not signed by the CA, and therefore won't be accepted. <p/> The REST endpoint requires users to be in "REST" role which is defined in roles.properties.
Test a custom REST client connected to a single Infinispan server. The server is running in domain mode.
Test a custom REST client connected to a single Infinispan server. The server is running in standalone mode.

{@link Category} tag for clustered REST tests in standalone mode.
{@link Category} tag for clustered REST tests in domain mode.
Tests for the REST client.
Tests for the RESTLocal client.
Tests DIGEST security for REST endpoint as is configured via "auth-method" attribute on "rest-connector" element in datagrid subsystem.
Utility class.

{@link Category} tag for local RESTLocal tests.
{@link Category} tag for local RESTLocal tests in domain mode.
The reference implementation of the {@link CacheEntryEvent}.
The reference implementation of {@link CacheStatisticsMXBean}.
Class to help implementers
A convenience class for registering CacheStatisticsMBeans with an MBeanServer.
A context for ranges. Allow specifying if the bounds are included or not. They are included by default. This context is considered completed.

Read-only set representing all the integers from {@code 0} to {@code size - 1} (inclusive).
A wrapper around a cached entry that encapsulates read committed semantics when writes are initiated, committed or rolled back.
Read function that returns the current counter's delta. <p> Singleton class. Use {@link ReadFunction#getInstance()} to retrieve it.
A specialization of {@link ReadWriteAccess} that ensures we never update data.
Assumes that the delegate collection already contains unique elements.
A Set view of keys in a data container, which is read-only and has efficient contains(), unlike some data container ley sets.


Read-only map implementation.
Set implementation that shows a read only view of the provided set by only allowing entries that map to a given segment using the provided consistent hash. <p> This set is useful when you don't want to copy an entire set but only need to see values from the given segments. <p> Note many operations are not constant time when using this set.  Please check the method you are using to see if it will perform differently than normally expected.
Iterator implementation that shows a read only view of the provided iterator by only allowing values that map to a given segment using the provided consistent hash. <p> This iterator is used with specifically with the {@link ReadOnlySegmentAwareEntryCollection} to properly filter the entry by the key instead of the entry instance itself.
Iterator implementation that shows a read only view of the provided iterator by only allowing values that map to a given segment using the provided consistent hash. <p> This iterator is specifically used with the {@link ReadOnlySegmentAwareEntryCollection} so that it will properly filter out entries by their key instead of by the entry instance
Iterator implementation that shows a read only view of the provided iterator by only allowing values that map to a given segment using the provided consistent hash. <p> This iterator is used with the other various SegmentAware Collections such as {@link ReadOnlySegmentAwareCollection}
Map implementation that shows a read only view of the provided entry by only allowing entries whose key maps to a given segment using the provided consistent hash. <p> Any operation that would modify this map will throw an {@link UnsupportedOperationException} <p> This map is useful when you don't want to copy an entire map but only need to see entries from the given segments. <p> Note many operations are not constant time when using this map.  The {@link ReadOnlySegmentAwareMap#values} method is not supported as well. Please check\ the method you are using to see if it will perform differently than normally expected.
Read-write or transactional entity region access for Infinispan.
TODO: the command does not carry previous values to backup, so it can cause the values on primary and backup owners to diverge in case of topology change

TODO: the command does not carry previous values to backup, so it can cause the values on primary and backup owners to diverge in case of topology change
TODO: the command does not carry previous values to backup, so it can cause the values on primary and backup owners to diverge in case of topology change


Read-write map implementation.

An interface that allows the {@link org.infinispan.remoting.inboundhandler.PerCacheInboundInvocationHandler} to check when this action is ready.
RealmAuthorizationCallbackHandler. A {@link CallbackHandler} for JGroups which piggybacks on the realm-provided {@link AuthorizingCallbackHandler}s and provides additional role validation
RealmSubjectUserInfo.
Created with

RebalancingStatus.
A thread gate, that uses an {@link java.util.concurrent.locks.AbstractQueuedSynchronizer}. <p/> This implementation allows you to create a latch with a default state (open or closed), and repeatedly open or close the latch.
Interface that adds recovery required information to a {@link org.infinispan.transaction.xa.GlobalTransaction}.
Admin utility class for allowing management of in-doubt transactions (e.g. transactions for which the originator node crashed after prepare).
DldGlobalTransaction that also holds xid information, required for recovery. The purpose of this class is to avoid the serialization of Xid objects over the wire in the case recovery is not enabled.
GlobalTransaction that also holds xid information, required for recovery.
Extends {@link org.infinispan.transaction.xa.LocalXaTransaction} and adds recovery related information.
Extends {@link org.infinispan.transaction.impl.RemoteTransaction} and adds recovery related information and functionality.
Base interface for transactions that are holders of recovery information.
Transaction table that delegates prepared transaction's management to the {@link RecoveryManager}.
Base class for recovery-related rpc-commands.
Defines recovery configuration for the cache.
Defines recovery configuration for the cache.

This makes sure that only xids pertaining to a certain cache are being returned when needed. This is required as the {@link RecoveryManagerImpl#preparedTransactions} is shared between different RecoveryManagers/caches.
RecoveryManager is the component responsible with managing recovery related information and the functionality associated with it. Refer to <a href="http://community.jboss.org/wiki/Transactionrecoverydesign">this</a> document for details on the design of recovery.
Factory for RecoveryManager.
Default implementation for {@link RecoveryManager}





Basic reflection utilities to enhance what the JDK provides.
Utility class for working with JDK Reflection and also CDI's {@link Annotated} metadata.
Handler to register the proto file(s) contents via DMR/CLI

Implemented by a resource artifact that can register itself.



A filter that rejects all inputs. Does not support sorting and projections.
Configuration of the RELAY2 protocol.

Resource definition for /subsystem=jgroups/stack=X/relay=RELAY
Reliability mode available for {@link org.infinispan.counter.api.CounterManager}.

Qualifier used to specify which remote cache will be injected.
A bridge between Infinispan Remote events and Spring.
Provides remote reference to a Hot Rod server/cluster. It implements {@link org.infinispan.Cache}, but given its nature (remote) some operations are not supported. All these unsupported operations are being overridden within this interface and documented as such. <p/> <b>New operations</b>: besides the operations inherited from {@link org.infinispan.Cache}, RemoteCache also adds new operations to optimize/reduce network traffic: e.g. versioned put operation. <p/> <b>Concurrency</b>: implementors of this interface will support multi-threaded access, similar to the way {@link org.infinispan.Cache} supports it. <p/> <b>Return values</b>: previously existing values for certain {@link java.util.Map} operations are not returned, null is returned instead. E.g. {@link java.util.Map#put(Object, Object)} returns the previous value associated to the supplied key. In case of RemoteCache, this returns null. <p/> <b>Synthetic operations</b>: aggregate operations are being implemented based on other Hot Rod operations. E.g. all the {@link java.util.Map#putAll(java.util.Map)} is implemented through multiple individual puts. This means that the these operations are not atomic and that they are costly, e.g. as the number of network round-trips is not one, but the size of the added map. All these synthetic operations are documented as such. <p/> <b>changing default behavior through {@link org.infinispan.client.hotrod.Flag}s</b>: it is possible to change the default cache behaviour by using flags on an per invocation basis. E.g. <pre> RemoteCache cache = getRemoteCache(); Object oldValue = cache.withFlags(Flag.FORCE_RETURN_VALUE).put(aKey, aValue); </pre> In the previous example, using {@link org.infinispan.client.hotrod.Flag#FORCE_RETURN_VALUE} will make the client to also return previously existing value associated with <tt>aKey</tt>. If this flag would not be present, Infinispan would return (by default) <tt>null</tt>. This is in order to avoid fetching a possibly large object from the remote server, which might not be needed. The flags as set by the {@link org.infinispan.client.hotrod.RemoteCache#withFlags(Flag...)} operation only apply for the very next operation executed <b>by the same thread</b> on the RemoteCache. <p/> <b><a href="http://community.jboss.org/wiki/Eviction">Eviction and expiration</a></b>: Unlike local {@link org.infinispan.Cache} cache, which allows specifying time values with any granularity (as defined by {@link TimeUnit}), HotRod only supports seconds as time units. If a different time unit is used instead, HotRod will transparently convert it to seconds, using {@link java.util.concurrent.TimeUnit#toSeconds(long)} method. This might result in loss of precision for values specified as nanos or milliseconds. <br/> Another fundamental difference is in the case of lifespan (naturally does NOT apply for max idle): If number of seconds is bigger than 30 days, this number of seconds is treated as UNIX time and so, represents the number of seconds since 1/1/1970. <br/> <b>Note on default expiration values:</b> Due to limitations on the first version of the protocol, it's not possible for clients to rely on default lifespan and maxIdle values set on the server. This is because the protocol does not support a way to tell the server that no expiration lifespan and/or maxIdle were provided and that default values should be used. This will be resolved in a future revision of the protocol. In the mean time, the workaround is to explicitly provide the desired expiry lifespan/maxIdle values in each remote cache operation.


Factory for {@link org.infinispan.client.hotrod.RemoteCache}s. <p/> <p> <b>Lifecycle:</b> </p> In order to be able to use an {@link org.infinispan.client.hotrod.RemoteCache}, the {@link org.infinispan.client.hotrod.RemoteCacheManager} must be started first: beside other things, this instantiates connections to Hot Rod server(s). Starting the {@link org.infinispan.client.hotrod.RemoteCacheManager} can be done either at creation by passing start==true to constructor or by using a constructor that does that for you (see C-tor documentation); or after construction by calling {@link #start()}. <p/> This is an "expensive" object, as it manages a set of persistent TCP connections to the Hot Rod servers. It is recommended to only have one instance of this per JVM, and to cache it between calls to the server (i.e. remoteCache operations). <p/> {@link #stop()} needs to be called explicitly in order to release all the resources (e.g. threads, TCP connections). <p/>
Remote Administration operations

A task that executes operations against a given remote cache manager.
Keeps collection of {@link RemoteCacheManager} objects, to be able to stop all of them when needed.
Thrown when trying to use an {@link org.infinispan.client.hotrod.RemoteCache} that is associated to an {@link org.infinispan.client.hotrod.RemoteCacheManager} that was not started.
Simple test for RemoteCache running in OSGi (Karaf). Both basic put/get operations and remote queries are tested.
The {@link RemoteCache} producer.
Tests remote cache store under the following circumstances: <p/> passivation == true --cache entries should get to the remote cache store only when evicted preload == false --after server restart, entries should be be preloaded to the cache purge == false --all entries should remain in the cache store after server restart (must be false so that we can test preload) <p/> Other attributes like singleton, shared, fetch-state do not make sense in single node cluster.

Purpose: keep all delegating and unsupported methods in one place -> readability.

Wrapper which emulates replace and remove with oldValue.


Base class for building wrappers over remote cache instances.

A listener that installed locally on each node when a cluster listener is installed on a given node.
Specifically used to create un-initialized {@link org.infinispan.commands.ReplicableCommand}s from a byte stream. This is a {@link Scopes#GLOBAL} component and doesn't have knowledge of initializing a command by injecting cache-specific components into it. <p /> Usually a second step to unmarshalling a command from a byte stream (after creating an un-initialized version using this factory) is to pass the command though {@link CommandsFactory#initializeReplicableCommand(ReplicableCommand,boolean)}.

Basic tests for continuous query over HotRod.
Represents an application-level exception originating in a remote node.
Container for the statistics corresponding to remote originated transactions. It only knows how to merge from others {@link RemoteExtendedStatisticsContainer}
This exception is thrown when the remote cache or cache manager does not have the right lifecycle state for operations to be called on it. Situations like this include when the cache is stopping or is stopped, when the cache manager is stopped...etc.
The IndexingBackend which forwards all operations to a different node using Infinispan's custom commands.
A tuple-style object holder containing references to Remote interfaces for JMX statistics access.
Basic test for query DSL based remote event filters.
Simple interface to extract all the keys that may need to be locked. <p> A {@link org.infinispan.commands.remote.CacheRpcCommand} that needs to acquire locks should implement this interface. This way, Infinispan tries to provide a better management to optimize the system resources usage.
The JBoss Logging interface which defined the logging methods for the CDI integration. The id range for the CDI integration is 17001-18000
This is a metadata type used by scattered cache during state transfer. The address points to node which has last known version of given entry: During key transfer RemoteMetadata is created and overwritten if another response with higher version comes. During value transfer the address is already final and we request the value + metadata only from this node.
When a remote node is suspected and evicted from the cluster while an operation is ongoing, the Hot Rod client emits this exception.
Tests for remote queries over HotRod on a local non-indexed cache.

Base class for tests for remote queries over HotRod.

Tests for remote query using jboss marshalling and Hibernate Search annotated classes. Protobuf is not used!
Tests for remote queries over HotRod but registering the proto file via DMR plugin.
Tests for Remote Query descriptors propagation across nodes.


Tests for remote queries over HotRod on a local cache using RAM directory.
Tests for remote queries over HotRod on a replicated cache using Infinispan directory.
Tests for keySet() method on a distributed remote cache that uses protobuf marshalling.

Basic remote query test with off-heap data container
Tests for remote queries over HotRod with security on a DIST indexed/non-indexed cache.

Tests for remote queries over HotRod using Protobuf annotations.


Configuration of a channel to a remote site, used by the RELAY2 protocol.

Resource definition for subsystem=jgroups/stack=X/relay=RELAY/remote-site=Y
Cache store that delegates the call to a infinispan cluster. Communication between this cache store and the remote cluster is achieved through the java HotRod client: this assures fault tolerance and smart dispatching of calls to the nodes that have the highest chance of containing the given key. This cache store supports both preloading and <b>fetchPersistentState</b>. <p/> Purging elements is not possible, as HotRod does not support the fetching of all remote keys (this would be a very costly operation as well). Purging takes place at the remote end (infinispan cluster). <p/>

RemoteStoreConfigurationBuilder. Configures a {@link org.infinispan.persistence.remote.RemoteStore}

Remote cache store parser.
RemoteStoreConfigurationParser60.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/remote-store=REMOTE_STORE
RemoteStoreConfigurationSerializer.
A test class that simulates a client's transaction.
Represents the statistic collected for a remote transaction
Context to be used for transaction that originated remotely.
Listener that is notified when a remote value is looked up
A CloseableIterator implementation that allows for a CloseableIterator that doesn't allow remove operations to implement remove by delegating the call to the provided consumer to remove the previously read value.
Placeholder interface used to describe a function that can be used as is for removal.  This is useful for allowing an iterator to use removal. <p> The resulting value should be able to be used by a remove call from the cache.  Thus users shouldn't ever need to use this interface directly since it would require knowing how the underlying data is stored and transferred.
An Iterator implementation that allows for a Iterator that doesn't allow remove operations to implement remove by delegating the call to the provided consumer to remove the previously read value.


Custom command to remove an alias for a cache-container.
Command to stop a cache and remove all its contents from both memory and any backing store.
Remove client listener operation. In order to avoid issues with concurrent event consumption, removing client listener operation is sent in a separate connection to the one used for event consumption, but it must go to the same node where the listener has been added.

Removes an entry that is expired from memory
Serializable function used by {@link org.infinispan.multimap.impl.EmbeddedMultimapCache#remove(Object)} and {@link org.infinispan.multimap.impl.EmbeddedMultimapCache#remove(Object, Object)} to remove a key or a key/value pair from the Multimap Cache, if such exists. <p> {@link #apply(EntryView.ReadWriteEntryView)} will return {@link Boolean#TRUE} when the operation removed a key or a key/value pair and will return {@link Boolean#FALSE} if the key or key/value pair does not exist
Cache "remove" operation handler.
Implements "removeIfUnmodified" operation as defined by <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
RemoveListenerAction
Service that provides a {@link ScheduledThreadPoolExecutor} that removes tasks from the task queue upon cancellation.
Implement "remove" operation as described in <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
Implements the "rm [cache.]key" statetement which removes the specified key from a cache
Generic remove operation step handler that delegates service removal/recovery to a dedicated {@link ResourceServiceHandler}.
Describes the common properties of a remove operation handler.

RepeatableLongByteSequence is a testing utility to get a source of bytes. Use nextByte() to produce them. The generated sequence is similar to a random generated sequence, but will always generate the same sequence and avoid immediate repetitions of bytes and close repetitive patterns (they might occur in large scale). After having written such a stream from one instance, create a second instance to assert equality of contents (see test) as the source is not random and will generate the same sequence.
An extension of {@link ReadCommittedEntry} that provides Repeatable Read semantics
Tracks all keys seen during iteration. Depends on ISPN-5451 to be done more efficiently, by discarding segments as soon as they are completed iterating.
A listener that listens for replication events on a cache it is watching.  Typical usage: <code> ReplListener r = attachReplicationListener(cache); r.expect(RemoveCommand.class); // ... r.waitForRPC(); </code>


The {@link CacheCommand#REPLACE} handler.
Implement "replaceIfUnmodified" as defined by  <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
Implements "Replace" operation as defined by  <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
Replaces an existing entry in the cache
The core of the command-based cache framework.  Commands correspond to specific areas of functionality in the cache, and can be replicated using the {@link org.infinispan.remoting.rpc.RpcManager}
ReplicableCommandExternalizer.
Replicable Command that runs the given Function passing the {@link EmbeddedCacheManager} as an argument
Replicable Command that runs the given Runnable


Resource description for the addressable resource /subsystem=infinispan/cache-container=X/replicated-cache=*
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/replicated-cache=*
Special implementation of {@link org.infinispan.distribution.ch.ConsistentHash} for replicated caches. The hash-space has several segments owned by all members and the primary ownership of each segment is evenly spread between members.
Factory for ReplicatedConsistentHash.
ConsistentHashFactory implementation that allows the user to control who the owners are.
Interface responsible to send back the return value to the sender.
A remote command invocation request.

Identifies a requirement.
Keeps the sample for percentile calculations. <p/> Please check <a href="http://en.wikipedia.org/wiki/Reservoir_sampling for more details">this</a> for more details
ResetComponentJmxStatisticsAction. This class can be used to reset the statistics for a given interceptor that implements {@link org.infinispan.interceptors.base.JmxStatsCommandInterceptor} and it is a component in the cache's registry.
Reset function that sets the counter's delta to it's initial delta.
ResetInterceptorJmxStatisticsAction. This class can be used to reset the statistics for a given interceptor that implements {@link org.infinispan.interceptors.impl.JmxStatsCommandInterceptor} and is an interceptor in the cache's chain.
This class was entirely copied from JGroups 2.7 (same name there). Couldn't simply reuse it because JGroups does not ship with MBean, ManagedAttribute and ManagedOperation. <p/> The original JGroup's ResourceDMBean logic has been modified so that invoke() method checks whether the operation called has been exposed as a {@link ManagedOperation}, otherwise the call fails. JGroups deviated from this logic on purpose because they liked the fact that you could expose all class methods by simply annotating class with {@link MBean} annotation.
Describes the properties of resource used by {@link AddStepHandler}. Supports supplying attributes and capabilities via enumerations. Also supports defining extra parameters that are not actually attributes of the target resource.
Service builder that can be configured via a resource model.
Create a service builder that can be configured via a resource model.
Handles service installation and removal for use by {@link AddStepHandler} and {@link RemoveStepHandler}.
This class uses CDI to alias Java EE resources, such as the persistence context, to CDI beans <p/> <p> Example injection on a managed bean field: </p> <p/> <pre> &#064;Inject private EntityManager em; </pre>
A basic responses. The rest of this file contains other response types.

A representation of a request's responses. <p>Thread-safety: The request will invoke {@link #addResponse(Address, Response)} and {@link #finish()} while holding the collector's monitor, so implementations don't normally need explicit synchronization.</p>

A mechanism of filtering RPC responses.  Used with the RPC manager.
A component that generates responses as is expected by different cache setups
Creates a ResponseGenerator
Represents different handling mechanisms when dealing with remote command responses. These include waiting for responses from all nodes in the cluster ({@link ResponseMode#SYNCHRONOUS}}), not waiting for any responses at all ({@link ResponseMode#ASYNCHRONOUS}}), or waiting for first valid response ({@link ResponseMode#WAIT_FOR_VALID_RESPONSE}})
Static helper to provide common way of writing response to channel
Logging filter that can be used to output requests in a similar fashion to HTTPD log output

RestAuthenticationAdd.
RestAuthenticationResource.

Creates Netty Channels for this server. <p> With ALPN support, this class acts only as a bridge between Server Core and ALPN Handler which bootstraps pipeline handlers </p>

RestCodec.

An exception representing non-critical HTTP processing errors which will be translated into {@link InfinispanResponse} and sent back to the client. <p> {@link Http20RequestHandler} and {@link Http11RequestHandler} are responsible for catching subtypes of this exception and translate them into proper Netty responses. </p>
Tests for REST rolling upgrades.
Tests for REST rolling upgrades.


Configuration builder for REST.
{@link org.infinispan.server.router.MultiTenantRouter}'s configuration for REST.
REST Protocol Server.

RestServerConfigurationBuilder.
A small utility class which helps managing REST server.
A service which starts the REST web application

RestStore.
RestStoreConfiguration.
RestStoreConfigurationBuilder. Configures a {@link org.infinispan.persistence.rest.RestStore}
RestStoreConfigurationChildBuilder.
Rest store configuration parser
RestStoreConfigurationParser60.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/rest-store=REST_STORE
RestStoreConfigurationSerializer.
RestSubsystemAdd.
RestSubsystemRemove.

RestartCacheResourceAdd. Restarts a cache when a child resource is added
RestartCacheResourceRemove. Restarts the cache when a child resource has been removed.

RestartableResource.
RestartableResourceAddHandler.

Iterates over query results <p/>
ResultKeys.

Base class for all the operations that need retry logic: if the operation fails due to connection problems, try with another available connection.
Invokes a command in a remote site. This class allows to set a {@link org.infinispan.remoting.transport.RetryOnFailureXSiteCommand.RetryPolicy} to retry the command in case of an exception. The {@link org.infinispan.remoting.transport.RetryOnFailureXSiteCommand.RetryPolicy} has the exception to decide if it should retry or not.
A cache invoker implementation that retries after a specified set of intervals upon timeout or suspect. If the invocation includes Flag.FAIL_SILENTLY, this will only be applied to the last attempt.
Used in @{link org.infinispan.configuration.cache.CacheMode#SCATTERED_SYNC scattered cache} The commit is executed in {@link ScatteredDistributionInterceptor} before replicating the change from primary owner. When the {@link ScatteredDistributionInterceptor} throws a {@link ConcurrentChangeException} during single-key command processing, we know that the entry has not been committed and can safely remove the whole entry from context and retry. When the command processes multiple keys, some of the entries might be already committed. Therefore we have to keep the original value in a {@link org.infinispan.container.entries.RepeatableReadEntry} and for committed entries we only reset the value before retry (we assume that the outcome of an operation is deterministic). The non-committed entries are removed and re-wrapped as in the single-key case.
A set that allows reverse iteration of the set elements, exposed via the {@link #reverseIterator()} method.  This only really makes sense for ordered Set implementations, such as sets which are linked.
RiverCloseListener is used by Infinispan's extension of River Marshaller and Unmarshaller so that pools can be notified of instances not being in use anymore.
Key provider that relies on {@link java.util.Random}'s distribution to generate keys. It doesn't offer any guarantee that the keys are unique.

Tests RocksDB cache store.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/store=Z/expiration=COMPRESSION
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/store=Z/expiration=EXPIRATION



RocksDB XML Parser
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/store=STORE
RocksDBStoreConfigurationSerializer.
A role to permission mapping.
The {@link CacheCommand#DENY} handler.

The {@link CacheCommand#ROLES} handler.
RolesStatement lists the roles of a user

Command corresponding to a transaction rollback.
A decode context to handle rollback request from a client.
Rolls back a running transaction
This component handles the control hooks to handle migrating from one version of Infinispan to another.
{@link org.junit.experimental.categories.Category} tag for Rolling Upgrades tests.
{@link org.junit.experimental.categories.Category} tag for Rolling Upgrades distributed tests.

Round-robin implementation for {@link org.infinispan.client.hotrod.impl.transport.tcp.FailoverRequestBalancingStrategy}.



The Router interface. Currently the Router is coupled closely with the the {@link Protocol} it implements.



Log abstraction for the Hot Rod server module. For this module, message ids ranging from 14000 to 15000 inclusively have been reserved.




Builder for constructing a {@link RoutingTable}.
A container for routing information.
A matcher for projection rows. This matcher is not stateless so it cannot be reused.





Thrown when an RPC problem occurred on the caller.
Provides a mechanism for communicating with other caches in the cluster, by formatting and passing requests down to the registered {@link Transport}.
A factory for the RpcManager
This component really is just a wrapper around a {@link org.infinispan.remoting.transport.Transport} implementation, and is used to set up the transport and provide lifecycle and dependency hooks into external transport implementations.
Classes that wraps all the configuration parameters to configure a remote invocation.
It builds {@link RpcOptions} instances with the options to be used in remote invocations.
Runnable adapter for distributed executor service Any RunnableAdapter refactoring might break CDI
RuntimeCacheConfigurationApplier.
RuntimeWriteAttributeHandler.



Starts test HotRod server instance with pre-defined set of caches.

SaslAdd.
Test JGroups' SASL protocol with various mechs (namely with DIGEST-MD5 and GSSAPI).
SaslClientCallbackHandler.
SaslConfiguration.

SaslInputStream.
SaslOutputStream.
SaslPolicyAdd.
SaslPolicyResource.


SaslPolicyAdd.

SaslQop. Possible values for the SASL QOP property
Handles QOP of the SASL protocol.
SaslResource.
Resource definition for /subsystem=jgroups/stack=X/sasl=SASL
SaslStrength. Possible values for the SASL strength property.
AuthenticatedTransportObjectFactory.
Utility methods for handling SASL authentication
Similar to {@link DistCacheWriterInterceptor} but as commands are not forwarded from primary owner so we just write to the store all the time (with non-shared interceptors). Uses its own locking scheme to order writes into the store - if there is a newer write into DC, the older write is ignored. This could improve contented case, but has one strange property: Assume CS contains V1, T2 writes V2 and T3 writes V3; if T2 receives version and stores into DC before T3 but arrives here after T3 the V2 write into CS is ignored but the operation is confirmed as if it was persisted correctly. If T3 then (spuriously) fails to write into the store, V1 stays in CS but the error is reported only to T3 - that means that T3 effectivelly rolled back V2 into V1 (and reported this as an error). This may surprise some users. Reads can be blocked by ongoing writes, though; when T2 finishes and then the application attempts to read the value, and removal from T3 is not complete yet the read would not find the value in DC (because it was removed by T3) but could load V1 from cache store. Therefore, read must wait until the current write (that could have interacted with previous write) finishes. TODO: block writes until other write completes, and don't block reads However, blocking reads in cachestore is not something unusual; the DC lock is acquired when writing the cache store during eviction/passivation, or during write skew checks in other modes as well.
CH used by scattered caches. Allows no owners for segments (until the CH is balanced). We cannot have an owner for each segment assigned all the time, because after one node crashes, {@link org.infinispan.distribution.ch.ConsistentHashFactory#updateMembers} is called and the result is sent in CH_UPDATE. Such topology is installed and later during rebalance, a diff of segments between the installed and new (rebalancing) topology is computed. If we assigned all the owners right in updateMembers, this diff would be empty.
Based on {@link DefaultConsistentHashFactory}.
This interceptor mixes several functions: A) replicates changes to other nodes B) commits the entry C) schedules invalidation On primary owner, the commit is executed before the change is replicated to other node. If the command reads previous value and the version of entry in {@link org.infinispan.container.DataContainer} has changed during execution {@link ConcurrentChangeException} is thrown and the command has to be retried.




Manages versions of entries and states of segments.

Used to configure and create scheduled executors

Configures executor factory.




Scheduled thread pool resource definitions for Infinispan subsystem. See {@link org.infinispan.factories.KnownComponentNames} and {@link org.infinispan.commons.executors.BlockingThreadPoolExecutorFactory#create(int, int)} for the hardcoded Infinispan default values.
Schema.

An optional service which can be utilised to register custom protostuff schemas when executing in compatibility mode. N.B. This can also be used on the client, however it is not necessary as you can also register custom schemas in client code, as long as the registration takes place before any Objects are marshalled/unmarshalled.
Defines the scope of a component in a cache system.  If not specified, components default to the {@link Scopes#NAMED_CACHE} scope.
Retrieves the declared scope of a component
ScopedPersistentState represents state which needs to be persisted, scoped by name (e.g. the cache name). The default implementation of persistent state uses the standard {@link java.util.Properties} format with the additional rule that order is preserved. In order to verify state consistency (e.g. across a cluster) a checksum of the state's data can be computed. State properties prefixed with the '@' character will not be included as part of the checksum computation (e.g. @timestamp)
ScopedPersistentStateImpl.
The different scopes that can be declared for a component in the cache system.  If components are not bounded to a specific scope explicitly, then it defaults to the {@link #NAMED_CACHE} scope.


ScriptMetadata. Holds meta information about a script obtained either implicitly by the script name and extension, or explicitly by its header. See the "Script metadata" chapter in the User Guide for the syntax and format.

ScriptRunner.

Intercepts updates to the script caches, extracts metadata and updates the compiled scripts accordingly
ScriptingManager. Defines the operations that can be performed on scripts. Scripts are stored in a dedicated cache.
ScriptingManagerImpl.
ScriptingMetadataFileFinder.
ScriptingTaskEngine.
Utility class containing general methods for use.

Wrapper around SearchIntegrator with guards to allow concurrent access
The SearchManager is the entry point to create full text queries on top of a cache.
Class that is used to build {@link org.infinispan.query.CacheQuery}

In a JMS Master/Slave configuration, every node should be able to find entities created by some other nodes after the synchronization succeed. <p/> Search dependencies are not added to the archives.
Test that the JMS backend can be used at the same time with Infinispan. <p/> Search dependencies are not added to the archives.
Execute the tests in {@link SearchNewEntityJmsMasterSlaveAndInfinispan} using the modules in JBoss AS to add the required dependencies.
Test the the combination of JMS+Infinispan as backend and the use of Infinispan as second level cache.
Creates collections of Work instances that should be performed by Hibernate-Search.
Use context pattern, so it can be easily extended / changed.
Class that implements {@link org.hibernate.search.cfg.spi.SearchConfiguration} so that within Infinispan-Query, there is no need for a Hibernate Core configuration object.

A base decode context to handle rollback or commit request from a client.
SecureCache.
SecureCacheImpl.
Tests script execution over HotRod client on secured cache.
{@link org.junit.experimental.categories.Category} tag for security tests
SecurityActions for the org.infinispan.client.hotrod.event package. Do not move. Do not change class and method visibility to avoid being called from other {@link java.security.CodeSource}s, thus granting privilege escalation to external code.
Used to configure and create executors which are aware of the current security context

Since Spring Session is heavily based on security - we need to define basic user/password.
SecurityConfiguration.
SecurityConfigurationBuilder.

SecurityConfigurationHelper is a convenient class for various security tests which provides remote configuration builders for various means of authentication.
Pluggable security domain which could be used as a bridge between {@link Authenticator} and Wildfly Security Realms.
Terminal stream operation that is aware of segments being lost.  This interface describes a single callback method to be invoked on the operation when a segment is lost and it is concurrently running some operation.


<p>SegmentReadLocker implementations have to make sure that segments are not deleted while they are being used by an IndexReader.</p> <p>When an {@link org.infinispan.lucene.impl.InfinispanIndexInput} is opened on a file which is split in smaller chunks, {@link #acquireReadLock(String)} is invoked; then the {@link #deleteOrReleaseReadLock(String)} is invoked when the stream is closed.</p> <p>The same {@link #deleteOrReleaseReadLock(String)} is invoked when a file is deleted, so if this invocation is not balancing a lock acquire this implementation must delete all segment chunks and the associated metadata.</p> <p>Note that if you can use and tune the {@link org.apache.lucene.index.LogByteSizeMergePolicy} you could avoid the need for readlocks by setting a maximum segment size to equal the chunk size used by the InfinispanDirectory; readlocks will be skipped automatically when not needed, so it's advisable to still configure an appropriate SegmentReadLocker for the cases you might want to tune the chunk size.</p>
A terminal based operation that runs the provided function to evaluate the operation.  If a segment is lost during the evaluation of the function the function results will be ignored and subsequently retried with the new stable segments.  This is repeated until either a full stable run is completed of the function or if the lost segment states that there are no more segments left.
Convert the 1.4 SEGMENTS value to VIRTUAL_NODES in model and operations, if defined and not an expression Remove the 1.4 attributes INDEXING_PROPERTIES and SEGMENTS from model and operations
A ClassLoader that loads classes whose classname begins with one of a given set of strings, without attempting first to delegate to its parent loader. <p> This class is intended to allow emulation of 2 different types of common J2EE classloading situations. <ul> <li>Servlet-style child-first classloading, where this class is the child loader.</li> <li>Parent-first classloading where the parent does not have access to certain classes</li> </ul> </p> <p> This class can also be configured to raise a ClassNotFoundException if asked to load certain classes, thus allowing classes on the classpath to be hidden from a test environment. </p>
This interface simplifies the task of writing fluent builders which need to inherit from other builders (abstract or concrete). It overcomes Java's limitation of not being able to return an instance of a class narrowed to the class itself. It should be used by all {@link Builder} classes which require inheritance.
Executes tasks in the given executor, but never has more than {@code maxConcurrentTasks} tasks running at the same time.
This executor below serializes the submission of tasks to a second executor, illustrating a composite executor. From the Java Executor class documentation.
This is a functional interface that is the same as a {@link BiConsumer} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link BiFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link BinaryOperator} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link Callable} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link Comparator} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link Consumer} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link DoubleBinaryOperator} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link DoubleConsumer} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link DoubleFunction} except that it must also be {@link java.io.Serializable}
This is a functional interface that is the same as a {@link DoublePredicate} except that it must also be {@link java.io.Serializable}
This is a functional interface that is the same as a {@link DoubleToIntFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link DoubleToLongFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link DoubleUnaryOperator} except that it must also be {@link java.io.Serializable}
This is a functional interface that is the same as a {@link Function} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link IntBinaryOperator} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link IntConsumer} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link IntFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link IntPredicate} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link IntToDoubleFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link IntToLongFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link IntUnaryOperator} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link LongBinaryOperator} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link LongConsumer} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link LongFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link LongPredicate} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link LongToDoubleFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link LongToIntFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link LongUnaryOperator} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link ObjDoubleConsumer} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link ObjIntConsumer} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link ObjLongConsumer} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link Predicate} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link Runnable} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link Supplier} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link ToDoubleFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link ToIntFunction} except that it must also be {@link Serializable}
This is a functional interface that is the same as a {@link ToLongFunction} except that it must also be {@link Serializable}
This xid implementation is needed because {@link javax.transaction.xa.Xid} is not {@link java.io.Serializable} and we need to serialize it and send it over the network. As the KTA spec does not enforce in anyway the equals and hashcode methods on Xid TM providers are expected to be able to cope with this Xid class when returned from XAResource's methods.

Configures serialization and marshalling settings.

Indicate that this function should be serialized with an instance of the given {@link Externalizer} class. Any externalizer type referred by this annotation must be either {@link java.io.Serializable} or {@link java.io.Externalizable} because the marshalling infrastructure will ship an instance of the externalizer to any node that's no aware of this externalizer, hence allowing for dynamic externalizer discovery.

Indicate that this class should be serialized with an instance of the given {@link Externalizer} class. Any externalizer type referred by this annotation must be either {@link java.io.Serializable} or {@link java.io.Externalizable} because the marshalling infrastructure will ship an instance of the externalizer to any node that's no aware of this externalizer, hence allowing for dynamic externalizer discovery.
JBoss Marshalling plugin class for {@link ClassExternalizerFactory} that allows for Infinispan annotations to be used instead of JBoss Marshalling ones in order to discover which classes are serializable with Infinispan externalizers.
SerializedWith, specifies the {@link ConfigurationSerializer} to use to serialize the annotated class
Serializes an Infinispan configuration to an {@link XMLExtendedStreamWriter}

An optional service which can be utilised to register custom Kryo serializers when executing in compatibility mode. N.B. This can also be used on the client, however it is not necessary as you can also register custom schemas in client code, as long as the registration takes place before any Objects are marshalled/unmarshalled.
A Hot Rod server address
ServerAuditLogger.


ServerConfiguration.
ServerConfigurationBuilder.
Server Constant values

ServerEvent.
ServerEventLogger. This event logger takes care of maintaining the server event log cache and provides methods for querying its contents across all nodes. For resilience, the event log is stored in a local, bounded, persistent cache and distributed executors are used to gather logs from all the nodes in the cluster.
ServerExtension
Adds dependency from deployed module to Infinispan core.


{@link DefaultsResolver} implementation that extracts default values from Wildfly {@link AttributeDefinition}s
Defines the possible list of statistics defined by the Hot Rod server. Can be obtained through {@link RemoteCache#stats()}

An interface for deployed server tasks. In order to deploy a custom ServerTask, deploy a module containing a service that implements this interface. The task will be accessible by the name returned by {@link #getName()} Before the execution, {@link TaskContext} is injected into the task to provide {@link org.infinispan.manager.EmbeddedCacheManager}, {@link org.infinispan.Cache}, {@link org.infinispan.commons.marshall.Marshaller} and parameters. <p/> Author: Michal Szynkiewicz <michal.l.szynkiewicz@gmail.com>
Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/20/16 Time: 12:32 PM
Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/19/16 Time: 1:37 PM
Server task registry. Stores server tasks that can be executed via {@link org.infinispan.tasks.TaskManager} <p/> Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/22/16 Time: 4:03 PM
Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/20/16 Time: 12:53 PM
Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/20/16 Time: 12:53 PM
Used by ServerTaskEngine to executed ServerTasks <p/> Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/28/16 Time: 9:33 AM
Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/28/16 Time: 9:32 AM
Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/20/16 Time: 2:04 PM
A {@link TransactionOriginatorChecker} implementation that is aware of client transactions. <p> The transaction originator in this case is the Hot Rod client.
A Transaction Table for client transaction. <p> It stores the global state of a transaction and the map between the {@link Xid} and {@link Transaction}'s run locally.


Helper methods for interacting with a modular service container.

ServiceFinder is a {@link java.util.ServiceLoader} replacement which understands multiple classpaths
Class copied from JBoss Fuse project and modified.
Provides a service name.



A {@link PrivilegedAction} that calls {@link AccessibleObject#setAccessible(boolean)}
SetCacheAvailabilityAction.
Set externalizer for all set implementations, i.e. HashSet and TreeSet
A set that maps another one to a new one of a possibly different type.  Note this set is read only and doesn't accept write operations. <p> This class currently only accepts a {@link Function} that also implements {@link InjectiveFunction} so that it can guarantee the resulting mapped values are distinct from each other.  This is important as many operations because very costly if this is not true. <p> Some operations such as {@link Collection#contains(Object)} and {@link Collection#containsAll(Collection)} may be more expensive then normal since they cannot utilize lookups into the original collection.
SetThreadContextClassLoaderAction.


ShardAllocatorManager is responsible for the mapping between index shards and Infinispan segments for all indexes in a cache.
Provides shard distribution information for an index.
Factory for {@link ShardDistribution} instances.
A sorted map abstraction implemented via an ordered forest of trees. The ordered forest of trees is stored in variable <i>forest</i>. Each trees is a shared object implemented with the atomic object factory. It contains at most <i>threshold</i> objects.
Base class for cache resources which require common cache attributes, clustered cache attributes and shared cache attributes.
Base class for cache resources which require common cache attributes, clustered cache attributes and shared cache attributes.

SharedState is used by LuceneUserThread when used concurrently to coordinate the assertions: different threads need a shared state to know what to assert about the Index contents.


Shell.
ShellImpl.



Behavior of the JVM shutdown hook registered by the cache
Variable length encoding for signed numbers, using the ZigZag technique
Invocation stage representing a computation that may or may not be done yet. It is only meant to support the simplest asynchronous invocation, {@link org.infinispan.interceptors.BaseAsyncInterceptor#asyncValue(CompletableFuture)}.
Simple local cache without interceptor stack. The cache still implements {@link AdvancedCache} since it is too troublesome to omit that.
Trivial cache invoker.
A simple versioning scheme that is cluster-aware
A version generator implementation for SimpleClusteredVersions
Connection factory implementation that will create database connection on a per invocation basis. Not recommended in production, {@link PooledConnectionFactory} or {@link ManagedConnectionFactory} should rather be used.
SimpleConnectionFactoryConfiguration.
SimpleConnectionFactoryBuilder.

This is mostly a marker interface for dynamic loading of externalizers via ServiceLoader.
SimpleGroupPrincipal.
Where is Java 1.6?
SimpleInstanceAttributeCopier. This {@link AttributeCopier} "copies" an instance by creating a new instance
Factory of local backends to simplify lazy initialization.
SimpleLoginHandler which pass login and password for authorization.
SimplePrincipalGroupRoleMapper maps names of principals contained in {@link SimpleGroup} to roles. These principals are assumed to be {@link SimplePrincipal}s. {@link SimpleGroup} of {@link SimplePrincipal}s is returned by WildFly logging modules, e.g. AdvancedLdapLoginModule.
Simple {@link org.jboss.as.controller.descriptions.ResourceDescriptionResolver} implementation that uses a static name/description mapping.
Simple {@link ResourceServiceHandler} that installs/removes a single service via a {@link ResourceServiceBuilderFactory}.
A server authentication handler which maintains a simple map of user names and passwords.
SimpleSubjectUserInfo.
SimpleUserPrincipal.
Simple implementation of {@link org.springframework.cache.interceptor.KeyGenerator} interface. It returns the first argument passed to a method.
A channel pipeline factory for testing that will inject a fixed length frame encoder of 2 bytes before a channel handler named <b>decoder</b>
SingleChunkIndexInput can be used instead of InfinispanIndexInput to read a segment when it has a size small enough to fit in a single chunk. In this quite common case for some segment types we don't need the readLock to span multiple chunks, the pointer to the buffer is safe enough. This leads to an extreme simple implementation.
Cluster executor implementation that sends requests to a single node at a time
A filesystem-based implementation of a {@link org.infinispan.persistence.spi.AdvancedLoadWriteStore}. This file store stores cache values in a single file <tt>&lt;location&gt;/&lt;cache name&gt;.dat</tt>, keys and file positions are kept in memory. <p/> Note: this CacheStore implementation keeps keys and file positions in memory! The current implementation needs about 100 bytes per cache entry, plus the memory for the key objects. <p/> So, the space taken by this cache store is both the space in the file itself plus the in-memory index with the keys and their file positions. With this in mind and to avoid the cache store leading to OutOfMemoryExceptions, you can optionally configure the maximum number of entries to maintain in this cache store, which affects both the size of the file and the size of the in-memory index. However, setting this maximum limit results in older entries in the cache store to be eliminated, and hence, it only makes sense configuring a maximum limit if Infinispan is used as a cache where loss of data in the cache store does not lead to data loss, and data can be recomputed or re-queried from the original data source. <p/> This class is fully thread safe, yet allows for concurrent load / store of individual cache entries.
Defines the configuration for the single file cache store.
Single file cache store configuration builder.

These are the tests for various JDBC stores (string, binary, mixed) with a single server. We test each store with 2 configurations: 1. passivation = true, preload = false 2. passivation = false, preload = true To speed things up, the tests use hotrod client so we can reuse a single server. Test for the write-behind store uses memcached client. Mixed store is not fully tested, because DefaultTwoWayKey2StringMapper (which does the decision string/binary) can handle both string keys (memcached) and byte array keys (hotrod), which means all the keys go into the string store.
Aggregates a single command for replication.
Runs the provided function once only and returns the result.  This is useful for operations that can be performed and its result is still valid even when a segment is lost.


Request implementation that waits for a response from a single target node.
Request implementation that waits for a response from a single target node.
RPC command to replicate cache operations (such as put, remove, replace, etc.) to the backup site.
SingletonStore is a delegating cache store used for situations when only one instance should interact with the underlying store. The coordinator of the cluster will be responsible for the underlying CacheStore. <p/> SingletonStore is a simply facade to a real CacheStore implementation. It always delegates reads to the real CacheStore. <p/> Writes are delegated <i>only if</i> this SingletonStore is currently the coordinator. This avoids having all stores in a cluster writing the same data to the same underlying store. Although not incorrect (e.g. a DB will just discard additional INSERTs for the same key, and throw an exception), this will avoid a lot of redundant work. <p/> Whenever the current coordinator dies (or leaves), the second in line will take over. That SingletonStore will then pass writes through to its underlying CacheStore. Optionally, when a new coordinator takes over the Singleton, it can push the in-memory state to the cache cacheStore, within a time constraint.

Response collector supporting {@link JGroupsTransport#invokeRemotelyAsync(Collection, ReplicableCommand, ResponseMode, long, ResponseFilter, DeliverOrder, boolean)}.
SingletonStore is a delegating cache store used for situations when only one instance in a cluster should interact with the underlying store. The coordinator of the cluster will be responsible for the underlying CacheStore. SingletonStore is a simply facade to a real CacheStore implementation. It always delegates reads to the real CacheStore.


The {@link CacheCommand#SITE} handler.



A {@link SiteMasterPicker} implementation that picks the first route. <p> Only a single route can be used in order to keep the data consistent for asynchronous cross-site replication.
Performs operation related to Cross-Site Replication
A site status. <p> A site could be online, offline or none of the previous. In the later case, it is consider in a mixed status and both {@link #isOnline()}  and {@link #isOffline()}  returns {@code false}.
A simple interface that is invoked by {@link org.infinispan.xsite.OfflineStatus} when a particular site changes its status to online/offline.


Command to calculate the size of the cache

Performs skip operation on a {@link DoubleStream}
SkipIndexingGuaranteed is an interceptor to verify all write operations are using the org.infinispan.context.Flag.SKIP_INDEXING Using SKIP_INDEXING is much lighter than having Infinispan Query need to use class reflection and attempt to reconfigure the Search engine dynamically.
Performs skip operation on a {@link IntStream}
Performs skip operation on a {@link LongStream}
Allows to skip a test on certain Operation Systems. <p> Note that TestNG implementation does not work properly on inherited test methods. In other words, you always need to override all <code>test*</code> methods in a class annotated using <code>SkipOnOs</code> </p>



Performs skip operation on a regular {@link Stream}

Wraps a buffer to expose only a slice of it. The buffer is not copied to avoid copy operations as the slice is expected to have a lifespan shorter than the buffer itself, so there would be no benefit in having a smaller copy in heap.
Wraps an InfinispanIndexInput to expose only a slice of it. Such slices are dependent on the parent IndexInput and will not handle readlocks.


Represent a set of integers (e.g. segments) as a {@code BitSet}. Memory usage depends on the highest element, as in {@link BitSet} and unlike in other collections such as {@link java.util.HashSet}.
JUnit category for smoke tests.
SniAdd.
Initializer for SNI Handlers.

SniResource.
Handler responsible for routing requests to proper backend based on SNI Host Name.

Local file-based cache store, optimized for write-through use with strong consistency guarantees (ability to flush disk operations before returning from the store call). * DESIGN: There are three threads operating in the cache-store: - LogAppender:  Requests to store entries are passed to the LogAppender thread via queue, then the requestor threads wait until LogAppender notifies them about successful store. LogAppender serializes the writes into append-only file, writes the offset into TemporaryTable and enqueues request to update index into UpdateQueue. The append-only files have limited size, when the file is full, new file is started. - IndexUpdater: Reads the UpdateQueue, applies the operation into B-tree-like structure Index (exact description below) and then removes the entry from TemporaryTable. When the Index is overwriten, the current entry offset is retrieved and IndexUpdater increases the unused space statistics in FileStats. - Compactor:    When a limit of unused space in some file is reached (according to FileStats), the Compactor starts reading this file sequentially, querying TemporaryTable or Index for the current entry position and copying the unchanged entries into another file. For the entries that are still valid in the original file, a compare-and-set (file-offset based) request is enqueued into UpdateQueue - therefore this operation cannot interfere with concurrent writes overwriting the entry. Multiple files can be merged into single file during compaction. Structures: - TemporaryTable: keeps the records about current entry location until this is applied to the Index. Each read request goes to the TemporaryTable, if the key is not found here, Index is queried. - UpdateQueue:    bounded queue (to prevent grow the TemporaryTable too much) of either forced writes (used for regular stores) or compare-and-set writes (used by Compactor). - FileStats:      simple (Concurrent)HashTable with actual file size and amount of unused space for each file. - Index:          B+-tree of IndexNodes. The tree is dropped and built a new if the process crashes, it does not need to flush disk operations. On disk it is kept as single random-accessed file, with free blocks list stored in memory. As IndexUpdater may easily become a bottleneck under heavy load, the IndexUpdater thread, UpdateQueue and tree of IndexNodes may be multiplied several times - the Index is divided into Segments. Each segment owns keys according to the hashCode() of the key. Amount of entries in IndexNode is limited by the size it occupies on disk. This size is limited by configurable nodeSize (4096 bytes by default?), only in case that the node contains single pivot (too long) it can be longer. A key_prefix common for all keys in the IndexNode is stored in order to reduce space requirements. For implementation reasons the keys are limited to 32kB - this requirement may be circumvented later. The pivots are not whole keys - it is the shortest part of key that is greater than all left children (but lesser or equal to all right children) - let us call this key_part. The key_parts are sorted in the IndexNode, naturally. On disk it has this format: key_prefix_length(2 bytes), key_prefix, num_parts(2 bytes), ( key_part_length (2 bytes), key_part, left_child_index_node_offset (8 bytes))+, right_child_index_node_offset (8 bytes) In memory, for every child a SoftReference<IndexNode> is held. When this reference is empty (but the offset in file is set), any reader may load the reference using double-locking pattern (synchronized over the reference itself). The entry is never loaded by multiple threads in parallel and even may block other threads trying to read this node. For each node in memory a RW-lock is held. When the IndexUpdater thread updates the Index (modifying some IndexNodes), it prepares a copy of these nodes (already stored into index file). Then, in locks only the uppermost node for writing, overwrites the references to new data and unlocks the this node. After that the changed nodes are traversed from top down, write locked and their record in index file is released. Reader threads crawl the tree from top down, locking the parent node (for reading), locking child node and unlocking parent node.



SoftIndexFileStoreSerializer.






Sort specification for a field.
Enumeration of the available sort directions.
Performs sorted operation with a comparator on a regular {@link Stream}
Performs sorted operation on a {@link DoubleStream}
Performs sorted operation on a {@link IntStream}
Performs sorted operation on a {@link LongStream}
Performs sorted operation on a regular {@link Stream}
Performs migration operations on the source server or cluster of servers
A spliterator that has been mapped from another spliterator.  This is nice to only lazily convert these values, so that you can convert across multiple threads or if the entire spliterator is not consumed. <p> This spliterator will <b>always</b> throw an {@link IllegalStateException} upon invocation of {@link Spliterator#getComparator()} since there is no trivial way of converting this with a mapper.
<p> A {@link org.springframework.cache.Cache <code>Cache</code>} implementation that delegates to a {@link org.infinispan.Cache <code>org.infinispan.Cache</code>} instance supplied at construction time. </p>
<p> A {@link org.springframework.cache.CacheManager <code>CacheManager</code>} implementation that is backed by an {@link org.infinispan.manager.EmbeddedCacheManager <code>Infinispan EmbeddedCacheManager</code>} instance. </p> <p> Note that this <code>CacheManager</code> <strong>does</strong> support adding new {@link org.infinispan.Cache <code>Caches</code>} at runtime, i.e. <code>Caches</code> added programmatically to the backing <code>EmbeddedCacheManager</code> after this <code>CacheManager</code> has been constructed will be seen by this <code>CacheManager</code>. </p>
<p> A {@link org.springframework.beans.factory.FactoryBean <code>FactoryBean</code>} for creating an {@link org.infinispan.spring.provider.SpringEmbeddedCacheManager <code>SpringEmbeddedCacheManager</code>} instance. The location of the Infinispan configuration file used to provide the default {@link org.infinispan.configuration.cache.Configuration configuration} for the <code>EmbeddedCacheManager</code> instance created by this <code>FactoryBean</code> is {@link #setConfigurationFileLocation(org.springframework.core.io.Resource) configurable}. </p> <p> If no configuration file location is set the <code>SpringEmbeddedCacheManager</code> instance created by this <code>FactoryBean</code> will use Infinispan's default settings. See Infinispan's <a href="http://www.jboss.org/infinispan/docs">documentation</a> for what those default settings are. </p> <p> A user may further customize the <code>SpringEmbeddedCacheManager</code>'s configuration using explicit setters on this <code>FactoryBean</code>. The properties thus defined will be applied either to the configuration loaded from Infinispan's configuration file in case one has been specified, or to a configuration initialized with Infinispan's default settings. Either way, the net effect is that explicitly set configuration properties take precedence over both those loaded from a configuration file as well as INFINISPAN's default settings. </p> <p> In addition to creating an <code>SpringEmbeddedCacheManager</code> this <code>FactoryBean</code> does also control that <code>SpringEmbeddedCacheManager</code>'s {@link org.infinispan.commons.api.Lifecycle lifecycle} by shutting it down when the enclosing Spring application context is closed. It is therefore advisable to <em>always</em> use this <code>FactoryBean</code> when creating an <code>SpringEmbeddedCacheManager</code>. </p>
Builder for tests of SpringEmbeddedCacheManagerFactoryBean.
<p> A {@link org.springframework.cache.CacheManager <code>CacheManager</code>} implementation that is backed by an {@link org.infinispan.client.hotrod.RemoteCacheManager <code>Infinispan RemoteCacheManager</code>} instance. </p>
<p> A {@link org.springframework.beans.factory.FactoryBean <code>FactoryBean</code>} for creating an {@link org.infinispan.spring.provider.SpringRemoteCacheManager <code>SpringRemoteCacheManager</code>} instance. </p> <strong>Configuration</strong><br/> <p> A <code>SpringRemoteCacheManager</code> is configured through a {@link java.util.Properties <code>Properties</code>} object. For an exhaustive list of valid properties to be used see <code>RemoteCacheManager</code>'s {@link org.infinispan.client.hotrod.RemoteCacheManager javadocs}. This <code>FactoryBean</code> provides means to either {@link #setConfigurationProperties(Properties) inject} a user-defined <code>Properties</code> instance or to {@link #setConfigurationPropertiesFileLocation(org.springframework.core.io.Resource) set} the location of a properties file to load those properties from. Note that it is <em>illegal</em> to use both mechanisms simultaneously. </p> <p> Alternatively or in combination with {@link #setConfigurationPropertiesFileLocation(org.springframework.core.io.Resource) setting} the location of a <code>Properties</code> file to load the configuration from, this <code>FactoryBean</code> provides (typed) setters for all configuration settings. Settings thus defined take precedence over those defined in the injected <code>Properties</code> instance. This flexibility enables users to use e.g. a company-wide <code>Properties</code> file containing default settings while simultaneously overriding select settings whenever special requirements warrant this.<br/> Note that it is illegal to use setters in conjunction with {@link #setConfigurationProperties(Properties) injecting} a <code>Properties</code> instance. </p> <p> In addition to creating a <code>SpringRemoteCacheManager</code> this <code>FactoryBean</code> does also control that <code>SpringRemoteCacheManager</code>'s lifecycle by shutting it down when the enclosing Spring application context is closed. It is therefore advisable to <em>always</em> use this <code>FactoryBean</code> when creating an <code>SpringRemoteCacheManager</code>. </p>

SslConfiguration.
SSLConfigurationBuilder.
ProtocolServerConfigurationChildBuilder.
SslContextFactory.
SslEngineConfiguration
SSLConfigurationBuilder.
A simple utility class for managing SSL Contexts


Resource description for the addressable resource /subsystem=jgroups/stack=X



Starts a new batch
StartCacheAction.



An entry that may have state, such as created, changed, valid, etc.
Encapsulates a chunk of cache entries that belong to the same segment. This representation is suitable for sending it to another cache during state transfer.
Handles inbound state transfers.
{@link StateConsumer} implementation.

Handles outbound state transfers.
{@link StateProvider} implementation.


This command is used by a StateConsumer to request transactions and cache entries from a StateProvider.
This command is used by a StateProvider to push cache entries to a StateConsumer.
Defines a set of logical threads, each with a list of states, and a partial ordering between states. <p/> <p>Logical threads are defined with {@link #logicalThread(String, String, String...)}. States in a logical thread are implicitly ordered - they must be entered in the order in which they were defined.</p> <p>The ordering between states in different logical threads can be defined with {@link #order(String, String, String...)}</p> <p>A state can also have an associated action, defined with {@link #action(String, java.util.concurrent.Callable)}. States that depend on another state with an associated action can only be entered after the action has finished.</p> <p>Entering a state with {@link #enter(String)} will block until all the other states it depends on have been exited with {@link #exit(String)}.</p>
Various helper methods for working with {@link StateSequencer}s.
Constructs {@link org.infinispan.statetransfer.StateTransferManager}, {@link org.infinispan.statetransfer.StateConsumer} and {@link org.infinispan.statetransfer.StateProvider} instances.
Configures how state is retrieved when a new cache joins the cluster. Used with invalidation and replication clustered modes.
Configures how state is transferred when a cache joins or leaves the cluster. Used in distributed and replication clustered modes.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/state-transfer=STATE_TRANSFER
This interceptor has two tasks: <ol> <li>If the command's topology id is higher than the current topology id, wait for the node to receive transaction data for the new topology id.</li> <li>If the topology id changed during a command's execution, retry the command, but only on the originator (which replicates it to the new owners).</li> </ol> If the cache is configured with asynchronous replication, owners cannot signal to the originator that they saw a new topology, so instead each owner forwards the command to all the other owners in the new topology.
We use the state transfer lock for three different things: <ol> <li>We don't want to execute a command until we have the transaction table for that topology id. For this purpose it works like a latch, commands wait on the latch and state transfer opens the latch when it has received all the transaction data for that topology id.</li> <li>Do not write anything to the data container in a segment that we have already removed. For this purpose, ownership checks and data container writes acquire a shared lock, and the segment removal acquires an exclusive lock.</li> <li>We want to handle state requests only after we have installed the same topology id, because this guarantees that we also have installed the corresponding view id and we have all the joiners in our JGroups view. Here it works like a latch as well, state requests wait on the latch and state transfer opens the latch when it has received all the transaction data for that topology id.</li> </ol>
{@code StateTransferLock} implementation.
A component that manages the state transfer when the topology of the cluster changes.
{@link StateTransferManager} implementation.
Abstact class for testing state transfer suppress functionality




Class responsible for serving static content
Accessor to the {@link org.hibernate.SessionFactory} statistics.
A Statistic Snapshot;

Input/Output ChannelHandler to keep statistics
Wraps existing {@link AdvancedCache} to collect statistics

The {@link CacheCommand#STATS} handler.
StatsImpl.
Implements to the stats operation as defined by <a href="http://community.jboss.org/wiki/HotRodProtocol">Hot Rod protocol specification</a>.
Displays statistics about a container or a cache

Method level annotation that indicates a (no-param) method to be called on a component registered in the ComponentRegistry when the cache stops. <p/>
StopCacheAction.
Stoppable implements simple wrappers for objects which need to be stopped in certain way after being used
The storage mode of a counter.
Enumeration defining the various storage types for the data container
Store. An annotation for identifying a persistent store and explicitly stating some of its characteristics.
Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. <p /> It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both. <p />
Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. <p /> It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both. <p />
StoreConfiguration contains generic configuration elements available to all the stores.
LoaderConfigurationBuilder is an interface which should be implemented by all cache loader builders

Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/store=STORE
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/*-cache=Y/loader=Z/property=A

Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/store=Z/write-behind=WRITE_BEHIND
Makes the 2 contained region factory implementations available to the Hibernate {@link org.hibernate.boot.registry.selector.spi.StrategySelector} service.


Factory that allows creation of a {@link LocalStreamManager} or {@link ClusterStreamManager} based on the provided configuration.
Static factory class containing methods that will provide marshallable instances for very common use cases. Every instance returned from the various static methods uses the Infinispan marshalling to reduce payload sizes considerably and should be used whenever possible.
Stream request command that is sent to remote nodes handle execution of remote intermediate and terminal operations.
Stream response command used to handle returning intermediate or final responses from the remote node
A stream response command that also returns back suspected segments that need to be retried
This contains all the stream lib top keys. Stream lib is a space efficient technique to obtains the top-most counters.
A specialization of {@link Marshaller} that supports streams. <p/> A single instance of any implementation is shared by multiple threads, so implementations <i>need</i> to be threadsafe, and preferably immutable.
StreamingRemoteCache implements streaming versions of most {@link RemoteCache} methods
Implementation of {@link StreamingRemoteCache}
A collection of stream related utility methods. <p/> <p>Exceptions that are thrown and not explicitly declared are ignored.
JUnit category for stress tests.
Tests cache operations in Invalidation mode. There's a cluster of 2 nodes backed by a common database (shared) accessed via jdbc string-based cache store.
Tests fetch-state and singleton attributes of a string-based jdbc cache store.


Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/string-keyed-jdbc-store=STRING_KEYED_JDBC_STORE


A utility class for replacing properties in strings.

Duplicates a set of counters in a set of stripes, so that multiple threads can increment those counters without too much contention. <p> Callers must first obtain a stripe for the current thread with {@link #stripeForCurrentThread()}, then use {@link #increment(AtomicLongFieldUpdater, Object)} or {@link #add(AtomicLongFieldUpdater, Object, long)} to update one or more counters in that stripe. They must also provide a {@link AtomicLongFieldUpdater} to access a specific counter in the stripe - it should be defined as {@code static final} so that it can be inlined by the JIT.
An hash function for stripping. <p> It calculates the number of segments based on the concurrency level desired and hashes the object to the corresponding segments.
Holder for read write locks that provides ability to retrieve them by offset and hashCode
A lock container used with lock stripping.
The strong consistent counter interface. <p> It provides atomic updates for the counter. All the operations are perform asynchronously and they complete the {@link CompletableFuture} when completed. <p> The implementation may support weakly consistent reads via {@link #weakGetValue()}.
{@link org.infinispan.counter.api.StrongCounter} configuration.
{@link org.infinispan.counter.api.StrongCounter} configuration builder.
The key to store in the {@link org.infinispan.Cache} used by {@link StrongCounter}.
SubjectACL.

Consolidates common logic when creating {@link org.jboss.as.controller.descriptions.ResourceDescriptionResolver}s for a given subsystem.
Successful entry processor result wrapper.
A successful response
Computes the sum of {@link Number}s. Returns {@link Long} when applied to fields of integral types (other than BigInteger); Double when applied to state-fields of floating point types; BigInteger when applied to state-fields of type BigInteger; and BigDecimal when applied to state-fields of type BigDecimal. Nulls are excluded from the computation. If there are no remaining non-null values to which the aggregate function can be applied, the result of the aggregate function is {@code null}.


This annotation is used for components that will be registered in the {@link org.infinispan.factories.ComponentRegistry}, that are meant to be retained in the component registry even after the component registry is stopped.  Components annotated as such would not have to be recreated and rewired between stopping and starting a component registry. <br /> As a rule of thumb though, use of this annotation on components should be avoided, since resilient components are retained even after a component registry is stopped and consume resources.  Only components necessary for and critical to bootstrapping and restarting the component registry should be annotated as such. ensure this annotation is available at runtime. only applies to classes.
Thrown when a member is suspected during remote method invocation
Defines the strategy contract to be plugging into an InfinispanBackendQueueProcessor

If configured all communications are synchronous, in that whenever a thread sends a message sent over the wire, it blocks until it receives an acknowledgment from the recipient. SyncConfig is mutually exclusive with the AsyncConfig.
If configured all communications are synchronous, in that whenever a thread sends a message sent over the wire, it blocks until it receives an acknowledgment from the recipient. SyncConfig is mutually exclusive with the AsyncConfig.
One of the assumptions people made on consistent hashing involves thinking that given a particular key and same topology, it would produce the same consistent hash value no matter which cache it was stored in. However, that's not exactly the case in Infinispan. In order to the optimise the number of segments moved on join/leave, Infinispan uses a consistent hash that depends on the previous consistent hash. Given two caches, even if they contain exactly the same keyset, it's very easy for the consistent hash history to differ, e.g. if 2 nodes join you might see two separate topology change in one cache and a single topology change in the other. The reason for that each node has to send a {@link org.infinispan.topology.CacheTopologyControlCommand} for each cache it wants to join and Infinispan can and does batch cache topology changes. For example, if a rebalance is in progress, joins are queued and send in one go when the rebalance has finished. This {@link org.infinispan.distribution.ch.ConsistentHashFactory} implementation avoids any of the issues mentioned and guarantees that multiple caches with the same members will have the same consistent hash. It has a drawback compared to {@link org.infinispan.distribution.ch.impl.DefaultConsistentHashFactory} though: it can potentially move a lot more segments during a rebalance than strictly necessary because it's not taking advantage of the optimisation mentioned above.

{@link LocalTransaction} implementation to be used with {@link SynchronizationAdapter}.
Response collector supporting {@link JGroupsTransport#invokeRemotelyAsync(Collection, ReplicableCommand, ResponseMode, long, ResponseFilter, DeliverOrder, boolean)}.
Multiple producer-single consumer queue. The producers are expected to call pushAndWait(), the consumer should call pop() in a loop and if a null is returned (meaning that the queue is either empty or the limit of elements processed in a loop has been reached, to call notifyAndWait(). Example: while (running) { T element = queue.pop(); if (element != null) { process(element); } else { flush(); queue.notifyAndWait(); } } // terminate producers and process the rest of the queue queue.notifyNoWait();
{@link SyncConsistentHashFactory} adapted for replicated caches, so that the primary owner of a key is the same in replicated and distributed caches.
A {@link StrongCounter} decorator that waits for the operation to complete.
A {@link WeakCounter} decorator that waits for the operation to complete.
{@link Synchronization} implementation for integrating with the TM. See <a href="https://issues.jboss.org/browse/ISPN-888">ISPN-888</a> for more information on this.
A class that handles restarts of components via multiple threads.  Specifically, if a component needs to be restarted and several threads may demand a restart but only one thread should be allowed to restart the component, then use this class. <p/> What this class guarantees is that several threads may come in while a component is being restarted, but they will block until the restart is complete. <p/> This is different from other techniques in that: <ul> <li>A simple compare-and-swap to check whether another thread is already performing a restart will result in the requesting thread returning immediately and potentially attempting to use the resource being restarted.</li> <li>A synchronized method or use of a lock would result in the thread waiting for the restart to complete, but on completion will attempt to restart the component again.</li> </ul> This implementation combines a compare-and-swap to detect a concurrent restart, as well as registering for notification for when the restart completes and then parking the thread if the CAS variable still indicates a restart in progress, and finally deregistering itself in the end.
Generates an Ickle query from an expression tree.
<p> A synthetic qualifier that can be used to replace other user-supplied configuration at deployment. </p> <p/> <p/>
SystemBindings.
SystemUtils.
This protocol allows for discovery to happen via data structures maintained in memory rather than relying on JGroup's transport. This allows for discovery to be much faster and predictable because it only relies on java method calls rather than network calls. Clearly, this protocol only works for clusters that are created in memory.
RELAY2 only allows setting the bridge cluster name and properties via XML. This is a hack to change the bridge cluster name after the RELAY2 configuration is parsed, so that multiple x-site tests can run in parallel.



TableManipulationConfigurationBuilder.
Value object for table name operations.


Performs migration operations on the target server or cluster of servers
{@link Category} tag for task tests. Author: Michal Szynkiewicz, michal.l.szynkiewicz@gmail.com Date: 1/28/16 Time: 8:45 AM
TaskContext. Defines the execution context of a task by specifying parameters, cache and marshaller

TaskEngine. An implementation of an engine for executing tasks. How the tasks are implemented is dependent on the engine itself.
TaskExecution. Contains information about a running task
TaskExecutionImpl. A concrete representation of a {@link TaskExecution}
TaskEventImplExternalizer.

TaskManager. Allows executing tasks and retrieving the list of currently running tasks

TaskManagerImpl.
Essentially a delegate to an ExecutorService, but a special one that is only used by perf tests so it can be ignored when profiling.
TasksMetadataFileFinder.
MBean Server builder instance for the TCK.
Transport implementation based on TCP.


Table holding the entry positions in log before these are persisted to the index.
Static factory class used to provide marshallable terminal operations
Interface describing an operation that is a terminal one that doesn't track keys.
{@link AdvancedExternalizer} that provides functionality required for marshalling all of the various terminal operations that are used by various distributed streams including the primitive forms.
{@link OutputPrinter} for text values.
Memcached text protocol utilities.

Log4j {@link Filter} that only allow events from threads matching a regular expression. Events with a level greater than {@code threshold} are always logged.








A probe handler for {@link org.jgroups.tests.Probe} protocol is JGroups. <p> It contains a single key and returns the information about the remote thread pool executor service.
Thread pool resource definitions for Infinispan subsystem. See {@link org.infinispan.factories.KnownComponentNames} and {@link org.infinispan.commons.executors.BlockingThreadPoolExecutorFactory#create(int, int)} for the hardcoded Infinispan default values.

A write handler that does not permit configuring thread-factory and executors in runtime. The deprecated attributes are kept in the model to be able to support older slave versions (EAP 6.x).
Encapsulates all the time related logic in this interface.
Time unit representation for HotRod

A channel pipeline factory for environments where idle timeout is enabled.  This is a trait, useful to extend by an implementation channel initializer.
Thrown when a timeout occurred. used by operations with timeouts, e.g. lock acquisition, or waiting for responses from all members.
Defines the behavior of the timestamps cache region for Infinispan.



This is used both as the storage in entry, and for efficiency also directly in the cache.put() commands.

Note that this does not implement all commands, only those appropriate for {@link TombstoneAccessDelegate} and {@link org.infinispan.hibernate.cache.impl.BaseTransactionalDataRegion} The behaviour here also breaks notifications, which are not used for 2LC caches.
Request to update cache either as a result of putFromLoad (if {@link #getValue()} is non-null or evict (if it is null). This object should *not* be stored in cache.
Top-key stats about locks.
An AddressGenerator which generates ExtendedUUID addresses with specified site, rack and machine ids.
Some of the commands sent over the wire can only be honored by the receiver if the topology of the cluster at delivery time is still 'compatible' with the topology in place at send time (eg. a 'get' command cannot execute on a node that is no longer owner after state transfer took place). These commands need to be tagged with the current topology id of the sender so the receiver can detect and handle topology mismatches.
Wraps a TopologyUUID JGroups address
Default topology-aware consistent hash factory implementation.
A {@link org.infinispan.distribution.ch.ConsistentHashFactory} implementation that guarantees caches with the same members have the same consistent hash and also tries to distribute segments based on the topology information in {@link org.infinispan.configuration.global.TransportConfiguration}. <p/> It has a drawback compared to {@link org.infinispan.distribution.ch.impl.DefaultConsistentHashFactory}: it can potentially move a lot more segments during a rebalance than strictly necessary. <p/> It is not recommended using the {@code TopologyAwareSyncConsistentHashFactory} with a very small number of segments. The distribution of segments to owners gets better with a higher number of segments, and is especially bad when {@code numSegments &lt; numNodes}
The listener to be invoked when the cache topology changes.
This annotation should be used on methods that need to be notified when the {@link ConsistentHash} implementation in use by the {@link DistributionManager} changes due to a change in cluster topology.  This is only fired in a {@link Configuration.CacheMode#DIST_SYNC} or {@link Configuration.CacheMode#DIST_ASYNC} configured cache. <p/> Methods annotated with this annotation should accept a single parameter, a {@link TopologyChangedEvent} otherwise a {@link IncorrectListenerException} will be thrown when registering your listener. <p/> Note that methods marked with this annotation will be fired <i>before</i> and <i>after</i> the updated {@link ConsistentHash} is installed, i.e., your method will be called twice, with {@link Event#isPre()} being set to <tt>true</tt> as well as <tt>false</tt>. <p/> ensure this annotation is available at runtime. ensure that this annotation is applied to classes.

The event passed in to methods annotated with {@link TopologyChanged}.
Maintains topology information about caches.
The cluster topology is a tree with five levels: the entire cluster, sites, racks, machines, and individual nodes.
It checks or waits until the required topology is installed.
TopologyStateTransferAdd.

Commit Command used in the 2nd phase of 2PC. This command is used when non versioned entries are needed
This interceptor handles distribution of entries across a cluster, as well as transparent lookup, when the total order based protocol is enabled
Created to control the total order validation. It disable the possibility of acquiring locks during execution through the cache API
Behaves as a latch between {@code org.infinispan.commands.tx.PrepareCommand} delivered in total order to coordinate conflicting transactions and between {@code org.infinispan.commands.tx.PrepareCommand} and state transfer (blocking the prepare until the state transfer is finished and blocking the state transfer until all the prepared transactions has finished)
Implementation of {@code TotalOrderLatch}
This class behaves as a synchronization point between incoming transactions (totally ordered) and between incoming transactions and state transfer. <p/> Main functions: <ul> <li> ensure an order between prepares before sending them to the thread pool, i.e. non-conflicting prepares can be processed concurrently; </li> <li> ensure that the state transfer waits for the previous delivered prepares; </li> <li> ensure that the prepare waits for state transfer in progress. </li> </ul>
Command corresponding to the 1st phase of 2PC when Total Order based protocol is used. This command is used when non versioned entries are needed.
Interface with the utilities methods that the prepare command must have when Total Order based protocol is used
Represents a state for a Remote Transaction when the Total Order based protocol is used.
The 2nd phase command of 2PC, used when a transaction must be aborted. This implementation is used when Total Order based protocol is used
Synchronizes the incoming totally ordered transactions with the state transfer.
A {@link org.infinispan.remoting.inboundhandler.PerCacheInboundInvocationHandler} implementation for total order caches.
Command corresponding to the 2nd phase of 2PC. Used in Total Order based protocol when versioned entries are needed
This interceptor is used in total order in distributed mode when the write skew check is enabled. After sending the prepare through TOA (Total Order Anycast), it blocks the execution thread until the transaction outcome is known (i.e., the write skew check passes in all keys owners)
Wrapping Interceptor for Total Order protocol when versions are needed
Command corresponding to the 1st phase of 2PC when Total Order based protocol is used. This command is used when versioned entries are needed.
Borrowed from TCK tests


An transaction boundary command that allows the retrieval of an attached {@link org.infinispan.transaction.xa.GlobalTransaction}
This annotation should be used on methods that need to be notified when the cache is called to participate in a transaction and the transaction completes, either with a commit or a rollback. <p/> Methods annotated with this annotation should accept a single parameter, a {@link org.infinispan.notifications.cachelistener.event.TransactionCompletedEvent} otherwise a {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your listener. <p/> Note that methods marked with this annotation will only be fired <i>after the fact</i>, i.e., your method will never be called with {@link org.infinispan.notifications.cachelistener.event.Event#isPre()} being set to <tt>true</tt>. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back. ensure this annotation is available at runtime. ensure that this annotation is applied to classes.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.TransactionCompleted}.
This event is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.TransactionCompleted}. <p/> Note that this event is only delivered <i>after the fact</i>, i.e., you will never see an instance of this event with {@link #isPre()} being set to <tt>true</tt>.
Defines transactional (JTA) characteristics of the cache.
Defines transactional (JTA) characteristics of the cache.

Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/transaction=TRANSACTION
Coordinates transaction prepare/commits as received from the {@link javax.transaction.TransactionManager}. Integrates with the TM through either {@link org.infinispan.transaction.xa.TransactionXaAdapter} or through {@link org.infinispan.transaction.synchronization.SynchronizationAdapter}.
A base decode context to handle prepare, commit and rollback requests from a client.
Factory for transaction related sate.

Transaction related helper
A basic {@link Transaction} implementation.
A representation of a transaction that is suitable for transferring between a StateProvider and a StateConsumer running on different members of the same cache.
Uses a number of mechanisms to retrieve a transaction manager.
A simple {@link TransactionManager} implementation. <p> It provides the basic to handle {@link Transaction}s and supports any {@link javax.transaction.xa.XAResource}. <p> Implementation notes: <ul> <li>The state is kept in memory only.</li> <li>Does not support recover.</li> <li>Does not support multi-thread transactions. Although it is possible to execute the transactions in multiple threads, this transaction manager does not wait for them to complete. It is the application responsibility to wait before invoking {@link #commit()} or {@link #rollback()}</li> <li>The transaction should not block. It is no possible to {@link #setTransactionTimeout(int)} and this transaction manager won't rollback the transaction if it takes too long.</li> </ul> <p> If you need any of the requirements above, please consider use another implementation. <p> Also, it does not implement any 1-phase-commit optimization.
Factory interface, allows {@link org.infinispan.Cache} to use different transactional systems. Names of implementors of this class can be configured using {@link Configuration#setTransactionManagerLookupClass}. Thread safety: it is possible for the same instance of this class to be used by multiple caches at the same time e.g. when the same instance is passed to multiple configurations: {@link org.infinispan.configuration.cache.TransactionConfigurationBuilder#transactionManagerLookup(TransactionManagerLookup)}. As infinispan supports parallel test startup, it might be possible for multiple threads to invoke the getTransactionManager() method concurrently, so it is highly recommended for instances of this class to be thread safe.



An interface to check if the transaction originator is left or not.

Enumerate with the possible commits protocols.
This annotation should be used on methods that need to be notified when the cache is called to participate in a transaction and registers a {@link javax.transaction.Synchronization} with a registered {@link javax.transaction.TransactionManager}. <p/> Methods annotated with this annotation should accept a single parameter, a {@link org.infinispan.notifications.cachelistener.event.TransactionRegisteredEvent} otherwise a {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your listener. <p/> Note that methods marked with this annotation will only be fired <i>after the fact</i>, i.e., your method will never be called with {@link org.infinispan.notifications.cachelistener.event.Event#isPre()} being set to <tt>true</tt>. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back. ensure this annotation is available at runtime. ensure that this annotation is applied to classes.
Event bridge for {@link org.infinispan.notifications.cachelistener.annotation.TransactionRegistered}.
This event is passed in to any method annotated with {@link org.infinispan.notifications.cachelistener.annotation.TransactionRegistered}. <p/> Note that this event is only delivered <i>after the fact</i>, i.e., you will never see an instance of this event with {@link #isPre()} being set to <tt>true</tt>.
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/cache=Y/transaction=TRANSACTION
A simple abstraction for transaction manager interaction
Keeps the temporary statistics for a transaction. Also, it has the common logic for the local and remote transactions
Factory for the TransactionSynchronizationRegistry

Passes the TransactionSynchronizationRegistry to Infinispan.
With the Non-Blocking State Transfer (NBST) in place it is possible for a transactional command to be forwarded multiple times, concurrently to the same node. This interceptor makes sure that for any given transaction, the interceptor chain, post {@link StateTransferInterceptor}, would only allows a single thread to amend a transaction. </p> E.g. of when this situation might occur: <ul> <li>1) Node A broadcasts PrepareCommand to nodes B, C </li> <li>2) Node A leaves cluster, causing new topology to be installed </li> <li>3) The command arrives to B and C, with lower topology than the current one</li> <li>4) Both B and C forward the command to node D</li> <li>5) D executes the two commands in parallel and finds out that A has left, therefore executing RollbackCommand></li> </ul> <p/> This interceptor must placed after the logic that handles command forwarding ({@link StateTransferInterceptor}), otherwise we can end up in deadlocks when a command is forwarded in a loop to the same cache: e.g. A->B->C->A. This scenario is possible when we have chained topology changes (see <a href="https://issues.jboss.org/browse/ISPN-2578">ISPN-2578</a>).
Interface that allows to fetch the {@link org.infinispan.transaction.xa.GlobalTransaction} associated to local or remote transactions.
Factory for {@link org.infinispan.transaction.impl.TransactionTable} objects.

This acts both as an local {@link org.infinispan.transaction.xa.CacheTransaction} and implementor of an {@link javax.transaction.xa.XAResource} that will be called by tx manager on various tx stages.
Defines the functionality of a transactional store.  This interface allows the implementing store to participate in the 2PC protocol of a cache's transaction. This enables the cache transaction to be rolledback if an exception occurs whilst writing key changes to the underlying store, or for the writes to the underlying store to be rolledback if the exception occurs in-memory. As this writer is part of the 2PC, all writes to the underlying store should only be executed by the originator of a transaction in normal operation.  In the event that the originator crashes between the prepare and commit/rollback phase it is expected that the underlying store's transaction will eventually timeout and rollback. In the event that the originator crashes and transaction recovery is enabled, then forcing commit will result in the replaying of said Tx's (prepare/commit) to the underlying store.
An event subtype that includes a transaction context - if one exists - as well as a boolean as to whether the call originated locally or remotely.
This class implements the {@link org.hibernate.search.backend.TransactionContext} interface.  It retrieves transaction context information from the {@link javax.transaction.TransactionManager} that gets passed in as a parameter upon instantiation. <p/> It is used by the {@link QueryInterceptor} to pass transaction information to a Hibernate Search {@link org.hibernate.search.backend.Work} object. <p/> <p/>
Invocation context to be used for transactional caches.
<p>Factory for locks obtained in <code>InfinispanDirectory</code>, this factory produces instances of <code>TransactionalSharedLuceneLock</code>.</p> <p>Usually Lucene acquires the lock when creating an IndexWriter and releases it when closing it; these open-close operations are mapped to transactions as begin-commit, so all changes are going to be effective at IndexWriter close. The advantage is that a transaction rollback will be able to undo all changes applied to the index, but this requires enough memory to hold all the changes until the commit.</p> <p>Using a TransactionalSharedLuceneLock is not compatible with Lucene's default MergeScheduler: use an in-thread implementation like SerialMergeScheduler <code>indexWriter.setMergeScheduler( new SerialMergeScheduler() );</code></p>
Simple interface to extract all the keys that may need to be locked for transactional commands.
Inter-IndexWriter Lucene index lock based on Infinispan. There are pros and cons about using this implementation, please see javadoc on the factory class <code>org.infinispan.lucene.locking.TransactionalLockFactory</code>
An interceptor which ensures that writes to an underlying transactional store are prepared->committed/rolledback as part of the 2PC, therefore ensuring that the cache and transactional store(s) remain consistent.

If you annotate your object with this, it can be used as a valid key for Infinispan to index.
The task of this interface is to convert keys from their original types to a String representation (which can be used in Lucene) and vice versa.
A cache entry that is transient, i.e., it can be considered expired after a period of not being used.
A transient cache value, to correspond with {@link org.infinispan.container.entries.TransientCacheEntry}
A cache entry that is both transient and mortal.
A transient, mortal cache value to correspond with {@link org.infinispan.container.entries.TransientMortalCacheEntry}
Transport abstraction.
Defines the configuration of a JGroups transport protocol.

Indicates a communication exception with the Hot Rod server: e.g. TCP connection is broken while reading a response from the server.
Transport factory for building and managing {@link org.infinispan.client.hotrod.impl.transport.Transport} objects.
Flags that allow JGroups transport stack to be tweaked depending on the test case requirements. For example, you can remove failure detection, or remove merge protocol...etc.
Implements an {@link InputStream} around a {@link Transport}. The transport is marked as <b>busy</b> so that it won't be released automatically

Implements an {@link OutputStream} around a {@link Transport}. The transport is marked as <b>busy</b> so that it won't be released automatically
Resource description for the addressable resource /subsystem=infinispan/cache-container=X/transport=TRANSPORT
Resource description for /subsystem=jgroups/stack=X/transport=*
Test the stack attribute of the transport element. The stack attribute is set to UDP.
Unsorted traversable stream for sequential and aggregating operations. <p>Traversable contains two type of operations: <ol> <li>Intermediate operations which transform a traversable, into another, e.g. {@link #filter(Predicate)}. </li> <li>Terminal operations which produce a side effect, e.g. {@link #forEach(Consumer)}. Once a terminal operation is completed, the resources taken by the traversable are released. </li> </ol> <p>Traversable cannot be reused and hence is designed to be used only once via its intermediate and terminal operations. <p>In distributed environments, unless individually specified, all lambdas passed to methods are executed where data is located. For example, if executing {@link #forEach(Consumer)}, the {@link Consumer} function is executed wherever a particular key resides. To execute a for-each operation where the side effects are executed locally, all the {@link Traversable}'s data needs to be collected and iterated over manually.

This is a tree-like facade around a {@link Cache} allowing for efficient tree-style access to cached data. <p/> The primary purpose of this interface is to allow for efficient caching of tree-like structures such as directories, as well as to provide a compatibility layer with JBoss Cache 3.x and earlier. <p/> For most purposes, we expect people to use the {@link Cache} interface directly as it is simpler. <p/> The tree API assumes that a collection of {@link Node}s, organized in a tree structure underneath a root node, contains key/value attributes of data. <p/> Any locking happens on a node-level granularity, which means that all attributes on a node are atomic and in terms of locking, is coarse grained.  At the same time, replication is fine grained, and only modified attributes in a Node are replicated. <p/> Obtaining a TreeCache is done using the {@link TreeCacheFactory}. <pre> Cache cache = new DefaultCacheFactory().getCache(); TreeCacheFactory tcf = new TreeCacheFactory(); TreeCache tree = tcf.createTreeCache(cache); </pre>
Factory class that contains API for users to create instances of {@link org.infinispan.tree.TreeCache}


Represents an operation that accepts three input arguments and returns no result.  This is the three-arity specialization of {@link Consumer}. Unlike most other functional interfaces, {@code TriConsumer} is expected to operate via side-effects. <p>This is a <a href="package-summary.html">functional interface</a> whose functional method is {@link #accept(Object, Object, Object)}.
Externalizer for the triangle acknowledges.
Non-transactional interceptor used by distributed caches that supports concurrent writes. <p> It is implemented based on the Triangle algorithm. <p> The {@link GetKeyValueCommand} reads the value locally if it is available (the node is an owner or the value is stored in L1). If it isn't available, a remote request is made. The {@link DataWriteCommand} is performed as follow: <ul> <li>The command if forwarded to the primary owner of the key.</li> <li>The primary owner locks the key and executes the operation; sends the {@link BackupWriteRpcCommand} to the backup owners; releases the lock; sends the {@link SuccessfulResponse} or {@link UnsuccessfulResponse} back to the originator.</li> <li>The backup owner applies the update and sends a {@link BackupAckCommand} back to the originator.</li> <li>The originator collects the ack from all the owners and returns.</li> </ul> The {@link PutMapCommand} is performed in a similar way: <ul> <li>The subset of the map is split by primary owner.</li> <li>The primary owner locks the key and executes the command; splits the keys by backup owner and send them; and replies to the originator.</li> <li>The backup owner applies the update and sends back the {@link BackupMultiKeyAckCommand} to the originator.</li> <li>The originator collects all the acknowledges from all owners and returns.</li> </ul> The acknowledges management is done by the {@link CommandAckCollector}. <p> If a topology changes while a command is executed, an {@link OutdatedTopologyException} is thrown. The {@link StateTransferInterceptor} will catch it and retries the command. <p> TODO: finish the wiki page and add a link to it!
An {@link Action} that checks if the command is the next to be executed. <p> This action is used by the triangle algorithm to order updates from the primary owner to the backup owner.
It manages the order of updates from the primary owner to backup owner. <p> It depends on the cache topology id. The primary owner assigns the sequence number to the backup command and then sends it to the backup owner. In the backup owner, the command awaits until it is its turn to be executed. <p> If the command topology id does not match, it throws an {@link OutdatedTopologyException}. <p> The sequence order starts with 1 and it is per segment based. This allows segments to be updated concurrently.
A {@link PerCacheInboundInvocationHandler} implementation for non-transactional and distributed caches that uses the triangle algorithm.

Extends {@link Key2StringMapper} and allows a bidirectional transformation between keys and Strings.  Note that the object instance created by {@link #getKeyMapping(String)} is guaranteed to be <i>equal</i> to the original object used to generate the String, but not necessarily the same object reference. <p /> The following condition should be satisfied by implementations of this interface: <code> assert key.equals(mapper.getKeyMapping(mapper.getStringMapping(key))); </code>


This is a delegating cluster stream manager that sends all calls to the underlying cluster stream manager.  However in the case of performing an operation it adds all entries that are in the provided tx context to the map of keys to exclude so those values are not processed in the remote nodes.
Command for removing recovery related information from the cluster.
A distributed cache stream that also utilizes transactional awareness.  Basically this adds functionality to take items from the local tx context and add them to the local stream that is produced to enable our stream to operate upon entries in the context that don't map to our segments that are normally ignored in a distributed stream.
Double variant of tx cache stream
Int variant of tx cache stream
Long variant of tx cache stream
Handles the distribution of the transactional caches.
Interceptor in charge with handling transaction related operations, e.g enlisting cache as an transaction participant, propagating remotely initiated changes.
Delegate for transactional caches
This interceptor acts as a replacement to the replication interceptor when the CacheImpl is configured with ClusteredSyncMode as INVALIDATE. <p/> The idea is that rather than replicating changes to all caches in a cluster when write methods are called, simply broadcast an {@link InvalidateCommand} on the remote caches containing all keys modified.  This allows the remote cache to look up the value in a shared cache loader which would have been updated with the changes.
Interface defining additional functionality for invocation contexts that propagate within a transaction's scope.
Locked Stream that is designed for transactions. This way it can suspend and resume the transaction upon invocation.
Intercepts transactions in Infinispan, calling {@link PutFromLoadValidator#beginInvalidatingKey(Object, Object)} before locks are acquired (and the entry is invalidated) and sends {@link EndInvalidationCommand} to release invalidation throught {@link PutFromLoadValidator#endInvalidatingKey(Object, Object)} after the transaction is committed.


A {@link TestResponse} used by prepare, commit or rollback requests.
A transaction state stored globally in all the cluster members.

A transaction write for testing.


This class represents Infinispan cache parameters that can be configured via hibernate configuration properties for either general entity/collection/query/timestamp data type caches and overrides for individual entity or collection caches. Configuration these properties override previously defined properties in XML file.
Type-aware properties.  Extends the JDK {@link Properties} class to provide accessors that convert values to certain types, using default values if a conversion is not possible.
TypedPropertiesAttributeCopier. This {@link AttributeCopier} can handle {@link TypedProperties}
Utility class for Types
Encoder to/from UTF-8 content using the java string encoding mechanism.

Checks if classpath contains proper configuration for Uber Jars and warns if it does not.

An unbounded strong consistent counter.
A delegating {@link java.io.ObjectInput} that delegates all methods except {@link ObjectInput#close()}.
An unclosable version of an {@link java.io.ObjectOutput}.  This delegates all methods except {@link #flush()} and {@link #close()}.
UndefineConfigurationAction.

Since the data handled in {@link TombstoneCallInterceptor} or {@link VersionedCallInterceptor} does not rely on the order how these are applied (the updates are commutative), this interceptor simply sends any command to all other owners without ordering them through primary owner. Note that {@link LockingInterceptor} is required in the stack as locking on backup is not guaranteed by primary owner.
Performs unordered operation on a {@link BaseStream}

Memory allocator that just allocates memory directly using {@link Unsafe}.
Handler to unregister a bunch of protobuf schemas given their names.
Controls certain tuning parameters that may break some of Infinispan's public API contracts in exchange for better performance in some cases. <p /> Use with care, only after thoroughly reading and understanding the documentation about a specific feature. <p />
Controls certain tuning parameters that may break some of Infinispan's public API contracts in exchange for better performance in some cases. <p /> Use with care, only after thoroughly reading and understanding the documentation about a specific feature. <p />

Helper to read and write unsigned numerics
JUnit category for unstable tests.
{@link org.junit.experimental.categories.Category} annotation for unstable and client dist/repl suite tests
{@link org.junit.experimental.categories.Category} annotation for unstable and client local suite test
{@link org.junit.experimental.categories.Category} annotation for unstable tests running with the arquillian "queries" group
An unsuccessful response
Exception thrown by certain cache stores when one tries to persist an entry with an unsupported key type.
An unsure response - used with Dist - essentially asks the caller to check the next response from the next node since the sender is in a state of flux (probably in the middle of rebalancing)
A class which is updatable makes transparent the fact that it is built atop a listenable cache (in contrast to a Serializable class). In return, it permits the developer a fine-grained control of the methods it declares using the tag <i>Update</i>. When a method is tagged with this keyword, the factory considers that it modifies the state of the object; otherwise the method is  perceived as read-only allowing several performance optimizations.
To declare a method as modifying the state of the object.

The {@link CacheCommand#UPGRADE} handler.
Performs operation related to rolling upgrades
Handler that performs the operation of uploading a protobuf file to be used.

Parent class for UserHS to demonstrate inheritance of indexed attributes.


UserPrincipal. A {@link Principal} which denotes a user
Thrown when client's code passed as a labda expression in commands such as {@link org.infinispan.commands.write.ComputeIfAbsentCommand} raises a exception. We don't want to convert this excepton into a {@link org.infinispan.commons.CacheException} but instead just propagate it to the user as it is.


Transaction related util class.
Utility methods.

Reads and writes unsigned variable length integer values. Even though it's deprecated, do not remove from source code for the moment because it's a good scala example and could be used as reference.
Reads and writes unsigned variable length long values. Even though it's deprecated, do not remove from source code for the moment because it's a good scala example and could be used as reference.
A valid response
Base class for response collectors, splitting responses into valid responses, exception responses, and target missing. Returning a non-{@code null} value or throwing an exception from any of the {@link #addValidResponse(Address, ValidResponse)}, {@link #addException(Address, Exception)}, or {@link #addTargetNotFound(Address)} methods will complete the request. If all invocations return {@code null}, the request will be completed with the result of {@link #finish()}.

CacheCollection that can be used for the values method of a cache.  Backs all the calls to the cacheSet version allowing for key filtering still to be applied.
Service dependency that provides a value.

A simple <code>Future</code> implementation whose <code>get()</code> method blocks until another thread calls <code>set()</code>.
A policy for determining if a write command should be executed based on the current value in the cache. When retrying conditional write commands in non-transactional caches, it is also used to determine the appropriate return value. E.g. if a {@code putIfAbsent(k, v)} already succeeded on a backup owner which became the primary owner, when retrying the command will find {@code v} in the cache but should return {@code null}. For non-conditional commands it's impossible to know what the previous value was, so the command is allowed to return {@code v}.
Value matcher mode.
Represents a range of values starting from value {@code from} and ending at {@code to}, including or excluding the interval ends as indicated by {@code includeLower} and {@code includeUpper} respectively. This is used to represent an interval specified in the 'between' clause of the query DSL.



Generates versions
Version generator component factory. Version generators are used for situations where version or ids are needed, e.g. data versioning, transaction recovery, or hotrod/memcached support.
Implementation of the "version" statement
Utilities to handle protocol versions
Versioned
Note that this does not implement all commands, only those appropriate for {@link TombstoneAccessDelegate} and {@link org.infinispan.hibernate.cache.impl.BaseTransactionalDataRegion} The behaviour here also breaks notifications, which are not used for 2LC caches.
The same as a {@link CommitCommand} except that version information is also carried by this command, used by optimistically transactional caches making use of write skew checking when using {@link org.infinispan.util.concurrent.IsolationLevel#REPEATABLE_READ}.
This class represents the work to be done by a decoder of a particular Hot Rod protocol version.
A version of the {@link TxDistributionInterceptor} that adds logic to handling prepares when entries are versioned.
This class represents the work to be done by an encoder of a particular Hot Rod protocol version.

Interceptor in charge with wrapping entries and add them in caller's context.

VersionedMetadata


Same as {@link PrepareCommand} except that the transaction originator makes evident the versions of entries touched and stored in a transaction context so that accurate write skew checks may be performed by the lock owner(s).
A version of RepeatableReadEntry that can perform write-skew checks during prepare.


Besides the key and value, also contains an version. To be used in versioned operations, e.g. {@link org.infinispan.client.hotrod.RemoteCache#removeWithVersion(Object, long)}.

This configuration element controls whether entries are versioned. Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.

The various versioning schemes supported

Indexed class which index name is very long - taken from the bug description (ISPN-3092). Sample long index name taken from the bug description
Listens for view changes.  Note that you do NOT have to register this listener; it does so automatically when constructed.
This annotation should be used on methods that need to be notified when the cache is used in a cluster and the cluster topology changes (i.e., a member joins or leaves the cluster). <p/> Methods annotated with this annotation should accept a single parameter, a {@link org.infinispan.notifications.cachemanagerlistener.event.ViewChangedEvent} otherwise a {@link org.infinispan.notifications.IncorrectListenerException} will be thrown when registering your listener. <p/> Any exceptions thrown by the listener will abort the call. Any other listeners not yet called will not be called, and any transactions in progress will be rolled back. ensure this annotation is available at runtime. ensure that this annotation is applied to classes.

This event is passed in to any method annotated with {@link org.infinispan.notifications.cachemanagerlistener.annotation.ViewChanged}. It represents a JGroups view change event.

A type of command that can accept {@link Visitor}s, such as {@link org.infinispan.interceptors.DDAsyncInterceptor}.
Visitor interface for expressions.
Accept all authentication mechanism.
No-op {@link javax.security.auth.callback.CallbackHandler}. Convenient CallbackHandler which comes handy when no auth. callback is needed. This applies namely to SASL EXTERNAL auth. mechanism when auth. information is obtained from external channel, like TLS certificate.
A weak consistent counter interface. <p> This interface represents a weak counter in the way that the write operations does not return a consistent results. In this way, all the writes return a {@link CompletableFuture<Void>}. <p> Note: the reset operation is not atomic.
{@link org.infinispan.counter.api.WeakCounter} configuration.
{@link org.infinispan.counter.api.WeakCounter} configuration builder.
A weak consistent counter implementation. <p> Implementation: The counter is split in multiple keys and they are stored in the cache. <p> Write: A write operation will pick a key to update. If the node is a primary owner of one of the key, that key is chosen based on thread-id. This will take advantage of faster write operations. If the node is not a primary owner, one of the key in key set is chosen. <p> Read: A read operation needs to read all the key set (including the remote keys). This is slower than atomic counter. <p> Weak Read: A snapshot of all the keys values is kept locally and they are updated via cluster listeners. <p> Reset: The reset operation is <b>not</b> atomic and intermediate results may be observed.
The key to store in the {@link org.infinispan.Cache} used by {@link WeakCounter}. <p> The weak consistent counters splits the counter's value in multiple keys. This class contains the index.
This Map will remove entries when the value in the map has been cleaned from garbage collection

WebSocketConnectorResource.
An HTTP server which serves Web Socket requests on an Infinispan cacheManager. <p> Websocket specific code lifted from Netty WebSocket Server example. </p>
WebSocketServerConfiguration.
WebSocketServerConfigurationBuilder.
Web Socket Server Handler (Netty). <p> Websocket specific code lifted from Netty WebSocket Server example. </p>
WebSocketSubsystemAdd.

The class should be in a package that is different from the test so that the test does not have access to the private embedded ID.
The class should be in a package that is different from the test so that the test does not have access to the private ID field.
An executor that works within the current thread.
Executor factory that creates WithinThreadExecutor. This executor executes the tasks in the caller thread.
Partitions {@link LuceneWork} based on the location it should be applied.

<a href="http://jmesnil.net/">Jeff Mesnil</a> (c) 2012 Red Hat, inc
Simple wrapper around a byte[] to provide equals and hashCode semantics
This class is an implementation for {@link TwoWayKey2StringMapper} that supports both primitives and {@link org.infinispan.commons.marshall.WrappedByteArray}s. It extends {@link DefaultTwoWayKey2StringMapper} to achieve this.
Size calculator that supports a {@link WrappedByteArray} by adding its size and the underlying byte[].
Interface that describes and object holding onto some bytes



Wraps another Hibernate Search {@link ErrorHandler} allowing extra processing of the backend error.

A command that modifies the cache in some way







Write-only map implementation.
Thrown when a write skew is detected
Encapsulates write skew logic in maintaining version maps, etc.
Exception indicating wrong context.

abstract class that needs to be overridden
An XML stream reader that can read nested {@code <xs:any>} content using a registered set of root elements.


XMLExtendedStreamWriterImpl.
{@link OutputPrinter} for xml values.

Command used for handling XSiteReplication administrative operations.
Managed bean exposing sys admin operations for Cross-Site replication functionality.

{@link org.infinispan.xsite.statetransfer.XSiteStateProvider} delegator. Mean to be overridden. For test purpose only!
Abstract class to invoke RPC on the remote site.
Represents the state of a single key to be sent to a backup site. It contains the only needed information, i.e., the key, current value and associated metadata.
It contains the logic needed to consume the state sent from other site.
It contains the logic needed to consume the state sent from other site.
It contains the logic to send state to another site.
It contains the logic to send state to another site.
Wraps the state to be sent to another site
It collects the acknowledgements sent from local site member to signal the ending of the state sent.
Configuration needed for State Transfer between different sites.
Configuration Builder to configure the state transfer between sites.
Command used to control the state transfer between sites.
It manages the state transfer between sites.
{@link org.infinispan.xsite.statetransfer.XSiteStateTransferManager} implementation.
XaConnectionProvider.
XaResourceCapableTransactionImpl.
XaResourceCapableTransactionManagerImpl.
{@link TransactionTable} to be used with {@link TransactionXaAdapter}.
A {@link Xid} implementation. <p> If need to be serialized, use the methods {@link #writeTo(ObjectOutput, XidImpl)} and {@link #readFrom(ObjectInput)} or the {@link AdvancedExternalizer} in {@link #EXTERNALIZER}.
A simple XML utility class for reading configuration elements

