
struct { uint32 gmt_unix_time; opaque random_bytes[28]; } Random; opaque SessionID<0..32>; uint8 CipherSuite[2]; enum { null(0), (255) } CompressionMethod; struct { ProtocolVersion client_version; Random random; SessionID session_id; CipherSuite cipher_suites<2..2^16-2>; CompressionMethod compression_methods<1..2^8-1>; select (extensions_present) { case false: struct {}; case true: Extension extensions<0..2^16-1>; }; } ClientHello; struct { ExtensionType extension_type; opaque extension_data<0..2^16-1>; } Extension; enum { server_name(0), max_fragment_length(1), client_certificate_url(2), trusted_ca_keys(3), truncated_hmac(4), status_request(5), (65535) } ExtensionType; enum { hello_request(0), client_hello(1), server_hello(2), certificate(11), server_key_exchange (12), certificate_request(13), server_hello_done(14), certificate_verify(15), client_key_exchange(16), finished(20) (255) } HandshakeType; struct { HandshakeType msg_type; uint24 length; select (HandshakeType) { case hello_request:       HelloRequest; case client_hello:        ClientHello; case server_hello:        ServerHello; case certificate:         Certificate; case server_key_exchange: ServerKeyExchange; case certificate_request: CertificateRequest; case server_hello_done:   ServerHelloDone; case certificate_verify:  CertificateVerify; case client_key_exchange: ClientKeyExchange; case finished:            Finished; } body; } Handshake; struct { uint8 major; uint8 minor; } ProtocolVersion; enum { change_cipher_spec(20), alert(21), handshake(22), application_data(23), (255) } ContentType; struct { ContentType type; ProtocolVersion version; uint16 length; opaque fragment[TLSPlaintext.length]; } TLSPlaintext;
JDK8 ALPN hack support method. These methods will be removed once JDK8 ALPN support is no longer required JDK8 ALPN hack support method. These methods will be removed once JDK8 ALPN support is no longer required JDK8 ALPN hack support method. These methods will be removed once JDK8 ALPN support is no longer required

removes the ALPN extensions from the server hello






{@inheritDoc } {@inheritDoc } {@inheritDoc }







Given two Runnables, return a Runnable that executes both in sequence, even if the first throws an exception, and if both throw exceptions, add any exceptions thrown by the second as suppressed exceptions of the first. Given two SegmentCompletionListener, return a SegmentCompletionListener that executes both in sequence, even if the first throws an exception, and if both throw exceptions, add any exceptions thrown by the second as suppressed exceptions of the first. If <code>usePrimary</code> is true the segments are the primary segments but only those that exist in targetSegments.  However if <code>usePrimary</code> is false then <code>targetSegments</code> must be provided and non null and this will be used specifically.

Copied from AbstractCollection to support toArray methods Copied from AbstractCollection to support toArray methods Copied from AbstractCollection since we need to close iterator Copied from AbstractCollection since we need to close iterator Copied from AbstractCollection since we need to close iterator





Constructs a component.
Blocks until the current cache instance is in its {@link org.infinispan.lifecycle.ComponentStatus#RUNNING started} phase. Blocks for up to {@link org.infinispan.configuration.cache.StateTransferConfiguration#timeout()} milliseconds, throwing an IllegalStateException if the cache doesn't reach this state even after this maximum wait time. Retrieves a component of a specified type from the registry, or null if it cannot be found. Retrieves the configuration component. Retrieves a component factory instance capable of constructing components of a specified type.  If the factory doesn't exist in the registry, one is created. Retrieves a component if one exists, and if not, attempts to find a factory capable of constructing the component (factories annotated with the {@link DefaultFactoryFor} annotation that is capable of creating the component class). <p/> If an instance needs to be constructed, dependencies are then automatically wired into the instance, based on methods on the component type annotated with {@link Inject}. <p/> Summing it up, component retrieval happens in the following order:<br /> 1.  Look for a component that has already been created and registered. 2.  Look for an appropriate component that exists in the {@link Configuration} that may be injected from an external system. 3.  Look for a class definition passed in to the {@link Configuration} - such as an EvictionPolicy implementation 4.  Attempt to create it by looking for an appropriate factory (annotated with {@link DefaultFactoryFor}) <p/> Returns an immutable set containing all the components that exists in the repository at this moment. Retrieves the state of the registry ------------------------------ END: Publicly available lifecycle methods ----------------------------- ------------------------------ START: Actual internal lifecycle methods -------------------------------- Sets the cacheStatus to FAILED and re-throws the problem as one of the declared types. Converts any non-RuntimeException Exception to CacheException. No such thing as a meta factory yet.  Factories are created using this method which attempts to use an empty public constructor. Actual stop ------------------------------ END: Actual internal lifecycle methods -------------------------------- Asserts whether invocations are allowed on the cache or not.  Returns <tt>true</tt> if invocations are to be allowed, <tt>false</tt> otherwise.  If the origin of the call is remote and the cache status is {@link org.infinispan.lifecycle.ComponentStatus#INITIALIZING}, this method will block for up to {@link org.infinispan.configuration.cache.StateTransferConfiguration#timeout()} millis, checking for a valid state. Scans each registered component for lifecycle methods, and adds them to the appropriate lists, and then sorts them by priority. Registers a component in the registry under the given type, and injects any dependencies needed.  If a component of this type already exists, it is overwritten. Registers the default class loader.  This method *must* be called before any other components are registered, typically called by bootstrap code.  Defensively, it is called in the constructor of ComponentRegistry with a null parameter. registers a special "null" component that has no dependencies. Removes any components not annotated as @SurvivesRestarts. Rewires components.  Used to rewire components in the CR if a cache has been stopped (moved to state TERMINATED), which would (almost) empty the registry of components.  Rewiring will re-inject all dependencies so that the cache can be started again. <p/> ------------------------------ START: Publicly available lifecycle methods ----------------------------- These methods perform a check for appropriate transition and then delegate to similarly named internal methods. This starts the components in the registry, connecting to channels, starting service threads, etc.  If the component is not in the {@link org.infinispan.lifecycle.ComponentStatus#INITIALIZING} state, it will be initialized first. Stops the component and sets its status to {@link org.infinispan.lifecycle.ComponentStatus#TERMINATED} once it is done.  If the component is not in the {@link org.infinispan.lifecycle.ComponentStatus#RUNNING} state, this is a no-op. Get the component from a wrapper, properly handling <code>null</code> components. Wires an object instance with dependencies annotated with the {@link Inject} annotation, creating more components as needed based on the Configuration passed in if these additional components don't exist in the {@link ComponentRegistry}.  Strictly for components that don't otherwise live in the registry and have a lifecycle, such as Commands.

Adds all elements from <code>src</code> list that do not already exist in <code>dest</code> list to the latter.

Arbitrary value, only need to start after JGroupsTransport Need to stop before the JGroupsTransport
method invoked after a successful remote invocation. method invoked before a remote invocation.











These are methods that convert to a different AbstractDelegating*CacheStream




Actual DoubleStream operations These are methods that convert to a different AbstractDelegating*CacheStream These are methods that should delegate to the original cache stream


Invoked after the command is handled. Invoked before the command is handled by the real {@link org.infinispan.remoting.inboundhandler.PerCacheInboundInvocationHandler}.
Actual IntStream operations These are methods that convert to a different AbstractDelegating*CacheStream These are methods that should delegate to the original cache stream

Actual LongStream operations These are methods that convert to a different AbstractDelegating*CacheStream These are methods that should delegate to the original cache stream



method invoked after a successful backup remote invocation. method invoked after a successful remote invocation. method invoked before a backup remote invocation. method invoked before a remote invocation.


Sets the {@link ConfigurationBuilder} to use when creating an <code>EmbeddedCacheManager</code>. Sets the {@link GlobalConfigurationBuilder} to use when creating an <code>EmbeddedCacheManager</code>. ------------------------------------------------------------------------ Create fully configured EmbeddedCacheManager instance ------------------------------------------------------------------------ ------------------------------------------------------------------------ Setter for location of configuration file ------------------------------------------------------------------------ <p> Sets the {@link org.springframework.core.io.Resource <code>location</code>} of the configuration file which will be used to configure the {@link org.infinispan.manager.EmbeddedCacheManager <code>EmbeddedCacheManager</code>} the {@link org.infinispan.spring.provider.SpringEmbeddedCacheManager <code>SpringEmbeddedCacheManager</code>} created by this <code>FactoryBean</code> delegates to. If no location is supplied, <tt>Infinispan</tt>'s default configuration will be used. </p> <p> Note that configuration settings defined via using explicit setters exposed by this <code>FactoryBean</code> take precedence over those defined in the configuration file pointed to by <code>configurationFileLocation</code>. </p>

Invoked by TransactionManagers, make sure it's an efficient implementation. System.identityHashCode(x) is NOT an efficient implementation.



Looks up the file, see : {@link DefaultFileLookup}. Looks up the file, see : {@link DefaultFileLookup}.











Returns session with optional parameter whether or not update time accessed.



Derived classes must call init() in their @Inject methods, to keep only one @Inject method per class.
This method is not supported and should not be used. Use cache.remove() instead.

TODO: these were initially package-level TODO: these were initially package-level TODO: these were initially package-level TODO: was package-level initially TODO: was package-level initially

Avoid weak references to this cache manager being garbage collected without being shutdown.





Use the specified {@link ConnectionFactory} to handle connection to the database Use the specified {@link ConnectionFactoryConfigurationBuilder} to configure connections to the database



Registers a set of MBean components and returns true if successfully registered; false otherwise.


[header][key length][key][lifespan][max idle][value length][value]
Creates a keytab file for given principal. Creates a default "ldap/${host}@INFINISPAN.ORG" server keytab. it can be overridden if you want to use another SPN, password or keytab file location (or do more magic here). Returns an absolute path to a keytab with JBoss AS credentials (ldap/${host}@INFINISPAN.ORG). Returns an absolute path to krb5.conf file. Private methods ------------------------------------------------------- Returns comma-separated list of JDK-supported encryption type names for use in krb5.conf. Public methods --------------------------------------------------------  Removes working directory with Kerberos related generated files.
Removes all listeners from the notifier Tests if a class is properly annotated as a CacheListener and returns the Listener annotation. Loops through all valid methods on the object passed in, and caches the relevant methods as {@link ListenerInvocation} for invocation by reflection. The builder provided will be used to create the listener invocations.  This method will set the target, subject sync, and methods as needed.  If other values are needed to be set they should be invoked before passing to this method.


We need this method in here because of putForExternalRead
The normal bit spreader...
This method implements {@link StreamingMarshaller#objectFromInputStream(java.io.InputStream)}, but its implementation has been moved here rather that keeping under a class that implements StreamingMarshaller in order to avoid code duplication. This is a convenience method for converting an object into a {@link org.infinispan.io.ByteBuffer} which takes an estimated size as parameter. A {@link org.infinispan.io.ByteBuffer} allows direct access to the byte array with minimal array copying

missing cas unique value NOTE: This is randomly failing test on various platforms.





Needs to be overwritten in test class, which should add annotation @OperateOnDeployment(getJoiningNodeName())







the following property is passed to the server at startup so that this test passes: -Dorg.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH=true


------------------------------------------------------------------------ Setters for configuring RemoteCacheManager ------------------------------------------------------------------------
creates a configuration with the same values as the hotrod-client.properties files, in ISPN 6.X.Y hotrod-client.properties file will be dropped Tests the load balancing feature Checks that a custom load balancing strategy, Node0Only, will cycle through the server list as operations are executed. NOTE: the default properties have a server list of node0/node1. Tests the constructor RemoteCacheManager() - the properties file hotrod-client.properties from classpath is used to define properties - confirm that the file hotrod-client.properties is picked up Tests the load balancing feature Checks that the default load balancing strategy, RoundRobin, will cycle through the server list as operations are executed. For each operation executed, we would need to obtain its Transport and call getServerAddress() to discover which address was used, but this is difficult to arrange. So instead, we simulate by making repeated calls to TransportFactory.getTransport()

Implement Callable for the timeout task Override complete(), completeExceptionally(), and cancel() to cancel the timeout task and remove the request from the map Called when the timeout task scheduled with {@link #setTimeout(ScheduledExecutorService, long, TimeUnit)} expires. Schedule a timeout task on the given executor, and complete the request with a {@link org.infinispan.util.concurrent.TimeoutException} when the task runs. If a timeout task was already registered with this request, it is cancelled.




Creates authenticaton=>jaspi node and its child nodes. Creates a {@link ModelNode} with the security component configuration. If the securityConfigurations array is empty or null, then null is returned.



Adds the member with an offline connection to the site. Adds the element with an online connection to the site.

Configuration for the async cache loader. If enabled, this provides you with asynchronous writes to the cache store, giving you 'write-behind' caching. If true, fetch persistent state when joining a cluster. If multiple cache stores are chained, only one of them can have this property enabled. Persistent state transfer with a shared cache store does not make sense, as the same persistent store that provides the data will just end up receiving it. Therefore, if a shared cache store is used, the cache will not allow a persistent state transfer even if a cache store has this property set to true. If true, any operation that modifies the cache (put, remove, clear, store...etc) won't be applied to the cache store. This means that the cache store could become out of sync with the cache. If true, purges this cache store when it starts up. SingletonStore is a delegating store used for situations when only one instance in a cluster should interact with the underlying store. The coordinator of the cluster will be responsible for the underlying CacheStore. SingletonStore is a simply facade to a real CacheStore implementation. It always delegates reads to the real CacheStore.
{@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } If true, purges this cache store when it starts up. {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc }


Extracts and validates the value after a read. <p> Any exception should be thrown using {@link CompletionException}. Retrieves and validate the value after a read. Initializes the weak value. Registers this instance as a cluster listener. <p> Note: It must be invoked when initialize the instance.



"Denormalize" the segments - for each hash segment, find numOwners integer values that map on the hash wheel to the interval [segmentIdx*segmentSize, segmentIdx*segmentSize+leeway], leeway being hardcoded on the first line of the function TODO This relies on implementation details (segment layout) of DefaultConsistentHash, and won't work with any other CH

This is what is returned to remote callers when an invalid RemoteTransaction is encountered.  Can happen if a remote node propagates a transactional call to the current node, and the current node has no idea of the transaction in question.  Can happen during rehashing, when ownerships are reassigned during a transactions. Returning a null usually means the transactional command succeeded.




Besides acquiring a lock, this method also handles the following situation: 1. consistentHash("k") == {A, B}, tx1 prepared on A and B. Then node A crashed (A  == single lock owner) 2. at this point tx2 which also writes "k" tries to prepare on B. 3. tx2 has to determine that "k" is already locked by another tx (i.e. tx1) and it has to wait for that tx to finish before acquiring the lock. The algorithm used at step 3 is: - the transaction table(TT) associates the current topology id with every remote and local transaction it creates - TT also keeps track of the minimal value of all the topology ids of all the transactions still present in the cache (minTopologyId) - when a tx wants to acquire lock "k": - if tx.topologyId > TT.minTopologyId then "k" might be a key whose owner crashed. If so: - obtain the list LT of transactions that started in a previous topology (txTable.getTransactionsPreparedBefore) - for each t in LT: - if t wants to write "k" then block until t finishes (CacheTransaction.waitForTransactionsToFinishIfItWritesToKey) - only then try to acquire lock on "k" - if tx.topologyId == TT.minTopologyId try to acquire lock straight away. Note: The algorithm described below only when nodes leave the cluster, so it doesn't add a performance burden when the cluster is stable. Same as {@link #lockOrRegisterBackupLock(TxInvocationContext, Object, long)} The backup (non-primary) owners keep a "backup lock" for each key they received in a lock/prepare command. Normally there can be many transactions holding the backup lock at the same time, but when the secondary owner becomes a primary owner a new transaction trying to obtain the "real" lock will have to wait for all backup locks to be released. The backup lock will be released either by a commit/rollback/unlock command or by the originator leaving the cluster (if recovery is disabled).

This is invoked only on the receiving node, before {@link #perform(org.infinispan.context.InvocationContext)}.
A default handler for all commands visited.  This is called for any visit method called, unless a visit command is appropriately overridden. Helper method to visit a collection of VisitableCommands. tx commands write commands read commands




Called after an item has been inserted (after the transaction completes), instead of calling release(). This method is used by "asynchronous" concurrency strategies. Called after an item has been updated (after the transaction completes), instead of calling release().  This method is used by "asynchronous" concurrency strategies. Forcibly evict an item from the cache immediately without regard for transaction isolation. Forcibly evict all items from the cache immediately without regard for transaction isolation. Called after an item has been inserted (before the transaction completes), instead of calling evict(). Attempt to cache an object, after loading from the database. Attempt to cache an object, after loading from the database, explicitly specifying the minimalPut behavior. Called after an item has become stale (before the transaction completes). Called to evict data from the entire region Called when we have finished the attempted update/delete (which may or may not have been successful), after transaction completion.  This method is used by "asynchronous" concurrency strategies. Called after an item has been updated (before the transaction completes), instead of calling evict().






Adds a listener to be invoked when this action is ready or canceled. It checks this action. <p/> When {@link ActionStatus#READY} or {@link ActionStatus#CANCELED} are final states. <p/> This method should be thread safe and idempotent since it can be invoked multiple times by multiples threads. Invoked when an exception occurs while processing the command. Invoked always after the command is executed.
Invoked when an {@link Action} is completed.


Get number of activations executed. Remove key and associated value from cache store and update the activation counter. <p/> The key is also removed from the shared configured stores. Remove key and associated value from cache store and update the activation counter.
After the cache loader manager, before the passivation manager


Adds new alias to a LIST ModelNode of existing aliases. An attribute write handler which performs special processing for ALIAS attributes. Gets whether a {@link OperationContext.Stage#RUNTIME} handler should be added. This default implementation returns {@code true} if the {@link org.jboss.as.controller.OperationContext#getProcessType()}  process type} is as sever and {@link OperationContext#isBooting() context.isBooting()} returns {@code false}.




Attributes of the add operation. Extra parameters (not specified by {@link #getAttributes()}) for the add operation.











Adds a custom interceptor to the interceptor chain, at specified position, where the first interceptor in the chain is at position 0 and the last one at NUM_INTERCEPTORS - 1. Adds a custom interceptor to the interceptor chain, after an instance of the specified interceptor type. Throws a cache exception if it cannot find an interceptor of the specified type. Adds a custom interceptor to the interceptor chain, before an instance of the specified interceptor type. Throws a cache exception if it cannot find an interceptor of the specified type. Applies the given Delta to the DeltaAware object stored under deltaAwareValueKey if and only if all locksToAcquire locks are successfully obtained Identical to {@link Cache#entrySet()} but is typed to return CacheEntries instead of Entries.  Please see the other method for a description of its behaviors. <p> This method is needed since nested generics do not support covariance An overloaded form of {@link #compute(K, BiFunction)}, which takes in an instance of {@link Metadata} which can be used to provide metadata information for the entry being stored, such as lifespan, version of value...etc. Overloaded {@link #compute(Object, BiFunction, Metadata)} with {@link SerializableBiFunction} An overloaded form of {@link #computeIfAbsent(K, Function)}, which takes in an instance of {@link Metadata} which can be used to provide metadata information for the entry being stored, such as lifespan, version of value...etc. The {@link Metadata} is only stored if the call is successful. Overloaded {@link #computeIfAbsent(Object, Function, Metadata)} with {@link SerializableFunction} An overloaded form of {@link #computeIfPresent(K, BiFunction)}, which takes in an instance of {@link Metadata} which can be used to provide metadata information for the entry being stored, such as lifespan, version of value...etc. The {@link Metadata} is only stored if the call is successful. Overloaded {@link #computeIfPresent(Object, BiFunction, Metadata)} with {@link SerializableBiFunction} TODO: Even better: add replace/remove calls that apply the changes if a given function is successful That way, you could do comparison not only on the cache value, but also based on version...etc Gets a collection of entries, returning them as {@link Map} of the values associated with the set of keys requested. <p> If the cache is configured read-through, and a get for a key would return null because an entry is missing from the cache, the Cache's {@link CacheLoader} is called in an attempt to load the entry. If an entry cannot be loaded for a given key, the returned Map will contain null for value of the key. <p> Unlike other bulk methods if this invoked in an existing transaction all entries will be stored in the current transactional context <p> The returned {@link Map} will be a copy and updates to the map will not be reflected in the Cache and vice versa.  The keys and values themselves however may not be copies depending on if storeAsBinary is enabled and the value was retrieved from the local node. Gets a collection of entries from the {@link AdvancedCache}, returning them as {@link Map} of the cache entries associated with the set of keys requested. <p> If the cache is configured read-through, and a get for a key would return null because an entry is missing from the cache, the Cache's {@link CacheLoader} is called in an attempt to load the entry. If an entry cannot be loaded for a given key, the returned Map will contain null for value of the key. <p> Unlike other bulk methods if this invoked in an existing transaction all entries will be stored in the current transactional context <p> The returned {@link Map} will be a copy and updates to the map will not be reflected in the Cache and vice versa.  The keys and values themselves however may not be copies depending on if storeAsBinary is enabled and the value was retrieved from the local node. Executes an equivalent of {@link Map#putAll(Map)}, returning previous values of the modified entries. Allows the modification of the interceptor chain. Experimental: The ability to modify the interceptors at runtime may be removed in future versions. Retrieves the {@link AuthorizationManager} if the cache has security enabled. Otherwise returns null Returns the cache's availability. In local mode this method will always return {@link AvailabilityMode#AVAILABLE}. In clustered mode, the {@link PartitionHandlingManager} is queried to obtain the availability mode. Returns the component in charge of batching cache operations. Retrieves a CacheEntry corresponding to a specific key. Returns the cache loader associated associated with this cache.  As an alternative to setting this on every invocation, users could also consider using the {@link DecoratedCache} wrapper.  Returns the container where data is stored in the cache. Users should interact with this component with care because direct calls on it bypass the internal interceptors and other infrastructure in place to guarantee the consistency of data. Retrieves a reference to the {@link org.infinispan.distribution.DistributionManager} if the cache is configured to use Distribution.  Otherwise, returns a null.   It fetches all the keys which belong to the group. <p/> Semantically, it iterates over all the keys in memory and persistence, and performs a read operation in the keys found. Multiple invocations inside a transaction ensures that all the keys previous read are returned and it may return newly added keys to the group from other committed transactions (also known as phantom reads). <p/> The {@code map} returned is immutable and represents the group at the time of the invocation. If you want to add or remove keys from a group use {@link #put(Object, Object)} and {@link #remove(Object)}. To remove all the keys in the group use {@link #removeGroup(String)}. <p/> To improve performance you may use the {@code flag} {@link org.infinispan.context.Flag#SKIP_CACHE_LOAD} to avoid fetching the key/value from persistence. However, you will get an inconsistent snapshot of the group.  Returns the component in charge of managing the interactions between the cache operations and the context information associated with them.    Returns the component that deals with all aspects of acquiring and releasing locks for cache entries. Returns the component in charge of communication with other caches in the cluster.  If the cache's {@link org.infinispan.configuration.cache.ClusteringConfiguration#cacheMode()} is {@link org.infinispan.configuration.cache.CacheMode#LOCAL}, this method will return null. Returns a {@link Stats} object that allows several statistics associated with this cache at runtime. Returns the transaction manager configured for this cache. If no transaction manager was configured, this method returns null.    Returns the {@link XAResource} associated with this cache which can be used to do transactional recovery. Locks a given key or keys eagerly across cache nodes in a cluster. <p> Keys can be locked eagerly in the context of a transaction only. Locks collections of keys eagerly across cache nodes in a cluster. <p> Collections of keys can be locked eagerly in the context of a transaction only. Whenever this cache acquires a lock it will do so using the given Object as the owner of said lock. <p> This can be useful when a lock may have been manually acquired and you wish to reuse that lock across invocations. <p> Great care should be taken with this command as misuse can very easily lead to deadlocks. Returns a sequential stream using this Cache as the source. This stream is very similar to using the {@link CacheStream} returned from the {@link CacheSet#stream()} method of the collection returned via {@link AdvancedCache#cacheEntrySet()}. The use of this locked stream is that when an entry is being processed by the user the entry is locked for the invocation preventing a different thread from modifying it. <p> Note that this stream is not supported when using a optimistic transactional or simple cache. Both non transactional and pessimistic transactional caches are supported. <p> The stream will not share any ongoing transaction the user may have. Code executed by the stream should be treated as completely independent. That is any operation performed via the stream will require the user to start their own transaction or will be done intrinsically on the invocation. Note that if there is an ongoing transaction that has a lock on a key from the cache, that it will cause a deadlock. <p> Currently simple cache, {@link org.infinispan.configuration.cache.ConfigurationBuilder#simpleCache(boolean)} was set to true, and optimistic caches, {@link org.infinispan.configuration.cache.TransactionConfigurationBuilder#lockingMode(LockingMode)} was set to {@link LockingMode#OPTIMISTIC}, do not support this method. In this case it will throw an {@link UnsupportedOperationException}. This restriction may be removed in a future version. Also this method cannot be used on a cache that has a lock owner already specified via {@link AdvancedCache#lockAs(Object)} as this could lead to a deadlock or the release of locks early and will throw an {@link IllegalStateException}. An overloaded form of {@link #merge(Object, Object, BiFunction)}, which takes in an instance of {@link Metadata} which can be used to provide metadata information for the entry being stored, such as lifespan, version of value...etc. The {@link Metadata} is only stored if the call is successful. Overloaded {@link #merge(Object, Object, BiFunction, Metadata)} with {@link SerializableBiFunction} An overloaded form of {@link #put(K, V)}, which takes in an instance of {@link org.infinispan.metadata.Metadata} which can be used to provide metadata information for the entry being stored, such as lifespan, version of value...etc. An overloaded form of {@link #putAll(Map)}, which takes in an instance of {@link org.infinispan.metadata.Metadata} which can be used to provide metadata information for the entries being stored, such as lifespan, version of value...etc. Asynchronous version of {@link #put(Object, Object, Metadata)} which stores metadata alongside the value.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #put(Object, Object, Metadata)} if used in LOCAL mode. <p/> An overloaded form of {@link #putForExternalRead(K, V)}, which takes in an instance of {@link Metadata} which can be used to provide metadata information for the entry being stored, such as lifespan, version of value...etc. The {@link Metadata} is only stored if the call is successful. An overloaded form of {@link #putIfAbsent(K, V)}, which takes in an instance of {@link Metadata} which can be used to provide metadata information for the entry being stored, such as lifespan, version of value...etc. The {@link Metadata} is only stored if the call is successful. Attempts to remove the entry if it is expired.  Due to expired entries not being consistent across nodes, this will still attempt to remove the value if it is not present.  Note that this will raise an expired event even if the entry is not present.  Normally this method should never be invoked except by the {@link ExpirationManager}. <p> This command will only remove the value if the value and lifespan also match if provided. <p> NOTE: This method may be removed at any point including in a minor release and is not supported for external usage. It removes all the key which belongs to a group. <p/> Semantically, it fetches the most recent group keys/values and removes them. <p/> Note that, concurrent addition perform by other transactions/threads to the group may not be removed. Removes the interceptor at a specified position, where the first interceptor in the chain is at position 0 and the last one at getInterceptorChain().size() - 1. Removes the interceptor of specified type. An overloaded form of {@link #replace(K, V, V)}, which takes in an instance of {@link Metadata} which can be used to provide metadata information for the entry being stored, such as lifespan, version of value...etc. The {@link Metadata} is only stored if the call is successful. An overloaded form of {@link #replace(K, V)}, which takes in an instance of {@link Metadata} which can be used to provide metadata information for the entry being stored, such as lifespan, version of value...etc. The {@link Metadata} is only stored if the call is successful. Manually change the availability of the cache. Doesn't change anything if the cache is not clustered or {@link PartitionHandlingConfiguration#whenSplit() is set to {@link org.infinispan.partitionhandling.PartitionHandling#ALLOW_READ_WRITES} Using this operation, users can call any {@link AdvancedCache} operation with a given {@link ClassLoader}. This means that any {@link ClassLoader} happening as a result of the cache operation will be done using the {@link ClassLoader} given. For example: <p /> When users store POJO instances in caches configured with {@link org.infinispan.configuration.cache.StoreAsBinaryConfiguration}, these instances are transformed into byte arrays. When these entries are read from the cache, a lazy unmarshalling process happens where these byte arrays are transformed back into POJO instances. Using {@link AdvancedCache#with(ClassLoader)} when reading that enables users to provide the class loader that should be used when trying to locate the classes that are constructed as a result of the unmarshalling process. <pre> cache.with(classLoader).get(key); </pre> <b>Note</b> that for the flag to take effect, the cache operation <b>must</b> be invoked on the instance returned by this method. <p /> As an alternative to setting this on every invocation, users could also consider using the {@link DecoratedCache} wrapper, as this allows for more readable code.  E.g.: <pre> Cache classLoaderSpecificCache = new DecoratedCache(cache, classLoader); classLoaderSpecificCache.get(key1); classLoaderSpecificCache.get(key2); classLoaderSpecificCache.get(key3); </pre> Performs any cache operations using the specified {@link Encoder}. Performs any cache operations using the specified pair of {@link Encoder}. A method that adds flags to any API call.  For example, consider the following code snippet: <pre> cache.withFlags(Flag.FORCE_WRITE_LOCK).get(key); </pre> will invoke a cache.get() with a write lock forced. <p /> <b>Note</b> that for the flag to take effect, the cache operation <b>must</b> be invoked on the instance returned by this method. <p /> As an alternative to setting this on every invocation, users could also consider using the {@link DecoratedCache} wrapper, as this allows for more readable code.  E.g.: <pre> Cache forceWriteLockCache = new DecoratedCache(cache, Flag.FORCE_WRITE_LOCK); forceWriteLockCache.get(key1); forceWriteLockCache.get(key2); forceWriteLockCache.get(key3); </pre> Performs any cache operations using the specified {@link Subject}. Only applies to caches with authorization enabled (see {@link ConfigurationBuilder#security()}). Performs any cache operations using the specified {@link Wrapper}. Performs any cache operations using the specified pair of {@link Wrapper}.
Using the thread in the pool, removed all the expired data from the persistence storage. For each removed entry, the supplied listener is invoked.  This should be preferred to {@link AdvancedCacheWriter#purge(Executor, PurgeListener)} since it allows for value and metadata to be provided which provides more accurate expiration when coordination is required.
Iterates in parallel over the entries in the storage using the threads from the <b>executor</b> pool. For each entry the {@link CacheLoaderTask#processEntry(MarshalledEntry, TaskContext)} is invoked. Before passing an entry to the callback task, the entry should be validated against the <b>filter</b>. Implementors should build an {@link TaskContext} instance (implementation) that is fed to the {@link CacheLoaderTask} on every invocation. The {@link CacheLoaderTask} might invoke {@link org.infinispan.persistence.spi.AdvancedCacheLoader.TaskContext#stop()} at any time, so implementors of this method should verify TaskContext's state for early termination of iteration. The method should only return once the iteration is complete or as soon as possible in the case TaskContext.stop() is invoked. Returns the number of elements in the store.


Removes all the data from the storage. Using the thread in the pool, removed all the expired data from the persistence storage. For each removed entry, the supplied listener is invoked. <p> When this method returns all entries will be purged and no tasks will be running due to this loader in the provided executor.  If however an exception is thrown there could be tasks still pending or running in the executor.

Returns an integer that identifies the externalizer type. This is used at read time to figure out which {@link AdvancedExternalizer} should read the contents of the incoming buffer. Using a positive integer allows for very efficient variable length encoding of numbers, and it's much more efficient than shipping {@link AdvancedExternalizer} implementation class information around. Negative values are not allowed. Implementers of this interface can use any positive integer as long as it does not clash with any other identifier in the system.  You can find information on the pre-assigned identifier ranges in <a href="http://infinispan.org/docs/dev/user_guide/user_guide.html#preassigned_externalizer_id_ranges">here</a>. It's highly recommended that maintaining of these identifiers is done in a centralized way and you can do so by making annotations reference a set of statically defined identifiers in a separate class or interface.  Such class/interface gives a global view of the identifiers in use and so can make it easier to assign new ids. Implementors can optionally avoid giving a meaningful implementation to this method (i.e. return null) and instead rely on XML or programmatic configuration to provide the AdvancedExternalizer id.  If no id can be determined via the implementation or XML/programmatic configuration, an error will be reported.  If an id has been defined both via the implementation and XML/programmatic configuration, the value defined via XML/programmatic configuration will be used ignoring the other. Returns a collection of Class instances representing the types that this AdvancedExternalizer can marshall.  Clearly, empty sets are not allowed. The externalizer framework currently requires all individual types to be listed since it does not make assumptions based on super classes or interfaces.








This numeric id is used exclusively for storage affinity in Infinispan.

























Add an annotation to the type declaration. Add an annotation to the specified field. If the field is not already present, it will be added. Add an annotation to the specified field. If the field is not already present, it will be added. Add an annotation to the specified method. If the method is not already present, it will be added. Add an annotation to the specified method. If the method is not already present, it will be added. Add an annotation to the specified method parameter. If the method is not already present, it will be added. If the method parameter is not already present, it will be added. Create an {@link AnnotatedType}. Any public members present on the underlying class and not overridden by the builder will be automatically added. Reads the annotations from an existing java type. Annotations already present will be overwritten Reads the annotations from an existing java type. If overwrite is true then existing annotations will be overwritten Reads in from an existing AnnotatedType. Any elements not present are added. The javaClass will be read in. If the annotation already exists on that element in the builder the read annotation will be used. Reads in from an existing AnnotatedType. Any elements not present are added. The javaClass will be read in if overwrite is true. If the annotation already exists on that element in the builder, overwrite determines whether the original or read annotation will be used. Remove an annotation from the type Remove an annotation from the specified field. Remove an annotation from the specified field. Remove an annotation from the specified method. Remove an annotation from the specified method. Remove an annotation from the specified method parameter.

Generates a deterministic signature for an {@link AnnotatedCallable}. Two <code>AnnotatedCallable</code>s that have the same annotations and underlying callable will generate the same signature. Creates a deterministic signature for a {@link Field}. Generates a deterministic signature for an {@link AnnotatedField}. Two <code>AnnotatedField</code>s that have the same annotations and underlying field will generate the same signature. Creates a string representation of a given type and set of annotations. Creates a string representation of an {@link AnnotatedParameter}. Generates a unique string representation of a list of {@link AnnotatedParameter}s. Generates a unique signature for a concrete class. Annotations are not read directly from the class, but are read from the <code>annotations</code>, <code>methods</code>, <code>fields</code> and <code>constructors</code> arguments Generates a deterministic signature for an {@link AnnotatedType}. Two <code>AnnotatedType</code>s that have the same annotations and underlying type will generate the same signature. <p/> This can be used to create a unique bean id for a passivation capable bean that is added directly through the SPI.











Performs an application of delta on a specified entry






Create a set from an array. If the array contains duplicate objects, the last object in the array will be placed in resultant set.





Asynchronous version of {@link #clear()}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #clear()} if used in LOCAL mode. Asynchronous version of {@link #get(Object)} that allows user code to retrieve the value associated with a key at a later stage, hence allowing multiple parallel get requests to be sent. Normally, when this method detects that the value is likely to be retrieved from from a remote entity, it will span a different thread in order to allow the asynchronous get call to return immediately. If the call will definitely resolve locally, for example when the cache is configured with LOCAL mode and no stores are configured, the get asynchronous call will act sequentially and will have no different to {@link #get(Object)}. Asynchronous version of {@link #putAll(Map)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #putAll(Map)} if used in LOCAL mode. Asynchronous version of {@link #putAll(Map, long, TimeUnit)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #putAll(Map, long, TimeUnit)} if used in LOCAL mode. Asynchronous version of {@link #putAll(Map, long, TimeUnit, long, TimeUnit)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #putAll(Map, long, TimeUnit, long, TimeUnit)} if used in LOCAL mode. Asynchronous version of {@link #put(Object, Object)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #put(Object, Object)} if used in LOCAL mode. <p/> Asynchronous version of {@link #put(Object, Object, long, TimeUnit)} .  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #put(Object, Object, long, TimeUnit)} if used in LOCAL mode. Asynchronous version of {@link #put(Object, Object, long, TimeUnit, long, TimeUnit)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #put(Object, Object, long, TimeUnit, long, TimeUnit)} if used in LOCAL mode. Asynchronous version of {@link #putIfAbsent(Object, Object)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #putIfAbsent(Object, Object)} if used in LOCAL mode. <p/> Asynchronous version of {@link #putIfAbsent(Object, Object, long, TimeUnit)} .  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #putIfAbsent(Object, Object, long, TimeUnit)} if used in LOCAL mode. Asynchronous version of {@link #putIfAbsent(Object, Object, long, TimeUnit, long, TimeUnit)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #putIfAbsent(Object, Object, long, TimeUnit, long, TimeUnit)} if used in LOCAL mode. Asynchronous version of {@link #remove(Object)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #remove(Object)} if used in LOCAL mode. Asynchronous version of {@link #remove(Object, Object)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #remove(Object, Object)} if used in LOCAL mode. Asynchronous version of {@link #replace(Object, Object)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #replace(Object, Object)} if used in LOCAL mode. Asynchronous version of {@link #replace(Object, Object, Object)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #replace(Object, Object, Object)} if used in LOCAL mode. Asynchronous version of {@link #replace(Object, Object, Object, long, TimeUnit)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #replace(Object, Object, Object, long, TimeUnit)} if used in LOCAL mode. Asynchronous version of {@link #replace(Object, Object, Object, long, TimeUnit, long, TimeUnit)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #replace(Object, Object, Object, long, TimeUnit, long, TimeUnit)} if used in LOCAL mode. Asynchronous version of {@link #replace(Object, Object, long, TimeUnit)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #replace(Object, Object, long, TimeUnit)} if used in LOCAL mode. Asynchronous version of {@link #replace(Object, Object, long, TimeUnit, long, TimeUnit)}.  This method does not block on remote calls, even if your cache mode is synchronous.  Has no benefit over {@link #replace(Object, Object, long, TimeUnit, long, TimeUnit)} if used in LOCAL mode.



Sets up the interceptor. Do not call explicitly. Perform some work for a command invocation. The interceptor is responsible for invoking the next interceptor in the chain, using {@link BaseAsyncInterceptor#invokeNext(InvocationContext, VisitableCommand)} or the other methods in {@link BaseAsyncInterceptor}.
Inserts the given interceptor at the specified position in the chain (0 based indexing). Adds a new interceptor in list after an interceptor of a given type. Adds a new interceptor in list before an interceptor of a given type. Appends at the end. Checks whether the chain contains the supplied interceptor instance. Checks whether the chain contains an interceptor with the given class. Checks whether the chain contains an interceptor with the given class, or a subclass. Returns the first interceptor extending the given class, or {@code null} if there is none. Returns the first interceptor with the given class, or {@code null} if there is none.  Walks the command through the interceptor chain. The received ctx is being passed in. <p>Note: Reusing the context for multiple invocations is allowed, however most context implementations are not thread-safe.</p> Walks the command through the interceptor chain. The received ctx is being passed in. Removes the interceptor at the given position. Removes all the occurrences of supplied interceptor type from the chain. Replaces an existing interceptor of the given type in the interceptor chain with a new interceptor instance passed as parameter. Returns the number of interceptors in the chain.
Ensures that the interceptor of type passed in isn't already added
If true, all modifications to this cache store happen asynchronously, on a separate thread. Unused Unused Sets the size of the modification queue for the async store. If updates are made at a rate that is faster than the underlying cache store can process this queue, then the async store behaves like a synchronous store for that period, blocking until the queue can accept more elements. Unused Unused Size of the thread pool whose threads are responsible for applying the modifications.
If true, all modifications to this cache store happen asynchronously, on a separate thread. Unused. Unused. Sets the size of the modification queue for the async store. If updates are made at a rate that is faster than the underlying cache store can process this queue, then the async store behaves like a synchronous store for that period, blocking until the queue can accept more elements. Unused. Unused. Size of the thread pool whose threads are responsible for applying the modifications.
Indicates that this service should *not* be started asynchronously. Indicates that this service should *not* be stopped asynchronously.



Retrieves an atomic map from a given cache, stored under a given key.  If an atomic map did not exist, one is created and registered in an atomic fashion. Retrieves an atomic map from a given cache, stored under a given key. Retrieves a fine grained atomic map from a given cache, stored under a given key. If a fine grained atomic map did not exist, one is created and registered in an atomic fashion. Retrieves an atomic map from a given cache, stored under a given key. Retrieves an atomic map from a given cache, stored under a given key. Retrieves an atomic map from a given cache, stored under a given key, for reading only.  The atomic map returned will not support updates, and if the map did not in fact exist, an empty map is returned. Removes the atomic map associated with the given key from the underlying cache.

Remove the object stored at <i>key</i>from the local state. If flag <i>keepPersistent</i> is set, a persistent copy of the current state of the object is also stored in the cache. Returns an atomic object of class <i>clazz</i>. The class of this object must be initially serializable, as well as all the parameters of its methods. Furthermore, the class must be deterministic. Returns an object of class <i>clazz</i>. The class of this object must be initially serializable, as well as all the parameters of its methods. Furthermore, the class must be deterministic. The object is atomic if <i>withReadOptimization</i> equals false; otherwise it is sequentially consistent.. In more details, if <i>withReadOptimization</i>  is set, every call to the object is first executed locally on a copy of the object, and in case the call does not modify the state of the object, the value returned is the result of this tentative execution. Returns an object of class <i>clazz</i>. The class of this object must be initially serializable, as well as all the parameters of its methods. Furthermore, the class must be deterministic. The object is atomic if <i>withReadOptimization</i> equals false; otherwise it is sequentially consistent.. In more details, if <i>withReadOptimization</i>  is set, every call to the object is executed locally on a copy of the object, and in case the call does not modify the state of the object, the value returned is the result of this tentative execution. If the method <i>equalsMethod</i>  is not null, it overrides the default <i>clazz.equals()</i> when testing that the state of the object and its copy are identical.







Add a child node. If the child already exists it just increments its usage counter and returns the existing child.  Decrement the usage counter of a child node and remove it if no usages remain. The removal works recursively up the path to the root.
Returns the named attribute Returns the attribute identified by the supplied {@link AttributeDefinition} Returns whether this attribute set contains the specified named attribute Returns whether this set contains the specified attribute definition Returns whether any attributes in this set have been modified Returns whether this attribute set is protected Returns a new ValueSet where immutable {@link Attribute}s are write-protected Copies all attribute from another AttributeSet Writes the attributes of this attributeset as part of the current element Writes this attributeset to the specified XMLStreamWriter as an element Writes the specified attributes in this attributeset to the specified XMLStreamWriter as an element Writer a single attribute to the specified {@link XMLStreamWriter} using the attribute's xmlName Writer a single attribute to the specified {@link XMLStreamWriter} using the supplied name Writer a single attribute to the specified {@link XMLStreamWriter} using the supplied name









Specifies a {@link CallbackHandler} to be used during the authentication handshake. The {@link Callback}s that need to be handled are specific to the chosen SASL mechanism. Sets the client subject, necessary for those SASL mechanisms which require it to access client credentials (i.e. GSSAPI) Disables authentication Enables authentication Configures whether authentication should be enabled or not Specifies the password to be used for authentication. A username is also required Specifies the password to be used for authentication. A username is also required Specifies the realm to be used for authentication. Username and password also need to be supplied. Selects the SASL mechanism to use for the connection to the server Sets the SASL properties Sets the SASL QOP property. If multiple values are specified they will determine preference order Sets the SASL strength property. If multiple values are specified they will determine preference order Sets the name of the server as expected by the SASL protocol Specifies the username to be used for authentication. This will use a simple CallbackHandler. This is mutually exclusive with explicitly providing the CallbackHandler



Challenges specific {@link InfinispanRequest} for authentication.




Verifies that the {@link Subject} has the requested permission. A {@link SecurityException} is thrown otherwise. Verifies that the {@link Subject} has the requested permission and role. A {@link SecurityException} is thrown otherwise. Verifies that the {@link Subject} associated with the current {@link AccessControlContext} has the requested permission. A {@link SecurityException} is thrown otherwise. Verifies that the {@link Subject} associated with the current {@link AccessControlContext} has the requested permission and role. A {@link SecurityException} is thrown otherwise.









Called when the cluster view changed (e.g. because one or more nodes left abruptly). Called when a node leaves gracefully. Called when a node joins. Called when the administrator manually changes the availability status. Called when two or more partitions merge, to compute the stable and current cache topologies for the merged cluster. Called when a rebalance ends. Can be used to re-assess the state of the cache and apply pending changes.
The members of the cache. Includes nodes which have tried to join the cache but are not yet part of the current {@code CacheTopology}. Does not include nodes which have left the cluster (either gracefully or abruptly) but are still in the current topology. Whenever a new cache topology without a {@code pendingCH} and with at least {@code numOwners} owners for each segment is installed, and the cache is {@link AvailabilityMode#AVAILABLE}, the current cache topology is marked as the stable topology. The same happens when a rebalance is scheduled to start, but it doesn't do anything because the current topology is already balanced. Queue (or start) a rebalance. Use the configured {@link ConsistentHashFactory} to create a new balanced consistent hash with the given members. If there is no rebalance in progress, start a rebalance right away. If there is a rebalance in progress, queue another rebalance. If there is a rebalance in the queue as well, it will be replaced with the new one. If {@code newConsistentHash == null}, remove any queued rebalance. Enter a new availability mode. Use the configured {@link ConsistentHashFactory} to create a new CH with the given {@code members}, but do not start a rebalance. Members missing from the current topology are ignored. Updates both the stable and the current topologies. Does not install the current topology on the cache members.






If the failure policy is set to {@link BackupFailurePolicy#CUSTOM} then the failurePolicyClass is required and should return the fully qualified name of a class implementing {@link org.infinispan.xsite.CustomFailurePolicy} Returns the name of the site where this cache backups its data. How does the backup happen: sync or async.
Configures how the system behaves when the backup call fails. Only applies to sync backups. The default values is  {@link org.infinispan.configuration.cache.BackupFailurePolicy#WARN} Configures whether this site is used for backing up data or not (defaults to true). If the failure policy is set to {@link BackupFailurePolicy#CUSTOM} then the failurePolicyClass is required and should return the fully qualified name of a class implementing {@link org.infinispan.xsite.CustomFailurePolicy}  Timeout(millis) used for replicating calls to other sites.    Sets the strategy used for backing up data: sync or async. If not specified defaults to {@link org.infinispan.configuration.cache.BackupConfiguration.BackupStrategy#ASYNC}. Configures whether the replication happens in a 1PC or 2PC for sync backups. The default value is "false"


Use this method if the remote cache that backups in this cache is the default cache.



It handles the state transfer control from a remote site. The control command must be broadcast to the entire cluster in which the cache exists. It handles the state transfer state from a remote site. It is possible to have a single node applying the state or forward the state to respective primary owners.

Returns the local cache associated defined as backup for the provided remote (site, cache) combo, or throws an exception if no such site is defined. <p/> Also starts the cache if not already stated; that is because the cache is needed for update after when this method is invoked.

Returns the local cache defined as backup for the provided remote (site, cache) combo, or throws an exception if no such site is defined. <p/> Also starts the cache if not already started; that is because the cache is needed for update after this method is invoked.
Returns the list of sites where the backups failed due to a bridge communication error (as opposed to an error caused by Infinispan, e.g. due to a lock acquisition timeout). Return the time in millis when this operation was initiated.
Prepares a transaction on the remote site. Brings a site with the given name back online. Processes the responses of a backup command. It might throw an exception in the case the replication to the remote site fail, based on the configured {@link CustomFailurePolicy}. Returns a Map having as entries the site names and as value Boolean.TRUE if the site is online and Boolean.FALSE if it is offline.





Very low-level access to decoding ASCII characters in the form of a byte array. Does not support automatically gunzipping or any other "fancy" features. end decode Decodes data from Base64 notation, automatically detecting gzip-compressed data and decompressing it. end decode ********  D E C O D I N G   M E T H O D S  ******** Decodes four bytes from array <var>source</var> and writes the resulting bytes (up to three of them) to <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by specifying <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays are large enough to accomodate <var>srcOffset</var> + 4 for the <var>source</var> array or <var>destOffset</var> + 3 for the <var>destination</var> array. This method returns the actual number of bytes that were converted from the Base64 encoding. end decodeToBytes Convenience method for reading a base64-encoded file and decoding it. end decodeFromFile Convenience method for decoding data to a file. end decodeToFile Attempts to decode Base64 data and deserialize a Java Object within. Returns <tt>null</tt> if there was an error. end decodeObject ********  E N C O D I N G   M E T H O D S  ******** Encodes up to the first three bytes of array <var>threeBytes</var> and returns a four-byte array in Base64 notation. The actual number of significant bytes in your array is given by <var>numSigBytes</var>. The array <var>threeBytes</var> needs only be as big as <var>numSigBytes</var>. Code can reuse a byte array by passing a four-byte array as <var>b4</var>. end encode3to4 Encodes up to three bytes of the array <var>source</var> and writes the resulting four Base64 bytes to <var>destination</var>. The source and destination arrays can be manipulated anywhere along their length by specifying <var>srcOffset</var> and <var>destOffset</var>. This method does not check to make sure your arrays are large enough to accomodate <var>srcOffset</var> + 3 for the <var>source</var> array or <var>destOffset</var> + 4 for the <var>destination</var> array. The actual number of significant bytes in your array is given by <var>numSigBytes</var>. end encode3to4 Encodes a byte array into Base64 notation. Does not GZip-compress data. end encodeBytes Encodes a byte array into Base64 notation. <p> Valid options:<pre> GZIP: gzip-compresses object before encoding it. DONT_BREAK_LINES: don't break lines at 76 characters <i>Note: Technically, this makes your encoding non-compliant.</i> </pre> <p> Example: <code>encodeBytes( myData, Base64.GZIP )</code> or <p> Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )</code> end encodeBytes Encodes a byte array into Base64 notation. Does not GZip-compress data. end encodeBytes Encodes a byte array into Base64 notation. <p> Valid options:<pre> GZIP: gzip-compresses object before encoding it. DONT_BREAK_LINES: don't break lines at 76 characters <i>Note: Technically, this makes your encoding non-compliant.</i> </pre> <p> Example: <code>encodeBytes( myData, Base64.GZIP )</code> or <p> Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )</code> end encodeBytes Convenience method for reading a binary file and base64-encoding it. end encodeFromFile Serializes an object and returns the Base64-encoded version of that serialized object. If the object cannot be serialized or there is another error, the method will return <tt>null</tt>. The object is not GZip-compressed before being encoded. end encodeObject Serializes an object and returns the Base64-encoded version of that serialized object. If the object cannot be serialized or there is another error, the method will return <tt>null</tt>. <p> Valid options:<pre> GZIP: gzip-compresses object before encoding it. DONT_BREAK_LINES: don't break lines at 76 characters <i>Note: Technically, this makes your encoding non-compliant.</i> </pre> <p> Example: <code>encodeObject( myObj, Base64.GZIP )</code> or <p> Example: <code>encodeObject( myObj, Base64.GZIP | Base64.DONT_BREAK_LINES )</code> end encode Convenience method for encoding data to a file. end encodeToFile
Suspend invocation until all {@code delays} complete, then if successful invoke the next interceptor. If the list is empty or null, invoke the next interceptor immediately. <p>If any of {@code delays} completes exceptionally, skip the next interceptor and continue with the exception.</p> <p>You need to wrap the result with {@link #makeStage(Object)} if you need to add another handler.</p> Suspend the invocation until {@code delay} completes, then if successful invoke the next interceptor. <p>If {@code delay} completes exceptionally, skip the next interceptor and continue with the exception.</p> <p>You need to wrap the result with {@link #makeStage(Object)} if you need to add another handler.</p> Suspend the invocation until {@code valueFuture} completes, then return its result without running the remaining interceptors. <p>The caller can add a callback that will run when {@code valueFuture} completes, e.g. {@code asyncValue(v).thenApply(ctx, command, (rCtx, rCommand, rv, t) -> invokeNext(rCtx, rCommand))}. For this particular scenario, however, it's simpler to use {@link #asyncInvokeNext(InvocationContext, VisitableCommand, CompletableFuture)}.</p> Invoke the next interceptor, possibly with a new command. <p>Use {@link #invokeNextThenApply(InvocationContext, VisitableCommand, InvocationSuccessFunction)} or {@link #invokeNextThenAccept(InvocationContext, VisitableCommand, InvocationSuccessAction)} instead if you need to process the return value of the next interceptor.</p> <p>Note: {@code invokeNext(ctx, command)} does not throw exceptions. In order to handle exceptions from the next interceptors, you <em>must</em> use {@link #invokeNextAndHandle(InvocationContext, VisitableCommand, InvocationFinallyFunction)}, {@link #invokeNextAndFinally(InvocationContext, VisitableCommand, InvocationFinallyAction)}, or {@link #invokeNextAndExceptionally(InvocationContext, VisitableCommand, InvocationExceptionFunction)}.</p> Invoke the next interceptor, possibly with a new command, and execute an {@link InvocationCallback} after all the interceptors have finished with an exception. <p>You need to wrap the result with {@link #makeStage(Object)} if you need to add another handler.</p> Invoke the next interceptor, possibly with a new command, and execute an {@link InvocationCallback} after all the interceptors have finished, with or without an exception. <p>You need to wrap the result with {@link #makeStage(Object)} if you need to add another handler.</p> Invoke the next interceptor, possibly with a new command, and execute an {@link InvocationCallback} after all the interceptors have finished, with or without an exception. <p>You need to wrap the result with {@link #makeStage(Object)} if you need to add another handler.</p> Invoke the next interceptor, possibly with a new command, and execute an {@link InvocationCallback} after all the interceptors have finished successfully. <p>You need to wrap the result with {@link #makeStage(Object)} if you need to add another handler.</p> Invoke the next interceptor, possibly with a new command, and execute an {@link InvocationCallback} after all the interceptors have finished successfully. <p>You need to wrap the result with {@link #makeStage(Object)} if you need to add another handler.</p> Encode the result of an {@link #invokeNext(InvocationContext, VisitableCommand)} in an {@link InvocationStage}. <p>May not create a new instance, if the result is already an {@code InvocationStage}. Used internally to set up the interceptor. Return the value if {@code throwable != null}, throw the exception otherwise.



<p> Create new book and return it. If the book already exists, throw exception. </p> <p> Remove the {@code Book} identified by the supplied {@code bookId} from this store. </p> <p> Look up and return the {@code Book} identified by the supplied {@code bookId}, or {@code null} if no such book exists. </p> <p> Update provided {@code book} and return its updated version. </p>
Disables tracking of rehash events that could occur to the underlying cache.  If a rehash event occurs while a terminal operation is being performed it is possible for some values that are in the cache to not be found. Note that you will never have an entry duplicated when rehash awareness is disabled, only lost values. <p>Most terminal operations will run faster with rehash awareness disabled even without a rehash occuring. However if a rehash occurs with this disabled be prepared to possibly receive only a subset of values.</p> Controls how many keys are returned from a remote node when using a stream terminal operation with a distributed cache to back this stream.  This value is ignored when terminal operators that don't track keys are used.  Key tracking terminal operators are {@link CacheStream#iterator()}, {@link CacheStream#spliterator()}, {@link CacheStream#forEach(Consumer)}.  Please see those methods for additional information on how this value may affect them. <p>This value may be used in the case of a a terminal operator that doesn't track keys if an intermediate operation is performed that requires bringing keys locally to do computations.  Examples of such intermediate operations are {@link CacheStream#sorted()}, {@link CacheStream#sorted(Comparator)}, {@link CacheStream#distinct()}, {@link CacheStream#limit(long)}, {@link CacheStream#skip(long)}</p> <p>This value is <b>always</b> ignored when this stream is backed by a cache that is not distributed as all values are already local.</p> Filters which entries are returned by what segment they are present in.  This method can be substantially more efficient than using a regular {@link CacheStream#filter(Predicate)} method as this can control what nodes are asked for data and what entries are read from the underlying CacheStore if present. Filters which entries are returned by only returning ones that map to the given key.  This method will be faster than a regular {@link CacheStream#filter(Predicate)} if the filter is holding references to the same keys. This would enable sending requests to all other remote nodes when a terminal operator is performed.  This requires additional overhead as it must process results concurrently from various nodes, but should perform faster in the majority of cases. <p>Parallel distribution is enabled by default except for {@link CacheStream#iterator()} & {@link CacheStream#spliterator()}</p> Allows registration of a segment completion listener that is notified when a segment has completed processing.  If the terminal operator has a short circuit this listener may never be called. <p>This method is designed for the sole purpose of use with the {@link CacheStream#iterator()} to allow for a user to track completion of segments as they are returned from the iterator.  Behavior of other methods is not specified.  Please see {@link CacheStream#iterator()} for more information.</p> <p>Multiple listeners may be registered upon multiple invocations of this method.  The ordering of notified listeners is not specified.</p> This would disable sending requests to all other remote nodes compared to one at a time. This can reduce memory pressure on the originator node at the cost of performance. <p>Parallel distribution is enabled by default except for {@link CacheStream#iterator()} & {@link CacheStream#spliterator()}</p> Sets a given time to wait for a remote operation to respond by.  This timeout does nothing if the terminal operation does not go remote. <p>If a timeout does occur then a {@link java.util.concurrent.TimeoutException} is thrown from the terminal operation invoking thread or on the next call to the {@link Iterator} or {@link Spliterator}.</p> <p>Note that if a rehash occurs this timeout value is reset for the subsequent retry if rehash aware is enabled.</p>

Returns the topmost condition, never {@code null}. ////////////////////////////// Delegate to parent QueryBuilder ///////////////////////////




Create a comparator to be used for ordering the results returned by {@link #getIterator()}. Create an iterator over the results of the query, in no particular order. Ordering will be provided if {@link #getComparator()} returns a non-null {@link Comparator}.



Sorting on a field that does not contain DocValues so Hibernate Search is forced to uninvert it.


Obtains the event type that corresponds to the given event annotation.

{@inheritDoc }

Since Lucene 4.7, method release() was renamed to close()
Decorates a matching instance before it is presented to the caller of the {@link ObjectFilter#filter(Object)}. Executes the registered filters and notifies each one of them whether it was satisfied or not by the given instance. Creates a new {@link MatcherEvalContext} capable of dealing with multiple filters. The context is created only if the given instance is recognized to be of a type that has some filters registered. If there are no filters, {@code null} is returned to signal this condition and make the evaluation faster. This method must be called while holding the internal write lock. Creates a new {@link MatcherEvalContext} capable of dealing with a single filter for a single type. The context is created only if the given instance is recognized to be of a type that has some filters registered. If there are no filters, {@code null} is returned to signal this condition and make the evaluation faster. This method must be called while holding the internal write lock.

Subclasses must implement this method in order to provide a way to lookup the {@link SerializationContext}
Returns the query string. Returns the named parameters Map. Returns the query string. Reset internal state after pagination or query parameters are modified. This is needed to ensure the next execution of the query uses the new values. Ensure all named parameters have non-null values.



Checks if the region is valid for operations such as storing new data in the region, or retrieving data from the region. {@inheritDoc } <p/> Not supported; returns -1 {@inheritDoc } <p/> Not supported; returns -1 Invalidates the region. Used to satisfy TransactionalDataRegion.isTransactionAware in subclasses Tell the TransactionManager to resume the given transaction Tell the TransactionManager to suspend any ongoing transaction.









Retrieves the name of the cache Retrieves the version of Infinispan {@inheritDoc } If the return value of this operation will be ignored by the application, the user is strongly encouraged to use the {@link org.infinispan.context.Flag#IGNORE_RETURN_VALUES} flag when invoking this method in order to make it behave as efficiently as possible (i.e. avoiding needless remote or network calls). An overloaded form of {@link #put(Object, Object)}, which takes in lifespan parameters. An overloaded form of {@link #put(Object, Object)}, which takes in lifespan parameters. An overloaded form of {@link #putAll(Map)}, which takes in lifespan parameters.  Note that the lifespan is applied to all mappings in the map passed in. An overloaded form of {@link #putAll(Map)}, which takes in lifespan parameters.  Note that the lifespan is applied to all mappings in the map passed in. An overloaded form of {@link #putIfAbsent(Object, Object)}, which takes in lifespan parameters. An overloaded form of {@link #putIfAbsent(Object, Object)}, which takes in lifespan parameters. {@inheritDoc } If the return value of this operation will be ignored by the application, the user is strongly encouraged to use the {@link org.infinispan.context.Flag#IGNORE_RETURN_VALUES} flag when invoking this method in order to make it behave as efficiently as possible (i.e. avoiding needless remote or network calls). An overloaded form of {@link #replace(Object, Object, Object)}, which takes in lifespan parameters. An overloaded form of {@link #replace(Object, Object, Object)}, which takes in lifespan parameters. An overloaded form of {@link #replace(Object, Object)}, which takes in lifespan parameters. An overloaded form of {@link #replace(Object, Object)}, which takes in lifespan parameters.
Retrieves the default cache associated with this cache container. <p/> As such, this method is always guaranteed to return the default cache, unless one has not been supplied to the cache container. <p /> <b>NB:</b> Shared caches are supported (and in fact encouraged) but if they are used it's the users responsibility to ensure that <i>at least one</i> but <i>only one</i> caller calls stop() on the cache, and it does so with the awareness that others may be using the cache. Retrieves a named cache from the system.  If the cache has been previously created with the same name, the running cache instance is returned.  Otherwise, this method attempts to create the cache first. <p/> In the case of a {@link org.infinispan.manager.EmbeddedCacheManager}: when creating a new cache, this method will use the configuration passed in to the EmbeddedCacheManager on construction, as a template, and then optionally apply any overrides previously defined for the named cache using the {@link EmbeddedCacheManager#defineConfiguration(String, org.infinispan.config.Configuration)} or {@link EmbeddedCacheManager#defineConfiguration(String, String, org.infinispan.config.Configuration)} methods, or declared in the configuration file. <p /> <b>NB:</b> Shared caches are supported (and in fact encouraged) but if they are used it's the users responsibility to ensure that <i>at least one</i> but <i>only one</i> caller calls stop() on the cache, and it does so with the awareness that others may be using the cache.

The basic event logger doesn't collect anything.



Starts a batch





Completes a batch if one has been started using {@link #startBatch()}.  If no batch has been started, this is a no-op. <p/> Starts a batch.  All operations on the current client thread are performed as a part of this batch, with locks held for the duration of the batch and any remote calls delayed till the end of the batch. <p/>

Simply check if there is an ongoing tx. <ul> <li>If there is one, this is a no-op and just passes the call up the chain.</li> <li>If there isn't one and there is a batch in progress, resume the batch's tx, pass up, and finally suspend the batch's tx.</li> <li>If there is no batch in progress, just pass the call up the chain.</li> </ul>
Add to the qualifiers used for bean creation. Add to the qualifiers used for bean creation. Add to the qualifiers used for bean creation. Add to the type closure used for bean creation. Add to the type closure used for bean creation. Add to the type closure used for bean creation. Define that the created bean will (or will not) be an alternative. Define the bean class used for bean creation. Define the {@link ContextualLifecycle} used for bean creation. <p> Use the bean builder's current state to define the bean. </p> The bean class currently defined for bean creation. The {@link ContextualLifecycle} currently defined for bean creation. The bean manager in use. This cannot be changed for this {@link BeanBuilder}. The id currently defined for bean creation. The injection points currently defined for bean creation. The name of the bean currently defined for bean creation. Qualifiers currently defined for bean creation. Scope currently defined for bean creation. Stereotypes currently defined for bean creation. The string used when {@link #toString()} is called on the bean. Type closure currently defined for bean creation. Define the id used for bean creation. Define the injection points used for bean creation. Whether the created bean will be an alternative. Whether the created bean will be nullable. Whether the created bean will be passivation capable. Define the name of the bean used for bean creation. Define that the created bean will (or will not) be nullable. Define that the created bean will (or will not) be passivation capable. Define the qualifiers used for bean creation. Define the qualifiers used for bean creation. <p> Read the {@link AnnotatedType}, creating a bean from the class and it's annotations. </p> <p/> <p> By default the bean lifecycle will wrap the result of calling {@link BeanManager#createInjectionTarget(AnnotatedType)}. </p> <p/> <p> {@link BeanBuilder} does <em>not</em> support reading members of the class to create producers or observer methods. </p> Define the scope used for bean creation. Define the stereotypes used for bean creation. Define the string used when {@link #toString()} is called on the bean. Define the type closure used for bean creation. Define the type closure used for bean creation.

By cleaning the final BeanManager map after the Deployment got Validated, we prevent premature loading of information from JNDI in cases where the container might not be fully setup yet. This might happen if someone uses the BeanManagerProvider during Extension startup. Cleanup on container shutdown The active {@link BeanManager} for the current application (/{@link ClassLoader}). This method will throw an {@link IllegalStateException} if the BeanManager cannot be found. Get or create the BeanManagerInfo for the given ClassLoader Detect the right ClassLoader. The lookup order is determined by: <ol> <li>ContextClassLoader of the current Thread</li> <li>ClassLoader of the given Object 'o'</li> <li>ClassLoader of this very ClassUtils class</li> </ol> Allows to get the current provider instance which provides access to the current {@link BeanManager} Returns if the {@link BeanManagerProvider} has been initialized. Usually it isn't needed to call this method in application code. It's e.g. useful for other frameworks to check if DeltaSpike and the CDI container in general have been started. Get the BeanManager from the JNDI registry. It basically doesn't matter which of the system events we use, but basically we use the {@link AfterBeanDiscovery} event since it allows to use the {@link BeanManagerProvider} for all events which occur after the {@link AfterBeanDiscovery} event. This function exists to prevent findbugs to complain about setting a static member from a non-static function.
Retrieves a setter name based on a field name passed in Returns a Method object corresponding to a getter that retrieves an instance of componentClass from target. Returns a getter for a given class Returns a Method object corresponding to a setter that sets an instance of componentClass from target. Returns a setter for a given class Retrieves a setter name based on a field name passed in
Returns a new set with @Default and @Any added as needed Given a method, and the bean on which the method is declared, create a collection of injection points representing the parameters of the method.

















It checks for tasks ready to be processed in this {@link ExecutorService}. The invocation is done asynchronously, so the invoker is never blocked. Executes the given command at some time in the future when the command is less probably to block a thread.




Creates a less restrictive (expanded) query that matches the same objects as the input query plus potentially some more (false positives). This query can be executed fully indexed and the result can be filtered in a second pass to remove the false positives. This method can eventually return TRUE and in that case the expansion is useless and it is better to just run the entire query unindexed (full scan). <p> If all fields used by the input query are indexed then the expansion is identical to the input query.






Creates a thread pool that reuses a fixed set of threads operating off a shared bounded queue. If any thread terminates due to a failure during execution prior to shutdown, a new one will take its place if needed to execute subsequent tasks. Creates a thread pool that reuses a fixed set of threads operating off a shared bounded queue, using the provided ThreadFactory to create new threads when needed.
Method to be invoked when adding a new entry address to the end of the lru nodes.  This occurs for newly created entries. This method should only be invoked after acquiring the lruLock This method repeatedly removes the head of the LRU list until there the current size is less than or equal to `maxSize`. <p> We need to hold the LRU lock in order to check the current size and to read the head entry, and then we need to hold the head entry's write lock in order to remove it. The problem is that the correct acquisition order is entry write lock first, LRU lock second, and we need to hold the LRU lock so that we know which entry write lock to acquire. <p> To work around it, we first try to acquire the entry write lock without blocking. If that fails, we release the LRU lock and we acquire the locks in the correct order, hoping that the LRU head doesn't change while we wait. Because the entry write locks are striped, we actually tolerate a LRU head change as long as the new head entry is in the same lock stripe. If the LRU list head changes, we release both locks and try again. Method to be invoked when moving an existing lru node to the end.  This occurs when the entry is accessed for this node. This method should only be invoked after acquiring the lruLock.





Modifies the buffer counter by the specified value. Acquires the read lock. Blocks if the buffer is empty or if the object is currently locked for writing. Releases the read lock. Resets the buffer counter to the specified number. Acquires the write lock and consumes the specified amount of buffer space. Blocks if the object is currently locked for reading, or if the buffer is full and count is greater than 0. Releases the write lock.
Provide the next buffer size taking in account the object to store in the buffer. Record the size of the of data in the last buffer used.
When set to a positive integer, this will force a specific data distribution: the hashing function will resolve all keys used to store the various entries for the resulting index to be owned by the specified segment id. Use with caution, as this will obviously lead into a severely unbalanced distribution. Sets the chunkSize option for the Directory being created. Creates a Directory instance Provides an Executor to handle delete operations in a background thread Overrides the default SegmentReadLocker. In some cases you might be able to provide more efficient implementations than the default one by controlling the IndexReader's lifecycle Overrides the IndexWriter LockFactory When set to true, the list of files of the Directory is propagated to other nodes asynchronously. This implies that a committed change to the index will not immediately be accessible by searching threads on other nodes, but the gap in time is not longer than the time of a single RPC so this gap should not be measurable unless there is some form of congestion. Currently defaults to false as it's safer.
Builds a service into the specified target.






Returns a new byte[] instance of size {@link #getLength()} that contains all the bytes owned by this buffer. Returns the underlying buffer. Length bytes, starting from offset, within the underlying byte[] (as returned by {@link #getBuf()} are owned by this buffer instance. Returns the offset within the underlying byte[] (as returned by {@link #getBuf()} owned by this buffer instance.





Gets the number of bytes to which the internal buffer should be resized. If not enough space, it doubles the size until the internal buffer reaches a configurable max size (default is 4MB), after which it begins growing the buffer in 25% increments.  This is intended to help prevent an OutOfMemoryError during a resize of a large buffer.
















Transfer elements common to both operations and models


Method that is invoked when a cache is to be injected.




Similar to {@link CacheCollectors#serializableCollector(SerializableSupplier)} except that the supplier provided must be marshable through ISPN marshalling techniques.  Note this is not detected until runtime. Creates a collector that is serializable and will upon usage create a collector using the serializable supplier provided by the user.


Add region so that commands can be cleared on shutdown. Clear all regions from this command factory.


Build an instance of {@link EvictAllCommand} for a given region.
An attribute write handler which performs cache operations


Transfer elements common to both operations and models Create a Configuration object initialized from the operation ModelNode







Returns the name of the default cache.



An attribute write handler which performs special processing for ALIAS attributes.



test that eviction-executor, listener-executor and replication-queue-executor attributes have been picked up by infinispan-subsystem and jboss.infinispan.default service should depend on these executors also test the start attribute: 'default' cache container has default start mode (=LAZY)  (mode of service - ACTIVE) 'special-cache-container' has EAGER start mode  (mode of service - ON_DEMAND)
Two constraints need to be dealt with here: 1. There may be no started cache container instance available to interrogate. Because of lazy deployment, a cache container instance is only started upon deployment of an application which uses that cache instance. 2. The attribute name passed in may not correspond to a defined metric Read-only attributes have no easy way to throw an exception without negatively impacting other parts of the system. Therefore in such cases, as message will be logged and a ModelNode of undefined will be returned.
Method to re-install any services associated with existing local caches.



Returns an appropriate service name for the specified container name


Returns <code>max-age</code> header value. Returns <code>no-cache</code> header value.

Checks if the transaction was already prepared in another node <p> The client can send multiple requests to the server (in case of timeout or similar). This request is ignored when (1) the originator is still alive; (2) the transaction is prepared or committed/rolled-back <p> If the transaction isn't prepared and the originator left the cluster, the previous transaction is rolled-back and a new one is started. Handles a commit request from a client Creates a transaction response with the specific xa-code. Commits or Rollbacks the transaction (second phase of two-phase-commit) Validates if the value read is still valid and the write operation can proceed. Handles a prepare request from a client Handles a rollback request from a client. Transforms lifespan pass as seconds into milliseconds following this rule (inspired by Memcached): <p> If lifespan is bigger than number of seconds in 30 days, then it is considered unix time. After converting it to milliseconds, we subtract the current time in and the result is returned. <p> Otherwise it's just considered number of seconds from now and it's returned in milliseconds unit. Checks if the configuration (and the transaction manager) is able to handle client transactions.




Retrieves entries being evicted.
Commits changes Commits changes  Retrieves the key to this entry    Retrieves the value of this entry     Tests whether the entry represents a null value, typically used for repeatable read.   Rolls back changes  See {@link #skipLookup()}.  Sets the value of the entry, returning the previous value  If the entry is marked as removed and doUndelete==true then the "valid" flag is set to true and "removed" flag is set to false.


Retrieves the value of the entry being activated.


Retrieves the value of the entry being created. This will be true if the write command that caused this had to be retried again due to a topology change.  This could be a sign that this event has been duplicated or another event was dropped and replaced (eg: ModifiedEvent replaced CreateEvent)

Retrieves the metadata associated with the entry. Retrieves the value of the affected cache entry


Retrieves the value of the entry being expired.  Note this event is raised after the value has been expired. <p />


Retrieves the value of the entry being invalidated.



Retrieves the value of the entry being loaded.


Retrieves the value of the entry being modified. <p /> This will be true if the write command that caused this had to be retried again due to a topology change.  This could be a sign that this event has been duplicated or another event was dropped and replaced (eg: ModifiedEvent replaced CreateEvent) Indicates whether the cache entry modification event is the result of the cache entry being created. This method helps determine if the cache entry was created when <tt>event.isPre()</tt> is <tt>false</tt>.


Retrieves the value of the entry being passivated. <p />


Regardless of whether <tt>isPre()</tt> is <tt>true</tt> or is <tt>false</tt>, this method returns the value of the entry being deleted. This method is useful for situations where cache listeners need to know what the old value being deleted is when getting <tt>isPre()</tt> is <tt>false</tt> callbacks. Retrieves the value of the entry being deleted. <p /> This will be true if the write command that caused this had to be retried again due to a topology change.  This could be a sign that this event has been duplicated or another event was dropped and replaced (eg: ModifiedEvent replaced CreateEvent)



Retrieves the value of the entry being visited.

Converts the given newValue into something different possibly.

Retrieves a cache event converter instance from this factory.
Whether or not this event should be raised to the listener it is attached to.

Will both filter the entry and if passed subsequently convert the value to a new value.  A returned value of null will symbolize the value not passing the filter, so ensure your conversion will not return null if you want this entry to be returned.

Retrieves a cache event filter and converter instance from this factory.
Retrieves a cache event filter instance from this factory.
Adds event to this holder. Adds event to this holder. Gets all events based on Cache annotation and class of events.

Adds needed intermediate operations to the provided stream, returning a possibly new stream as a result of the operations.  This method keeps the contract of filter and conversion being performed in only 1 call as the {@link KeyValueFilterConverter} was designed to do.  The key, value and metadata are all used to determine whether the value is returned and the converted value. Creates a new {@link Function} using the provided converter as a basis for the operation.  This is useful for when using {@link Stream#map(Function)} method on distributed streams.  The key, value and metadata are all used to determine the converted value. Creates a new {@link Predicate} using the provided key value filter as a basis for the operation.  This is useful for when using {@link Stream#filter(Predicate)} method on distributed streams.  The key, value and metadata are all used to determine if the predicate returns true or not.
Returns Cache name. Returns Cache health status.

Registers the {@link CounterManagerNotificationManager}'s listeners to the cache hold by this instance. <p> It invokes {@link CounterManagerNotificationManager#listenOn(Cache)} method and it should protect itself to avoid registering multiple times.
Ignores a given cache if it wasn't before Queries whether the cache is ignored Replaces all ignored caches with the set provided No longer ignore the given cache if it was before


Returns the cache name. If this is the default cache, it returns a more friendly name. Returns String representation of ComponentStatus enumeration in order to avoid class not found exceptions in JMX tools that don't have access to infinispan classes. If this is a transactional cache and autoCommit is set to true then starts a transaction if this is not a transactional call. Returns the version of Infinispan. CacheSupport does not extend AdvancedCache, so it cannot really call up to the cache methods that take Metadata parameter. Since CacheSupport methods are declared final, the easiest is for CacheImpl to stop extending CacheSupport and implement the base methods directly. Wraps a return value as a future, if needed.  Typically, if the stack, operation and configuration support handling of futures, this retval is already a future in which case this method does nothing except cast to future. <p/> Otherwise, a future wrapper is created, which has already completed and simply returns the retval.  This is used for API consistency.

Invokes the specified operation on the specified cache.
Here is where the registration is being performed. Unregister when the cache is being stopped.


Returns the aggregated parameter meta data for the given method. Returns the cache key invocation context corresponding to the given invocation context. Returns the method meta data for the given method.



Returns true if the storage contains an entry associated with the given key. Used to initialize a cache loader.  Typically invoked by the {@link org.infinispan.persistence.manager.PersistenceManager} when setting up cache loaders. Fetches an entry from the storage. If a {@link MarshalledEntry} needs to be created here, {@link org.infinispan.persistence.spi.InitializationContext#getMarshalledEntryFactory()} and {@link InitializationContext#getByteBufferFactory()} should be used.

Disables a store of a given type. If the given type cannot be found, this is a no-op.  If more than one store of the same type is configured, all stores of the given type are disabled. This method returns a collection of cache loader types (fully qualified class names) that are configured and enabled. Loads from the cache loader the entry for the given key.  A found value is loaded into the current context.  The method returns whether the value was found or not, or even if the cache loader was checked.
Resolves and creates an instance of {@link javax.cache.annotation.CacheKeyGenerator}. To resolve the cache key generator class the algorithm defined in JCACHE specification is used. Resolves the cache name of a method annotated with a JCACHE annotation. Returns the default cache name associated to the given method according to JSR-107.



On start, the mbeans are registered. On stop, the mbeans are unregistered.
handler
Notifies all registered listeners of a viewChange event.  Note that viewChange notifications are ALWAYS sent immediately.


Two constraints need to be dealt with here: 1. There may be no started cache instance available to interrogate. Because of lazy deployment, a cache instance is only started upon deployment of an application which uses that cache instance. 2. The attribute name passed in may not correspond to a defined metric Read-only attributes have no easy way to throw an exception without negatively impacting other parts of the system. Therefore in such cases, as message will be logged and a ModelNode of undefined will be returned.
Returns number of seconds since cache started Map.put(key,value) :: oldValue

Returns true if the mode is invalidation, either sync or async.




Notifies all registered listeners of a {@link org.infinispan.notifications.cachelistener.event.CacheEntriesEvictedEvent} event. Notifies all registered listeners of a {@link org.infinispan.notifications.cachelistener.event.CacheEntryActivatedEvent} event. Notifies all registered listeners of a {@link org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent} event. Notifies all registered listeners of a CacheEntryExpired event. Notifies all registered listeners of a {@link org.infinispan.notifications.cachelistener.event.CacheEntryInvalidatedEvent} event. Notifies all registered listeners of a {@link org.infinispan.notifications.cachelistener.event.CacheEntryLoadedEvent} event. Notifies all registered listeners of a {@link org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent} event. Notifies all registered listeners of a {@link org.infinispan.notifications.cachelistener.event.CacheEntryPassivatedEvent} event. Notifies all registered listeners of a {@link org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent} event. Notifies all registered listeners of a {@link org.infinispan.notifications.cachelistener.event.CacheEntryVisitedEvent} event. Notifies all registered listeners of a transaction completion event. Notifies all registered listeners of a transaction registration event.
Adds the listener using the provided filter converter and class loader.  The provided builder is used to add additional configuration including (clustered, onlyPrimary & identifier) which can be used after this method is completed to see what values were used in the addition of this listener Configure event data. Currently used for 'activated', 'loaded', 'visited' events. Configure event data. Currently used for 'expired' events. Configure event data. Currently used for 'created', 'modified', 'removed', 'invalidated' events.
Clears all event from events map.
Implementation of HTTP DELETE request invoked on root context. Implementation of HTTP DELETE request invoked with a key. Implementation of HTTP GET and HTTP HEAD requests invoked with a key. Implementation of HTTP GET request invoked on root context. Implementation of HTTP PUT and HTTP POST requests invoked with a key.







Disable a given filter by its name. Enable a given filter by its name. Return the Lucene {@link org.apache.lucene.search.Explanation} object describing the score computation for the matching object/document in the current query Allows lucene to filter the results. Sets a result with a given index to the first result.  Gets the total number of results matching the query, ignoring pagination (firstResult, maxResult). Returns the results of a search as a {@link ResultIterator}. This calls {@link CacheQuery#iterator(FetchOptions fetchOptions)} with default FetchOptions; this implies eager loading of all results. Returns the results of a search as a {@link ResultIterator}. Warning: the return type is an extension of {@link java.util.Iterator} which introduces a {@link ResultIterator#close()} method. This close method needs to be invoked when the iteration is complete to avoid resource leakage. Returns the results of a search as a list. Sets the maximum number of results to the number passed in as a parameter. Defines the Lucene field names projected and returned in a query result Each field is converted back to it's object representation, an Object[] being returned for each "row" <p/> A projectable field must be stored in the Lucene index and use a {@link org.hibernate.search.bridge.TwoWayFieldBridge} Unless notified in their JavaDoc, all built-in bridges are two-way. All @DocumentId fields are projectable by design. <p/> If the projected field is not a projectable field, null is returned in the object[] Allows lucene to sort the results. Integers are sorted in descending order. Set the timeout for this query. If the query hasn't finished processing before the timeout, an exception will be thrown.
Disable a given filter by its name. Enable a given filter by its name. Takes in a lucene filter and sets it to the filter field in the class. Sets the the result of the given integer value to the first result.
A read handler which performs special processing for MODE attributes













Get the origin of the command Set the origin of the command



{@inheritDoc }

Returns an appropriate service name for the specified container and cache names


Adds a member with an online/offline connection to the server based on the {@code online} parameter.




Adds a value to a local statistic. This value is not associated with any transaction. Adds a value to a remote statistic. This value is not associated with any transaction.   Prints the cache statistics values to a {@link PrintStream}. Dumps all the cache statistic values to a {@link StringBuilder}   Merges a transaction statistics in this cache statistics. reset all the statistics collected so far.
Adds a value to a statistic. Signals the start of a transaction.  Prints the cache statistics values to a {@link PrintStream}.    Increments the statistic value. It is equivalent to {@code add(stat, 1, globalTransaction, local)}. Marks the transaction as a write transaction (instead of a read only transaction) Invoked when a {@link org.infinispan.commands.tx.PrepareCommand} is received for a transaction. Resets the cache statistics collected so far. Sets the transaction outcome to commit or rollback, depending if the transaction has commit successfully or not respectively. Signals the ending of a transaction. After this, no more statistics are updated for this transaction and the values measured are merged with the cache statistics.





Returns new instance based on {@link org.infinispan.configuration.cache.StoreConfiguration}.
Adds a new factory for processing. Removes all factories associated to this registry. Creates new Object based on configuration.

Same as {@link CacheStream#allMatch(Predicate)} except that the Predicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link CacheStream#anyMatch(Predicate)} except that the Predicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on the elements of this stream using a {@code Collector} that is lazily created from the {@code Supplier} provided. This method behaves exactly the same as {@link #collect(Collector)} with the enhanced capability of working even when the mutable reduction operation has to run in a remote node and the operation is not {@link Serializable} or otherwise marshallable. So, this method is specially designed for situations when the user wants to use a {@link Collector} instance that has been created by {@link java.util.stream.Collectors} static factory methods. In this particular case, the function that instantiates the {@link Collector} will be marshalled using Infinispan {@link org.infinispan.commons.marshall.Externalizer} class or one of its subtypes. {@inheritDoc } <p>Note when using a distributed backing cache for this stream the collector must be marshallable.  This prevents the usage of {@link java.util.stream.Collectors} class.  However you can use the {@link org.infinispan.stream.CacheCollectors} static factory methods to create a serializable wrapper, which then creates the actual collector lazily after being deserialized.  This is useful to use any method from the {@link java.util.stream.Collectors} class as you would normally. Alternatively, you can call {@link #collect(SerializableSupplier)} too.</p> Performs a <a href="package-summary.html#MutableReduction">mutable reduction</a> operation on the elements of this stream using a {@code Collector} that is lazily created from the {@code SerializableSupplier} provided. This method behaves exactly the same as {@link #collect(Collector)} with the enhanced capability of working even when the mutable reduction operation has to run in a remote node and the operation is not {@link Serializable} or otherwise marshallable. So, this method is specially designed for situations when the user wants to use a {@link Collector} instance that has been created by {@link java.util.stream.Collectors} static factory methods. In this particular case, the function that instantiates the {@link Collector} will be marshalled according to the {@link Serializable} rules. Same as {@link CacheStream#collect(Supplier, BiConsumer, BiConsumer)} except that the various arguments must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc } <p>This operation will be invoked both remotely and locally when used with a distributed cache backing this stream. This operation will act as an intermediate iterator operation requiring data be brought locally for proper behavior.  This is described in more detail in the {@link CacheStream} documentation</p> <p>This intermediate iterator operation will be performed locally and remotely requiring possibly a subset of all elements to be in memory</p> <p>Any subsequent intermediate operations and the terminal operation are then performed locally.</p> {@inheritDoc } {@inheritDoc } Same as {@link CacheStream#filter(Predicate)} except that the Predicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc } {@inheritDoc } Same as {@link CacheStream#flatMap(Function)} except that the Function must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link CacheStream#flatMapToDouble(Function)} except that the Function must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link CacheStream#flatMapToInt(Function)} except that the Function must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link CacheStream#flatMapToLong(Function)} except that the Function must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link CacheStream#forEach(Consumer)} except that it takes a {@link BiConsumer} that provides access to the underlying {@link Cache} that is backing this stream. <p> Note that the <code>CacheAware</code> interface is not supported for injection using this method as the cache is provided in the consumer directly. {@inheritDoc } <p>This operation is performed remotely on the node that is the primary owner for the key tied to the entry(s) in this stream.</p> <p>NOTE: This method while being rehash aware has the lowest consistency of all of the operators.  This operation will be performed on every entry at least once in the cluster, as long as the originator doesn't go down while it is being performed.  This is due to how the distributed action is performed.  Essentially the {@link CacheStream#distributedBatchSize} value controls how many elements are processed per node at a time when rehash is enabled. After those are complete the keys are sent to the originator to confirm that those were processed.  If that node goes down during/before the response those keys will be processed a second time.</p> <p>It is possible to have the cache local to each node injected into this instance if the provided Consumer also implements the {@link org.infinispan.stream.CacheAware} interface.  This method will be invoked before the consumer <code>accept()</code> method is invoked.</p> <p>This method is ran distributed by default with a distributed backing cache.  However if you wish for this operation to run locally you can use the {@code stream().iterator().forEachRemaining(action)} for a single threaded variant.  If you wish to have a parallel variant you can use {@link java.util.stream.StreamSupport#stream(Spliterator, boolean)} passing in the spliterator from the stream.  In either case remember you <b>must</b> close the stream after you are done processing the iterator or spliterator..</p> Same as {@link CacheStream#forEach(BiConsumer)} except that the <code>BiConsumer</code> must also implement <code>Serializable</code> Same as {@link CacheStream#forEach(Consumer)} except that the Consumer must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } <p>Usage of this operator requires closing this stream after you are done with the iterator.  The preferred usage is to use a try with resource block on the stream.</p> <p>This method has special usage with the {@link org.infinispan.CacheStream.SegmentCompletionListener} in that as entries are retrieved from the next method it will complete segments.</p> <p>This method obeys the {@link CacheStream#distributedBatchSize(int)}.  Note that when using methods such as {@link CacheStream#flatMap(Function)} that you will have possibly more than 1 element mapped to a given key so this doesn't guarantee that many number of entries are returned per batch.</p> <p>Note that the {@link Iterator#remove()} method is only supported if no intermediate operations have been applied to the stream and this is not a stream created from a {@link Cache#values()} collection.</p> {@inheritDoc } <p>This intermediate operation will be performed both remotely and locally to reduce how many elements are sent back from each node.  More specifically this operation is applied remotely on each node to only return up to the <b>maxSize</b> value and then the aggregated results are limited once again on the local node.</p> <p>This operation will act as an intermediate iterator operation requiring data be brought locally for proper behavior.  This is described in more detail in the {@link CacheStream} documentation</p> <p>Any subsequent intermediate operations and the terminal operation are then performed locally.</p> {@inheritDoc } Same as {@link CacheStream#map(Function)} except that the Function must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link CacheStream#mapToDouble(ToDoubleFunction)}  except that the ToDoubleFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link CacheStream#mapToInt(ToIntFunction)}  except that the ToIntFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link CacheStream#mapToLong(ToLongFunction)}  except that the ToLongFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link CacheStream#max(Comparator)} except that the Comparator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link CacheStream#min(Comparator)} except that the Comparator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link CacheStream#noneMatch(Predicate)} except that the Predicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc }  {@inheritDoc } Same as {@link CacheStream#peek(Consumer)} except that the Consumer must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link CacheStream#reduce(Object, BiFunction, BinaryOperator)} except that the BinaryOperator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link CacheStream#reduce(Object, BinaryOperator)}  except that the BinaryOperator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link CacheStream#reduce(BinaryOperator)} except that the BinaryOperator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } <p>This operation is performed entirely on the local node irrespective of the backing cache.  This operation will act as an intermediate iterator operation requiring data be brought locally for proper behavior. This is described in more detail in the {@link CacheStream} documentation</p> <p>Depending on the terminal operator this may or may not require all entries or a subset after skip is applied to be in memory all at once.</p> <p>Any subsequent intermediate operations and the terminal operation are then performed locally.</p> {@inheritDoc } <p>This operation is performed entirely on the local node irrespective of the backing cache.  This operation will act as an intermediate iterator operation requiring data be brought locally for proper behavior. Beware this means it will require having all entries of this cache into memory at one time.  This is described in more detail at {@link CacheStream}</p> <p>Any subsequent intermediate operations and the terminal operation are also performed locally.</p> {@inheritDoc } <p>This operation is performed entirely on the local node irrespective of the backing cache.  This operation will act as an intermediate iterator operation requiring data be brought locally for proper behavior. Beware this means it will require having all entries of this cache into memory at one time.  This is described in more detail at {@link CacheStream}</p> <p>Any subsequent intermediate operations and the terminal operation are then performed locally.</p> Same as {@link CacheStream#sorted(Comparator)} except that the Comparator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } <p>Usage of this operator requires closing this stream after you are done with the spliterator.  The preferred usage is to use a try with resource block on the stream.</p> {@inheritDoc } Same as {@link CacheStream#toArray(IntFunction)} except that the BinaryOperator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc }
This is intentionally a non-public method meant as an integration point for bytecode manipulation. Don't remove or alter the signature even if it might look like unreachable code. Implementors should perform a put operation but optimizing it as return values are not required.
The current consistent hash.  The future consistent hash. Should be {@code null} if there is no rebalance in progress. Read operations should always go to the "current" owners. The id of the latest started rebalance. The union of the current and future consistent hashes. Should be {@code null} if there is no rebalance in progress. When there is a rebalance in progress, write operations should go to the union of the "current" and "future" owners.

Invoked when state transfer has to be started. The caller will not consider the local rebalance done when this method returns. Instead, the handler will have to call {@link LocalTopologyManager#confirmRebalancePhase(String, int, int, Throwable)} Invoked when the CH has to be immediately updated because of a leave or when the state transfer has completed and we have to install a permanent CH (pendingCH == null). A state transfer is not always required.


Sets the version read for this key. The version is only set at the first time, i.e. multiple invocation of this method will not change the state. <p/> Note: used in Repeatable Read + Write Skew + Clustering + Versioning. It cleans up the backup locks for this transaction. Prevent new modifications after prepare or commit started. Returns all the modifications visible within the current transaction, including those using Flag#CACHE_MODE_LOCAL. The returned list is never null. Returns the transaction identifier.  Returns the modifications visible within the current transaction. Any modifications using Flag#CACHE_MODE_LOCAL are excluded. The returned list is never null. It returns a {@link CompletableFuture} that completes when the lock for the {@code key} is released. If the {@code key} is not locked by this transaction, it returns {@code null}. Same as {@link #getReleaseFutureForKey(Object)} but it returns a pair with the key and the future. Note: used in Repeatable Read + Write Skew + Clustering + Versioning. Checks if a modification of the given class (or subclass) is present in this transaction. Any modifications using Flag#CACHE_MODE_LOCAL are ignored.    Sets the version read fr this key, replacing the old version if it exists, i.e each invocation updates the version of the key. This method is used when a remote get is performed for the key. <p/> Note: used in Repeatable Read + Write Skew + Clustering + Versioning. Checks if this transaction holds a lock on the given key and then waits until the transaction completes or until the timeout expires and returns <code>true</code> if the transaction is complete or <code>false</code> otherwise. If the key is not locked or if the transaction is already completed it returns <code>true</code> immediately. <p/> This method is subject to spurious returns in a way similar to {@link java.lang.Object#wait()}. It can sometimes return before the specified time has elapsed and without guaranteeing that this transaction is complete. The caller is responsible to call the method again if transaction completion was not reached and the time budget was not spent.



TODO: implement visitPutMapCommand

Remove all provided keys from the store in a single batch operation. If this is not supported by the underlying store, then keys are removed from the store individually via {@link #delete(Object)}. Used to initialize a cache loader.  Typically invoked by the {@link org.infinispan.persistence.manager.PersistenceManager} when setting up cache loaders. Persists the entry to the storage. Persist all provided entries to the store in a single batch update. If this is not supported by the underlying store, then entries are written to the store individually via {@link #write(MarshalledEntry)}.




<p> Remove the book identified by the supplied {@code bookId} from database. By annotating this method with {@code @CacheEvict(value = "books", key = "#bookId")} we make sure that Spring will remove the book cache under key {@code bookId} (if any) from the {@link org.springframework.cache.Cache <code>Cache</code>} &quot;books&quot;. </p> <p> Look up and return the {@code Book} identified by the supplied {@code bookId}. By annotating this method with {@code @Cacheable(value = "books", key = "#bookId")} we achieve the following: <ol> <li> {@code Book} instances returned from this method will be cached in a named {@link org.springframework.cache.Cache <code>Cache</code>} &quot;books&quot;</li> <li> The key used to cache {@code Book} instances will be the supplied {@code bookId}.</li> </ol> </p> <p> Note that it is <strong>important</strong> that we explicitly tell Spring to use {@code bookId} as the cache key. Otherwise, Spring would <strong>derive</strong> a cache key from the parameters passed in (in our case only {@code bookId}), a cache key we have no control over. This would get us into trouble when in {@link #updateBook(org.infinispan.spring.provider.sample.entity.Book)} we need a book's cache key to remove it from the cache. But we wouldn't know that cache key since we don't know Spring's key generation algorithm. Therefore, we consistently use {@code key = "#bookId"} or {@code key = "#book.id"} to tell Spring to <strong>always</strong> use a book's id as its cache key. </p> <p> Store the supplied {@code bookToStore} in database. Since it is annotated with {@code @CacheEvict(value = "books", key = "#book.id", condition = "#book.id != null")} this method will tell Spring to remove any book cached under the key {@code book.getId()} from the {@link org.springframework.cache.Cache <code>Cache</code>} &quot;books&quot;. This eviction will only be triggered if that id is not {@code null}. </p>






Transform a given cache into a cache that writes cache entries without waiting for them to complete, adding an extra flag. Broadcast an evict-all command with the given cache instance. Transform a given cache into a cache that fails silently if cache reads fail. Transform a given cache into a cache that fails silently if cache writes fail. Transform a given cache into a cache that fails silently if cache writes fail, adding an extra flag. Transform a given cache into a cache that ignores return values for operations returning previous values, i.e. {@link AdvancedCache#put(Object, Object)} Transform a given cache into a cache that ignores return values for operations returning previous values, i.e. {@link AdvancedCache#put(Object, Object)}, adding an extra flag. Indicates whether the given cache is configured to cluster its contents. A cache is considered to clustered if it's configured with any cache mode except {@link org.infinispan.configuration.cache.CacheMode#LOCAL} Indicates whether the given cache is configured with {@link org.infinispan.configuration.cache.CacheMode#INVALIDATION_ASYNC} or {@link org.infinispan.configuration.cache.CacheMode#INVALIDATION_SYNC}. Indicates whether the given cache is configured with {@link org.infinispan.configuration.cache.CacheMode#REPL_SYNC}, {@link org.infinispan.configuration.cache.CacheMode#INVALIDATION_SYNC}, or {@link org.infinispan.configuration.cache.CacheMode#DIST_SYNC}. Transform a given cache into a local cache Call an operation within a transaction. This method guarantees that the right pattern is used to make sure that the transaction is always either committed or rollbacked. Call an operation within a transaction. This method guarantees that the right pattern is used to make sure that the transaction is always either committed or rollback.









Returns UUID of a command
Cancels (invokes Thread#interrupt) a thread given a thread id Registers thread with {@link CancellationService} under the given UUID id Unregisters thread with {@link CancellationService} given an id


The hacks here allow casts to work properly, since Java doesn't work as well with nested generics This is a hack to allow for cast to work properly, since Java doesn't work as well with nested generics





Returns the protocol stack configuration of this channel factory. Determines whether or not the specified message response indicates the fork stack or fork channel required to handle a request does not exist on the recipient node.







Returns an appropriate service name for the default channel Returns an appropriate service name for the specified channel

Push a cache entry value out onto the websocket channel (to the browser). Cache key, value and cache-name to JSON string. <p> Note that value objects (like String, Numbers, Characters) are not being converted. </p>
Creates {@link Charset} based on {@link MediaType} as string. Creates Java {@link java.nio.charset.Charset} from this object.



Get the bufferSize. Get the chunkId. Get the fileName. Get the indexName. Changing the encoding could break backwards compatibility



This method throws IOException because it is assumed that we got the id from network.  for external ids we'll probably use Map<Integer, Class<?>> instead of array


Adds a listener to the component.  Typically, listeners would need to be annotated with {@link org.infinispan.notifications.Listener} and further to that, contain methods annotated appropriately, otherwise the listener will not be registered. <p/> See the {@link org.infinispan.notifications.Listener} annotation for more information. <p/> Adds a listener with the provided filter and converter and using a given classloader when invoked.  See {@link org.infinispan.notifications.FilteringListenable#addListener(Object, org.infinispan.notifications.cachelistener.filter.CacheEventFilter, org.infinispan.notifications.cachelistener.filter.CacheEventConverter)} for more details. <p/>
Adds a listener along with a class loader to use for the invocation
Get a value from the map. Put a value into the map.  Any previous mapping is discarded silently. Get a string summary representation of this map.









Appends the new command.





Created cache entry's key. Provides access to the version of the created cache entry. This version can be used to invoke conditional operations on the server, such as {@link org.infinispan.client.hotrod.RemoteCache#replaceWithVersion(Object, Object, long)} or {@link org.infinispan.client.hotrod.RemoteCache#removeWithVersion(Object, long)} This will be true if the write command that caused this had to be retried again due to a topology change.  This could be a sign that this event has been duplicated or another event was dropped and replaced (eg: ModifiedEvent replaced CreateEvent)
Customized event data. It can be any type as long as it can be converted to binary format for shipping between the server and client. This will be true if the write command that caused this had to be retried again due to a topology change.  This could be a sign that this event has been duplicated or another event was dropped and replaced (eg: ModifiedEvent replaced CreateEvent)

Created cache entry's key.

Modifiedcache entry's key. Provides access to the version of the modified cache entry. This version can be used to invoke conditional operations on the server, such as {@link org.infinispan.client.hotrod.RemoteCache#replaceWithVersion(Object, Object, long)} or {@link org.infinispan.client.hotrod.RemoteCache#removeWithVersion(Object, long)} This will be true if the write command that caused this had to be retried again due to a topology change.  This could be a sign that this event has been duplicated or another event was dropped and replaced (eg: ModifiedEvent replaced CreateEvent)

Created cache entry's key. This will be true if the write command that caused this had to be retried again due to a topology change.  This could be a sign that this event has been duplicated or another event was dropped and replaced (eg: ModifiedEvent replaced CreateEvent)





Register a client listener that uses a query DSL based filter. The listener is expected to be annotated such that {@link org.infinispan.client.hotrod.annotation.ClientListener#useRawData} = true and {@link org.infinispan.client.hotrod.annotation.ClientListener#filterFactoryName} and {@link org.infinispan.client.hotrod.annotation.ClientListener#converterFactoryName} are equal to {@link Filters#QUERY_DSL_FILTER_FACTORY_NAME}

Defines the converter factory for this client listener. Converter factories create event converters that customize the contents of the events sent to this listener. When event customization is enabled, {@link org.infinispan.client.hotrod.annotation.ClientCacheEntryCreated}, {@link org.infinispan.client.hotrod.annotation.ClientCacheEntryModified}, and {@link org.infinispan.client.hotrod.annotation.ClientCacheEntryRemoved} callbacks receive {@link org.infinispan.client.hotrod.event.ClientCacheEntryCustomEvent} instances as parameters instead of their corresponding create/modified/removed event. Event customization helps reduce the payload of events, or increase to send even more information back to the client listener. By default, no event customization is applied. Defines the key/value filter factory for this client listener. Filter factories create filters that help decide which events should be sent to this client listener. This helps with reducing traffic from server to client. By default, no filtering is applied. This flag enables cached state to be sent back to remote clients when either adding a cache listener for the first time, or when the node where a remote listener is registered changes. When enabled, state is sent back as cache entry created events to the clients. In the special case that the node where the remote listener is registered changes, before sending any cache entry created events, the client receives a failover event so that it's aware of the change of node. This is useful in order to do local clean up before receiving the state again. For example, a client building a local near cache and keeping it up to date with remote events might decide to clear in when the failover event is received and before the state is received. If disabled, no state is sent back to the client when adding a listener, nor it gets state when the node where the listener is registered changes. By default, including state is disabled in order to provide best performance. If clients must receive all events, enable including state. This option affects the type of the parameters received by a configured filter and/or converter. If using raw data, filter and/or converter classes receive raw binary arrays as parameters instead of unmarshalled instances, which is the default. On top of that, when raw data is enabled, custom events produced by the converters are expected to be byte arrays. This option is useful when trying to avoid marshalling costs involved in unmarshalling data to pass to filter/converter callbacks or costs involved in marshalling custom event POJOs. Using raw data also helps with potential classloading issues related to loading callback parameter classes or custom event POJOs. By using raw data, there's no need for class sharing between the server and client. By default, using raw binary data for filter/converter callbacks is disabled.





{@inheritDoc } <p> This iterator should be explicitly closed when iteration upon it is completed. Failure to do so could cause resources to not be freed properly {@inheritDoc } <p> This stream should be explicitly closed after it has been used. Failure to do so could cause resources to not be freed properly {@inheritDoc } <p> This spliterator should be explicitly closed after it has been used. Failure to do so could cause resources to not be freed properly {@inheritDoc } <p> This stream should be explicitly closed after it has been used. Failure to do so could cause resources to not be freed properly








Creates a closeable iterator from the given iterator that does nothing when close is called. Creates a closeable iterator that when closed will close the underlying stream as well Creates a closeable spliterator from the given spliterator that does nothing when close is called. Creates a closeable spliterator that when closed will close the underlying stream as well Takes a provided closeable iterator and wraps it appropriately so it can be used as a closeable spliterator that will close the iterator when the spliterator is closed. Creates a stream that when closed will also close the underlying iterator Creates a stream that when closed will also close the underlying spliterator

Method that is invoked on the node that has the given cluster listener that when registered generated the given listenerId.  Note this will notify only cluster listeners and regular listeners are not notified of the events. Will fire the events in the order of the iteration of the collection. This method is invoked so that this node can send the details required for a new node to be bootstrapped with the existing cluster listeners that are already installed.


-------------------------------------------- JMX information -----------------------------------------------
called from doHandleClusterView/doLeave/confirmRebalancePhase called from doHandleClusterView/doLeave/confirmRebalancePhase called from doHandleClusterView/doLeave/confirmRebalancePhase Helpers for working with immutable lists   TODO: newMembers isn't really used, pruneInvalidMembers uses expectedMembers Should be called after the members list was updated in any other way ({@link #removeMember(Address)}, {@link #retainMembers} etc.)







Adds additional cluster events that need to be sent remotely for an event originating locally. These events are not sent at time of registering but rather after the {@link ClusterEventManager#sendEvents()} is invoked. These events are gathered on a per thread basis and batched to reduce number of RPCs required. Drops and ignores all previously added events on this thread. Sends all previously added events on this thread



When a command is submitted it will submit this command to all of the available nodes that pass the provided filter.  Fail over is not supported with this configuration. This is the default submission method. {@inheritDoc } <p> This command will be ran in the desired nodes, but no result is returned to notify the user of completion or failure. This command will return immediately while the runnable is processed asynchronously. The same as {@link Executor#execute(Runnable)}, except the Runnable must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. Allows for filtering of address nodes by only allowing addresses in this collection from being contacted. Note that this method overrides any previous filtering that was done (ie. calling {@link ClusterExecutor#filterTargets(Predicate)}. Allows for filtering of address nodes dynamically per invocation.  The predicate is applied to each member in the cluster at invocation to determine which targets to contact.  Note that this method overrides any previous filtering that was done (ie. calling {@link ClusterExecutor#filterTargets(Collection)}). Allows for filtering of address nodes by only allowing addresses that match the given execution policy to be used. Note this method overrides any previous filtering that was done (ie. calling {@link ClusterExecutor#filterTargets(Collection)}). <p> The execution policy is only used if the addresses are configured to be topology aware. That is that the {@link TransportConfiguration#hasTopologyInfo()} method returns true.  If this is false this method will throw an {@link IllegalStateException}. Allows for filtering of address nodes dynamically per invocation.  The predicate is applied to each member that is part of the execution policy. Note that this method overrides any previous filtering that was done (ie. calling {@link ClusterExecutor#filterTargets(Collection)}). <p> The execution policy is only used if the addresses are configured to be topology aware. That is that the {@link TransportConfiguration#hasTopologyInfo()} method returns true.  If this is false this method will throw an {@link IllegalStateException}. Applies no filtering and will send any invocations to any/all current nodes. When a command is submitted it will only be submitted to one node of the available nodes, there is no strict requirements as to which node is chosen and is implementation specific. Fail over is not used with the returned executor, if you desire to use fail over you should invoke {@link ClusterExecutor#singleNodeSubmission(int)} instead. When a command is submitted it will only be submitted to one node of the available nodes, there is no strict requirements as to which node is chosen and is implementation specific. However if a command were to fail either by the command itself or via network issues then the command will fail over, that is that it will retried up to the provided number of times using an available node until an exception is not met or the number of fail over counts has been reached. If a {@link org.infinispan.util.concurrent.TimeoutException} is throwing, this will not be retried as this is the same exception that is thrown when using {@link ClusterExecutor#timeout(long, TimeUnit)}. Each time the fail over occurs any available node is chosen, there is no requirement as to which can be chosen and is left up to the implementation to decide. Submits the runnable to the desired nodes and returns a CompletableFuture that will be completed when all desired nodes complete the given command <p> If a node encounters an exception, the first one to respond with such an exception will set the responding future to an exceptional state passing the given exception. The same as {@link ClusterExecutor#submit(Runnable)}, except the Runnable must also implement Serializable. <p> <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. Submits the given command to the desired nodes and allows for handling of results as they return.  The user provides a {@link TriConsumer} which will be called back each time for each desired node.  Note that these callbacks can be called from different threads at the same time.  A completable future is returned to the caller used for the sole purpose of being completed when all nodes have sent responses back. <p> If this cluster executor is running in failover mode via {@link ClusterExecutor#singleNodeSubmission(int)} the triConsumer will be called back each time a failure occurs as well. To satisfy ordering a retry is not resubmitted until after the callback has completed. <p> Note the {@link TriConsumer} is only ran on the node where the task was submitted and thus doesn't need to be serialized. The same as {@link ClusterExecutor#submitConsumer(Function, TriConsumer)}, except the Callable must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. Sets a duration after which a command will timeout. This will cause the command to return a {@link org.infinispan.util.concurrent.TimeoutException} as the throwable. <p>The timeout parameter is used for both local and remote nodes. There are no guarantees as to whether the timed out command is interrupted.


Returns the name of the cluster. Returns total cluster health. Returns node names. Returns the number of nodes in the cluster.



A test to check whether the cache is in its started state.  If not, calls should not be made as the channel may not have properly started, blocks due to state transfers may be in progress, etc.






Reset the collected statistics
Awaits completion of the given request.  Returns true when the request completes otherwise returns false after the time elapses Frees any resources related to this operation and signals to any ongoing remote operations to no longer continue processing Tests whether this operation is still pending or not. Receives a response for a given request Key tracking remote operation that doesn't have rehash enabled. Performs the remote stream operation without rehash awareness. Key tracking remote operation that has rehash enabled Performs the remote stream operation with rehash awareness.

Retrieves the rebalancing status of a cache Signals that a new member is joining the cache. The returned {@code CacheStatusResponse.cacheTopology} is the current cache topology before the node joined. If the node is the first to join the cache, the returned topology does include the joiner, and it is never {@code null}. Signals that a member is leaving the cache. Marks the rebalance as complete on the sender. Returns whether rebalancing is enabled or disabled for this container. Sets the id of the initial topology in given cache. This is necessary when using entry versions that contain topology id; had we started with topology id 1, newer versions would not be recognized properly. Globally enables or disables whether automatic rebalancing should occur. Enables or disables rebalancing for the specified cache

Wait until we have received view {@code joinerViewId} and we have finished recovering the cluster state. <p> Returns early if the node is shutting down. <p> This method should be invoked with the lock hold.






Create a Configuration object initialized from the data in the operation.
only testing owners=1, owners=2 is tested all across the testsuite (it's also the default)

Create a cache using default configuration

Two constraints need to be dealt with here: 1. There may be no started cache instance available to interrogate. Because of lazy deployment, a cache instance is only started upon deployment of an application which uses that cache instance. 2. The attribute name passed in may not correspond to a defined metric Read-only attributes have no easy way to throw an exception without negatively impacting other parts of the system. Therefore in such cases, as message will be logged and a ModelNode of undefined will be returned.
number of results of each node of cluster




Invokes a logical "get(key)" on a remote cache and returns results.

Invokes a query on a (remote) cache and returns results (list of keys).


Broadcast this ClusteredQueryCommand to all cluster nodes. The command will be also invoked on local node. Retrieves the value (using doc index) in a remote query instance


Monitors cache events and updates the local cache Monitors cache events and updates the local cache Brings all data from the distributed cache into our local cache.



Cache mode. See {@link CacheMode} for information on the various cache modes available. Configure hash sub element For scattered cache, the threshold after which batched invalidations are sent This method allows configuration of the L1 cache for distributed caches. When this method is called, it automatically enables L1. So, if you want it to be disabled, make sure you call {@link org.infinispan.configuration.cache.L1ConfigurationBuilder#disable()} Configures cluster's behaviour in the presence of partitions or node failures. This is the timeout used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown. This is the timeout used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown. Configure sync sub element. Once this method is invoked users cannot subsequently invoke <code>async()</code> as two are mutually exclusive
Cache mode. See {@link CacheMode} for information on the various cache modes available. Configure hash sub element For scattered cache, the threshold after which batched invalidations are sent This method allows configuration of the L1 cache for distributed caches. L1 should be explicitly enabled by calling {@link L1ConfigurationBuilder#enable()} This is the timeout used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown. This is the timeout used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown. Configure the {@code stateTransfer} sub element for distributed and replicated caches. It doesn't have any effect on LOCAL or INVALIDATION-mode caches.
Allows fine-tuning of rehashing characteristics. Must only used with 'distributed' cache mode. Configures the L1 cache behavior in 'distributed' caches instances. In any other cache modes, this element is ignored. Configures how the cache will react to cluster partitions. Configures how state is transferred when a new cache joins the cluster. Used with distribution and replication clustered modes. If configured all communications are synchronous, in that whenever a thread sends a message sent over the wire, it blocks until it receives an acknowledgment from the recipient. SyncConfig is mutually exclusive with the AsyncConfig.




Logger for Hot Rod client codec Reads a stream of data Reads a response header from the transport and returns the status of the response. Read and unmarshall byte array. Writes a stream of data Writes client listener parameters Write lifespan/maxidle parameters. Writes a request header with the given parameters to the transport and returns an updated header parameters.

IMPORTANT NOTE: Hot Rod protocol agrees to this calculation for a virtual node address hash code calculation, so any changes to the implementation require modification of the protocol.

















Create a Set backed by the specified array.

Write operations are not supported!

Creates a {@link java.util.Set} with the given elements.
The exception results of the primary owner. The write operation's return value.


Acknowledges a write operation completion in the backup owner. Acknowledges an exception during the operation execution. <p> The collector is completed without waiting any further acknowledges. Creates a collector for a single key write operation. Creates a collector for {@link org.infinispan.commands.write.PutMapCommand}.   Acknowledges a {@link org.infinispan.commands.write.PutMapCommand} completion in the backup owner. Notifies a change in member list.





Retrieves the next interceptor in the chain. Since 9.0, it returns {@code null} if the next interceptor does not extend {@code CommandInterceptor}. The default behaviour of the visitXXX methods, which is to ignore the call and pass the call up to the next interceptor in the chain. Note: Unlike {@link #getNext()}, this method does not ignore interceptors that do not extend {@code CommandInterceptor} Invokes the next interceptor in the chain.  This is how interceptor implementations should pass a call up the chain to the next interceptor. Does nothing since 9.0.


Accept only the {@code nth} invocation that matches <b>all</b> the other conditions. <p>The default, {@code matchCount = -1}, matches all invocations. Use {@code matchCount >= 0} to match only one invocation, e.g. {@code matchCount = 0} matches the first invocation. Note that a {@code null} origin means any origin, including local. If you need to match only local commands, use {@link #localOnly()}.

Builds a ApplyDeltaCommand used for applying Delta objects to DeltaAware containers stored in cache Builds CancelCommandCommand used to cancel other commands executing on Infinispan cluster Builds a ClearCommand Builds a ClusteredGetAllCommand, which is a remote lookup command Builds a ClusteredGetCommand, which is a remote lookup command Builds a CommitCommand Builds a CompleteTransactionCommand command. Builds a ComputeCommand Builds a ComputeIfAbsentCommand Same as {@code buildCreateCacheCommand(cacheName, cacheConfigurationName, false, 0)}. Builds a CreateCacheCommand used to create/start cache around Infinispan cluster Builds a DistributedExecuteCommand used for migration and execution of distributed Callables and Runnables. Builds a EntrySetCommand Builds an EvictCommand Builds a GetAllCommand Builds a GetCacheEntryCommand Builds a {@link org.infinispan.commands.remote.recovery.GetInDoubtTransactionsCommand}.  Builds a GetKeyValueCommand Builds {@link org.infinispan.commands.remote.GetKeysInGroupCommand} used to fetch all the keys belonging to a group. Builds an InvalidateCommand Builds an InvalidateFromL1Command  Builds a KeySetCommand Same as {@link #buildLockControlCommand(Object, long, GlobalTransaction)} but for locking a single key vs a collection of keys. Builds a LockControlCommand to control explicit remote locking Builds a PrepareCommand Builds a PutKeyValueCommand Builds a PutMapCommand Builds a RemoveCommand Builds an expired remove command that is used to remove only a specific expired entry Builds a ReplaceCommand Builds a RollbackCommand Builds a SingleRpcCommand "envelope" containing a single ReplicableCommand Builds SingleRpcCommand used to perform {@link org.infinispan.commands.VisitableCommand} on the backup site, Builds a SizeCommand Builds a StateRequestCommand used for requesting transactions and locks and for starting or canceling transfer of cache entries. Builds a StateResponseCommand used for pushing cache entries to another node in response to a StateRequestCommand. Builds {@link StreamResponseCommand} used to send back a response either intermediate or complete to the originating node with the information for the stream request. Builds a {@link org.infinispan.commands.remote.recovery.TxCompletionNotificationCommand}.  Builds a VersionedCommitCommand Builds a VersionedPrepareCommand Builds XSiteAdminCommand used to perform system administrator operations. Builds XSiteStatePushCommand used to transfer a single chunk of data between sites. Builds XSiteStateTransferControlCommand used to control the-cross site state transfer. Retrieves the cache name this CommandFactory is set up to construct commands for. Initializes a {@link org.infinispan.commands.ReplicableCommand} read from a data stream with components specific to the target cache instance. <p/> Implementations should also be deep, in that if the command contains other commands, these should be recursed into. <p/>
needs to happen early on


It tries to commit the cache entry. The entry is not committed if it is originated from state transfer and other operation already has updated it.   It starts tracking keys committed. All the keys committed will be flagged with this flag. State transfer received after the key is tracked will be discarded. It stops tracking keys committed.















Disables compatibility mode between embedded. Enables compatibility mode between embedded and different remote endpoints (Hot Rod, Memcached, REST...etc). Sets whether compatibility mode is enabled or disabled. Sets the marshaller instance to be used by the interoperability layer.


Marshals the instance using Protobuf.
Wait for a long time until the {@link CompletableFuture} is completed. It waits until the {@link CompletableFuture} is completed. <p> It ignore if the {@link CompletableFuture} is completed normally or exceptionally.




Usage: ComponentMetadataPersister [path containing .class files to scan] [output file to generate]
Locates metadata for a given component type if registered.  If not registered, superclasses/interfaces are consulted, until, finally, an empty instance of {@link ComponentMetadata} is returned effectively declaring that the component has no dependencies or any lifecycle methods declared. Locates metadata for a given component type if registered.  If not registered, a null is returned. Locates the fully qualified class name of a factory capable of constructing an instance of <pre>componentType</pre>. Typically this is a factory annotated with {@link DefaultFactoryFor}. Initializes this repository.  The Iterable passed in should contain all {@link ModuleMetadataFileFinder} instances for all loaded Infinispan modules.  Note that the core module is always loaded and need not be contained in this iterable. Inject a factory for a given component type.

Invoked after {@link BootstrapFactory} is registered but before any {@link ModuleCommandInitializer}. This is a good place to register components that don't have any dependency. Invoked last after all services are wired Caching shortcut for #getComponent(StreamingMarshaller.class, KnownComponentNames.CACHE_MARSHALLER); Caching shortcut for #getLocalComponent(CommandsFactory.class); Caching shortcut for #getComponent(PerCacheInboundInvocationHandler.class); Caching shortcut for #getComponent(ResponseGenerator.class); Caching shortcut for #getComponent(StateTransferManager.class); Caching shortcut for #getComponent(StateTransferManager.class); Caching shortcut for #getLocalComponent(VersionGenerator.class)



Performs the MBean registration. Unregisters all the MBeans registered through {@link #registerMBeans()}.





Create a File Appender. Returns the file name this appender is associated with.
Returns the FileManager.







Removes all of the mappings from this map. Legacy method testing if some key maps into the specified value in this table.  This method is identical in functionality to {@link #containsValue}, and exists solely to ensure full compatibility with class {@link Hashtable}, which supported this method prior to introduction of the Java Collections framework. Tests if the specified object is a key in this table. Returns <tt>true</tt> if this map maps one or more keys to the specified value. Note: This method requires a full internal traversal of the hash table, and so is much slower than method <tt>containsKey</tt>. Returns an enumeration of the values in this table. Returns a {@link Set} view of the mappings contained in this map. The set is backed by the map, so changes to the map are reflected in the set, and vice-versa.  The set supports element removal, which removes the corresponding mapping from the map, via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt> operations.  It does not support the <tt>add</tt> or <tt>addAll</tt> operations. <p/> <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator that will never throw {@link ConcurrentModificationException}, and guarantees to traverse elements as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect any modifications subsequent to construction. Returns the value to which the specified key is mapped, or {@code null} if this map contains no mapping for the key. <p/> <p>More formally, if this map contains a mapping from a key {@code k} to a value {@code v} such that {@code key.equals(k)}, then this method returns {@code v}; otherwise it returns {@code null}.  (There can be at most one such mapping.) ---------------- Small Utilities -------------- Applies a supplemental hash function to a given hashCode, which defends against poor quality hash functions. This is critical because ConcurrentReferenceHashMap uses power-of-two length hash tables, that otherwise encounter collisions for hashCodes that do not differ in lower or upper bits. Returns <tt>true</tt> if this map contains no key-value mappings. Returns a {@link Set} view of the keys contained in this map.  The set is backed by the map, so changes to the map are reflected in the set, and vice-versa.  The set supports element removal, which removes the corresponding mapping from this map, via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt> operations.  It does not support the <tt>add</tt> or <tt>addAll</tt> operations. <p/> <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator that will never throw {@link ConcurrentModificationException}, and guarantees to traverse elements as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect any modifications subsequent to construction. Returns an enumeration of the keys in this table. Removes any stale entries whose keys have been finalized. Use of this method is normally not necessary since stale entries are automatically removed lazily, when blocking operations are required. However, there are some cases where this operation should be performed eagerly, such as cleaning up old references to a ClassLoader in a multi-classloader environment. <p/> Note: this method will acquire locks, one at a time, across all segments of this table, so if it is to be used, it should be used sparingly. Maps the specified key to the specified value in this table.  Neither the key nor the value can be null. <p/> <p>The value can be retrieved by calling the <tt>get</tt> method with a key that is equal to the original key. Copies all of the mappings from the specified map to this one.  These mappings replace any mappings that this map had for any of the keys currently in the specified map. {@inheritDoc } Removes the key (and its corresponding value) from this map.  This method does nothing if the key is not in the map. {@inheritDoc } {@inheritDoc } {@inheritDoc } Returns the segment that should be used for key with given hash. Returns the number of key-value mappings in this map. If the map contains more than <tt>Integer.MAX_VALUE</tt> elements, returns <tt>Integer.MAX_VALUE</tt>. Returns a {@link Collection} view of the values contained in this map. The collection is backed by the map, so changes to the map are reflected in the collection, and vice-versa.  The collection supports element removal, which removes the corresponding mapping from this map, via the <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt> operations.  It does not support the <tt>add</tt> or <tt>addAll</tt> operations. <p/> <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator that will never throw {@link ConcurrentModificationException}, and guarantees to traverse elements as they existed upon construction of the iterator, and may (but is not guaranteed to) reflect any modifications subsequent to construction.







Adds a new remote server cluster List of regular expressions for classes that can be deserialized using standard Java deserialization when reading data that might have been stored with a different endpoint, e.g. REST. Adds a new remote server Adds a list of remote servers in the form: host1[:port][;host2[:port]]... Configuration for the executor service used for asynchronous work on the Transport, including asynchronous marshalling and Cache 'async operations' such as Cache.putAsync(). For replicated (vs distributed) Hot Rod server clusters, the client balances requests to the servers according to this strategy. For replicated (vs distributed) Hot Rod server clusters, the client balances requests to the servers according to this strategy. For replicated (vs distributed) Hot Rod server clusters, the client balances requests to the servers according to this strategy. Sets the batch size of internal iterators (ie. <code>keySet().iterator()</code>. Defaults to 10_000 Builds a configuration object Specifies the {@link ClassLoader} used to find certain resources used by configuration when specified by name (e.g. certificate stores). Infinispan will search through the classloader which loaded this class, the system classloader, the TCCL and the OSGi classloader (if applicable). Specifies the level of "intelligence" the client should have Configures the connection pool This property defines the maximum socket connect timeout before giving up connecting to the server. Defines the {@link ConsistentHash} implementation to use for the specified version. By default, {@link ConsistentHashV2} is used for version 1 and {@link ConsistentHashV2} is used for version 2. Defines the {@link ConsistentHash} implementation to use for the specified version. By default, {@link ConsistentHashV2} is used for version 1 and {@link ConsistentHashV2} is used for version 2. Whether or not to implicitly FORCE_RETURN_VALUE for all calls. This hint allows sizing of byte buffers when serializing and deserializing keys, to minimize array resizing. It defaults to 64. Allows you to specify a custom {@link Marshaller} implementation to serialize and deserialize user objects. This method is mutually exclusive with {@link #marshaller(Marshaller)}. Allows you to specify a custom {@link Marshaller} implementation to serialize and deserialize user objects. This method is mutually exclusive with {@link #marshaller(Marshaller)}. Allows you to specify an instance of {@link Marshaller} to serialize and deserialize user objects. This method is mutually exclusive with {@link #marshaller(Class)}. It sets the maximum number of retries for each request. A valid value should be greater or equals than 0 (zero). Zero means no retry will made in case of a network failure. It defaults to 10. This property defines the protocol version that this client should use. Defaults to the latest protocol version supported by this client. Security Configuration This property defines the maximum socket read timeout in milliseconds before giving up waiting for bytes from the server. Defaults to 60000 (1 minute) Affects TCP KEEPALIVE on the TCP stack. Defaults to disable Affects TCP NODELAY on the TCP stack. Defaults to enabled Controls which transport to use. Currently only the TcpTransport is supported. Controls which transport to use. Currently only the TcpTransport is supported. This hint allows sizing of byte buffers when serializing and deserializing values, to minimize array resizing. It defaults to 512 This property defines the protocol version that this client should use. Defaults to the latest protocol version supported by this client. Configures this builder using the specified properties






Extracts a boolean value from configuration properties Retrieves a configuration property and parses it as an Integer if it exists, or returns null if the property is not set (undefined). Get the string property or defaults if not present Parses a string to recognize exactly either "true" or "false". In case value is null or an empty string the defValue is returned Parses a string into an integer value.
The entry point of a configuration parser which gets passed a {@link XMLExtendedStreamReader} positioned at a root element associated with the parser itself according to the registered mapping.
Is version previous to, and not including, 1.2?


Returns the builder that was used to build this class.  This is determined by the instance having a class that has a {@link org.infinispan.commons.configuration.BuiltBy} annotation present on it.  If one is not present a {@link org.infinispan.commons.CacheConfigurationException} is thrown The same as {@link org.infinispan.commons.configuration.ConfigurationUtils#builderFor(Object)} except that it won't throw an exception if no builder class is found.  Instead null will be returned.

The name of the cache to configure. If no value is provided the configured cache is the default one.

Get all CacheEntry's that exists for a given key. Note, concurrent calls to this method for the same key will utilise the same CompletableFuture inside this method and consequently return the same results as all other invocations. If this method is invoked during state transfer it will block until rehashing has completed.  Similarly, if state transfer is initiated during an invocation of this method and rehashing affects the segments of the provided key, the initial requests for the entries versions are cancelled and re-attempted once state transfer has completed. This method utilises the addresses of the local {@link DistributionInfo#writeOwners()} to request values for a given key. If a value does not exist for a key at one of the addresses, then a null valued is mapped to said address. Returns a stream of conflicts detected in the cluster. This is a lazily-loaded stream which searches for conflicts by sequentially fetching cache segments from their respective owner nodes.  If a rebalance is initiated whilst the stream is fetching a cache segment, then a CacheException is thrown when executing the stream.   Utilises {@link ConflictManager#getConflicts()} to discover conflicts between Key replicas and utilises the configured {@link EntryMergePolicy} to determine which entry should take precedence. The resulting {@link org.infinispan.container.entries.CacheEntry} is then applied on all replicas in the cluster. Utilises {@link ConflictManager#getConflicts()} to discover conflicts between Key replicas and utilises the provided {@link EntryMergePolicy} to determine which entry should take precedence. The resulting {@link org.infinispan.container.entries.CacheEntry} is then applied on all replicas in the cluster.



Fetches a connection from the factory. Constructs a {@link ConnectionFactory} based on the supplied class name. Constructs a {@link ConnectionFactory} based on the supplied class name. Destroys a connection. Important: null might be passed in, as an valid argument. Starts the connection factory. A pooled factory might be create connections here. Closes the connection factory, including all allocated connections etc.





Specifies what happens when asking for a connection from a server's pool, and that pool is exhausted. Sets the LIFO status. True means that borrowObject returns the most recently used ("last in") idle object in a pool (if there are idle instances available). False means that pools behave as FIFO queues - objects are taken from idle object pools in the order that they are returned. The default setting is true Controls the maximum number of connections per server that are allocated (checked out to client threads, or idle in the pool) at one time. When non-positive, there is no limit to the number of connections per server. When maxActive is reached, the connection pool for that server is said to be exhausted. The default setting for this parameter is -1, i.e. there is no limit. Controls the maximum number of idle persistent connections, per server, at any time. When negative, there is no limit to the number of connections that may be idle per server. The default setting for this parameter is -1. Sets a global limit on the number persistent connections that can be in circulation within the combined set of servers. When non-positive, there is no limit to the total number of persistent connections in circulation. When maxTotal is exceeded, all connections pools are exhausted. The default setting for this parameter is -1 (no limit). The amount of time in milliseconds to wait for a connection to become available when the exhausted action is {@link ExhaustedAction#WAIT}, after which a {@link java.util.NoSuchElementException} will be thrown. If a negative value is supplied, the pool will block indefinitely. Specifies the minimum amount of time that an connection may sit idle in the pool before it is eligible for eviction due to idle time. When non-positive, no connection will be dropped from the pool due to idle time alone. This setting has no effect unless timeBetweenEvictionRunsMillis > 0. The default setting for this parameter is 1800000(30 minutes). Sets a target value for the minimum number of idle connections (per server) that should always be available. If this parameter is set to a positive number and timeBetweenEvictionRunsMillis > 0, each time the idle connection eviction thread runs, it will try to create enough idle instances so that there will be minIdle idle instances available for each server. The default setting for this parameter is 1. Indicates the maximum number of connections to test during idle eviction runs. The default setting is 3. Indicates whether connections should be validated before being taken from the pool by sending an TCP packet to the server. Connections that fail to validate will be dropped from the pool. The default setting for this parameter is false. Indicates whether connections should be validated when being returned to the pool sending an TCP packet to the server. Connections that fail to validate will be dropped from the pool. The default setting for this parameter is false. Indicates whether or not idle connections should be validated by sending an TCP packet to the server, during idle connection eviction runs. Connections that fail to validate will be dropped from the pool. This setting has no effect unless timeBetweenEvictionRunsMillis > 0. The default setting for this parameter is true. Indicates how long the eviction thread should sleep before "runs" of examining idle connections. When non-positive, no eviction thread will be launched. The default setting for this parameter is 2 minutes. Configures the connection pool parameter according to properties

Computes hash code of a given object, and then normalizes it to ensure a positive value is always returned.















Adds the cache with the {@link SiteStatus} connection to the site. Adds the cache with an mixed connection to the site.






Throws {@link WrongContextException} if context is incorrect.



Callback invoked by a created bean when {@link Bean#create(CreationalContext)} is called. Callback invoked by a created bean when {@link Bean#destroy(Object, CreationalContext)} is called.
Create the instance destroy the bean Get the instance
Add a listener for a continuous query. Add a listener for a continuous query. Add a listener for a continuous query. Get the list of currently registered listeners. Unregisters all listeners. Remove a continuous query listener.
Registers a continuous query listener that uses a query DSL based filter. The listener will receive notifications when a cache entry joins or leaves the matching set defined by the query.
Receives notification that a cache entry has joined the matching set. This is invoked initially when receiving the existing entries that match the query and subsequently whenever a previously non-matching entry is updated and starts to match. Receives notification that a cache entry has left the matching set. This can happen due to an update or removal. Receives notification that a cache entry from the matching set was updated and continues to match the query. The modified attributes causing this update are not necessarily part of the query.


Asserts that the given parameter is not {@code null}.
Sets {@code this} flag to the {@code bitSet}.









Wraps a {@link InternalCacheEntry}} with an immutable {@link InternalCacheEntry}}. There is no copying involved.




Sets the counter's initial value. <p> Default value is zero. Sets the counter's name. <p> This attribute is required. Sets the counter's storage mode. <p> Default value is {@link Storage#VOLATILE}.





It generates the {@link CounterEvent}. <p> The {@code value} is the new value of {@link CounterEvent}.






Defines a counter with the specific {@code name} and {@link CounterConfiguration}. <p> It does not overwrite existing configurations.  Returns the {@link StrongCounter} with that specific name. <p> If the {@link StrongCounter} does not exists, it is created based on the {@link CounterConfiguration}. <p> Note that the counter must be defined prior to this method invocation using {@link CounterManager#defineCounter(String, CounterConfiguration)} or via global configuration. This method only supports {@link CounterType#BOUNDED_STRONG} and {@link CounterType#UNBOUNDED_STRONG} counters. Returns the {@link WeakCounter} with that specific name. <p> If the {@link WeakCounter} does not exists, it is created based on the {@link CounterConfiguration}. <p> Note that the counter must be defined prior to this method invocation using {@link CounterManager#defineCounter(String, CounterConfiguration)} or via global configuration. This method only supports {@link CounterType#WEAK} counters.

Clears all the configured counters.   Sets the number of copies of the counter's value available in the cluster. <p> A higher value will provide better availability at the cost of more expensive updates. <p> Default value is 2. Sets the {@link Reliability} mode. <p> Default value is {@link Reliability#AVAILABLE}.
It registers the cache listeners if they aren't already registered. It registers a new counter created locally. It registers an user's {@link CounterListener} for a specific counter. The executor to use where the user's {@link CounterListener} is invoked.





Creates a new valid {@link CounterValue} with the value. Creates a new {@link CounterValue} with the value and state based on the boundaries. Creates a new {@link CounterValue} with the value and state. Creates the initial {@link CounterValue} based on {@link CounterConfiguration}.

Wait until we get responses for all started requests.
























Invoked during the initialization phase.

This specifies a list of {@link InterceptorConfiguration} instances to be referenced when building the interceptor chain.
Adds a new custom interceptor definition, to be added to the cache when the cache is started.

























Returns the capacity of the underlying container. This is only supported if the container is bounded. An {@link UnsupportedOperationException} is thrown otherwise. Removes all entries in the container Computes the new value for the key. <p/> See {@link org.infinispan.container.DataContainer.ComputeAction#compute(Object, org.infinispan.container.entries.InternalCacheEntry, InternalEntryFactory)}. <p/> The {@code key} must be activate by invoking {@link org.infinispan.eviction.ActivationManager#onRemove(Object, boolean)} or {@link org.infinispan.eviction.ActivationManager#onUpdate(Object, boolean)} depending if the value returned by the {@link org.infinispan.container.DataContainer.ComputeAction} is null or not respectively. <p> Note the entry provided to {@link org.infinispan.container.DataContainer.ComputeAction} may be expired as these entries are not filtered as many other methods do. Tests whether an entry exists in the container Returns a mutable set of immutable cache entries exposed as immutable Map.Entry instances. Clients of this method such as Cache.entrySet() operation implementors are free to convert the set into an immutable set if needed, which is the most common use case. <p/> If a client needs to iterate through a mutable set of mutable cache entries, it should iterate the container itself rather than iterating through the return of entrySet(). <p> This set is a read only backed view of the entries underneath. This set will only show non expired entries when invoked. The size method of the set will count expired entries for the purpose of having a O(1) time cost compared to O(N) if it is to not count expired entries. Atomically, it removes the key from {@code DataContainer} and passivates it to persistence. <p/> The passivation must be done by invoking the method {@link org.infinispan.eviction.PassivationManager#passivate(org.infinispan.container.entries.InternalCacheEntry)}. Executes task specified by the given action on the container key/values filtered using the specified key filter. Executes task specified by the given action on the container key/values filtered using the specified keyvalue filter. Retrieves a cached entry {@inheritDoc } <p>This iterator only returns entries that are not expired, however it will not remove them while doing so.</p> Same as {@link DataContainer#iterator()} except that is also returns expired entries. Returns a set of keys in the container. When iterating through the container using this method, clients should never call {@link #get(Object)} method but instead {@link #peek(Object)}, in order to avoid changing the order of the underlying collection as a side of effect of iterating through it. <p> This set of keys will include expired entries. If you wish to only retrieve non expired keys please use the {@link DataContainer#entrySet()} method and retrieve keys from there. Retrieves a cache entry in the same way as {@link #get(Object)}} except that it does not update or reorder any of the internal constructs. I.e., expiration does not happen, and in the case of the LRU container, the entry is not moved to the end of the chain. <p/> This method should be used instead of {@link #get(Object)}} when called while iterating through the data container using methods like {@link #iterator()} to avoid changing the underlying collection's order. Puts an entry in the cache along with metadata adding information such lifespan of entry, max idle time, version information...etc. <p/> The {@code key} must be activate by invoking {@link org.infinispan.eviction.ActivationManager#onUpdate(Object, boolean)}. Removes an entry from the cache <p/> The {@code key} must be activate by invoking {@link org.infinispan.eviction.ActivationManager#onRemove(Object, boolean)}. Resizes the capacity of the underlying container. This is only supported if the container is bounded. An {@link UnsupportedOperationException} is thrown otherwise.   This returns all values in the container including expired entries. If you wish to only receive values that are not expired it is recommended to use {@link DataContainer#entrySet()} and pull values from there directly.
Data container implementation in use
Add key/value property pair to this data container configuration Specify the data container in use Set the {@link org.infinispan.commons.equivalence.Equivalence} instance to use to compare keys stored in data container. {@link org.infinispan.commons.equivalence.Equivalence} implementations allow for custom comparisons to be provided when the JDK, or external libraries, do not provide adequate comparison implementations, i.e. arrays. Set the {@link org.infinispan.commons.equivalence.Equivalence} instance to use to compare values stored in data container. {@link org.infinispan.commons.equivalence.Equivalence} implementations allow for custom comparisons to be provided when the JDK, or external libraries, do not provide adequate comparison implementations, i.e. arrays. Set key/value properties to this {@link DataContainer} configuration











Initializes the {@link BackupWriteRpcCommand} to send the update to backup owner of a key. <p> This method will be invoked in the primary owner only.

name change name change name change name change ========== methods simulating those from SingleCacheManagerTest ========== ===================== MultipleCacheManagersTest methods ==================== name change name change ========================= AbstractInfinispanTest methods ================== name change =========================== AbstractCacheTest methods ====================== name change



It checks for deadlock. <p> It accepts two arguments: the {@code pendingOwner} is a lock owner that tries to acquire the lock and the {@code currentOwner} is the current lock owner. If a deadlock is detected and the {@code pendingOwner} must rollback, it must return {@code true}. If no deadlock is found or the {@code currentOwner} must rollback, it must return {@code false}. <p> This method may be invoked multiples times and in multiple threads. Thread safe is advised.

Whether deadlock detection is enabled or disabled Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock
Disable deadlock detection Enable deadlock detection Enable or disable deadlock detection Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock


Not exposed on interface




{@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc }


{@inheritDoc } Retrieves the default cache associated with this cache manager. Note that the default cache does not need to be explicitly created with {@link #createCache(String, String)} (String)} since it is automatically created lazily when first used. <p/> As such, this method is always guaranteed to return the default cache. Retrieves a named cache from the system. If the cache has been previously created with the same name, the running cache instance is returned. Otherwise, this method attempts to create the cache first. <p/> When creating a new cache, this method will use the configuration passed in to the CacheManager on construction, as a template, and then optionally apply any overrides previously defined for the named cache using the {@link #defineConfiguration(String, Configuration)} or {@link #defineConfiguration(String, String, Configuration)} methods, or declared in the configuration file. {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc }
Do not rely on automatic discovery but enforce the registration of the required Externalizers.



Merges two consistent hash objects that have the same number of segments, numOwners and hash function. For each segment, the primary owner of the first CH has priority, the other primary owners become backups.
Merges two consistent hash objects that have the same number of segments, numOwners and hash function. For each segment, the primary owner of the first CH has priority, the other primary owners become backups. Leavers are removed and segments without owners are assigned new owners. Joiners might get some of the un-owned segments but otherwise they are not taken into account (that should happen during a rebalance).




the main mechanics of invokeAny. This was essentially copied from {@link AbstractExecutorService} doInvokeAny except that we replaced the {@link ExecutorCompletionService} with our {@link DistributedExecutionCompletionService}.
Components that may be constructed by a factory annotated with this annotation.

















Returns the definition of this object.


Stops handling the invocation. This is called when the listener is being unregistered.














Merge the current Delta instance with a given {@link DeltaAware} instance, and return a coherent and complete {@link DeltaAware} instance.  Implementations should be able to deal with null values passed in, or values of a different type from the expected DeltaAware instance.  Usually the approach would be to ignore what is passed in, create a new instance of the DeltaAware implementation that the current Delta implementation is written for, apply changes and pass it back.
Indicate that all deltas collected to date has been extracted (via a call to {@link #delta()}) and can be discarded.  Often used as an optimization if the delta isn't really needed, but the cleaning and resetting of internal state is desirable. Extracts changes made to implementations, in an efficient format that can easily and cheaply be serialized and deserialized.  This method will only be called once for each changeset as it is assumed that any implementation's internal changelog is wiped and reset after generating and submitting the delta to the caller.


Creates a new document having just one field containing a string Returns a list of the values of all stored fields Returns a list of Addresses of all members in the cluster Runs a Query and returns the stored field for each matching document Parses a query using the single field as default





Add a dependency between two elements Return the dependents Check if an element is depended on Remove element from the graph Remove a dependency Calculates a topological sort of the graph, in linear time







The base deployment web archive. The CDI extension is packaged as an individual jar.



Starting point to create a Directory instance.

Was part of the Directory contract for Lucene 2.9.x

Verified the file exists and has a specified value for readLock; Consider that null should be interpreted as value 1; For a given FileCacheKey return the total size of all chunks related to the file. Verifies that no garbage elements are left over in the cache and that for each type of object the expected value is stored. Also asserts for proper size metadata comparing to actual bytes used in chunks. It's assumed that only one index is stored in the inspected cache, and that the index is not being used by IndexReaders or IndexWriters.
Closes the underlying Directory. After it's closed, no other invocations are expected on this Adapter; we don't check explicitly for it as the Directory instance takes care of it.  ContainsKey implementation for chunk elements ContainsKey implementation for chunk elements Guess in how many chunks we should split this file. Should return the same value consistently for the same file (segments are immutable) so that a full segment can be rebuilt from the upper layers without anyone actually specifying the chunks numbers. Index segment files might be larger than 2GB; so it's possible to have an autoChunksize which is too low to contain all bytes in a single array (overkill anyway). In this case we ramp up and try splitting with larger chunkSize values. Load the value for a specific key Loads all "entries" from the CacheLoader; considering this is actually a Lucene index, that's going to transform segments in entries in a specific order, simplest entries first. Load implementation for FileListCacheKey; must return a ConcurrentHashSet containing the names of all files in this Directory. Loads the actual byte array from a segment, in the range of a specific chunkSize. Not that while the chunkSize is specified in this case, it's likely derived from the invocations of other loading methods. Load implementation for FileCacheKey: must return the metadata of the requested file. Load some keys in the collector, excluding some and to a maximum number of collected (non-excluded) keys.
{@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } Force release of the lock in this directory. Make sure to understand the consequences  {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc }




after the distribution manager! ---- WRITE commands








Implementation of abstract method processModelNode suitable for distributed cache


{@inheritDoc } Note: this method doesn't pay attention to ordering constraints and any sorting performed on the stream will be ignored by this terminal operator.  If you wish to have an ordered collector use the {@link DistributedCacheStream#collect(Collector)} method making sure the {@link java.util.stream.Collector.Characteristics#UNORDERED} property is not set. Intermediate operations that are stored for lazy evalulation The next ones are key tracking terminal operators Now we have terminal operators These are the custom added methods for cache streams This is a hack to allow for cast to work properly, since Java doesn't work as well with nested generics

Invoked by execution environment after DistributedCallable has been migrated for execution to a specific Infinispan node.
Rest are terminal operators These are the custom added methods for cache streams
Performs invocation of Callable and returns result
{@inheritDoc CompletionService} {@inheritDoc CompletionService} {@inheritDoc CompletionService} {@inheritDoc CompletionService} {@inheritDoc CompletionService}

Returns DistributedTaskBuilder for this DistributedExecutorService and a given Callable. As it name implies clients can use DistributedTaskBuilder to create DistributedTask instances. Submits the given Callable task for execution on a single Infinispan node. <p> Execution environment will chose an arbitrary node N hosting some or all of the keys specified as input. If all keys are not available locally at node N they will be retrieved from the cluster. Submits the given DistributedTask for execution on a single Infinispan node. <p> Execution environment will chose an arbitrary node N hosting some or all of the keys specified as input. If all keys are not available locally at node N they will be retrieved from the cluster. Submits the given Callable task for execution on the specified target Infinispan node. <p> Submits the given DistributedTask for execution on the specified target Infinispan node. <p> Submits the given Callable task for execution on all available Infinispan nodes. Submits the given Callable task for execution on all available Infinispan nodes using input keys specified by K input. <p> Execution environment will chose all nodes in Infinispan cluster where input keys are local, migrate given Callable instance to those nodes, execute it and return result as a list of Futures Submits the given DistributedTask for execution on all available Infinispan nodes. Submits the given DistributedTask for execution on all available Infinispan nodes using input keys specified by K input. <p> Execution environment will chose all nodes in Infinispan cluster where input keys are local, migrate given Callable instance to those nodes, execute it and return result as a list of Futures
Rest are terminal operators These are the custom added methods for cache streams



Reset are terminal operators These are the custom added methods for cache streams




Acquires a readlock on all chunks for this file, to make sure chunks are not deleted while iterating on the group. This is needed to avoid an eager lock on all elements. If no value is found in the cache, a disambiguation procedure is needed: not value might mean both "existing, no readlocks, no deletions in progress", but also "not existent file". The first possibility is coded as no value to avoid storing readlocks in a permanent store, which would unnecessarily slow down and provide unwanted long term storage of the lock; so the value is treated as one if not found, but obviously it's also not found for non-existent or concurrently deleted files. Deletes or releases a read-lock for the specified filename, so that if it was marked as deleted and no other {@link org.infinispan.lucene.impl.InfinispanIndexInput} instances are reading from it, then it will be effectively deleted. Evaluates if the file is potentially being stored as fragmented into multiple chunks; when it's a single chunk we don't need to apply readlocks. The {@link org.apache.lucene.store.Directory#deleteFile(String)} is not deleting the elements from the cache but instead flagging the file as deletable. This method will really remove the elements from the cache; should be invoked only by {@link #deleteOrReleaseReadLock(String)} after having verified that there are no users left in need to read these chunks.





Returns {@link Callable} for this task Returns custom {@link DistributedTaskExecutionPolicy} for this task Returns custom {@link DistributedTaskFailoverPolicy}  for this task Returns timeout for the execution of this task
Completes creation of DistributedTask with the currently provided attributes of this DistributedTaskBuilder Provide relevant {@link Callable} for the {@link DistributedTask} Provide {@link DistributedTaskExecutionPolicy} for the task being built Provide {@link DistributedTaskFailoverPolicy} for the task being built Provide {@link DistributedTask} task timeout

As parts of distributively executed task can fail due to the task itself throwing an exception or it can be an Infinispan system caused failure (e.g node failed or left cluster during task execution etc). Maximum number of fail over attempts permitted by this DistributedTaskFailoverPolicy




Returns the data locality characteristics of a given key. Returns the first Address containing the key.  Equivalent to returning the first element of {@link #locate(Object)}   Tests whether a given key is affected by a rehash that may be in progress.  If no rehash is in progress, this method returns false.  Helps determine whether additional steps are necessary in handling an operation with a given key. Tests whether the current instance has completed joining the cluster Tests whether a rehash is in progress Locates a key in a cluster.  The returned addresses <i>may not</i> be owners of the keys if a rehash happens to be in progress or is pending, so when querying these servers, invalid responses should be checked for and the next address checked accordingly. Locates a list of keys in a cluster.  Like {@link #locate(Object)} the returned addresses <i>may not</i> be owners of the keys if a rehash happens to be in progress or is pending, so when querying these servers, invalid responses should be checked for and the next address checked accordingly.

Tests whether a rehash is in progress Start before RpcManagerImpl
Returns the key this transaction intends to lock. Sets the random number that defines the coin toss. A coin toss is a random number that is used when a deadlock is detected for deciding which transaction should commit and which should rollback.


Same as {@link DoubleCacheStream#allMatch(DoublePredicate)} except that the DoublePredicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link DoubleCacheStream#anyMatch(DoublePredicate)} except that the DoublePredicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link DoubleCacheStream#collect(Supplier, ObjDoubleConsumer, BiConsumer)} except that the arguments must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } Same as {@link DoubleCacheStream#filter(DoublePredicate)} except that the DoublePredicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc } {@inheritDoc } Same as {@link DoubleCacheStream#flatMap(DoubleFunction)} except that the DoubleFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link DoubleCacheStream#forEach(DoubleConsumer)} except that it takes an {@link ObjDoubleConsumer} that provides access to the underlying {@link Cache} that is backing this stream. <p> Note that the <code>CacheAware</code> interface is not supported for injection using this method as the cache is provided in the consumer directly. Same as {@link DoubleCacheStream#forEach(DoubleConsumer)} except that the DoubleConsumer must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link DoubleCacheStream#forEach(ObjDoubleConsumer)} except that the <code>BiConsumer</code> must also implement <code>Serializable</code> {@inheritDoc } {@inheritDoc } Same as {@link DoubleCacheStream#map(DoubleUnaryOperator)} except that the DoubleUnaryOperator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link DoubleCacheStream#mapToInt(DoubleToIntFunction)} except that the DoubleToIntFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link DoubleCacheStream#mapToLong(DoubleToLongFunction)} except that the DoubleToLongFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link DoubleCacheStream#mapToObj(DoubleFunction)} except that the DoubleFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link DoubleCacheStream#noneMatch(DoublePredicate)} except that the DoublePredicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc }  {@inheritDoc } Same as {@link DoubleCacheStream#flatMap(DoubleFunction)} except that the DoubleFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link DoubleCacheStream#reduce(double, DoubleBinaryOperator)} except that the DoubleBinaryOperator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link DoubleCacheStream#reduce(DoubleBinaryOperator)} except that the DoubleBinaryOperator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc }
{@inheritDoc } Sets an inclusive lower bound of this validator. Sets an exclusive lower bound of this validator. Sets the inclusive upper bound of this validator. Sets the exclusive upper bound of this validator.
Returns the arithmetic mean of seen values, or null if no values have been seen. If any value is a NaN or the sum is at any point a NaN then the average will be NaN. The average returned can vary depending upon the order in which values are seen. Returns the sum of seen values. If any value is a NaN or the sum is at any point a NaN then the average will be NaN. The average returned can vary depending upon the order in which values are seen. Used to compute right sum for non-finite inputs





Starts a new transaction, and associate it with the calling thread. Commit the transaction associated with the calling thread. Get the status of the transaction associated with the calling thread. Get the transaction associated with the calling thread. Resume the association of the calling thread with the given transaction. Rolls back the transaction associated with the calling thread. Mark the transaction associated with the calling thread for rollback only. Just used for unit tests Change the transaction timeout for transactions started by the calling thread with the {@link #begin()} method. Suspend the association the calling thread has to a transaction, and return the suspended transaction. When returning from this method, the calling thread is no longer associated with a transaction.
Adds a new environment property to the environment of this context.  If the property already exists, its value is overwritten. See class description for more details on environment properties. Binds a name to an object. See {@link #bind(Name,Object)} for details. Binds a name to an object. All intermediate contexts and the target context (that named by all but terminal atomic component of the name) must already exist. Closes this context. This method releases this context's resources immediately, instead of waiting for them to be released automatically by the garbage collector. <p/> <p> This method is idempotent:  invoking it on a context that has already been closed has no effect.  Invoking any other method on a closed context is not allowed, and results in undefined behaviour. Composes the name of this context with a name relative to this context. See {@link #composeName(Name,Name)} for details. Composes the name of this context with a name relative to this context. Given a name (<code>name</code>) relative to this context, and the name (<code>prefix</code>) of this context relative to one of its ancestors, this method returns the composition of the two names using the syntax appropriate for the naming system(s) involved.  That is, if <code>name</code> names an object relative to this context, the result is the name of the same object, but relative to the ancestor context.  None of the names may be null. <p/> For example, if this context is named "wiz.com" relative to the initial context, then <pre> composeName("east", "wiz.com")   </pre> might return <code>"east.wiz.com"</code>. If instead this context is named "org/research", then <pre> composeName("user/jane", "org/research")  </pre> might return <code>"org/research/user/jane"</code> while <pre> composeName("user/jane", "research")   </pre> returns <code>"research/user/jane"</code>. Creates and binds a new context. See {@link #createSubcontext(Name)} for details. Creates and binds a new context. Creates a new context with the given name and binds it in the target context (that named by all but terminal atomic component of the name).  All intermediate contexts and the target context must already exist. Destroys the named context and removes it from the namespace. See {@link #destroySubcontext(Name)} for details. Destroys the named context and removes it from the namespace. Any attributes associated with the name are also removed. Intermediate contexts are not destroyed. <p/> <p> This method is idempotent. It succeeds even if the terminal atomic name is not bound in the target context, but throws <tt>NameNotFoundException</tt> if any of the intermediate contexts do not exist. <p/> <p> In a federated naming system, a context from one naming system may be bound to a name in another.  One can subsequently look up and perform operations on the foreign context using a composite name.  However, an attempt destroy the context using this composite name will fail with <tt>NotContextException</tt>, because the foreign context is not a "subcontext" of the context in which it is bound. Instead, use <tt>unbind()</tt> to remove the binding of the foreign context.  Destroying the foreign context requires that the <tt>destroySubcontext()</tt> be performed on a context from the foreign context's "native" naming system. Retrieves the environment in effect for this context. See class description for more details on environment properties. <p/> <p> The caller should not make any changes to the object returned: their effect on the context is undefined. The environment of this context may be changed using <tt>addToEnvironment()</tt> and <tt>removeFromEnvironment()</tt>. Retrieves the full name of this context within its own namespace. <p/> <p> Many naming services have a notion of a "full name" for objects in their respective namespaces.  For example, an LDAP entry has a distinguished name, and a DNS record has a fully qualified name. This method allows the client application to retrieve this name. The string returned by this method is not a JNDI composite name and should not be passed directly to context methods. In naming systems for which the notion of full name does not make sense, <tt>OperationNotSupportedException</tt> is thrown. Retrieves the parser associated with the named context. See {@link #getNameParser(Name)} for details. Retrieves the parser associated with the named context. In a federation of namespaces, different naming systems will parse names differently.  This method allows an application to get a parser for parsing names into their atomic components using the naming convention of a particular naming system. Within any single naming system, <tt>NameParser</tt> objects returned by this method must be equal (using the <tt>equals()</tt> test). Enumerates the names bound in the named context, along with the class names of objects bound to them. See {@link #list(Name)} for details. Enumerates the names bound in the named context, along with the class names of objects bound to them. The contents of any subcontexts are not included. <p/> <p> If a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined. Enumerates the names bound in the named context, along with the objects bound to them. See {@link #listBindings(Name)} for details. Enumerates the names bound in the named context, along with the objects bound to them. The contents of any subcontexts are not included. <p/> <p> If a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined. Retrieves the named object. See {@link #lookup(Name)} for details. Retrieves the named object. If <tt>name</tt> is empty, returns a new instance of this context (which represents the same naming context as this context, but its environment may be modified independently and it may be accessed concurrently). Retrieves the named object, following links except for the terminal atomic component of the name. See {@link #lookupLink(Name)} for details. Retrieves the named object, following links except for the terminal atomic component of the name. If the object bound to <tt>name</tt> is not a link, returns the object itself. Binds a name to an object, overwriting any existing binding. See {@link #rebind(Name,Object)} for details. Binds a name to an object, overwriting any existing binding. All intermediate contexts and the target context (that named by all but terminal atomic component of the name) must already exist. <p/> <p> If the object is a <tt>DirContext</tt>, any existing attributes associated with the name are replaced with those of the object. Otherwise, any existing attributes associated with the name remain unchanged. Removes an environment property from the environment of this context.  See class description for more details on environment properties. Binds a new name to the object bound to an old name, and unbinds the old name. See {@link #rename(Name,Name)} for details. Binds a new name to the object bound to an old name, and unbinds the old name.  Both names are relative to this context. Any attributes associated with the old name become associated with the new name. Intermediate contexts of the old name are not changed. Unbinds the named object. See {@link #unbind(Name)} for details. Unbinds the named object. Removes the terminal atomic name in <code>name</code> from the target context--that named by all but the terminal atomic part of <code>name</code>. <p/> <p> This method is idempotent. It succeeds even if the terminal atomic name is not bound in the target context, but throws <tt>NameNotFoundException</tt> if any of the intermediate contexts do not exist. <p/> <p> Any attributes associated with the name are removed. Intermediate contexts are not changed.
Creates an Initial Context for beginning name resolution. Special requirements of this context are supplied using <code>environment</code>. <p/> The environment parameter is owned by the caller. The implementation will not modify the object or keep a reference to it, although it may keep a reference to a clone or copy.


If true, then writes to this store are artificially slowed by {@value DummyInMemoryStore#SLOW_STORE_WAIT} milliseconds. A storeName can be utilised to lookup existing DummyInMemoryStore instances associated with the provided String. If an instance is already mapped to the provided string, then that instance is utilised.  Otherwise a new instance is created and associated with the given string. This can be useful for testing shared stores, across multiple CacheManager instances.



Implementing an efficient hashCode is critical for performance:






Attempt to commit this transaction. De-list an XA resource from this transaction. Enlist an XA resource with this transaction. Get the status of the transaction. Must be defined for increased performance Register a {@link Synchronization} callback with this transaction. Rolls back this transaction. Runs the second phase of two-phase-commit protocol. If {@code forceRollback} is {@code true}, then a {@link RollbackException} is thrown with the message {@link #FORCE_ROLLBACK_MESSAGE}. Mark the transaction so that the only possible outcome is a rollback.


Starts a new transaction, and associate it with the calling thread. Attempt to commit this transaction. Get the status of the transaction. Rolls back this transaction. Mark the transaction so that the only possible outcome is a rollback. Change the transaction timeout for transactions started by the calling thread with the {@link #begin()} method.


Creates new {@link DefaultCacheManager} with default {@link org.infinispan.configuration.cache.Configuration}. This test will fail if CDI Extension registers and won't set Cache Manager's name.








HSEARCH-2389





Add a dependency between two caches. The cache manager will make sure that a cache is stopped before any of its dependencies A cache is considered to exist if it has been created and started via one of the {@link #getCache()} methods and has not yet been removed via {@link #removeCache(String)}. </p> In environments when caches are continuously created and removed, this method offers the possibility to find out whether a cache has either, not been started, or if it was started, whether it's been removed already or not. Defines a named cache's configuration using by first reading the template configuration and then applying the override afterwards to generate a configuration. <p/> The other way to define named cache's configuration is declaratively, in the XML file passed in to the cache manager. <p/> If templateName is null or there isn't any named cache with that name, this methods works exactly like {@link #defineConfiguration(String, Configuration)}. <p/> If this cache was already configured either declaritively or programmatically this method will throw a {@link org.infinispan.commons.CacheConfigurationException}. Defines a named cache's configuration by using the provided configuration <p/> Unlike previous versions of Infinispan, this method does not build on an existing configuration (default or named). If you want this behavior, then use {@link ConfigurationBuilder#read(org.infinispan.configuration.cache.Configuration)}. <p/> The other way to define named cache's configuration is declaratively, in the XML file passed in to the cache manager. <p/> If this cache was already configured either declaritively or programmatically this method will throw a {@link org.infinispan.commons.CacheConfigurationException}. Providess the cache manager based executor.  This can be used to execute a given operation upon the cluster or a single node if desired.  If this manager is not clustered this will execute locally only. <p> Note that not all {@link EmbeddedCacheManager} implementations may implement this.  Those that don't will throw a {@link UnsupportedOperationException} upon invocation.  Retrieves a named cache from the system in the same way that {@link #getCache(String)} does except that if offers the possibility for the named cache not to be retrieved if it has not yet been started, or if it's been removed after being started. If a non-template configuration exists with the same name, it will be used to configure the cache. Retrieves a named cache from the system in the same way that {@link #getCache(String)} does except that if offers the possibility to specify a specific configuration template. Multiple caches can be created using the same configuration. Retrieves a named cache from the system in the same way that {@link #getCache(String)} does except that if offers the possibility to specify a specific configuration template. Multiple caches can be created using the same configuration. Tihs method also offers the possibility for the named cache not to be retrieved if it has not yet been started, or if it's been removed after being started. Returns the configuration for the given cache. This method returns a collection of cache configuration names which contains the cache configurations that have been defined via XML or programmatically, and the cache configurations that have been defined at runtime via this cache manager instance. If no cache configurations are registered or no caches have been created, this method returns an empty set.  The default cache is never included in this set of cache names, as well a caches for internal-only use {@link org.infinispan.registry.InternalCacheRegistry} Returns global configuration for this CacheManager This method returns a collection of caches names which contains the caches that have been defined via XML or programmatically, and the caches that have been created at runtime via this cache manager instance. If no named caches are registered or no caches have been created, this method returns an empty set.  The default cache is never included in this set of cache names, as well a caches for internal-only use {@link org.infinispan.registry.InternalCacheRegistry}   Returns default configuration for this CacheManager Returns an entry point for a Health Check API.  Returns statistics for this cache manager since 7.1    Tests whether the default cache is running. Tests whether a named cache is running. Removes a cache with the given name from the system. This is a cluster wide operation that results not only in stopping the cache with the given name in all nodes in the cluster, but also deletes its contents both in memory and in any backing cache store. Starts a set of caches in parallel. Infinispan supports both symmetric and asymmetric clusters; that is, multiple nodes having the same or different sets of caches running, respectively. Calling this method on application/application server startup with all your cache names will ensure that the cluster is symmetric. Removes a configuration from the set of defined configurations. If the configuration is currently in use by one of the caches, an {@link IllegalStateException} is thrown. If the named configuration does not exist, nothing happens
































Cache name used for storing session data. This is the session timeout in seconds. By default, it is set to 1800 seconds (30 minutes). This should be a non-negative integer.
Cache name used for storing session data. This is the session timeout in seconds. By default, it is set to 1800 seconds (30 minutes). This should be a non-negative integer.
Convert from storage format to the read/write format. Each encoder is associated with an unique id in order to optimize serialization. Known ids are kept in {@link EncoderIds}.  Convert data in the read/write format to the storage format.

HACK!











Decode object from storage format. Encode object to storage format.










Logs an informational message indicating that an endpoint has started Logs an informational message indicating that an endpoint is being started. Logs an informational message indicating that an endpoint has started









todo [anistor] now that all types are predeclared we could be able to resolve unqualified type names too




Wraps an entry for reading.  Usually this is just a raw {@link CacheEntry} but certain combinations of isolation levels and the presence of an ongoing JTA transaction may force this to be a proper, wrapped MVCCEntry.  The entry is also typically placed in the invocation context. Insert an entry that exists in the data container into the context. Doesn't do anything if the key was already wrapped. Insert an external entry (e.g. loaded from a cache loader or from a remote node) into the context.



Retrieves a map of entries looked up within the current scope. <p/> Retrieves an entry from the collection of looked up entries in the current scope. <p/> Puts an entry in the registry of looked up entries in the current scope. <p/>
This method is called by {@link ConflictManager#resolveConflicts()} for each conflict discovered to determine which {@link CacheEntry} should be utilised. This merge policy is used when a user explicitly calls {@link ConflictManager#resolveConflicts()} as well as when a partition merge occurs with {@link PartitionHandling#ALLOW_READ_WRITES} set. In the event of a partition merge, we define the preferred partition as the partition whom's coordinator is coordinating the current merge.




Method used to calculate how much memory in size the key and value use.

Compares the given version against the current instance.


For convenience, a lambda might decide to return the entry view it received as parameter, because that makes easy to return both value and meta parameters back to the client. <p> If the lambda function decides to return an view, launder it into an immutable view to avoid the user trying apply any modifications to the entry view from outside the lambda function. <p> If the view is read-only, capture its data into a snapshot from the cached entry and avoid changing underneath.

Locks the value for the keys accessed by the command to avoid being override from a remote get. Locks the value for the keys accessed by the command to avoid being override from a remote get. total order condition: only commits when it is remote context and the prepare has the flag 1PC set






Compares the two given objects for order. Returns a negative integer, zero, or a positive integer as the first object is less than, equal to, or greater than the second object. For future support for objects that are not comparable, i.e. arrays Indicates whether the objects passed are "equal to" each other. As an example, implementors can provide an alternative implementation for the equals for arrays. So, instead of relying on {@link Object#equals(Object)}}, call {@link java.util.Arrays#equals(Object[], Object[])}. Returns a hash code value for the object passed. As an example, implementors can provide an alternative implementation for the hash code calculation for arrays. So, instead of relying on {@link Object#hashCode()}, call {@link java.util.Arrays#hashCode()}. Returns whether the given object is comparable. In other words, if given an instance of the object, a sensible comparison can be computed using {@link #compare(Object, Object)} method. For future support for objects that are not comparable, i.e. arrays Returns a string representation of the given object.


Adds the specified element to this set if it is not already present. Removes all of the elements from this set. Returns {@code true} if this set contains the specified element. Returns the hash code value for this set using the {@link Equivalence} function associated with it.  The hash code of a set is defined to be the sum of the hash codes of the elements in the set, where the hash code of a <tt>null</tt> element is defined to be zero. This ensures that {@link Equivalence#equals(Object s1, Object s2)} implies that {@link Equivalence#hashCode(Object s1)}=={@link Equivalence#hashCode(Object s2)} for any two sets <tt>s1</tt> and <tt>s2</tt>, as required by the general contract of {@link Object#hashCode}. <p>This implementation iterates over the set, calling the <tt>hashCode</tt> method on each element in the set, and adding up the results. Returns {@code true} if this set contains no elements. Returns an iterator over the elements in this set. Removes the specified element from this set if it is present. Returns the number of elements in this set.  If this set contains more than {@code Integer.MAX_VALUE} elements, it returns {@code Integer.MAX_VALUE}.




------------------------------ setters -----------------------------




Replaces the event logger with the provided one.

Sets a context of this event log. Sets a cache as context of this event log. The name of the cache will be used to indicate the context. Sets a detail for this event log which could include additional information. Sets a throwable to include as detail for this event. Both the localized message of the Throwable as well as its stack trace will be recorded as the event's detail Logs a message to the event log using the {@link EventLogLevel#ERROR} severity Logs a message to the event log using the {@link EventLogLevel#FATAL} severity Retrieves the event logs from the cluster within the specified range Logs a message to the event log using the {@link EventLogLevel#INFO} severity Logs a message to the event log with the specified level Sets the scope of this event log, e.g. a node address. This should be used for events which reference a single node in the cluster Sets a node address as the scope of this event log Logs a message to the event log using the {@link EventLogLevel#WARN} severity Sets a security name for this event log. Sets a security principal for this event log. The name of the principal will be recorded in the log. Sets a security subject for this event log. The name of the main user principal of the subject will be recorded in the log.








Maximum number of entries in a cache instance. Cache size is guaranteed not to exceed upper limit specified by max entries. However, due to the nature of eviction it is unlikely to ever be exactly maximum number of entries specified here. Only makes sense when using the COUNT type.  Eviction strategy. Available options are 'UNORDERED', 'LRU', 'LIRS' and 'NONE' (to disable eviction). Threading policy for eviction.
Maximum number of entries in a cache instance. Backward-compatible shortcut for type(EvictionType.COUNT).size(maxEntries); Defines the maximum size before eviction occurs. See {@link #type(EvictionType)} Eviction strategy. Available options are 'UNORDERED', 'LRU', 'LIRS' and 'NONE' (to disable eviction). Threading policy for eviction. Sets the eviction type which can either be <ul> <li>COUNT - entries will be evicted when the number of entries exceeds the {@link #size(long)}</li> <li>MEMORY - entries will be evicted when the approximate combined size of all values exceeds the {@link #size(long)}</li> </ul> Cache size is guaranteed not to exceed upper limit specified by max entries. However, due to the nature of eviction it is unlikely to ever be exactly maximum number of entries specified here.


Called back when an entry has been activated Called back before an entry is evicted Called back after entries have been evicted Called when an entry is specifically removed from the container.
Handles notifications of evicted entries





Need to de-serialize the object as the default JavaSerializationMarshaller is used by Memcached endpoint.



TODO: was package-level initially TODO: was package-level initially TODO: was package-level initially TODO: was package-level initially
Execute against the specified context.





Add key/value property pair to this executor factory configuration Specify factory class for executor Specify factory class for executor Set key/value properties to this executor factory configuration

Gets the highest internal buffer size after which if more capacity is needed the buffer will grow in 25% increments rather than 100%. Gets the number of bytes to which the internal buffer should be resized. Gets the internal buffer array. Note that the length of this array will almost certainly be longer than the data written to it; call <code>size()</code> to get the number of bytes of actual data. Overriden only to avoid unneeded synchronization


Return expiry for a given cache operation. It returns null when the expiry time cannot be determined, in which case clients should not update expiry settings for the cached entry.
Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire. Note that this can be overridden on a per-entry basis by using the Cache API. Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire. Note that this can be overridden on a per-entry basis by using the Cache API. Determines whether the background reaper thread is enabled to test entries for expiration. Regardless of whether a reaper is used, entries are tested for expiration lazily when they are touched. Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set wakeupInterval to -1.
Disable the background reaper to test entries for expiration. to test entries for expiration. Regardless of whether a reaper is used, entries are tested for expiration lazily when they are touched. Enable the background reaper to test entries for expiration. Regardless of whether a reaper is used, entries are tested for expiration lazily when they are touched. Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire. Note that this can be overridden on a per-entry basis by using the Cache API. Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire. Note that this can be overridden on a per-entry basis by using the Cache API. Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire. Note that this can be overridden on a per-entry basis by using the Cache API. Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire. Note that this can be overridden on a per-entry basis by using the Cache API. Enable the background reaper to test entries for expiration. Regardless of whether a reaper is used, entries are tested for expiration lazily when they are touched. Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set wakeupInterval to -1. Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set wakeupInterval to -1.



This should be invoked passing in an entry that is now expired.  This method may attempt to lock this key to preserve atomicity. This is to be invoked when a store entry expires.  This method may attempt to lock this key to preserve atomicity. <p> Note this method doesn't currently take a {@link InternalCacheEntry} and this is due to a limitation in the cache store API.  This may cause some values to be removed if they were updated at the same time. This is to be invoked when a store entry expires and the value and/or metadata is available to be used.  This method is preferred over {@link ExpirationManager#handleInStoreExpiration(Object)} as it allows for more specific expiration to possibly occur.  Processes the expiration event queue. This is to be invoked with a when a write is known to occur to prevent expiration from happening.  This way we won't have a swarm of remote calls required. This should always be invoked after registering write but after performing any operations required.

Deletes the key from the store as well as notifies the cache listeners of the expiration of the given key, value, metadata combination. make sure this starts after the PersistenceManager
handler


Gets the highest internal buffer size after which if more capacity is needed the buffer will grow in 25% increments rather than 100%. Gets the number of bytes to which the internal buffer should be resized. Gets the internal buffer array. Note that the length of this array will almost certainly be longer than the data written to it; call <code>size()</code> to get the number of bytes of actual data. Overriden only to avoid unneeded synchronization




Reads a byte if possible.  If not present the reader index is reset to the last mark. Read a range of bytes prefixed by its length (encoded as a signed VInt). Reads a range of bytes if possible.  If not present the reader index is reset to the last mark. Reads a string if possible.  If not present the reader index is reset to the last mark. Reads a variable size int if possible.  If not present the reader index is reset to the last mark. Reads a variable long if possible.  If not present the reader index is reset to the last mark. Reads optional range of bytes. Negative lengths are translated to None, 0 length represents empty Array Reads an optional String. 0 length is an empty string, negative length is translated to None. Reads length of String and then returns an UTF-8 formatted String of such length. If the length is 0, an empty String is returned.


It cancels the {@link LockPromise} if possible.

Returns number unread buffered bytes.


public to be used by the tests JMX exposed methods it is going to replace LockManager and RpcManager. set to 11 because DeadlockDetectingLockManager has default priority of 10 and RpcManagerImpl has priority 9.



it adds the value to the statistic. If the statistic does not exist in this container, it fails silently  it merges in {@code this} the statistic's values in {@code other}. If for some reason the {@code other} cannot be merged, it fails silently










Read an instance from the stream.  The instance will have been written by the {@link #writeObject(ObjectOutput, Object)} method.  Implementations are free to create instances of the object read from the stream in any way that they feel like. This could be via constructor, factory or reflection. Write the object reference to the stream.



Adds package or class name to the externally marshallable white list.


Returns the Throwable which was the cause of the task failure. This includes both system exception related to Infinispan transient failures (node crash, transient errors etc) as well as application level exceptions. Returned Throwable will most likely contain the chain of Exceptions that interested clients can inspect and, if desired, find the root cause of the returned Throwable Returns a list of candidates for possible repeated execution governed by installed {@link DistributedTaskFailoverPolicy} Returns an Address of the node where the task failed Returns a list of input keys for this task. Note that this method does not return all of the keys used as input for {@link DistributedTask} but rather only the input keys used as input for a part of that task where the execution failed




Returns a string representation of this map.  The string representation consists of a list of key-value mappings in the order returned by the map's <tt>entrySet</tt> view's iterator, enclosed in braces (<tt>"{}"</tt>).  Adjacent mappings are separated by the characters <tt>", "</tt> (comma and space).  Each key-value mapping is rendered as the key followed by an equals sign (<tt>"="</tt>) followed by the associated value.  Keys and values are converted to strings as by {@link String#valueOf(Object)}.

Set the fetch mode to be used to fetch matching results Set the fetch size for batch loading of matches


Get the fileName. Get the indexName. Changing the encoding could break backwards compatibility

Guaranteed to be a power of two
Get the indexName. Changing the encoding could break backwards compatibility
Adds the filename from the set if it exists Removes the filename from the set if it exists
Adds a new fileName in the list of files making up this index Deleted a file from the list of files actively part of the index     Optimized implementation to perform both a remove and an add Makes sure the Cache is updated.
Looks up the file, see : {@link FileLookupFactory.DefaultFileLookup}. Looks up the file, see : {@link FileLookupFactory.DefaultFileLookup}. Looks up the file, see : {@link FileLookupFactory.DefaultFileLookup}.



Get the fileName. Get the indexName.

Receives notification that an instance matches the filter.

Creates a new context and connects it with the current one using boolean AND. The new context is added after the current one. The two conditions are not grouped so operator precedence in the resulting condition might change. <p/> The effect is: a AND b Connects a given context with the current one using boolean AND. The new context is added after the current one and is grouped. Operator precedence will be unaffected due to grouping. <p/> The effect is: a AND (b) Creates a new context and connects it with the current one using boolean OR. The new context is added after the current one. <p/> The effect is: a OR b Connects a given context with the current one using boolean OR. The new context is added after the current one and is grouped. <p/> The effect is: a OR (b) Get the {@link QueryBuilder} that created this context. As of Infinispan 9.0 this is no longer needed.

Checks that the left argument is between the given range limits. The limits are inclusive by default, but this can be changed using the methods from the returned {@link RangeConditionContext} Checks that the left argument (which is expected to be an array or a Collection) contains the given element. Checks that the left argument (which is expected to be an array or a Collection) contains all of the the given elements, in any order. Checks that the left argument (which is expected to be an array or a Collection) contains all the elements of the given collection, in any order. Checks that the left argument (which is expected to be an array or a Collection) contains any of the the given elements. Checks that the left argument (which is expected to be an array or a Collection) contains any of the elements of the given collection. Checks that the left argument is equal to the given value. Alias for {@link #eq(Object)} Checks that the left argument is greater than the given value. Checks that the left argument is greater than or equal to the given value. Checks that the left operand is equal to one of the (fixed) list of values given as argument. Checks that the left operand is equal to one of the elements from the Collection of values given as argument. Checks that the left argument is null. Checks that the left argument (which is expected to be a String) matches a wildcard pattern that follows the JPA rules. Checks that the left argument is less than the given value. Checks that the left argument is less than or equal to the given value.



Returns the result of the filter. This method should be called only after the evaluation of all predicates (except the ones that were suspended).

Starts handling an invocation that uses an {@link IndexedFilter}. Start the provider. This is called after the dependencies are injected. Stop the provider. Reports whether this provider supports the given filter type.










The associated callback that is being notified of successful matches. The comparator corresponding to the 'order by' clause, if any. The fully qualified entity type name accepted by this filter. The event types. The array of '.' separated path names of the projected fields if any, or {@code null} otherwise. The array of sort specifications if defined, or {@code null} otherwise.

Registers a listener limiting the cache-entry specific events only to annotations that are passed in as parameter. <p/> For example, if the listener passed in contains callbacks for {@link CacheEntryCreated} and {@link CacheEntryModified}, and filtered annotations contains only {@link CacheEntryCreated}, then the listener will be registered only for {@link CacheEntryCreated} callbacks. <p/> Callback filtering only applies to {@link CacheEntryCreated}, {@link CacheEntryModified}, {@link CacheEntryRemoved} and {@link CacheEntryExpired} annotations. If the listener contains other annotations, these are preserved. <p/> This methods enables dynamic registration of listener interests at runtime without the need to create several different listener classes. Adds a listener to the component.  Typically, listeners would need to be annotated with {@link org.infinispan.notifications.Listener} and further to that, contain methods annotated appropriately, otherwise the listener will not be registered. <p/> See the {@link org.infinispan.notifications.Listener} annotation for more information. <p/> Registers a listener that will be notified on events that pass the filter condition.  The value presented in the notifications will be first converted using the provided converter if there is one. <p> Some implementations may provide optimizations when a {@link org.infinispan.notifications.cachelistener.filter.CacheEventFilterConverter} is provided as both arguments to the <b>filter</b> and <b>converter</b> arguments.  Note the provided object must have reference equality ie. (==) to be recognized.  This allows for the filter and conversion step to take place in the same method call reducing possible overhead.


Warning: with pessimistic locking/optimistic locking without WSC, when the map is removed and a new key is added before the removal transaction commit, the map may be removed but the key left dangling.
Allocates shards in a round robin fashion for the servers, ignoring those without segments. Associates segments to each shard.

Add a single flag to the command. Add a set of flags to the command. Add a set of flags to the command.   Check whether any of the flags in the {@code flagsBitSet} parameter is present in the command. Should be used with the constants in {@link FlagBitSets}. Check whether a particular flag is present in the command. Set the flags, replacing any existing flags. Set the flags, replacing any existing flags.

Creates a copy of a Flag BitSet removing instances of FAIL_SILENTLY.


































All calls to this {@link Bean} instance are forwarded to the delegate unless overridden.
We already break equals contract in several places when comparing all the various CacheEntry types as the same ones We already break hashcode contract in several places when comparing all the various CacheEntry types as the same ones

All calls to this {@link ObserverMethod} instance are forwarded to the delegate unless overridden.
Calculates a hash code by summing the hash code of all elements. Compares this Fqn to another Returns true if obj is a Fqn with the same elements. Retrieves an Fqn that represents the array of elements passed in. ----------------- END: Private constructors for use by factory methods only. ---------------------- Retrieves an Fqn that represents the list of elements passed in. Retrieves an Fqn that represents the array of elements passed in, relative to the base Fqn. Retrieves an Fqn that represents the absolute Fqn of the relative Fqn passed in. Retrieves an Fqn that represents the List<Object> of elements passed in, relative to the base Fqn. Returns a new Fqn from a string, where the elements are deliminated by one or more separator ({@link #SEPARATOR}) characters.<br><br> Example use:<br> <pre> Fqn.fromString("/a/b/c/"); </pre><br> is equivalent to:<br> <pre> Fqn.fromElements("a", "b", "c"); </pre>  Obtains an ancestor of the current Fqn.  Literally performs <code>elements.subList(0, generation)</code> such that if <code> generation == Fqn.size() </code> then the return value is the Fqn itself (current generation), and if <code> generation == Fqn.size() - 1 </code> then the return value is the same as <code> Fqn.getParent() </code> i.e., just one generation behind the current generation. <code> generation == 0 </code> would return Fqn.ROOT.  If this is the root, returns {@link Fqn#SEPARATOR}. Returns the parent of this Fqn. The parent of the root node is {@link #ROOT}. Examples: <pre> Fqn<String> f1 = Fqn.fromString("/a"); Fqn<String> f2 = Fqn.fromString("/a/b"); assertEquals(f1, f2.getParent()); assertEquals(Fqn.ROOT, f1.getParent().getParent()); assertEquals(Fqn.ROOT, Fqn.ROOT.getParent()); </pre> Obtains a sub-Fqn from the given Fqn.  Literally performs <code>elements.subList(startIndex, endIndex)</code>  Returns a hash code with Fqn elements. Returns true if this Fqn is child of parentFqn. Example usage: <pre> Fqn<String> f1 = Fqn.fromString("/a/b"); Fqn<String> f2 = Fqn.fromString("/a/b/c"); assertTrue(f1.isChildOf(f2)); assertFalse(f1.isChildOf(f1)); assertFalse(f2.isChildOf(f1)); </pre> Returns true if this Fqn is equals or the child of parentFqn. Example usage: <pre> Fqn<String> f1 = Fqn.fromString("/a/b"); Fqn<String> f2 = Fqn.fromString("/a/b/c"); assertTrue(f1.isChildOrEquals(f2)); assertTrue(f1.isChildOrEquals(f1)); assertFalse(f2.isChildOrEquals(f1)); </pre> Returns true if this Fqn is a <i>direct</i> child of a given Fqn. Returns true if this is a root Fqn. Peeks into the elements that build up this Fqn.  The list returned is read-only, to maintain the immutable nature of Fqn. Creates a new Fqn whose ancestor has been replaced with the new ancestor passed in. declared final so compilers can optimise and in-line.  Returns this Fqn as a string, prefixing the first element with a {@link Fqn#SEPARATOR} and joining each subsequent element with a {@link Fqn#SEPARATOR}. If this is the root Fqn, returns {@link Fqn#SEPARATOR}. Example: <pre> new Fqn(new Object[] { "a", "b", "c" }).toString(); // "/a/b/c" Fqn.ROOT.toString(); // "/" </pre>
Returns -1 if the first comes before; 0 if they are the same; 1 if the second Fqn comes before.  <code>null</code> always comes first. Compares two Fqn elements. If e1 and e2 are the same class and e1 implements Comparable, returns e1.compareTo(e2). Otherwise, returns e1.toString().compareTo(e2.toString()).








////////////////////////////////////////////////////////////////////////// ////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////


Functional map's name. Functional map's status. Tells if the underlying cache is using encoding or not Tweak functional map executions providing {@link Param} instances.
Finds the first decorated cache if there are delegates surrounding it otherwise null
Notify registered {@link ReadWriteListener} instances of the created entry. Notify registered {@link ReadWriteListener} instances of the modified entry passing the previous and new value. Notify registered {@link ReadWriteListener} instances of the removed entry passing in the removed entry. Notify registered {@link WriteListener} instances of the written entry.








Try to figure out which TransactionManager to use Get the system-wide used TransactionManager





















































The instance of an {@link AuditLogger} to be used to track operations performed on caches and cachemanagers. The default logger is the {@link NullAuditLogger}. You can also use the {@link LoggingAuditLogger} which will send audit messages to the log. The class of a mapper which converts the {@link Principal}s associated with a {@link Subject} into a set of roles
Removes a cache with the given name, returning true if the cache was removed.
Set up a list of sequencer states after interceptor {@code interceptorClass} has returned. <p/> Each invocation accepted by {@code matcher} will enter/exit the next state from the list, and does nothing after the list is exhausted. Set up a list of sequencer states before interceptor {@code interceptorClass} is called. <p/> Each invocation accepted by {@code matcher} will enter/exit the next state from the list, and does nothing after the list is exhausted.
Get the classloader in use by this configuration.
Helper method that gets you a default constructed GlobalConfiguration, preconfigured to use the default clustering stack. Helper method that gets you a default constructed GlobalConfiguration, preconfigured for use in LOCAL mode
Configuration for the asynchronous operations thread pool Builds a {@link GlobalConfiguration} object using the settings applied to this builder Sets the name of the cache that acts as the default cache and is returned by {@link EmbeddedCacheManager#getCache()}. Not Please use {@link GlobalConfigurationChildBuilder#expirationThreadPool()} Configuration for the expiration thread pool Global JMX configuration Global state configuration Configuration for the listener thread pool Global modules configuration Configuration for the persistence thread pool  Security-related configuration Global serialization (i.e. marshalling) configuration Shutdown configuration Cross-site replication configuration Configuration for the state-transfer thread pool Transport-related (i.e. clustering) configuration


If true, multiple cache manager instances could be configured under the same configured JMX domain. Each cache manager will in practice use a different JMX domain that has been calculated based on the configured one by adding an incrementing index to it. If JMX statistics are enabled, this property represents the name of this cache manager. It offers the possibility for clients to provide a user-defined name to the cache manager which later can be used to identify the cache manager within a JMX based management tool amongst other cache managers that might be running under the same JVM. If JMX statistics are enabled then all 'published' JMX objects will appear under this name. This is optional, if not specified an object name will be created for you by default. Sets the instance of the {@link org.infinispan.jmx.MBeanServerLookup} class to be used to bound JMX MBeans to. Sets properties which are then passed to the MBean Server Lookup implementation specified.
Should start after the externalizer table and before transport Stop after transport to avoid send/receive and marshaller not being ready

Adds a permission to a role Adds a permission to a role



Defines global roles as groups of permissions Defines the timeout in milliseconds for which to cache user access roles. A value of -1 means the entries never expire. A value of 0 will disable the cache. Defines the timeout for which to cache user access roles. A value of -1 means the entries never expire. A value of 0 will disable the cache.
Flushes the ACL cache for this node Returns the global ACL cache


Returns the filesystem path where persistent state data which needs to survive container restarts should be stored. Defaults to the user.dir system property which usually is where the application was started. Returns the filesystem path where temporary state should be stored. Defaults to the value of the java.io.tmpdir system property.
Enables or disables the storage of global state. Defines the filesystem path where persistent state data which needs to survive container restarts should be stored. The data stored at this location is required for graceful shutdown and restore. Defaults to the user.dir system property which usually is where the application was started. This value should be overridden to a more appropriate location. Defines the filesystem path where temporary state should be stored. Defaults to the value of the java.io.tmpdir system property.

Reads the persistent state for the specified scope. Registers a state provider within this state manager Persists the global state by contacting all registered scope providers Persists the specified scoped state

Must start before everything else
This method is invoked by the {@link GlobalStateManager} just before persisting the global state This method is invoked by the {@link GlobalStateManager} after starting up to notify that global state has been restored.

Returns a simplified representation of the transaction.











Checks whether the parent directories are present (and are directories). If createIfAbsent is true, creates missing dirs Guaranteed to be a power of two Returns path of this file. To avoid issues arising from file separator differences between different operative systems, the path returned always uses Unix-like path separator, '/' character. Any client code calling this method should bear that if disecting the path. Verifies whether child is a child (dir or file) of parent
Returns the file denoted by pathname. Returns the file denoted by pathname. If the file does not yet exist, it is initialized with the given chunkSize. However, if the file at pathname already exists, the chunkSize parameter is ignored and the file's actual chunkSize is used. Opens an InputStream for reading from the given file. Opens an InputStream for reading from the file denoted by pathname. Opens an OutputStream for writing to the file denoted by pathname. If a file at pathname already exists, writing to the returned OutputStream will overwrite the contents of the file. Opens an OutputStream for writing to the file denoted by pathname. The OutputStream can either overwrite the existing file or append to it. Opens an OutputStream for writing to the file denoted by pathname. Opens an OutputStream for writing to the given file. Opens a ReadableGridFileChannel for reading from the file denoted by the given file path. One of the benefits of using a channel over an InputStream is the possibility to randomly seek to any position in the file (see #ReadableGridChannel.position()). Opens a WritableGridFileChannel for writing to the file denoted by pathname. If a file at pathname already exists, writing to the returned channel will overwrite the contents of the file. Opens a WritableGridFileChannel for writing to the file denoted by pathname. The channel can either overwrite the existing file or append to it. Opens a WritableGridFileChannel for writing to the file denoted by pathname. Removes the file denoted by absolutePath.



related to ISPN-2127


Get the group for a given key It returns the primary owner of the group. Checks if this node is an owner of the group. It checks if this node is the primary owner of the group.






If grouping support is enabled, then {@link Group} annotations are honored and any configured groupers will be invoked Get's the current groupers in use
Add a grouper Clear the groupers Disable grouping support so that {@link Group} annotations are not used and any configured groupers will not be be invoked Enable grouping support so that {@link Group} annotations are honored and any configured groupers will be invoked Enable grouping support so that {@link Group} annotations are honored and any configured groupers will be invoked Set the groupers to use





Removes the {@link CounterListener}.
Hashes a byte array efficiently. An incremental version of the hash function, that spreads a pre-calculated hash code, such as one derived from {@link Object#hashCode()}. A helper that calculates the hashcode of an object, choosing the optimal mechanism of hash calculation after considering the type of the object (byte array, String or Object).
Controls the proportion of entries that will reside on the local node, compared to the other nodes in the cluster. This is just a suggestion, there is no guarantee that a node with a capacity factor of {@code 2} will have twice as many entries as a node with a capacity factor of {@code 1}.  The consistent hash factory in use. Configuration for various grouper definitions. See the user guide for more information. The hash function in use. Used as a bit spreader and a general hash code generator. Typically one of the the many default {@link org.infinispan.distribution.ch.ConsistentHash} implementations shipped. Number of cluster-wide replicas for each cache entry. Controls the total number of hash space segments (per cluster). <p>A hash space segment is the granularity for key distribution in the cluster: a node can own (or primary-own) one or more full segments, but not a fraction of a segment. As such, larger {@code numSegments} values will mean a more even distribution of keys between nodes. <p>On the other hand, the memory/bandwidth usage of the new consistent hash grows linearly with {@code numSegments}. So we recommend keeping {@code numSegments <= 10 * clusterSize}. If false, no rebalancing or rehashing will take place when a new node joins the cluster or a node leaves Rehashing timeout
Controls the proportion of entries that will reside on the local node, compared to the other nodes in the cluster. This is just a suggestion, there is no guarantee that a node with a capacity factor of {@code 2} will have twice as many entries as a node with a capacity factor of {@code 1}.  The consistent hash factory in use. The hash function in use. Used as a bit spreader and a general hash code generator. Typically used in conjunction with the many default {@link org.infinispan.distribution.ch.ConsistentHash} implementations shipped. NOTE: Currently Infinispan will not use the object instance, but instead instantiate a new instance of the class. Therefore, do not expect any state to survive, and provide a no-args constructor to any instance. This will be resolved in Infinispan 5.2.0 Key partitioner, controlling the mapping of keys to hash segments. <p> The default implementation {@code org.infinispan.distribution.ch.impl.HashFunctionPartitioner}, uses the hash function configured via {@link #hash(Hash)}. Future versions may ignore the hash function. Number of cluster-wide replicas for each cache entry. Controls the total number of hash space segments (per cluster). <p>A hash space segment is the granularity for key distribution in the cluster: a node can own (or primary-own) one or more full segments, but not a fraction of a segment. As such, larger {@code numSegments} values will mean a more even distribution of keys between nodes. <p>On the other hand, the memory/bandwidth usage of the new consistent hash grows linearly with {@code numSegments}. So we recommend keeping {@code numSegments <= 10 * clusterSize}.  Disable rebalancing and rehashing, which would have taken place when a new node joins the cluster or a node leaves Enable rebalancing and rehashing, which will take place when a new node joins the cluster or a node leaves Enable rebalancing and rehashing, which will take place when a new node joins the cluster or a node leaves Rehashing timeout



Returns per cache health. Returns Cluster health. Gets basic information about the host.

Returns per Cache statuses. Returns cluster health status. Returns cluster name. Returns the amount of free memory (KB) in the host. Returns the total amount of CPUs for the JVM. Returns total nodes in the cluster. Returns the amount of total memory (KB) in the host.





Returns the given value converted into the type of the given property as determined via the field bridge of the property. Determines whether the given property path denotes an embedded entity (not a property of such entity).

Gets the actual types by resolving TypeParameters.
Load Hikari properties in priority of properties file specified in configuration then hikari.properties on the classpath

Gets free memory in KB. Returns the number of CPUs installed in the host. Gets total memory in KB.















Reads the header and returns whether we should try to continue Should be called when state is transferred.  This also marks the buffer read position so when we can't read bytes it will be reset to here.













Magic | Message Id | Op code | Status | Topology Change Marker
ISPN-4977 @Test(expected = org.infinispan.client.hotrod.exceptions.HotRodClientException.class) public void testReaderBuldRead() throws PrivilegedActionException, LoginException { initAsReader(); remoteCache.getBulk(); }










Test correct behaviour for RemoteCacheManagers start/stop function <br> Current operations can be completed, but no new operations are supposed to be issued Check the server status for tests which involve shutting servers down Convenience method for killing servers according to number parity Test basic memory consumption difference between standard API and streaming API Test behaviour if one server is killed Test behaviour if one server is gracefully shutdown Refresh the resources for each test Convenience method for starting servers according to number parity Convenience method for stopping servers according to number parity Test for basic functionality on multiple streams Test behaviour of cache if stream object if garbageCollected Test cache behaviour if same key is being manipulated multiple times Test stream reaction on negative one value in stream



Builds {@link HotRodRouterConfiguration}. Sets TCP Keep Alive Sets Receive buffer size. Sets Send buffer size Sets TCP No Delay.
Returns TCP Keep Alive setting. Returns Receive buffer size. Returns Send buffer size. Returns TCP No Delay setting.

Configures authentication for this endpoint Sets the external address of this node, i.e. the address which clients will connect to Sets the external port of this node, i.e. the port which clients will connect to Configures whether to enable waiting for initial state transfer for the topology cache. See {@link StateTransferConfigurationBuilder#awaitInitialTransfer(boolean)} Configures the lock acquisition timeout for the topology cache. See {@link LockingConfigurationBuilder#lockAcquisitionTimeout(long)}. Defaults to 10 seconds Configures the replication timeout for the topology cache. See {@link SyncConfigurationBuilder#replTimeout(long)}. Defaults to 10 seconds Configures whether to enable state transfer for the topology cache. If disabled, a {@link org.infinispan.persistence.cluster.ClusterLoader} will be used to lazily retrieve topology information from the other nodes. Defaults to true.

Sets the external address of this node, i.e. the address which clients will connect to Sets the external port of this node, i.e. the port which clients will connect to Configures whether to enable waiting for initial state transfer for the topology cache. See {@link StateTransferConfigurationBuilder#awaitInitialTransfer(boolean)} Configures the lock acquisition timeout for the topology cache. See {@link LockingConfigurationBuilder#lockAcquisitionTimeout(long)}. Defaults to 10 seconds Configures the replication timeout for the topology cache. See {@link SyncConfigurationBuilder#replTimeout(long)}. Defaults to 10 seconds Configures whether to enable state transfer for the topology cache. If disabled, a {@link org.infinispan.persistence.cluster.ClusterLoader} will be used to lazily retrieve topology information from the other nodes. Defaults to true.













Creates a handler for HTTP/1.1 -> HTTP/2 upgrade Gets HTTP/1.1 handler. Gets HTTP/2 handler.



Configure the pipeline for a cleartext upgrade from HTTP to HTTP/2. Configure the pipeline for TLS NPN negotiation to HTTP/2.
Wait for this handler to be added after the upgrade to HTTP/2, and for initial preface handshake to complete.


Wait (sequentially) for a time duration for each anticipated response Create an association between an anticipated response stream id and a {@link io.netty.channel.ChannelPromise}








Acquires a Matcher instance from the ComponentRegistry of the given Cache object.




Acquires a Matcher instance from the ComponentRegistry of the given Cache object.



Returns the projections of the parsed query, represented as dot paths in case of references to fields of embedded entities, e.g. {@code ["foo", "bar.qaz"]}. Returns the entity type of the parsed query. Returns the original entity name as given in the query Returns the filter created while walking the parse tree.











Set the list of illegal import statements.






See {@link #writeExternal(java.io.ObjectOutput)} for serialization format Format: - entry array size (int) - elements (Object)



Creates a new immutable copy of the specified Collection. Wraps a collection with an immutable collection. There is no copying involved. Wraps a key and value with an immutable {@link Map.Entry}}. There is no copying involved. Wraps a {@link Map.Entry}} with an immutable {@link Map.Entry}}. There is no copying involved. Converts a Collection to an immutable List by copying it. Creates an immutable copy of the list. Creates a new immutable list containing the union (combined entries) of both lists. Wraps an array with an immutable list. There is no copying involved. Creates an immutable copy of the specified map. Wraps a map with an immutable map. There is no copying involved. Converts a Collections into an immutable Set by copying it. Creates an immutable copy of the specified set. Wraps a set with an immutable set. There is no copying involved. Creates an immutable copy of the properties. Whether or not this collection type is immutable





Handles the {@link org.infinispan.commands.ReplicableCommand} from other node belonging to local site. Handles the {@link org.infinispan.commands.ReplicableCommand} from remote site.

Set up a list of sequencer states after interceptor {@code interceptorClass} has returned. <p/> Each invocation accepted by {@code matcher} will enter/exit the next state from the list, and does nothing after the list is exhausted. Set up a list of sequencer states before interceptor {@code interceptorClass} is called. <p/> Each invocation accepted by {@code matcher} will enter/exit the next state from the list, and does nothing after the list is exhausted.
Cancels a subset of the segments. If it happens that all segments are cancelled then the whole task is marked as cancelled and completion is signalled.. Send START_STATE_TRANSFER request to source node. Terminate abruptly regardless if the segments were received or not. This is used when the source node is no longer alive.




Get position + numRecords, without expiration Get position or null if expired Get record or null if expired

Deletes the current index lock, even if anything is actively writing on the index: this will not notify the writer in any way, so use with care.
This is returning as soon as the lock is available, or after 10 seconds.
For a given configuration, define which IndexModificationStrategy is going to be used.
Called on the most bottom node Can be called only from single writer thread (therefore the write lock guards only other readers) called only internally or for root
Applies pre-defined configurations



This numeric id is used exclusively for storage affinity in Infinispan. It is not included in the equals and hashcode implementations! Different indexes are required to use different names







Receives stream-style index update operations from the Search engine. Receives transactional index update operations from the Search engine. Signals that the current implementation is being discarded, and if any pending update operations are being buffered these should be delegated for further processing to the replacement IndexingBackend. Mostly useful for testing and diagnostics.
Determines if autoconfig is enabled for this IndexingConfiguration Whether indexing is enabled. False by default. Returns the indexing mode of this cache. If true, only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates. Check if the indexes can be shared. Currently only "ram" based indexes don't allow any sort of sharing <p> These properties are passed directly to the embedded Hibernate Search engine, so for the complete and up to date documentation about available properties refer to the Hibernate Search reference of the version you're using with Infinispan Query. </p>
<p> Defines a single property. Can be used multiple times to define all needed properties, but the full set is overridden by {@link #withProperties(Properties)}. </p> <p> These properties are passed directly to the embedded Hibernate Search engine, so for the complete and up to date documentation about available properties refer to the the Hibernate Search reference of the version used by Infinispan Query. </p> When enabled, applies to properties default configurations based on the cache type Disable indexing Enable indexing Enable or disable indexing Indicates indexing mode If true, only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates. <p> Defines a single value. Can be used multiple times to define all needed property values, but the full set is overridden by {@link #withProperties(Properties)}. </p> <p> These properties are passed directly to the embedded Hibernate Search engine, so for the complete and up to date documentation about available properties refer to the the Hibernate Search reference of the version used by Infinispan Query. </p> <p> The Query engine relies on properties for configuration. </p> <p> These properties are passed directly to the embedded Hibernate Search engine, so for the complete and up to date documentation about available properties refer to the Hibernate Search reference of the version you're using with Infinispan Query. </p>

TODO [anistor] The index name is ignored for now because all types get indexed in the same index of ProtobufValueWrapper
Recognized annotations: @Indexed (default 'value' boolean argument; defaults to true; the 'value' argument is deprecated, 'index' optional string attribute; defaults to empty string) @Analyzer (definition = "<definition name>") @IndexedField (index = true/false; defaults to true, store = true/false; defaults to true) - deprecated annotation, prefer @Field instead @Field (name optional string, index = true/false, defaults to true, analyze = true/false, defaults to true, store = true/false, defaults to false, analyzer = @Analyzer(definition = "<definition name>")) @SortableField
All fields that were not seen until the end of this message are missing and will be indexed with their default value or null if none was declared. The null value is replaced with a special null token placeholder because Lucene cannot index nulls.





Returns the elements that are present in s1 but which are not present in s2, without changing the contents of neither s1, nor s2. Given a collection, transforms the collection to a map given a {@link MapMakerFunction} Given a map of well known key/value types, it makes a shallow copy of it while at the same time transforming it's value type to a desired output type. The transformation of the value type is done using a given a function.
Resolves an Infinispan configuration file but using the Hibernate Search classloader. The returned Infinispan configuration template also overrides Infinispan's runtime classloader to the one of Hibernate Search. After having parsed the Infinispan configuration file, we might want to override the specified JGroups configuration file.


Shuts down the <code>org.infinispan.Cache</code> created by this <code>FactoryBean</code>.   Always returns <code>true</code>. <p> Sets the {@link org.infinispan.manager.CacheContainer <code>org.infinispan.manager.CacheContainer</code>} to be used for creating our {@link org.infinispan.Cache <code>Cache</code>} instance. Note that this is a <strong>mandatory</strong> property. </p>




------------------------------------------------------------------------ org.springframework.beans.factory.InitializingBean ------------------------------------------------------------------------  ------------------------------------------------------------------------ org.springframework.beans.factory.DisposableBean ------------------------------------------------------------------------ Shuts down the <code>EmbeddedCacheManager</code> instance created by this <code>FactoryBean</code>. ------------------------------------------------------------------------ org.springframework.beans.factory.FactoryBean ------------------------------------------------------------------------   Always returns <code>true</code>.



{@inheritDoc } {@inheritDoc }
The default cache manager is an instance of {@link DefaultCacheManager} initialized with the default configuration (either produced by {@link #createDefaultEmbeddedConfigurationBean(BeanManager)} or provided by user). The default cache manager can be overridden by creating a producer which produces the new default cache manager. The cache manager produced must have the scope {@link ApplicationScoped} and the {@linkplain javax.enterprise.inject.Default Default} qualifier. The default embedded cache configuration can be overridden by creating a producer which produces the new default configuration. The configuration produced must have the scope {@linkplain javax.enterprise.context.Dependent Dependent} and the {@linkplain javax.enterprise.inject.Default Default} qualifier.

The default remote cache manager can be overridden by creating a producer which produces the new default remote cache manager. The remote cache manager produced must have the scope {@link ApplicationScoped} and the {@linkplain javax.enterprise.inject.Default Default} qualifier.
Lucene might try seek(pos) using an illegal pos value RAMDirectory teaches to position the cursor to the end of previous chunk in this case





It tries to acquire this lock. <p/> If it is invoked multiple times with the same owner, the same {@link ExtendedLockPromise} is returned until it has timed-out or {@link #release(Object)}  is invoked. <p/> If the lock is free, it is immediately acquired, otherwise the lock owner is queued. It tests if the lock has the lock owner. <p/> It return {@code true} if the lock owner is the current lock owner or it in the queue. It forces a deadlock checking.  It checks if the lock is acquired. <p/> A {@code false} return value does not mean the lock is free since it may have queued lock owners. It tries to release the lock held by {@code lockOwner}. <p/> If the lock is not acquired (is waiting or timed out/deadlocked) by {@code lockOwner}, its {@link ExtendedLockPromise} is canceled. If {@code lockOwner} is the current lock owner, the lock is released and the next lock owner available will acquire the lock. If the {@code lockOwner} never tried to acquire the lock, this method does nothing. Tests purpose only!
Logs an informational message indicating the Infinispan subsystem is being activated. Logs a debug message indicating that named cache container has been installed. Logs a warning message indicating that the module attribute of the cache element is no longer valid. Logs an informational message indicating that a cache is being started. Logs an informational message indicating that a cache is being stopped. Logs debug message when starting Deployed Cache service. Logs debug message when stopping Deployed Cache service. Logs a warning message indicating that the eager attribute of the transactional element is no longer valid Logs a warning message indicating that the flush-lock-timeout attribute of the write-behind element is no longer valid Logs an info message about installing implementation service. Logs an info message about installing implementation service. Logs an error when requested cache store is not loaded within 1 minute Logs debug message when starting deployed task. Logs a warning message indicating that the flush-lock-timeout attribute of the write-behind element is no longer valid Logs a warning message indicating that the specified topology attribute of the transport element is no longer valid Logs debug message when stopping deployed task. Logs a warning message stating that the 'virtual-nodes' attribute is deprecated.



Creates an exception indicating that the cache is aborting after the specified number of retries. Creates an exception indicating that an attribute has been deprecated. Creates an exception indicating the a cache loader cannot be added as one already exists. Creates an exception indicating the a cache store cannot be added as one already exists. Creates an exception indicating unable to remove an alias from an empty list of aliases. Creates an exception indicating a failure to resolve the outbound socket binding represented by the {@code binding} parameter. Returns a message for failed operations A message indicating that the resource could not be parsed. Creates an exception indicating an invalid cache loader. Creates an exception indicating an invalid cache store. Creates an exception indicating an invalid compatibility marshaller. Creates an exception indicating an invalid cache store. Creates an exception indicating the an executor property is invalid. Creates an exception indicating incompatible parameter sizes Creates an exception indicating incompatible parameter type Creates an exception indicating the an operation parameter is invalid. Creates an exception indicating the an transport property is invalid. A message indicating that the resource could not be located. Creates an exception indicating the a cache store cannot be added as one already exists. Creates an exception indicating a singleton resource already exists. Error message thrown when Subsystem can't instantiate given class.

API to introduce a customised {@link ConfigurationBuilder} that will override the default configurations which are already available on this class. This can <strong>only</strong> be used if {@link #setConfigurationTemplateMode(String)} has been set to <code>CUSTOM</code>. ------------------------------------------------------------------------ org.springframework.beans.factory.InitializingBean ------------------------------------------------------------------------  ------------------------------------------------------------------------ org.springframework.beans.factory.DisposableBean ------------------------------------------------------------------------ Shuts down the <code>org.infinispan.Cache</code> created by this <code>FactoryBean</code>. ------------------------------------------------------------------------ org.springframework.beans.factory.FactoryBean ------------------------------------------------------------------------   Always returns <code>true</code>. ------------------------------------------------------------------------ org.springframework.beans.factory.BeanNameAware ------------------------------------------------------------------------  ------------------------------------------------------------------------ Properties ------------------------------------------------------------------------ <p> Sets the {@link org.infinispan.Cache#getName() name} of the {@link org.infinispan.Cache <code>org.infinispan.Cache</code>} to be created. If no explicit <code>cacheName</code> is set, this <code>FactoryBean</code> will use its {@link #setBeanName(String) <code>beanName</code>} as the <code>cacheName</code>. </p>  <p> Sets the {@link org.infinispan.manager.EmbeddedCacheManager <code>org.infinispan.manager.EmbeddedCacheManager</code>} to be used for creating our {@link org.infinispan.Cache <code>Cache</code>} instance. Note that this is a <strong>mandatory</strong> property. </p>
------------------------------------------------------------------------ org.springframework.beans.factory.InitializingBean ------------------------------------------------------------------------  ------------------------------------------------------------------------ org.springframework.beans.factory.FactoryBean ------------------------------------------------------------------------   Always return true. ------------------------------------------------------------------------ org.springframework.beans.factory.BeanNameAware ------------------------------------------------------------------------  ------------------------------------------------------------------------ Properties ------------------------------------------------------------------------ <p> Sets the {@link org.infinispan.Cache#getName() name} of the {@link org.infinispan.Cache <code>org.infinispan.Cache</code>} to be created. If no explicit <code>cacheName</code> is set, this <code>FactoryBean</code> will use its {@link #setBeanName(String) <code>beanName</code>} as the <code>cacheName</code>. </p> <p> Sets the {@link org.infinispan.client.hotrod.RemoteCacheManager <code>org.infinispan.client.hotrod.RemoteCacheManager</code>} to be used for creating our {@link org.infinispan.Cache <code>Cache</code>} instance. Note that this is a <strong>mandatory</strong> property. </p>





This method is overridden in WildFly, so the signature must not change. In WF, the global configuration setting is ignored

------------------------------------------------------------------------ org.springframework.beans.factory.InitializingBean ------------------------------------------------------------------------  ------------------------------------------------------------------------ org.springframework.beans.factory.DisposableBean ------------------------------------------------------------------------ {@link org.infinispan.client.hotrod.RemoteCacheManager#stop() <code>stop</code>} the <code>RemoteCacheManager</code> created by this factory. ------------------------------------------------------------------------ org.springframework.beans.factory.FactoryBean ------------------------------------------------------------------------   Always return <code>true</code>.



Returns request's payload. Returns <code>Accepts</code> header value. Returns <code>Authorization</code> header value. Returns cache name. Returns <code>Content-Type</code> header value. Returns Netty context. Returns <code>If-Match</code> header value. Returns <code>If-Modified-Since</code> header value. Returns <code>If-None-Match</code> header value. Returns <code>If-Unmodified-Since</code> header value. Returns whether client wishes to return 'Extended Headers'. Returns key. Returns <code>maxIdleTimeSeconds</code> header value. Returns Netty context. Returns Netty request. Returns HTTP/2.0 Stream Id. Returns <code>timeToLiveSeconds</code> header value. Returns whether request should be done asynchronously. Creates new {@link InfinispanRequest} based on Netty types.

Creates an {@link InfinispanResponse} as an error. Adds <code>www-authenticate</code> header. Adds Cache Control headers. Adds a charset. Adds <code>Cluster-Node-Name</code> header. Adds <code>Cluster-Primary-Owner</code> header. Adds <code>Cluster-Server-Address</code> header. Adds content as binary array. Adds content as text. Converts it internally to <code>UTF-8</code>. Adds <code>Content-Type</code> header. Adds ETAG. Adds <code>expires</code> header. Adds HTTP version header. Creates an {@link InfinispanResponse} as a reply to specific {@link InfinispanRequest}. Checks whether this is a Keep Alive type of response. Add <code>last-modified</code> header. Adds <code>maxIdleTimeSeconds</code> header. Adds status code. Renders {@link FullHttpResponse} object.
Get ID of process listening on 127.0.0.1:8080 (or 8180 or 8280). Used on Windows. Note! This method is closing InputStream.



To avoid pulling in TestingUtil and its plethora of dependencies




{@inheritDoc }
{@inheritDoc }




To be used for building {@link org.infinispan.commons.io.ByteBuffer} objects. To be used for building {@link org.infinispan.marshall.core.MarshalledEntry} objects.




Get the bean manager used by this injectable method. Get the injectable parameters of this method. Invoke the method, causing all parameters to be injected according to the CDI type safe resolution rules. Invoke the method, calling the parameter redefiner for each parameter, allowing the caller to override the default value obtained via the CDI type safe resolver.











Same as {@link IntCacheStream#allMatch(IntPredicate)} except that the IntPredicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link IntCacheStream#anyMatch(IntPredicate)} except that the IntPredicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc } {@inheritDoc } Same as {@link IntCacheStream#collect(Supplier, ObjIntConsumer, BiConsumer)} except that the arguments must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } Same as {@link IntCacheStream#filter(IntPredicate)} except that the IntPredicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc } {@inheritDoc } Same as {@link IntCacheStream#flatMap(IntFunction)} except that the IntFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link IntCacheStream#forEach(IntConsumer)} except that it takes an {@link ObjIntConsumer} that provides access to the underlying {@link Cache} that is backing this stream. <p> Note that the <code>CacheAware</code> interface is not supported for injection using this method as the cache is provided in the consumer directly. Same as {@link IntCacheStream#forEach(IntConsumer)} except that the IntConsumer must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link IntCacheStream#forEach(ObjIntConsumer)} except that the <code>BiConsumer</code> must also implement <code>Serializable</code> {@inheritDoc } {@inheritDoc } Same as {@link IntCacheStream#map(IntUnaryOperator)} except that the IntUnaryOperator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link IntCacheStream#mapToDouble(IntToDoubleFunction)} except that the IntToIntFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link IntCacheStream#mapToLong(IntToLongFunction)} except that the IntToLongFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } Same as {@link IntCacheStream#mapToObj(IntFunction)} except that the IntFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link IntCacheStream#noneMatch(IntPredicate)} except that the IntPredicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc }  {@inheritDoc } Same as {@link IntCacheStream#flatMap(IntFunction)} except that the IntFunction must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link IntCacheStream#reduce(int, IntBinaryOperator)} except that the IntBinaryOperator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Same as {@link IntCacheStream#reduce(IntBinaryOperator)} except that the IntBinaryOperator must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc }


Inserts the given interceptor at the specified position in the chain (o based indexing). Adds a new interceptor in list after an interceptor of a given type. Adds a new interceptor in list after an interceptor of a given type.  Appends at the end. Returns an unmofiable list with all the interceptors in sequence. If first in chain is null an empty list is returned. Checks whether the chain contains the supplied interceptor instance.  Returns all interceptors which extend the given command interceptor. Returns all the interceptors that have the fully qualified name of their class equal with the supplied class name. Walks the command through the interceptor chain. The received ctx is being passed in. <p>Note: Reusing the context for multiple invocations is allowed. However, the two invocations must not overlap, so calling {@code invoke(ctx, command)} from an interceptor is not allowed. If an interceptor needs to invoke a new command through the entire chain, it must first copy the invocation context with {@link InvocationContext#clone()}.</p> Removes the interceptor at the given postion. Removes all the occurences of supplied interceptor type from the chain. Replaces an existing interceptor of the given type in the interceptor chain with a new interceptor instance passed as parameter. Mainly used by unit tests to replace the interceptor chain with the starting point passed in. Returns the number of interceptors in the chain.


Dictates that the custom interceptor appears immediately <i>after</i> the specified interceptor. If the specified interceptor is not found in the interceptor chain, a {@link CacheConfigurationException} will be thrown when the cache starts. Dictates that the custom interceptor appears immediately <i>before</i> the specified interceptor. If the specified interceptor is not found in the interceptor chain, a {@link CacheConfigurationException} will be thrown when the cache starts. Clears the interceptor properties Specifies a position in the interceptor chain to place the new interceptor.  The index starts at 0 and goes up to the number of interceptors in a given configuration.  An {@link IllegalArgumentException} is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain. An instance of the new custom interceptor to add to the configuration. Warning: if you use this configuration for multiple caches, the interceptor instance will be shared, which will corrupt interceptor stack. Use {@link #interceptorClass} instead.  Class of the new custom interceptor to add to the configuration. Specifies a position, denoted by the {@link Position} enumeration, where to place the new interceptor. Sets interceptor properties


Set up a list of sequencer states after interceptor {@code interceptorClass} has returned. <p/> Each invocation accepted by {@code matcher} will enter/exit the next state from the list, and does nothing after the list is exhausted. Set up a list of sequencer states before interceptor {@code interceptorClass} is called. TODO Should we add beforeInvokeNext() and afterInvokeNext()?





Handles injection of components for various dependencies that the intermediate operation has Performs the actualy intermediate operation returning the resulting stream


Only used with entries that have a lifespan, this determines when an entry is due to expire.    "Reincarnates" an entry.  Essentially, resets the 'created' timestamp of the entry to the current time. "Reincarnates" an entry.  Essentially, resets the 'created' timestamp of the entry to the current time. Creates a representation of this entry as an {@link org.infinispan.container.entries.InternalCacheValue}. The main purpose of this is to provide a representation that does <i>not</i> have a reference to the key. This is useful in situations where the key is already known or stored elsewhere, making serialization and deserialization more efficient. <p/> Note that this should not be used to optimize memory overhead, since the saving of an additional reference to a key (a single object reference) does not warrant the cost of constructing an InternalCacheValue.  This <i>only</i> makes sense when marshalling is involved, since the cost of marshalling the key again can be sidestepped using an InternalCacheValue if the key is already known/marshalled. <p/> Updates access timestamps on this instance Updates access timestamps on this instance to a specified time
Bootstraps this factory with a Configuration and a ComponentRegistry. This implementation clones the configuration passed in before using it.
Removes the private caches from the specified set of cache names Retrieves the names of all the internal caches Returns whether a particular internal cache has a specific flag Returns whether the cache is internal, i.e. it has been registered using the {@link #registerInternalCache(String, Configuration)} method Returns whether the cache is private, i.e. it has been registered using the {@link #registerInternalCache(String, Configuration, EnumSet<Flag>)} method without the {@link Flag#USER} flag Registers an internal cache. The cache will be marked as private and volatile Registers an internal cache with the specified flags. Unregisters  an internal cache
Synchronized to prevent users from registering the same configuration at the same time


Creates a copy of this cache entry and synchronizes serializes the copy process with the {@link #update(org.infinispan.container.entries.InternalCacheEntry, org.infinispan.metadata.Metadata)}. This is requires so that readers of the entry will get an consistent snapshot of the value red. Creates a new {@link InternalCacheEntry} instance based on the version and timestamp/lifespan information reflected in the {@link CacheEntry} instance passed in.  Key and value are both passed in explicitly. Creates a new {@link InternalCacheEntry} instance To be deprecated, once metadata object can be retrieved remotely... Creates a new {@link InternalCacheEntry} instance Creates a new {@link InternalCacheEntry} instance Creates a new {@link InternalCacheEntry} instance Creates a new {@link InternalCacheEntry} instance based on the key, value, version and timestamp/lifespan information reflected in the {@link CacheEntry} instance passed in. Creates a L1 entry. Creates an {@link InternalCacheValue} based on the {@link InternalCacheEntry} passed in. Retrieve an {@link InternalCacheValue} from the provided {@link InvocationContext} if an {@link InternalCacheEntry} exists, otherwise create {@link InternalCacheEntry} from the context's {@link CacheEntry} and return its value. Similar to {@link #update(org.infinispan.container.entries.InternalCacheEntry, org.infinispan.metadata.Metadata)} but it also updates the {@link org.infinispan.container.entries.InternalCacheEntry} value. <p/> If the same internal cache entry is returned and if it is a mortal cache entry, the returned instance needs to be reincarnated. TODO: Adjust javadoc Updates an existing {@link InternalCacheEntry} with new metadata.  This may result in a new {@link InternalCacheEntry} instance being created, as a different {@link InternalCacheEntry} implementation may be more appropriate to suit the new metadata values.  As such, one should consider the {@link InternalCacheEntry} passed in as a parameter as passed by value and not by reference.
TODO: Do we need this??? Indicates whether the entire metadata object needs to be stored or not. This check is done to avoid keeping the entire metadata object around when only lifespan or maxIdle time is stored. If more information needs to be stored (i.e. version), or the metadata object is not the embedded one, keep the entire metadata object around.









Add the {@code Interval} into this {@code IntervalTree} and return the Node. Possible duplicates are found and the existing Node is returned instead of adding a new one. Compare two Intervals. Checks if this {@code IntervalTree} does not have any Intervals. Removes the Interval. Find all Intervals that contain a given value.





Performs an invalidation on a specified entry
Returns true if the write that caused the invalidation was performed on this node. More formal, if a put(k) happens on node A and ch(A)={B}, then an invalidation message might be multicasted by B to all cluster members including A. This method returns true if and only if the node where it is invoked is A.


Attempt to retrieve an object from the cache. Attempt to cache an object, after loading from the database, explicitly specifying the minimalPut behavior.
used to create subsystem description









Tracks the given key as locked by this invocation context. Clones the invocation context. Returns the class loader associated with this invocation Returns the in behalf of which locks will be acquired. Returns the set of keys that are locked for writing.  Returns true if the lock being tested is already held in the current scope, false otherwise. Returns true if this call is performed in the context of an transaction, false otherwise. Returns true if the call was originated locally, false if it is the result of a remote rpc.  Sets the class loader associated for this invocation Sets the object to be used by lock owner.
Remove the stored InvocationContext from the calling thread. Must be called as each thread exists the interceptor chain. Returns the {@link InvocationContext} that is currently associated with the calling thread. Important: implementations of this method are most likely expensive, involving thread locals. It is recommended to cache the result of this method rather than repeating the call. Associate the InvocationContext parameter with the calling thread.
Will create an {@link ClearInvocationContext} with the {@link ClearInvocationContext#isOriginLocal()} returning true. If we are in a tx scope this will return an {@link org.infinispan.context.impl.TxInvocationContext}. Otherwise it will return an {@link org.infinispan.context.impl.NonTxInvocationContext}. Either way, both context will be marked as local, i.e. {@link org.infinispan.context.InvocationContext#isOriginLocal()} will be true. Creates an invocation context Will create an {@link org.infinispan.context.impl.NonTxInvocationContext} with the {@link org.infinispan.context.impl.NonTxInvocationContext#isOriginLocal()} returning true. Returns an {@link org.infinispan.context.impl.NonTxInvocationContext} whose {@link org.infinispan.context.impl.NonTxInvocationContext#isOriginLocal()} flag will be true. As {@link #createRemoteInvocationContext(org.infinispan.remoting.transport.Address)}, but returning the flags to the context from the Command if any Flag was set. Returns an {@link org.infinispan.context.impl.RemoteTxInvocationContext}. Will create an {@link org.infinispan.context.impl.NonTxInvocationContext} with the {@link org.infinispan.context.impl.NonTxInvocationContext#isOriginLocal()} returning true. Returns a {@link org.infinispan.context.impl.LocalTxInvocationContext}.
If the cache is STOPPING, non-transaction invocations, or transactional invocations for transaction others than the ongoing ones, are no allowed. This method returns true if under this circumstances meet. Otherwise, it returns false.





After this stage completes successfully, invoke {@code function} and return either its result







Some PAX-URL protocols are not supported by Karaf. This method can be used when one of the unsupported protocol is required. The URLs are resolved outside Karaf and the bundles are provided as stream bundles. Some test packages are split across several Maven modules this option repackages them and exposes them through a single bundle. Sets the system variables used inside persistence.xml to use H2. PAX URL needs to know the location of the local maven repo to resolve mvn: URLs. When running the tests on the CI machine TeamCity passes a custom local repo location using -Dmaven.repo.local to isolate the build targets and PAX URL is not aware there's a custom repo to be used and tries to load from the default local repo location. <p/> This option will pass the location specified using -Dmaven.repo.local to the appropriate system property of the container. Wraps the specified test jars as bundles fragments and attaches them to the specified host bundle. The host bundle must be the one exporting the packages contained in the test jar. Run tests with uberjar by default























{@inheritDoc }
Fetches the next available, entry that satisfies the filter from the underlying iterator {@inheritDoc } {@inheritDoc } {@inheritDoc }






Run a task with a given {@link CachingProvider}.
Creates canonical name of managed bean Accesses cache trough HR client to confirm its existence and insert data, then attempts to access it trough JCache API and retrieve the data Test enableManagement command on JCache API<br> <br> Fix pending in <b>ISPN-7095</b> Test enableStatistics command on JCache API <br> <br> Fix pending in <b>ISPN-7095</b> Test whether cache is found in cache name list of JCache API, fix pending<br> <br> Fix pending in <b>ISPN-7095</b>




{@inheritDoc } {@inheritDoc }






Retrieves a JGroups channel.  Passes in all of the properties used to configure the channel.
Remove all failure detection related protocols from the given JGroups stack.
{@inheritDoc } {@inheritDoc }
Logs an informational message indicating the JGroups subsystem is being activated. A message indicating a resource could not be located. A message indicating a file could not be parsed.


Formats a string using the specified pattern. Get the namespace URI for this schema version. Indicates whether this version of the schema is greater than or equal to the version of the specified schema.





{@inheritDoc }

This is per CM, so the CL in use should be the CM CL  Initializes the transport with global cache configuration and transport-specific properties. Send a command to multiple targets. Doesn't send the command to itself unless {@code deliverOrder == TOTAL}. Send a command to the entire cluster. Doesn't send the command to itself unless {@code deliverOrder == TOTAL}.




If set to false, statistics gathering cannot be enabled during runtime. Performance optimization.
If set to false, statistics gathering cannot be enabled during runtime. Performance optimization. Disable statistics gathering and reporting Enable statistics gathering and reporting Enable or disable statistics gathering and reporting

Creates a new {@code Properties} instance with all properties from {@code properties} which start with the given











Use the specified {@link ConnectionFactory} to handle connection to the database Use the specified {@link ConnectionFactoryConfigurationBuilder} to configure connections to the database Configures a connection pool to be used by this JDBC Cache Store to handle connections to the database Configures a DataSource to be used by this JDBC Cache Store to handle connections to the database Configures this JDBC Cache Store to use a single connection to the database

This method is public static so that it can be reused by custom cache store/loader configuration parsers This method is public static so that it can be reused by custom cache store/loader configuration parsers



The class of a {@link Key2StringMapper} to use for mapping keys to strings suitable for storage in a database table. Defaults to {@link DefaultTwoWayKey2StringMapper} The class name of a {@link Key2StringMapper} to use for mapping keys to strings suitable for storage in a database table. Defaults to {@link DefaultTwoWayKey2StringMapper} Allows configuration of table-specific parameters such as column names and types







ISPN-8291 for channel and protocol MBeans, test only they're registered, not all the attributes/operations ISPN-8291


Returns whether an interceptor's statistics are being captured. Resets an interceptor's cache statistics Enables an interceptor's cache statistics If true, the interceptor will capture statistics and make them available through the mbean.
Returns whether an interceptor's statistics are being captured. Resets statistics gathered.  Is a no-op, and should be overridden if it is to be meaningful.
Build the JMX domain name. Looks up the {@link javax.management.MBeanServer} instance based on the configuration parameters. Register the given dynamic JMX MBean. Unregister the MBean located under the given {@link javax.management.ObjectName} Unregister all mbeans whose object names match a given filter.

















creates an LdapServer and starts before returning the instance Returns an LdapServer instance and starts it before returning the instance, infering the configuration from the Stack trace Just gives an instance of {@link LdapServer} without starting it. For getting a running LdapServer instance see {@link #createLdapServer(CreateLdapServer, DirectoryService)}

Must return an unique String for the supplied key. Do we support this key type?
Returns a key that will be distributed on the same node as the supplied key. Returns a key that will be distributed on the cluster node identified by address. Checks weather or not the service is started.
Creates a key affinity service for use with the specified cache, that generates key using the specified generator.


Invoked when the lock is available.
It adds the listener to this {@link LockPromise}. <p> The listener is invoked when the {@link LockPromise#isAvailable()} returns true. For more info, check {@link KeyAwareLockListener}.






Obtains the segment for a key. Must be thread-safe. Initialization. <p>The partitioner can also use injection to access other cache-level or global components. This method will be called before any other injection methods.</p> <p>Does not need to be thread-safe (Infinispan safely publishes the instance after initialization).</p>





Handles injection of components for various intermediate and this operation. Invoked when a key aware operation is desired without rehash being enabled. Invoked when a key and rehash aware operation is desired. This method is to be invoked only locally after a key tracking operation has been serialized to a new node
Gets the KeyTransformationHandler instance used by the supplied cache. Retrieves a {@link org.infinispan.query.Transformer} instance for this key.  If the key is not {@link org.infinispan.query.Transformable} and no transformer has been registered for the key's class, null is returned. Registers a {@link org.infinispan.query.Transformer} for the supplied key class.




Will both filter the entry and if passed subsequently convert the value to a new value.  A returned value of null will symbolize the value not passing the filter, so ensure your conversion will not return null if you want this entry to be returned.
















Entries in L1 cache are stored directly into "main" cache. They are fetched from remote (distribution) node. In TRACE we can see: "Doing a remote get for key KeyA" and "Caching remotely retrieved entry for key KeyA in L1" Number of hits is increased for cache on which is issued get. Hits on real-owner are still 0. For caching L1 entries there is NO increase for number of stores. (Only for number of entries)
Determines how often a cleanup thread runs to clean up an internal log of requestors for a specific key <p> Determines whether a multicast or a web of unicasts are used when performing L1 invalidations. </p> <p> By default multicast will be used. </p> <p> If the threshold is set to -1, then unicasts will always be used. If the threshold is set to 0, then multicast will be always be used. </p> Maximum lifespan of an entry placed in the L1 cache. Default 10 minutes.
How often the L1 requestors map is cleaned up of stale items How often the L1 requestors map is cleaned up of stale items <p> Determines whether a multicast or a web of unicasts are used when performing L1 invalidations. </p> <p> By default multicast will be used. </p> <p> If the threshold is set to -1, then unicasts will always be used. If the threshold is set to 0, then multicast will be always be used. </p> Maximum lifespan of an entry placed in the L1 cache. Maximum lifespan of an entry placed in the L1 cache.


Records a request that will be cached in another nodes L1 Registers the given write synchronizer to be notified whenever a remote value is looked up for the given key. If the synchronizer is no longer needed to be signaled, the user should unregister it using {@link L1Manager#unregisterL1WriteSynchronizer(Object, org.infinispan.interceptors.distribution.L1WriteSynchronizer)} Unregister the given write synchronizer if present.  Note the synchronizer is only unregistered if it matches using instance equality (==) due to possibly concurrent usage of write synchronizers





Attempts to the L1 update and set the value.  If the L1 update was marked as being skipped this will instead just set the value to release blockers. A null value can be provided which will not run the L1 update but will just alert other waiters that a null was given. Attempts to mark the L1 update to only retrieve the value and not to actually update the L1 cache. If the L1 skipping is not successful, that means it is currently running, which means for consistency any writes should wait until this update completes since the update doesn't acquire any locks



















Invoked on component start Invoked on component stop

Dynamic index uninverting is deprecated: using it will cause warnings to be logged, to encourage people to use the annotation org.hibernate.search.annotations.SortableField. The default in Hibernate Search is to throw an exception rather than logging a warning; we opt to be more lenient by default in the Infinispan use case, matching the behaviour of previous versions of Hibernate Search. Registers the Search interceptor in the cache before it gets started Check that the indexable classes declared by the user are really indexable.







When stopping, cancel any queued tasks.


Adds a listener to the component.  Typically, listeners would need to be annotated with {@link Listener} and further to that, contain methods annotated appropriately, otherwise the listener will not be registered. <p/> See the {@link Listener} annotation for more information. <p/>  Removes a listener from the component.
Defines whether the annotated listener is clustered or not. Important: Clustered listener can only be notified for @CacheEntryRemoved, @CacheEntryCreated, If set to true then the entire existing state within the cluster is evaluated. For existing matches of the value, an @CacheEntryCreated event is triggered against the listener during registration.  This is only supported if the listener is also {@link org.infinispan.notifications.Listener#clustered()}. <p> If using a distributed clustered cache it is possible to retrieve new events before the initial transfer is completed.  This is handled since only new events are queued until the segment it belongs to is completed for iteration.  This also will help reduce memory strain since a distributed clustered listener will need to eventually retrieve all values from the cache. Returns the type of observation level this listener defines. Specifies whether the event should be fired on the primary data owner of the affected key, or all nodes that see the update. <p> Note that is value is ignored when {@link org.infinispan.notifications.Listener#clustered()} is true. Specifies whether callbacks on any class annotated with this annotation happens synchronously (in the caller's thread) or asynchronously (using a separate thread).  Defaults to <tt>true</tt>.

The listener instance that is notified of events Invokes the event







used to create subsystem description

used to create subsystem description


Method to inject a cache into a consumer.  Note we only support this for the consumer at this time.




Method to inject a cache into a consumer.  Note we only support this for the consumer at this time.



Method to inject a cache into a consumer.  Note we only support this for the consumer at this time.

{@inheritDoc } {@inheritDoc }
Method to inject a cache into a consumer.  Note we only support this for the consumer at this time.










Stream operation for a key aware operation without rehash enabled Stream operation for a non key aware operation without rehash enabled. Stream operation for a key aware operation with rehash enabled Stream operation for a non key aware operation with rehash enabled.
We need to listen to data rehash events in case if data moves while we are iterating over it. If a rehash occurs causing this node to lose a segment and there is something iterating over the stream looking for values of that segment, we can't guarantee that the data has all been seen correctly, so we must therefore suspect that node by sending it back to the owner.
Initiates a cluster-wide cache shutdown for the specified cache Confirm that the local cache {@code cacheName} has finished receiving the new data for topology {@code topologyId}. <p>The coordinator can change during the state transfer, so we make the rebalance RPC async and we send the response as a different command. Retrieves the availability state of a cache.  Returns the local UUID of this node. If global state persistence is enabled, this UUID will be saved and reused across restarts Retrieve the rebalancing status for the specified cache  Handles the local operations related to gracefully shutting down a cache Performs the state transfer. Update the stable cache topology. Mostly needed for backup, so that a new coordinator can recover the stable topology of the cluster. Recovers the current topology information for all running caches and returns it to the coordinator. TODO Add a new class to hold the CacheJoinInfo and the CacheTopology Updates the current and/or pending consistent hash, without transferring any state. Checks whether rebalancing is enabled for the specified cache. Checks whether rebalancing is enabled for the entire cluster. Checks if the cache defined by {@code cacheName} is using total order. <p/> If this component is not running or the {@code cacheName} is not defined, it returns {@code false}. Forwards the join request to the coordinator. Forwards the leave request to the coordinator. Updates the availability state of a cache (for the entire cluster). Enable or disable rebalancing for the specified cache. Enable or disable rebalancing in the entire cluster.

Update the cache topology in the LocalCacheStatus and pass it to the CacheTopologyHandler. called by the coordinator Arbitrary value, only need to start after the (optional) GlobalStateManager and JGroupsTransport Start isn't called with any locks, but it runs before the component is accessible from other threads Need to stop before the JGroupsTransport Synchronization is required to prevent topology updates while preparing the status response.
Calculates the list of nodes to which a commit/rollback needs to be sent based on the nodes to which prepare was sent. If the commit/rollback is to be sent in the same topologyId, then the 'recipients' param is returned back. If the current topologyId is different than the topologyId of this transaction ({@link #getTopologyId()} then this method returns the reunion between 'recipients' and {@link #getRemoteLocksAcquired()} from which it discards the members that left.  When x-site replication is used, this returns when this operation happens as a result of backing up data from a remote site.  Sets the commit or rollback sent for this transaction Sets the prepare sent for this transaction


As per the JTA spec, XAResource.start is called on enlistment. That method also sets the xid for this local transaction.






It forces a deadlock checks in all existing locks.


Invoked when the lock is available.
Retrieves the owner of the lock for the {@code key}. Tests if the {@code key} is locked. Attempts to lock the {@code key} if the lock isn't already held by the {@code lockOwner}. <p> This method is non-blocking and return immediately a {@link LockPromise}. The {@link LockPromise} can (and should) be used by the invoker to check when the lock is really acquired by invoking {@link LockPromise#lock()}. Same as {@link #lock(Object, Object, long, TimeUnit)} but for multiple keys. <p> It ensures no deadlocks if the method is invoked by different lock owners for the same set (or subset) of keys. Tests if the {@code lockOwner} owns a lock on the {@code key}. Prints lock information for all locks. Releases the lock for the {@code key} if the {@code lockOwner} is the lock owner. <p> Note this method <b>will</b> unlock a lock where the key is the lockOwner </p> Same as {@link #unlock(Object, Object)} but for multiple keys. <p> Note this method will <b>not</b> unlock a lock where the key is the lockOwner </p> Same as {@code unlockAll(context.getLockedKeys(), context.getKeyLockOwner();}. <p> Note this method will <b>not</b> unlock a lock where the key is the lockOwner </p>


Adds a {@link LockListener} to be invoked when the lock is available. <p> The {@code acquired} parameter indicates that the lock is acquired (when it is {@code true}) or it timed out (when it is {@code false}). It tests if the lock is available. <p> The lock is consider available when it is successfully acquired or the timeout is expired. In any case, when it returns {@code true}, the {@link #lock()} will never block. It locks the key (or keys) associated to this promise. <p> This method will block until the lock is available or the timeout is expired.

Returns a locked stream consisting of the elements of this stream that match the given predicate. <p> This filter is after the lock is acquired for the given key. This way the filter will see the same value as the consumer is given. Same as {@link LockedStream#filter(Predicate)} except that the Predicate must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> Performs an action for each element of this stream on the primary owner of the given key. <p> This method is performed while holding exclusive lock over the given entry and will be released only after the consumer has completed. If the entry is directly modified via the {@link java.util.Map.Entry#setValue(Object)} method this will be the same as if {@link java.util.Map#put(Object, Object)} was invoked. <p> If using a pessimistic transaction this lock is not held using a transaction and thus the user can start a transaction in this consumer which also must be completed before returning. A transaction can be started in the consumer and if done it will share the same lock used to obtain the key. <p> Remember that if you are using an explicit transaction or an async method that these must be completed before the consumer returns to guarantee that they are operating within the scope of the lock for the given key. Failure to do so will lead into possible inconsistency as they will be performing operations without the proper locking. <p> Some methods on the provided cache may not work as expected. These include {@link AdvancedCache#putForExternalRead(Object, Object)}, {@link AdvancedCache#lock(Object[])}, {@link AdvancedCache#lock(Collection)}, and {@link AdvancedCache#removeGroup(String)}. If these methods are used inside of the Consumer on the cache it will throw a {@link IllegalStateException}. This is due to possible interactions with transactions while using these commands. Same as {@link LockedStream#forEach(BiConsumer)}  except that the BiConsumer must also implement <code>Serializable</code> <p> The compiler will pick this overload for lambda parameters, making them <code>Serializable</code> This method is not supported when using a {@link LockedStream} This method is not supported when using a {@link LockedStream} This method is not supported when using a {@link LockedStream} Sets the timeout for the acquisition of the lock for each entry.
Method to be overridden by a subclass so that chained methods return the correct implementation
Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan. Similar to the concurrencyLevel tuning parameter seen in the JDK's ConcurrentHashMap. Cache isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation levels. See <a href= 'http://en.wikipedia.org/wiki/Isolation_level'>http://en.wikipedia.org/wiki/Isolation_level</a > for a discussion on isolation levels. Maximum time to attempt a particular lock acquisition This option applies to non-transactional caches only (both clustered and local): if set to true(default value) the cache keeps data consistent in the case of concurrent updates. For clustered caches this comes at the cost of an additional RPC, so if you don't expect your application to write data concurrently, disabling this flag increases performance. If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system. This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception.
Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan. Similar to the concurrencyLevel tuning parameter seen in the JDK's ConcurrentHashMap. Cache isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation levels. See <a href= 'http://en.wikipedia.org/wiki/Isolation_level'>http://en.wikipedia.org/wiki/Isolation_level</a > for a discussion on isolation levels. Maximum time to attempt a particular lock acquisition Maximum time to attempt a particular lock acquisition  If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system. This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception.



id = 4008 is now logged to TRACE(ISPN-1794)







Same as {@link LongCacheStream#allMatch(LongPredicate)} except that the LongPredicate must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. Same as {@link LongCacheStream#anyMatch(LongPredicate)} except that the LongPredicate must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. {@inheritDoc } {@inheritDoc } Same as {@link LongCacheStream#collect(Supplier, ObjLongConsumer, BiConsumer)} except that the arguments must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } Same as {@link LongCacheStream#filter(LongPredicate)} except that the LongPredicate must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. {@inheritDoc } {@inheritDoc } {@inheritDoc } Same as {@link LongCacheStream#flatMap(LongFunction)} except that the LongFunction must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. Same as {@link LongCacheStream#forEach(LongConsumer)} except that it takes an {@link ObjLongConsumer} that provides access to the underlying {@link Cache} that is backing this stream. <p> Note that the <code>CacheAware</code> interface is not supported for injection using this method as the cache is provided in the consumer directly. Same as {@link LongCacheStream#forEach(LongConsumer)} except that the LongConsumer must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. Same as {@link LongCacheStream#forEach(ObjLongConsumer)} except that the <code>BiConsumer</code> must also implement <code>Serializable</code> {@inheritDoc } {@inheritDoc } Same as {@link LongCacheStream#map(LongUnaryOperator)} except that the LongUnaryOperator must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. {@inheritDoc } Same as {@link LongCacheStream#mapToDouble(LongToDoubleFunction)} except that the LongToLongFunction must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. {@inheritDoc } Same as {@link LongCacheStream#mapToInt(LongToIntFunction)} except that the LongToIntFunction must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. {@inheritDoc } Same as {@link LongCacheStream#mapToObj(LongFunction)} except that the LongFunction must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. Same as {@link LongCacheStream#noneMatch(LongPredicate)} except that the LongPredicate must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. {@inheritDoc } {@inheritDoc }  {@inheritDoc } Same as {@link LongCacheStream#flatMap(LongFunction)} except that the LongFunction must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. Same as {@link LongCacheStream#reduce(long, LongBinaryOperator)} except that the LongBinaryOperator must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. Same as {@link LongCacheStream#reduce(LongBinaryOperator)} except that the LongBinaryOperator must also implement Serializable. <p> This method will be used automatically by lambdas, which prevents users from having to manually cast to a Serializable lambda. {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc }






BooleanQuery has a static (but reconfigurable) limit for the number of clauses. If any node was able to bypass this limit, we'll need to assume that this limit was somehow relaxed and some point in time, so we need to apply the same configuration to this node.

Looks up the Directory adapter if it's already known, or attempts to initialize indexes. Attempts to open a Lucene FSDirectory on the specified path There might be Directories we didn't store yet in the openDirectories Map. Make sure they are all initialized before serving methods such as {@link #process(KeyFilter, org.infinispan.persistence.spi.AdvancedCacheLoader.CacheLoaderTask, java.util.concurrent.Executor, boolean, boolean)}

This method has to perform the inverse transformation of the keys used in the Lucene Directory from String to object. So this implementation is strongly coupled to the toString method of each key type.
When Index Affinity is enabled, this returns the segment id to which the current index is bound to. When the segment size is larger than this number of bytes, separate segments will be created of this particular size. The location of the root directory of the index.
When the index is stored on a per-segment affinity base, set the affinity id for this index instance. Ignore this when not using the Index Affinity feature. When segment files are larger than this amount of bytes, the segment will be split into multiple chunks of this size. Path to the root directory containing all indexes. Indexes are loaded from the immediate subdirectories of specified path, and each such subdirectory name will be the index name that must match the name parameter of a Directory constructor.



Returns the projections of the parsed query, represented as dot-separated paths to fields of embedded entities. Returns the created Lucene query. Returns the optional Lucene sort specification. Returns the entity metadata (usually a Class) resolved from the original entity name. Returns the original entity name from the query.










Collect all documents from an index Counts the documents Read all terms from a field











Retrieves an {@link MBeanServer} instance.
{@inheritDoc }

Makes internal copies of the entry for updates   Returns whether this entry was marked as being expired or not Check is this entry as loaded from the cache (as opposed to generated by the application using write-only command), mostly for purposes of the write skew check. Replaces {@link org.infinispan.transaction.xa.CacheTransaction#keyRead(Object)}. Reset the current value of the entry to the value before the commmand was executed the first time. This is invoked before the command is retried. Mark this context-entry as already committed to the {@link DataContainer}. Marks this entry as being expired.  This is a special form of removal. Mark that this entry was loaded from the cache (as opposed to generated by the application using write-only command), mostly for purposes of the write skew check. Replaces {@link org.infinispan.transaction.xa.CacheTransaction#addReadKey(Object)}. Update the previous value of the entry - set it to current value. This is invoked when the command is successfuly finished (there won't be any more retries) or when the value was updated from external source.

The






{@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc }


{@inheritDoc } {@inheritDoc } {@inheritDoc } {@inheritDoc }
























Marshall arrays. <p> This method supports {@code null} {@code array}. Same as {@link #marshallArray(Object[], ObjectOutput)} but specialized for byte arrays. Marshall a {@link Collection}. <p> This method supports {@code null} {@code collection}. Marshall a {@link Collection}. <p> This method supports {@code null} {@code collection}. Marshalls a collection of integers. Marshall the {@code map} to the {@code ObjectOutput}. <p> {@code null} maps are supported. Marshall the {@code map} to the {@code ObjectOutput}. <p> {@code null} maps are supported. A special marshall implementation for integer. <p> This method supports negative values but they are handles as {@link #NULL_VALUE}. It means that the real value is lost and {@link #NULL_VALUE} is returned by {@link #unmarshallSize(ObjectInput)}. <p> The integer is marshalled in a variable length from 1 to 5 bytes. Negatives values are always marshalled in 1 byte. Marshall the {@link String}. <p> Same behavior as {@link ObjectOutput#writeUTF(String)} but it checks for {@code null}. If the {@code string} is never {@code null}, it is better to use {@link ObjectOutput#writeUTF(String)}. Marshall the {@link UUID} by sending the most and lest significant bits. <p> This method supports {@code null} if {@code checkNull} is set to {@link true}. Unmarshall arrays. Same as {@link #unmarshallArray(ObjectInput, ArrayBuilder)} but specialized for byte array. <p> No {@link ArrayBuilder} is necessary. Unmarshal a {@link Collection}. Unmarshal a {@link Collection}. Same as {@link #unmarshallCollection(ObjectInput, CollectionBuilder)}. <p> Used when the size of the {@link Collection} is not needed for it construction. Unmarshalls a collection of integers. Unmarshall the {@link Map}. <p> If the marshalled map is {@link null}, then the {@link MapBuilder} is not invoked. Unmarshall the {@link Map}. <p> If the marshalled map is {@link null}, then the {@link MapBuilder} is not invoked. Unmarshall an integer. Unmarshall a {@link String}. Unmarshall {@link UUID}.


Clear the cached marshallable type hints. Get the serialized form size predictor for a particular type. Returns whether the hint on whether a particular type is marshallable or not is available. This method can be used to avoid attempting to marshall a type, if the hints for the type have already been calculated. Returns whether a type can be serialized. In order for a type to be considered marshallable, the type must have been marked as marshallable using the {@link #markMarshallable(Class, boolean)} method earlier, passing true as parameter. If a type has not yet been marked as marshallable, this method will return false. Marks a particular type as being marshallable or not being not marshallable.
Returns the same key as {@link #getKeyBytes()}, but unmarshalled. Returns the key in serialized format.   Returns the same value as {@link #getKeyBytes()}, but unmarshalled. Returns the value in serialize format.




Returns a marshalled payload size predictor for a particular type. Accurate prediction of a type's serialized payload size helps avoid unnecessary copying and speeds up application performance. A method that checks whether the given object is marshallable as per the rules of this marshaller. Unmarshalls an object from a byte array. Unmarshalls an object from a specific portion of a byte array. A method that returns an instance of {@link org.infinispan.commons.io.ByteBuffer}, which allows direct access to the byte array with minimal array copying Marshalls an object to a byte array. Marshalls an object to a byte array.  The estimatedSize parameter is a hint that can be passed in to allow for efficient sizing of the byte array before attempting to marshall the object.  The more accurate this estimate is, the less likely byte[]s will need to be resized to hold the byte stream generated by marshalling the object.





Registers proto files and marshallers.







Obtains an ObjectFilter instance that is capable of testing a single filter condition. Test the given instance against all the subscribed filters and notify all callbacks registered for instances of the same instance type. The {@code isDelta} parameter of the callback will be {@code false}. Test two instances (which are actually before/after snapshots of the same instance) against all the subscribed filters and notify all callbacks registered for instances of the same instance type. The {@code isDelta} parameter of the callback will be {@code true}.
The instance being matched with the filters.
Get the Maven properties defined in the project.


Converts text into {@link MediaType}. Returns {@link OutputPrinter} associated to this {@link MediaType}.




returns "DELETED" or "NOT_FOUND" depending whether the key existed. Returns the value for the key. Returns the value for the key. returns server time retrieved via stats command -1 if time stat is not returned.







Transforms lifespan pass as seconds into milliseconds following this rule: <p> If lifespan is bigger than number of seconds in 30 days, then it is considered unix time. After converting it to milliseconds, we substract the current time in and the result is returned. <p> Otherwise it's just considered number of seconds from now and it's returned in milliseconds unit.







Use {@link ProtocolServerConfigurationBuilder#defaultCacheName(String)} instead






Returns a stream of longs that are all of the various memory locations Same as {@link MemoryAddressHash#toStream()} except that the memory addresses are also cleared out (set to 0)

The address pointer count The configured eviction type Size of the eviction, -1 if disabled Storage type to use for the data container
Configuration setting when using off-heap that defines how many address pointers there are. This number will be rounded up to the next power of two.  This helps performance in that the more address pointers there are the less collisions there will be which improve performance of both read and write operations. Sets the eviction type which can either be <ul> <li>COUNT - entries will be evicted when the number of entries exceeds the {@link #size(long)}</li> <li>MEMORY - entries will be evicted when the approximate combined size of all values exceeds the {@link #size(long)}</li> </ul> Cache size is guaranteed not to exceed upper limit specified by max entries. However, due to the nature of eviction it is unlikely to ever be exactly maximum number of entries specified here. Defines the maximum size before eviction occurs. See {@link #evictionType(EvictionType)} for more details on the size is interpreted. Set the {@link StorageType} to determine how the data is stored in the data container.











Returns the value of the meta parameter.

Construct a collection of {@link MetaParam} instances. If multiple instances of the same {@link MetaParam} are present, the last value is only considered since there can only be one instance per type in the {@link MetaParams} collection.


Transforms a String property name path into an internal representation of the path which might not be String based (AttributeId is an Integer in the Protobuf case).
Get metadata of this cache entry. Set the metadata in the cache entry.
Get metadata of this command. Sets metadata for this command.













Applies version in source metadata to target metadata, if no version in target metadata. This method can be useful in scenarios where source version information must be kept around, i.e. write skew, or when reading metadata from cache store. Set the {@code providedMetadata} on the cache entry. If the entry already has a version, copy the version in the new metadata.

The definition of this metric.
Executes the specified metric against the specified context.




Expects externalizer string to be a comma-separated list of "<id>:<class>"












Delegates a Mockito invocation to a target object, and returns the mock instead of the target object. Useful when {@code Mockito.spy(object)} doesn't work and the mocked class has a fluent interface.






Returns the value of the node as an Enum value, or null if the node is undefined. Returns the value of the node as an Enum value, or the specified default value if the node is undefined. Returns the value of the node as a float, or null if the node is undefined. Returns the value of the node as a string, or the specified default value if the node is undefined. Returns the value of the node as a module identifier, or null if the node is undefined. Returns the value of the node as a module identifier, or the specified default if the node is undefined. Returns the value of the node as a string, or null if the node is undefined. Returns the value of the node as a string, or the specified default value if the node is undefined.




Construct and initialize a {@link ReplicableCommand} based on the command id. Construct and initialize a {@link CacheRpcCommand} based on the command id. Provides a map of command IDs to command types of all the commands handled by the command factory instance. Unmarshalling requests for these command IDs will be dispatched to this implementation.

Initializes a command constructed using {@link ModuleCommandFactory#fromStream(byte)} with necessary named-cache-specific components.



Retrieves an Iterable containing metadata file finders declared by each module.




Call {@link BaseAsyncInterceptor#invokeNext(InvocationContext, VisitableCommand)} on a sequence of sub-commands. <p> Stop when one of the sub-commands throws an exception, and return an invocation stage with that exception. If all the sub-commands are successful, return the {@code finalStage}. If {@code finalStage} has and exception, skip all the sub-commands and just return the {@code finalStage}.



Returns builder for Hot Rod. Returns builder for REST. Returns builder for Routing Table.
Gets internal {@link Router} implementation for given protocol. Starts the router. Stops the router.
Gets Hot Rod Configuration. Gets REST Configuration. Gets the {@link RoutingTable}.
Returns assembled configuration.

Asynchronous method that returns {@link Boolean#TRUE} if this multimap cache contains the key-value pair. Asynchronous method. Returns {@link Boolean#TRUE} if this multimap cache contains the key. Asynchronous method that returns {@link Boolean#TRUE} if this multimap cache contains the value at any key. * Asynchronous method. Returns a <i>view collection</i> of the values associated with key in this multimap cache, if any. Any changes to the retrieved collection won't change the values in this multimap cache. <b>When this method returns an empty collection, it means the key was not found.</b> Retrieves a CacheEntry corresponding to a specific key in this multimap cache. Asynchronous method. Puts a key-value pair in this multimap cache. <ul> <li>If this multimap cache supports duplicates, the value will be always added.</li> <li>If this multimap cache does <i>not support</i> duplicates and the value exists on the key, nothing will be done.</li> </ul> Asynchronous method. Removes the entry associated with the key from this multimap cache, if such exists. Asynchronous method. Removes a key-value pair from this multimap cache, if such exists. Returns true when the key-value pair has been removed from the key. <p> <ul> <li>In the case where duplicates are <b>not supported</b>, <b>only one</b> the key-value pair will be removed, if such exists.</li> <li>In the case where duplicates are supported, <b>all the key-value pairs</b> will be removed.</li> <li>If the values remaining after the remove call are empty, the whole entry will be removed.</li> </ul> Asynchronous method. Removes every value that match the {@link Predicate}. <p> This method <b>is blocking</b> used in a explicit transaction context. Overloaded method of {@link MultimapCache#remove(Predicate)} with {@link SerializablePredicate}. The compiler will pick up this method and make the given predicate {@link java.io.Serializable}. Returns the number of key-value pairs in this multimap cache. It doesn't return the distinct number of keys. <p> This method <b>is blocking</b> in a explicit transaction context. <p> The {@link CompletableFuture} is a Multimap can support duplicates on the same key k -> ['a', 'a', 'b'] or not k -> ['a', 'b'] depending on configuration. <p> Returns duplicates are supported or not in this multimap cache.
Defines a named multimap cache's configuration by using the provided configuration If this cache was already configured either declaritively or programmatically this method will throw a {@link org.infinispan.commons.CacheConfigurationException}. Currenly, the MultimapCache with the given name "foo" can be also accessed as a regular cache named "foo". Retrieves a named multimap cache from the system.


Hash a value using the x64 128 bit variant of MurmurHash3 Hash a value using the x64 128 bit variant of MurmurHash3 Hash a value using the x64 32 bit variant of MurmurHash3 Hash a value using the x64 32 bit variant of MurmurHash3 Hash a value using the x64 64 bit variant of MurmurHash3 Hash a value using the x64 64 bit variant of MurmurHash3 Hashes a byte array efficiently.
Hash a value using the x64 128 bit variant of MurmurHash3 Hash a value using the x64 128 bit variant of MurmurHash3 Hash a value using the x64 32 bit variant of MurmurHash3 Hash a value using the x64 32 bit variant of MurmurHash3 Hash a value using the x64 64 bit variant of MurmurHash3 Hash a value using the x64 64 bit variant of MurmurHash3 Hashes a byte array efficiently.
TODO: was initially package-level TODO: was initially package-level
Mutate the view
No need to occupy externalizer ids when we have a limited set of options














Constructs a component.


Get the URI of this namespace.
Recursively parses the current element of an XML stream using an appropriate {@link ConfigurationParser} depending on the element's namespace.










Initialize netty channel














Adds a child node with the given {@link Fqn} under the current node.  Returns the newly created node. <p/> If the child exists returns the child node anyway.  Guaranteed to return a non-null node. <p/> The {@link Fqn} passed in is relative to the current node.  The new child node will have an absolute fqn calculated as follows: <pre>new Fqn(getFqn(), f)</pre>.  See {@link Fqn} for the operation of this constructor. Removes all mappings from the node's data map.  Returns the value to which this node maps the specified key. Returns <code>null</code> if the node contains no mapping for this key.  Returns the child node Returns an immutable set of children nodes. Returns an immutable set of children node names. Returns a map containing the data in this {@link Node}. Returns the {@link Fqn} which represents the location of this {@link Node} in the cache structure.  The {@link Fqn} returned is absolute. Returns a {@link Set} containing the data in this {@link Node}. Returns the parent node. If this is the root node, this method returns <code>this</code>. Returns true if the child node denoted by the Object name passed in exists. Returns true if the child node denoted by the relative {@link Fqn} passed in exists. Tests if a node reference is still valid.  A node reference may become invalid if it has been removed, invalidated or moved, either locally or remotely.  If a node is invalid, it should be fetched again from the cache or a valid parent node.  Operations on invalid nodes will throw a {@link org.infinispan.tree.NodeNotValidException}. Associates the specified value with the specified key for this node. If this node previously contained a mapping for this key, the old value is replaced by the specified value. Copies all of the mappings from the specified map to this node's map. If any data exists, existing keys are overwritten with the keys in the new map. The behavior is equivalent to: <pre> Node node; for (Map.Entry me : map.entrySet()) node.put(me.getKey(), me.getValue()); </pre> If the specified key is not already associated with a value, associate it with the given value, and returns the Object (if any) that occupied the space, or null. <p/> Equivalent to calling <pre> if (!node.getKeys().contains(key)) return node.put(key, value); else return node.get(key); </pre> <p/> except that this is atomic. Removes the mapping for this key from this node if it is present. Returns the value to which the node previously associated the key, or <code>null</code> if the node contained no mapping for this key Removes a child node specified by the given name. Removes a child node specified by the given relative {@link Fqn}. <p/> If you wish to remove children based on absolute {@link Fqn}s, use the {@link TreeCache} interface instead. Replace entry for key only if currently mapped to some value. Acts as <pre> if ((node.getKeys().contains(key)) { return node.put(key, value); } else return null; </pre> <p/> except that this is atomic. Replace entry for key only if currently mapped to given value. Acts as <pre> if (node.get(key).equals(oldValue)) { node.put(key, newValue); return true; } else return false; </pre> <p/> except that this is atomic. Similar to {@link #putAll(java.util.Map)} except that it removes any entries that exists in the data map first. Note that this happens atomically, under a single lock.  This is the analogous to doing a {@link #clearData()} followed by a {@link #putAll(java.util.Map)} in the same transaction.
Multiple threads might call this method at the same time. This gets called by RemoteCache upon receiving a toplogy update, among other callers.
Multiple threads might call this method at the same time. This gets called by ReemoteCache upon receiving a toplogy update, among other callers.





















we're assuming that this function is ran on primary owner of given segments





doesn't do anything and returns true doesn't do anything















Always returns {@literal null}.


after Transport

Tests if an object instance matches the filter. The comparator corresponding to the 'order by' clause, if any. The fully qualified entity type name accepted by this filter. Returns the parameter names or an empty Set if there are no parameters. The array of '.' separated path names of the projected fields if any, or {@code null} otherwise. The array of sort specifications if defined, or {@code null} otherwise. Creates a new ObjectFilter based on current one and the given parameters.


Converts the given property value (usually a String representation coming right from the user's query string) into the type expected by the query backend. Returns the given value converted into the type of the given property as determined via the field bridge of the property. Lookup a type by name and return the metadata that represents it. Returns the type of the primitive property. Tests if the attribute path contains repeated (collection/array) attributes.



Clears the memory lookups and cache data. Invoked when an entry is about to be created.  The new address is fully addressable, The write lock will already be acquired for the given * segment the key mapped to. Invoked when an entry is about to be removed.  You can read values from this but after this method is completed this memory address may be freed. The write lock will already be acquired for the given segment the key mapped to. Invoked when an entry is about to be replaced with a new one.  The old and new address are both addressable, however oldAddress may be freed after this method returns.  The write lock will already be acquired for the given segment the key mapped to. Invoked when an entry is successfully retrieved.  The read lock will already be acquired for the given segment the key mapped to. Performs the actual put operation putting the new address into the memory lookups.  The write lock for the given key <b>must</b> be held before calling this method. Performs the actual remove operation removing the new address from the memory lookups.  The write lock for the given key <b>must</b> be held before calling this method.
Creates an off heap entry using the provided key value and metadata Returns whether the given key as bytes is the same key as the key stored in the entry for the given address. Create an entry from the off heap pointer Returns the hashCode of the address.  This Returns the key for the given address Returns the address to the next linked pointer if there is one for this bucket or 0 if there isn't one Returns how many bytes in memory this address location uses assuming it is an {@link InternalCacheEntry} Called to update the next pointer index when a collision occurs requiring a linked list within the entries themselves
Create an entry off-heap.  The first 8 bytes will always be 0, reserved for a future reference to another entry Assumes the address points to the entry excluding the pointer reference at the beginning Assumes the address doesn't contain the linked pointer at the beginning


Allocates a new chunk of memory sized to the given length. Deallocates the memory allocated at the given address Deallocates the memory at the given address assuming a given size

Configures the site to use the supplied configuration for determining when to take a site offline. Also triggers a state reset.


Handle a websocket channel operation.
The definition of this operation.
Executes the specified operation against the specified context.


Creates a composite operation using the specified operation steps. Creates a composite operation using the specified operation steps. Creates a describe operation using the specified address. Creates a read-attribute operation using the specified address and name. Creates an undefine-attribute operation using the specified address and name. Creates a write-attribute operation using the specified address, namem and value. Returns the attribute name of the specified operation Returns the attribute value of the specified operation Returns the name of the specified operation Returns the address of the specified operation
Construct a fault tolerant ping request. This operation should be capable to deal with nodes being down, so it will find the first node successful node to respond to the ping. Construct a ping request directed to a particular node.
todo [anistor] must also validate that the argument type is compatible with the operator
This 'has been prepared' logic only applies to optimistic transactions, hence it is not present in the LocalTransaction object itself.











Load the class and break on first found match. TODO: Should this throw a different exception or warn if multiple classes were found? Naming collisions can and do happen in OSGi... Load the resource and break on first found match. TODO: Should this throw a different exception or warn if multiple resources were found? Naming collisions can and do happen in OSGi... Load the resources and return an Enumeration Note: Since they're Enumerations, do not cache these results!

Set up a list of sequencer states after interceptor {@code interceptorClass} has returned. <p/> Each invocation accepted by {@code matcher} will enter/exit the next state from the list, and does nothing after the list is exhausted. Set up a list of sequencer states before interceptor {@code interceptorClass} is called. <p/> Each invocation accepted by {@code matcher} will enter/exit the next state from the list, and does nothing after the list is exhausted.
Cancel the whole task. Cancel some of the segments. If all segments get cancelled then the whole task will be cancelled. todo [anistor] check thread interrupt status in loops to implement faster cancellation

Converts specific value to a desired output format. Converts all values in the cache to a desired output format.






Parameter's value. A parameter's identifier. Each parameter must have a different id. <p>A numeric id makes it flexible enough to be stored in collections that take up low resources, such as arrays.

Create an instance of {@link KeyValueFilterConverter}

Returns the named parameters Map. Sets the value of a named parameter. Sets multiple named parameters at once. Parameters names cannot be empty or {@code null}. Parameter values must not be {@code null}.


Builds the validator.
Callback allowing the default parameter value (that which would be injected according to the CDI type safe resolution rules) to be overridden.

Adds all parameters and returns a new parameter collection. Checks whether all the parameters passed in are already present in the current parameters. This method can be used to optimise the decision on whether the parameters collection needs updating at all. Retrieve a param given its identifier. Callers are expected to know the exact type of parameter that will be returned. Such assumption is possible because as indicated in {@link Param} implementations will only come from Infinispan itself. Bridging method between flags and params, provided for efficient checks.

Get an exception reporting that an attribute of a given name has already been declared in this scope. Get an exception reporting that an element of a given type and name has already been declared in this scope. Get an exception reporting an invalid XML attribute value. Get an exception reporting a missing, required XML attribute. Get an exception reporting a missing, required XML child element. Read an element which contains only a single boolean attribute. Read an element which contains only a single string attribute. Require all the named attributes, returning their values in order. Checks that the current element has no attributes, throwing an {@link javax.xml.stream.XMLStreamException} if one is found. Consumes the remainder of the current element, throwing an {@link javax.xml.stream.XMLStreamException} if it contains any child elements. Require that the current element have only a single attribute with the given name. Get an exception reporting an unexpected XML attribute. Get an exception reporting an unexpected XML attribute. Get an exception reporting an unexpected XML element. Get an exception reporting an unexpected end tag for an XML element.

This method is public static so that it can be reused by custom cache store/loader configuration parsers
This method is public static so that it can be reused by custom cache store/loader configuration parsers






Converts a time representation into milliseconds







Adds a partially committed transaction. <p/> The transaction is committed in one phase and it is register if it is not sure that the transaction was committed successfully in all the affected nodes. Adds a partially committed transaction. <p/> The transaction is committed in the second phase and it is register if it is not sure that the transaction was committed successfully in all the affected nodes. Adds a partially aborted transaction. <p/> The transaction should be registered when it is not sure if the abort happens successfully in all the affected nodes. It checks if the transaction can be aborted when the originator leaves the cluster. <p/> The only case in which it is not possible to abort is when partition handling is enabled and the originator didn't leave gracefully. The transaction will complete when the partition heals. test use only. it can be removed if we update the tests  It checks if the transaction resources (for example locks) can be released. <p/> The transaction resource can't be released when the transaction is partially committed. Notifies the {@link PartitionHandlingManager} that the cache topology was update. <p/> It detects when the partition is merged and tries to complete all the partially completed transactions.



The mode the current cluster is in.  This determines which operations can be ran in the cluster.

Skips the passivation when the cache is stopped.








Create a new probe, don't reuse the default. PAX EXAM reuses the default one which means all the test addresses from the previous runs are present in the probe header. If some of them extend classes from dependencies which are not available for the current probe bundle NoClassDefFound exceptions will occur.





Peaks at a value for the given key.  Note that this does not update any expiration or eviction information when this is performed on the map, unlike the get method.
Invoked when {@link PendingLockPromise} is ready.
It waits for any transaction with older topology id to complete that may have the lock for any key in {@code keys} acquired. It waits for any transaction with older topology id to complete that may have the lock for {@code key} acquired. Same as {@link #awaitPendingTransactionsForKey(TxInvocationContext, Object, long, TimeUnit)} but non-blocking. <p> Multiple invocations with the same transaction returns the same {@link PendingLockPromise}. For cleanup purposes, {@link #awaitPendingTransactionsForKey(TxInvocationContext, Object, long, TimeUnit)} must be invoked afterwards. Same as {@link #awaitPendingTransactionsForAllKeys(TxInvocationContext, Collection, long, TimeUnit)} but non-blocking. <p> Multiple invocations with the same transaction returns the same {@link PendingLockPromise}. For cleanup purposes, {@link #awaitPendingTransactionsForAllKeys(TxInvocationContext, Collection, long, TimeUnit)} must be invoked afterwards.
Adds a listener to this promise. <p> The listener must be non-null and it is invoked only once. If {@link #isReady()} returns {@code true}, the {@code listener} is immediately invoked in the invoker thread.


Handles the {@link org.infinispan.commands.remote.CacheRpcCommand} from other node.




Loops through all individual cache loader configs and checks if fetchPersistentState is set on any of them If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. <br /> <br /> If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Loops through all individual cache loader configs and checks if preload is set on any of them
Adds a cluster cache loader Adds a single file cache store Adds a cache loader which uses the specified builder class to build its configuration Adds a cache loader which uses the specified builder instance to build its configuration Removes any configured stores from this builder. If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. <br /> <br /> If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration.


Invokes {@link org.infinispan.persistence.spi.AdvancedCacheWriter#clear()} on all the stores that aloes it. Perform the commit operation for the provided transaction on all Tx stores. Remove all entries from the underlying non-transactional stores as a single batch. Marks the given storage as disabled. Returns the store one configured with fetch persistent state, or null if none exist.  Loads the data from the external store into memory during cache startup. Perform the prepare phase of 2PC on all Tx stores. Removes the expired entries from all the existing storage. Perform the rollback operation for the provided transaction on all Tx stores. Write all entries to the underlying non-transactional stores as a single batch. Write to all stores that are not transactional. A store is considered transactional if all of the following are true: <p><ul> <li>The store implements {@link org.infinispan.persistence.spi.TransactionalCacheWriter}</li> <li>The store is configured to be transactional</li> <li>The cache's TransactionMode === TRANSACTIONAL</li> </ul></p>






Adds a mapping between an {@link Address} and a {@link PersistentUUID} Provides a remapping operator which translates addresses to persistentuuids Retrieves the {@link Address} of a node given its {@link PersistentUUID} Retrieves the {@link PersistentUUID} of a node given its {@link Address} Returns a list of {@link PersistentUUID}s for the supplied {@link Address}es Provides a remapping operator which translates persistentuuids to addresses Removes any address mapping for the specified {@link Address} Removes any address mapping for the specified {@link PersistentUUID}









this is protected in order to demonstrate that direct field access will be used instead of method access









generate the XML report given what we know from all the test results             Reset all member variables for next test.




Optional parameter which defines the order in which this method will be called.  Defaults to 10.

Callback that is invoked after every handleXXX() method defined above. tx commands read commands




Checks if two predicates are identical or opposite.  Removes duplicate occurrences of same predicate in a conjunction or disjunction. Also detects and removes tautology and contradiction. The following translation rules are applied: <ul> <li>X || X => X</li> <li>X && X => X</li> <li>!X || !X => !X</li> <li>!X && !X => !X</li> <li>X || !X => TRUE (tautology)</li> <li>X && !X => FALSE (contradiction)</li> </ul>

If we have more expected members than stable members, then we know that a split brain heal is occurring However if the maxTopologySize == 1, then we know that we have a new coordinator


TODO: this is not completely aligned with single-entry prefetch



If set to true, then the keys touched by this transaction are to be wrapped again and original ones discarded.
Prepares the transaction. Advances the transaction to prepared state. Rollbacks the transaction if it fails to prepare. Starts a transaction.

handler


Returns the left child value expression to which the predicate is attached. The {@link ValueExpr} should always be a {@link PropertyValueExpr} after the tree was normalized and constant expressions were removed.
Returns a sun.misc.Unsafe.  Suitable for use in a 3rd party package. Replace with a simple call to Unsafe.getUnsafe when integrating into a jdk.

Resolves Principal Name (e.g. user name) based on session.
Maps a principal name to a set of role names. The principal name depends on the source of the principal itself. For example, in LDAP a Principal might use the Distinguished Name format (DN). The mapper should return null if it does not recognize the principal. Sets the context for this {@link PrincipalRoleMapper}
Returns the {@link EmbeddedCacheManager} in which this role mapper is being instantiated






Supply some custom programmatic mappings.












Obtains the {@link SerializationContext} associated with the given remote cache manager.




todo [anistor] missing tags need to be fired with default value defined in proto schema or null if they admit null; missing messages need to be fired with null at end of the nesting level. BTW, seems like this is better to be included in Protostream as a feature



Starts the ___protobuf_metadata when needed. This method must be invoked for each cache that uses protobuf. Obtain the cache, lazily. Obtains the ProtobufMetadataManagerImpl instance associated to a cache manager. Defines the configuration of the ___protobuf_metadata internal cache.
For preload, we need to copy the CACHE_MODE_LOCAL flag from the put command. But we also need to remove the SKIP_CACHE_STORE flag, so that existing .errors keys are updated.
Gets the error messages (caused by parsing, linking, etc) associated to a *.proto schema file. Get the full names of all files with errors. Gets the contents of a registered *.proto schema file. Get the full names of all registered schema files. Register a *.proto schema file. If there are any syntax or semantic errors a *.proto.errors key will be created in the underlying cache and its value will be the actual error message. The error message, if any, can be retrieved using {@link #getFileErrors(String fileName)} method. The list of offending files can be retrieved using {@link #getFilesWithErrors()} method. Registers multiple *.proto schema files. If there are any syntax or semantic errors a *.proto.errors key will be created in the underlying cache for each offending file and its value will be the actual error message. The error message, if any, can be retrieved using {@link #getFileErrors(String fileName)} method. The list of offending files can be retrieved using {@link #getFilesWithErrors()} method. Unregister a *.proto schema file. Unregisters multiple *.proto schema files.







{@inheritDoc }




Returns the configuration used to start this server Gets the decoder for this protocol server. The decoder is responsible for reading client requests. This method cannot return null. Gets the encoder for this protocol server. The encoder is responsible for writing back common header responses back to client. This method can return null if the server has no encoder. You can find an example of the server that has no encoder in the Memcached server. Returns a pipeline factory Starts the server backed by the given cache manager and with the corresponding configuration. Stops the server


Indicates the {@link AdminOperationsHandler} which will be used to handle admin operations Builds a configuration object Specifies the cache to use as a default cache for the protocol Specifies the host or IP address on which this server will listen Specifies the maximum time that connections from client will be kept open without activity Sets the caches to be ignored Specifies a custom name for this server in order to easily distinguish it from other servers, e.g. via JMX. Defaults to the empty string. Specifies the port on which this server will listen Sets the size of the receive buffer Sets the size of the send buffer Configures SSL Indicates whether transport implementation should or should not be started. Affects TCP NODELAY on the TCP stack. Defaults to enabled Sets the number of worker threads






Returns an appropriate service name for the default stack Returns an appropriate service name for the specified stack












Acquire a lock giving the calling thread the right to put data in the cache for the given key. <p> <strong>NOTE:</strong> A call to this method that returns <code>true</code> should always be matched with a call to {@link #releasePutFromLoadLock(Object, Lock)}. </p> Besides the call from constructor, this should be called only from tests when mocking the validator. Invalidates any {@link #registerPendingPut(SessionImplementor, Object, long) previously registered pending puts} and disables further registrations ensuring a subsequent call to {@link #acquirePutFromLoadLock(SessionImplementor, Object, long)} will return <code>false</code>. <p> This method will block until any concurrent thread that has {@link #acquirePutFromLoadLock(SessionImplementor, Object, long) acquired the putFromLoad lock} for the given key has released the lock. This allows the caller to be certain the putFromLoad will not execute after this method returns, possibly caching stale data. </p> After this transaction completes, {@link #endInvalidatingKey(Object, Object)} needs to be called } Invalidates all {@link #registerPendingPut(SessionImplementor, Object, long) previously registered pending puts} ensuring a subsequent call to {@link #acquirePutFromLoadLock(SessionImplementor, Object, long)} will return <code>false</code>. <p> This method will block until any concurrent thread that has {@link #acquirePutFromLoadLock(SessionImplementor, Object, long) acquired the putFromLoad lock} for the any key has released the lock. This allows the caller to be certain the putFromLoad will not execute after this method returns, possibly caching stale data. </p> Called after the transaction completes, allowing caching of entries. It is possible that this method is called without previous invocation of {@link #beginInvalidatingKey(Object, Object)}, then it should be a no-op. Called when the region invalidation is finished. ---------------------------------------------------------------- Private we can't use SessionImpl.toString() concurrently Notifies this validator that it is expected that a database read followed by a subsequent {@link #acquirePutFromLoadLock(SessionImplementor, Object, long)} call will occur. The intent is this method would be called following a cache miss wherein it is expected that a database read plus cache put will occur. Calling this method allows the validator to treat the subsequent <code>acquirePutFromLoadLock</code> as if the database read occurred when this method was invoked. This allows the validator to compare the timestamp of this call against the timestamp of subsequent removal notifications. Releases the lock previously obtained by a call to {@link #acquirePutFromLoadLock(SessionImplementor, Object, long)}. This methods should be called only from tests; it removes existing validator from the cache structures in order to replace it with new one.




For non transactional caches that support concurrent writes (default), the commands are forwarded between nodes, e.g.: - commands is executed on node A, but some of the keys should be locked on node B - the command is send to the main owner (B) - B tries to acquire lock on the keys it owns, then forwards the commands to the other owners as well - at this last stage, the command has the "isForwarded" flag set to true.





Gets the total number of results matching the query, ignoring pagination (firstResult, maxResult). todo [anistor] this should probably be a long? Returns the results of a search as a list.
Id of this QueryBox Get the "docIndex" value on the correct DocumentExtractor Kill the query (DocumentExtractor) Register a query (DocumentExtractor), so we can lazily load the results.
Builds the query object. Once built, the query is immutable (except for the named parameters).
Gets the cached query object. The key used for lookup is an object pair containing the query string and a discriminator value which is usually the Class of the cached query object and an optional {@link List} of {@link FieldAccumulator}s. Obtain the cache. Start it lazily when needed. Create the configuration of the internal query cache.

Build a Lucene index query. Make a new FilterParsingResult after normalizing the query. This FilterParsingResult is not supposed to have grouping/aggregation. Swaps all occurrences of PropertyPaths in given expression tree (the HAVING clause) with new PropertyPaths according to the mapping found in {@code columns} map.



Creates a Query based on an Ickle query string. Creates a QueryBuilder for the given entity type. Creates a QueryBuilder for the given entity type. Creates a condition on the given attribute path that is to be completed later by using it as a sub-condition. Creates a condition on the given attribute path that is to be completed later by using it as a sub-condition. Creates a negated condition that is to be completed later by using it as a sub-condition. Creates a negated condition based on a given sub-condition. The negation is grouped.
Use this executor for Async operations The set of known classes. Some might be indexable, some are not. Indexing management of the Clear command Indexing management of a ComputeCommand Indexing management of a ComputeCommand Indexing management of a ComputeIfAbsentCommand Indexing management of a ComputeIfAbsentCommand Indexing management of a PutKeyValueCommand Indexing management of a PutMapCommand Indexing management of a ReadWriteKeyCommand Indexing management of a RemoveCommand Indexing management of a ReplaceCommand Remove all entries from all known indexes Method that will be called when data needs to be removed from Lucene. Remove entries from all indexes by key Customize work creation during indexing In case of a remotely originating transactions we don't have a chance to visit the single commands but receive this "batch". We then need the before-apply snapshot of some types to route the cleanup commands to the correct indexes. Note we don't need to visit the CommitCommand as the indexing context is registered as a transaction sync.
Run command and retry if suspect exception was thrown. Start the internal cache lazily.



Parses the given query string. render a given source query into an output query, by invoking {@link QueryRendererDelegate} while traversing the given query tree resolves the elements in given source query into an output query, by invoking {@link QueryResolverDelegate} while traversing the given query tree
Sets a property path representing one property in the SELECT, GROUP BY, WHERE or HAVING clause of a given query. Sets the sort direction, either "asc" or "desc", for the current property. The property was previously specified by {@link #setPropertyPath(PropertyPath)}
Add 'group by' criteria. This implements the equality predicate; the comparison predicate could be a constant, a subfunction or some random type parameter. The tree node has all details but with current tree rendering it just passes it's text so we have to figure out the options again. See rule entityName Sets a property path representing one property in the SELECT, GROUP BY, WHERE or HAVING clause of a given query. Add field sort criteria.

Notifies this delegate when parsing of a property path in the SELECT or WHERE is completed.






Remove one handler from the deque, or freeze the deque if there are no more elements.

This method is to be called just before marking the transfer as complete and after all keys have been manually processed.  This will return all the entries that were raised in an event but not manually marked.  This is indicative of a CREATE event occurring but not seeing the value. This should be called by any listener when an event is generated to possibly queue it.  If it is not queued, then the caller should take appropriate action such as manually firing the invocation. This should be invoked on a key before actually processing the data.  This way the handler knows to keep any newer events have come after the iteration. This should invoked after the key has been successfully processed to tell the handler that the key is done. This is needed to tell the handler when the complete iteration is done.  Depending on the implementation this could also fire all queued events that are remaining.














returns full uri for given server number cache name and key if key is null the key part is ommited the same as the normal get, without the asserts, so the caller can decide what to do in case the request fails



Returns the key of the cache entry with the event Returns the value of the cache entry with the event Returns the value of the cache entry with the event Whether the old value is available {@inheritDoc }
TODO: was package-level initially {@inheritDoc } <p/> Statistics will also automatically be cleared if internal counters overflow. The mean time to execute gets. <p/> In a read-through cache the time taken to load an entry on miss is not included in get time. The mean time to execute puts. The mean time to execute removes.  The total number of requests to the cache. This will be equal to the sum of the hits and misses. <p/> A "get" is an operation that returns the current or previous value. Returns cache hits as a percentage of total gets.  Returns cache misses as a percentage of total gets.  The total number of puts to the cache. <p/> A put is counted even if it is immediately evicted. A replace includes a put and remove. The total number of removals from the cache. This does not include evictions, where the cache itself initiates the removal to make space. <p/> TODO: was package-level initially Maps an Infinispan statistic to a value that's accepted by the JCache specification.

Creates an object name using the scheme "javax.cache:type=Cache&lt;Statistics|Configuration&gt;,CacheManager=&lt;cacheManagerName&gt;,name=&lt;cacheName&gt;" Checks whether an ObjectName is already registered. Filter out invalid ObjectName characters from string. Utility method for registering CacheStatistics with the platform MBeanServer TODO: was package-level originally Removes registered CacheStatistics for a Cache TODO: was package-level initially



Tests whether a flag is set. Utility method that sets the value of the given flag to true. Utility method that sets the value of the flag to false.




Not really invoked unless in local mode Apply function on entry without any data


Checks if the provided set is empty.  This is done by iterating over all of the values until it can find a key that maps to a given segment. <p> This method should always be preferred over checking the size to see if it is empty. <p> This time complexity for this method between O(1) to O(N). Returns the size of the read only set.  This is done by iterating over all of the values counting all that are in the segments. <p> If you are using this method to verify if the set is empty, you should instead use the {@link ReadOnlySegmentAwareEntryCollection#isEmpty()} as it will perform better if the size is only used for this purpose. <p> This time complexity for this method is always O(N).



Checks if the provided map is empty.  This is done by iterating over all of the keys until it can find a key that maps to a given segment. <p> This method should always be preferred over checking the size to see if it is empty. <p> This time complexity for this method between O(1) to O(N). Returns the size of the read only map.  This is done by iterating over all of the keys counting all that are in the segments. <p> If you are using this method to verify if the map is empty, you should instead use the {@link ReadOnlySegmentAwareEntryMap#isEmpty()} as it will perform better if the size is only used for this purpose. <p> This time complexity for this method is always O(N). NOTE: this method is not supported.  Due to the nature of this map, we don't want to copy the underlying value collection.  Thus almost any operation will require O(N) and therefore this method is not provided.









It adds a listener that is invoked when this action is ready.  Cleanup when the command throws an exception while executing. Invoked always after the command is executed and the reply is sent.










Returns true if this transaction failed during 2nd phase of 2PC(prepare or commit). E.g. when the transaction successfully prepared but the commit failed due to a network issue.
Check's if this transaction's originator is no longer part of the cluster (orphan transaction) and updates {@link #isOrphan()}. Following values might be returned: <ul> <li> - {@link Status#STATUS_PREPARED} if the tx is prepared </li> <li> - {@link Status#STATUS_COMMITTED} if the tx is committed</li> <li> - {@link Status#STATUS_ROLLEDBACK} if the tx is rollback</li> <li> - null otherwise</li> </ul> A transaction is in doubt if it is prepared and and it is orphan. A remote transaction is orphan if the node on which the transaction originated (ie the originator) is no longer part of the cluster. Called when after the 2nd phase of a 2PC is successful.

First moves the prepared transactions originated on the leavers into the recovery cache and then cleans up the transactions that are not yet prepared. Iterates over the remote transactions and returns the XID of the one that has an internal id equal with the supplied internal Id.  Marks the transaction as prepared. If at a further point the originator fails, the transaction is removed form the "normal" transactions collection and moved into the cache that holds in-doubt transactions. See {@link #cleanupLeaverTransactions(java.util.List)}

Determines if recovery is enabled for the cache. Sets the name of the cache where recovery related information is held. If not specified defaults to a cache named {@link RecoveryConfiguration#DEFAULT_RECOVERY_INFO_CACHE}
Disable recovery for this cache Enable recovery for this cache Enable recovery for this cache Sets the name of the cache where recovery related information is held. If not specified defaults to a cache named {@link RecoveryConfiguration#DEFAULT_RECOVERY_INFO_CACHE}


Replays the given transaction by re-running the prepare and commit. This call expects the transaction to exist on this node either as a local or remote transaction. This method invokes {@link #forceTransactionCompletion(javax.transaction.xa.Xid, boolean)} on the specified node. Same as {@link #getInDoubtTransactionInfoFromCluster()}, but only returns transactions from the local node. Returns a {@link Set} containing all the in-doubt transactions from the cluster, including the local node. This does not include transactions that are prepared successfully and for which the originator is still in the cluster. Local call that returns a list containing: <pre> - all the remote transactions prepared on this node for which the originator(i.e. the node where the tx stared) is no longer part of the cluster. AND - all the locally originated transactions which are prepared and for which the commit failed </pre> Local call returning the remote transaction identified by the supplied xid or null. Returns the list of transactions in prepared state from both local and remote cluster nodes. Implementation can take advantage of several optimisations: <ul> <li>in order to get all tx from the cluster a broadcast is performed. This can be performed only once (assuming the call is successful), the first time this method is called. After that a local, cached list of tx prepared on this node is returned.</li> <li>during the broadcast just return the list of prepared transactions that are not originated on other active nodes of the cluster.</li> </ul> Checks both internal state and transaction table's state for the given tx. If it finds it, returns true if tx is prepared. Same as {@link #removeRecoveryInformation(javax.transaction.xa.Xid)} but identifies the tx by its internal id. Removes from the specified nodes (or all nodes if the value of 'where' is null) the recovery information associated with these Xids. Remove recovery information stored on this node (doesn't involve rpc). Same as {@link #removeRecoveryInformation(java.util.Collection, javax.transaction.xa.Xid, boolean, org.infinispan.transaction.xa.GlobalTransaction, boolean)} but the transaction is identified by its internal id, and not by its xid.







Returns a set of Methods that contain the given method annotation.  This includes all public, protected, package and private methods, as well as those of superclasses.  Note that this does *not* include overridden methods. Returns a set of Methods that contain the given method annotation.  This includes all public, protected, package and private methods, but not those of superclasses and interfaces. Inspects the class passed in for the class level annotation specified.  If the annotation is not available, this method recursively inspects superclasses and interfaces until it finds the required annotation. <p/> Returns null if the annotation cannot be found. Retrieves the value of a field of an object instance via reflection Inspects a class and its superclasses (all the way to {@link Object} for method instances that contain a given annotation. This even identifies private, package and protected methods, not just public ones. Invokes a method using reflection, in an accessible manner (by using {@link Method#setAccessible(boolean)} Tests whether an annotation is present on a class.  The order tested is: <ul> <li>The class itself</li> <li>All implemented interfaces</li> <li>Any superclasses</li> </ul> Tests whether a method has already been found, i.e., overridden.
<p> Perform a runtime cast. Similar to {@link Class#cast(Object)}, but useful when you do not have a {@link Class} object for type you wish to cast to. </p> <p/> <p> {@link Class#cast(Object)} should be used if possible </p> Get all the declared fields on the class hierarchy. This <b>will</b> return overridden fields. Get all the declared methods on the class hierarchy. This <b>will</b> return overridden methods. <p> Get the value of the field, on the specified instance, casting the value of the field to the expected type. </p> <p/> <p> This method wraps {@link Field#get(Object)}, converting the checked exceptions that {@link Field#get(Object)} specifies to runtime exceptions. </p> Inspects an annotated element for the given meta annotation. This should only be used for user defined meta annotations, where the annotation must be physically present. Extract the qualifiers from a set of annotations. Extract the qualifiers from a set of annotations. Extract the raw type, given a type. <p> Invoke the method on the instance, with any arguments specified, casting the result of invoking the method to the expected return type. </p> <p/> <p> This method wraps {@link Method#invoke(Object, Object...)}, converting the checked exceptions that {@link Method#invoke(Object, Object...)} specifies to runtime exceptions. </p> <p/> <p> If instructed, this method attempts to set the accessible flag of the method in a {@link PrivilegedAction} before invoking the method. </p> <p> Invoke the specified method on the provided instance, passing any additional arguments included in this method as arguments to the specified method. </p> <p/> <p> This method attempts to set the accessible flag of the method in a {@link PrivilegedAction} before invoking the method if the first argument is true. </p> <p/> <p>This method provides the same functionality and throws the same exceptions as {@link Reflections#invokeMethod(boolean, Method, Class, Object, Object...)}, with the expected return type set to {@link Object}.</p> <p> Invoke the specified method on the provided instance, passing any additional arguments included in this method as arguments to the specified method. </p> <p/> <p>This method provides the same functionality and throws the same exceptions as {@link Reflections#invokeMethod(boolean, Method, Class, Object, Object...)}, with the expected return type set to {@link Object} and honoring the accessibility of the method.</p> Check the assignability of one type to another, taking into account the actual type arguements Check if a class is serializable. Check whether whether any of the types1 matches a type in types2 Set the accessibility flag on the {@link AccessibleObject} as described in {@link AccessibleObject#setAccessible(boolean)} within the context of a {@link PrivilegedAction}.


Registers this object with a resource.









The remote cache name. If no value is provided the default cache is assumed.

Add a client listener to receive events that happen in the remote cache. The listener object must be annotated with @{@link org.infinispan.client.hotrod.annotation.ClientListener} annotation. Add a client listener to receive events that happen in the remote cache. The listener object must be annotated with @ClientListener annotation.  Executes a remote script passing a set of named parameters Retrieves all of the entries for the provided keys.  A key will not be present in the resulting map if the entry was not found in the cache. Bulk get operations, returns all the entries within the remote cache. Same as {@link #getBulk()}, but limits the returned set of values to the specified size. No ordering is guaranteed, and there is no guarantee that "size" elements are returned( e.g. if the number of elements in the back-end server is smaller that "size") Returns {@link CacheTopologyInfo} for this cache. Returns a set with all the listeners registered by this client for the given cache. Returns the HotRod protocol version supported by this RemoteCache implementation Returns the {@link org.infinispan.client.hotrod.RemoteCacheManager} that created this cache. Returns the {@link VersionedValue} associated to the supplied key param, or null if it doesn't exist. Returns the {@link MetadataValue} associated to the supplied key param, or null if it doesn't exist.  Synthetic operation. Synthetic operation. The client iterates over the set of keys and calls put for each one of them. This results in operation not being atomic (if a failure happens after few puts it is not rolled back) and costly (for each key in the parameter map a remote call is performed). Synthetic operation. Synthetic operation. Synthetic operation. Synthetic operation. {@inheritDoc } <p> The returned value is only sent back if {@link Flag#FORCE_RETURN_VALUE} is enabled. {@inheritDoc } <p> This method requires 2 round trips to the server. The first to retrieve the value and version and a second to remove the key with the version if the value matches. If possible user should use {@link RemoteCache#getWithMetadata(Object)} and {@link RemoteCache#removeWithVersion(Object, long)}. Remove a previously added client listener. If the listener was not added before, this operation is a no-op. Removes the given entry only if its version matches the supplied version. A typical use case looks like this: <pre> VersionedEntry ve = remoteCache.getVersioned(key); //some processing remoteCache.removeWithVersion(key, ve.getVersion(); </pre> Lat call (removeWithVersion) will make sure that the entry will only be removed if it hasn't been changed in between.  {@inheritDoc } <p> This method requires 2 round trips to the server. The first to retrieve the value and version and a second to replace the key with the version if the value matches. If possible user should use {@link RemoteCache#getWithMetadata(Object)} and {@link RemoteCache#replaceWithVersion(Object, Object, long)}. {@inheritDoc } <p> This method requires 2 round trips to the server. The first to retrieve the value and version and a second to replace the key with the version if the value matches. If possible user should use {@link RemoteCache#getWithMetadata(Object)} and {@link RemoteCache#replaceWithVersion(Object, Object, long, long, TimeUnit, long, TimeUnit)}. {@inheritDoc } <p> This method requires 2 round trips to the server. The first to retrieve the value and version and a second to replace the key with the version if the value matches. If possible user should use {@link RemoteCache#getWithMetadata(Object)} and {@link RemoteCache#replaceWithVersion(Object, Object, long, long, TimeUnit, long, TimeUnit)} if possible. Replaces the given value only if its version matches the supplied version. See {@link #removeWithVersion(Object, long)} for a sample usage of the version-based methods. A overloaded form of {@link #replaceWithVersion(Object, Object, long)} which takes in lifespan parameters. A overloaded form of {@link #replaceWithVersion(Object, Object, long)} which takes in lifespan and maximum idle time parameters. A overloaded form of {@link #replaceWithVersion(Object, Object, long)} which takes in lifespan and maximum idle time parameters.     Retrieve entries from the server  Retrieve entries from the server matching a query. Retrieve entries with metadata information Returns a cache where values are manipulated using {@link java.io.InputStream} and {@link java.io.OutputStream}  Applies one or more {@link Flag}s to the scope of a single invocation.  See the {@link Flag} enumeration to for information on available flags. <p /> Sample usage: <pre> remoteCache.withFlags(Flag.FORCE_RETURN_VALUE).put("hello", "world"); </pre>
Retrieves the configuration currently in use. The configuration object is immutable. If you wish to change configuration, you should use the following pattern: <pre><code> ConfigurationBuilder builder = new ConfigurationBuilder(); builder.read(remoteCacheManager.getConfiguration()); // modify builder remoteCacheManager.stop(); remoteCacheManager = new RemoteCacheManager(builder.build()); </code></pre> Switch remote cache manager to a different cluster, previously declared via configuration. If the switch was completed successfully, this method returns {@code true}, otherwise it returns {@code false}. Switch remote cache manager to a the default cluster, previously declared via configuration. If the switch was completed successfully, this method returns {@code true}, otherwise it returns {@code false}.

Retrieves the default cache from the remote server. Retrieves a named cache from the remote server if the cache has been defined, otherwise if the cache name is undefined, it will return null.  Stop the remote cache manager, disconnecting all existing connections. As part of the disconnection, all registered client cache listeners will be removed since client no longer can receive callbacks.
Creates a cache on the remote server cluster using the specified template. Creates a cache on the remote server cluster using the specified template and flags. Performs a mass reindexing of the specified cache. The command will return immediately and the reindexing will be performed asynchronously Removes a cache from the remote server cluster.


Stop all managers created by this factory.


Retrieves the {@link Remote} annotation instance on the given annotated element. Produces the remote cache. Retrieves the {@link RemoteCacheManager} bean with the following qualifiers.
1. store 3 entries in the local cache 2. verify that there are only 2 in the local cache (third one evicted) 3. verify the evicted entry (and not anything else) is in the remote cache 4. retrieve the evicted entry from local cache (should call remote cache internally) 5. verify the evicted entry was removed from the remote cache Test for read-only attribute of store - if true, no entries will be written into store

This is intentionally a non-public method meant as an integration point for bytecode manipulation. Don't remove or alter the signature even if it might look like unreachable code. Implementors should perform a put operation but optimizing it as return values are not required.







Creates an un-initialized command.  Un-initialized in the sense that parameters will be set, but any components specific to the cache in question will not be set. <p/> You would typically set these parameters using {@link CommandsFactory#initializeReplicableCommand(ReplicableCommand,boolean)} <p/> Resolve an {@link CacheRpcCommand} from the stream.





Decides whether a command should be sent sync or async If some error happened, and a new IndexingBackend was provided, it is safe to assume the error relates with the fact the current backend is no longer valid. At this point we can still forward the work from the current stack to the next backend, creating a linked list of forwards to the right backend:


It returns the lock owner of the key. <p> Usually, in transaction caches it is the {@link org.infinispan.transaction.xa.GlobalTransaction} and in non-transactional caches the {@link org.infinispan.commands.CommandInvocationId}. It returns a {@link Collection} with the keys to be lock. <p> It may return an empty collection if no keys needs to be locked independently of the return value of {@link #hasSkipLocking()}. It may contains duplicated keys and {@code null} is not a valid return value. It checks if this command should acquire locks.




Get the protobuf SerializationContext or {@code null} if we are not using protobuf.







Sorting on a field that does not contain DocValues so Hibernate Search is forced to uninvert it.





TODO [anistor] these are only used for remote query with Lucene engine









Adds a new remote server Configuration for the executor service used for asynchronous work on the Transport, including asynchronous marshalling and Cache 'async operations' such as Cache.putAsync(). For replicated (vs distributed) Hot Rod server clusters, the client balances requests to the servers according to this strategy. Configures the connection pool This property defines the maximum socket connect timeout before giving up connecting to the server. Whether or not to implicitly FORCE_RETURN_VALUE for all calls. Configures this RemoteStore so that it enables all settings needed to create entries to be served by a HotRod endpoint, for example when performing rolling upgrades. The class name of the driver used for connecting to the database. Allows you to specify a custom {@link org.infinispan.commons.marshall.Marshaller} implementation to serialize and deserialize user objects. Allows you to specify a custom {@link org.infinispan.commons.marshall.Marshaller} implementation to serialize and deserialize user objects. This property defines the protocol version that this client should use. Defaults to {@link ProtocolVersion#DEFAULT_PROTOCOL_VERSION} This property defines the protocol version that this client should use. Defaults to {@link ProtocolVersion#DEFAULT_PROTOCOL_VERSION} Normally the {@link org.infinispan.persistence.remote.RemoteStore} stores values wrapped in {@link InternalCacheEntry}. Setting this property to true causes the raw values to be stored instead for interoperability with direct access by {@link RemoteCacheManager}s The name of the remote cache in the remote infinispan cluster, to which to connect to. If unspecified, the default cache will be used Configures connection security This property defines the maximum socket read timeout in milliseconds before giving up waiting for bytes from the server. Defaults to 60000 (1 minute) Affects TCP NODELAY on the TCP stack. Defaults to enabled Controls which transport to use. Currently only the TcpTransport is supported. Controls which transport to use. Currently only the TcpTransport is supported. This hint allows sizing of byte buffers when serializing and deserializing values, to minimize array resizing.







Invoked when a remote value is found from a remote source Invoked when a remote value is not found from the remote source for the given key





An attribute write handler which performs special processing for ALIAS attributes. Remove an alias from a LIST ModelNode of existing aliases. Gets whether a {@link org.jboss.as.controller.OperationContext.Stage#RUNTIME} handler should be added. This default implementation returns {@code true} if the {@link org.jboss.as.controller.OperationContext#getProcessType()} process type} is a server and {@link org.jboss.as.controller.OperationContext#isBooting() context.isBooting()} returns {@code false}.



Performs an expiration on a specified entry








The description resolver for the operation.




Expects a specific set of commands.  {@link #waitForRpc()} will block until all of these commands are detected. Expects any commands.  The moment a single command is detected, the {@link #waitForRpc()} command will be unblocked. Expects any commands, within transactional scope (i.e., as a payload to a PrepareCommand).  If the cache mode is synchronous, a CommitCommand is expected as well. Expects a specific set of commands, within transactional scope (i.e., as a payload to a PrepareCommand).  If the cache mode is synchronous, a CommitCommand is expected as well. Blocks for a predefined amount of time (120 Seconds) until commands defined in any of the expect*() methods have been detected.  If the commands have not been detected by this time, an exception is thrown. The same as {@link #waitForRpc()} except that you are allowed to specify the max wait time.






If true, the command is processed asynchronously in a thread provided by an Infinispan thread pool. Otherwise, the command is processed directly in the JGroups thread. <p/> This feature allows to avoid keep a JGroups thread busy that can originate discard of messages and retransmissions. So, the commands that can block (waiting for some state, acquiring locks, etc.) should return true. Used by marshallers to convert this command into an id for streaming. Invoke the command synchronously. <p> <p>This method is optional. Unless your command never blocks, please implement {@link #invokeAsync()} instead.</p> Invoke the command asynchronously. <p> <p>This method replaces {@link #perform(InvocationContext)} for remote execution. The default implementation and {@link #perform(InvocationContext)} will be removed in future versions. </p> If true, a return value will be provided when performed remotely.  Otherwise, a remote {@link org.infinispan.remoting.responses.ResponseGenerator} may choose to simply return null to save on marshalling costs. If true, a return value will be marshalled as a {@link org.infinispan.remoting.responses.SuccessfulResponse}, otherwise it will be marshalled as a {@link org.infinispan.remoting.responses.UnsuccessfulResponse}. Performs the primary function of the command.  Please see specific implementation classes for details on what is performed as well as return types. <b>Important</b>: this method will be invoked at the end of interceptors chain. It should never be called directly from a custom interceptor. Reads this instance from the stream written by {@link #writeTo(ObjectOutput)}. Sets the sender's {@link Address}. <p> By default, it doesn't set anything. Implement this method if the sender's {@link Address} is needed. Writes this instance to the {@link ObjectOutput}.



used to create subsystem description
used to create subsystem description





Sends back the return value to the sender.
Complete the request with an exception and release its resources.  Called when the node received a new cluster view. Called when a response is received for this response.








Configures this builder using the specified expression resolver and model.
Creates a builder for this resource's service.
Installs runtime services for a resource, configured from the specified model. Removes runtime services for a resource.



Called when a response is received, or when a target node becomes unavailable. <p>When a target node leaves the cluster, this method is called with a {@link org.infinispan.remoting.responses.CacheNotFoundResponse}.</p> <p>Should return a non-{@code null} result if the request should complete, or {@code null} if it should wait for more responses. If the method throws an exception, the request will be completed with that exception. If the last response is received and {@code addResponse()} still returns {@code null}, {@link #finish()} will also be called to obtain a result. <p>Thread safety: {@code addResponse()} will *not* be called concurrently from multiple threads, and the request will not be completed while {@code addResponse()} is running.</p> Called after {@link #addResponse(Address, Response)} returns {@code null} for the last response. <p>If {@code finish()} finishes normally, the request will complete with its return value (even if {@code null}). If {@code finish()} throws an exception, the request will complete exceptionally with that exception, wrapped in a {@link java.util.concurrent.CompletionException} (unless the exception is already a {@link java.util.concurrent.CompletionException}). </p>

Determines whether a response from a given sender should be added to the response list of the request Right after calling {@link #isAcceptable(Response, Address)}, this method is called to see whether we are done with the request and can unblock the caller



Writes the response to the channel









Creates Netty response based on error.




Builds {@link RestRouterConfiguration}.

Gets Authentication mechanism. Returns Netty Channel Initializer for REST. Sets Authentication mechanism.



{@inheritDoc } {@inheritDoc } {@inheritDoc }




Determines whether to append the cache name to the path URI. Defaults to false. Configures the connection pool The host to connect to The class of a {@link org.infinispan.persistence.keymappers.Key2StringMapper} to use for mapping keys to strings suitable for RESTful retrieval/storage. Defaults to {@link WrappedByteArrayOrPrimitiveMapper} The class name of a {@link org.infinispan.persistence.keymappers.Key2StringMapper} to use for mapping keys to strings suitable for RESTful retrieval/storage. Defaults to {@link WrappedByteArrayOrPrimitiveMapper} Sets the maximum content length. Defaults to 10M. The class of a {@link MetadataHelper} to use for managing appropriate metadata for the entries Defaults to {@link EmbeddedMetadataHelper} The class name of a {@link MetadataHelper} to use for managing appropriate metadata for the entries Defaults to {@link EmbeddedMetadataHelper} The path portion of the RESTful service. Defaults to / The port to connect to. Defaults to 80 Reads/writes "raw" values to the REST server instead of marshalling (used by the rolling upgrades feature)













This method must be called on your iterator once you have finished so that any local or remote resources can be freed up.



Invokes remotely the command using the {@code Transport} passed as parameter. It builds a new instance with the destination site, the command and the retry policy.
{@inheritDoc }








Creates database if it doesn't exist.





Returns a pre-computed access mask which contains the permissions specified by this role Returns the name of this role Returns the list of permissions associated with this role








Registers a migrator for a specific data format or endpoint. In the Infinispan ecosystem, we'd typically have one Migrator implementation for Hot Rod, one for memcached, one for REST and one for embedded/in-VM mode, and these would typically be added to the upgrade manager on first access via any of these protocols.



Returns same value as {@link FailoverRequestBalancingStrategy#nextServer(java.util.Set)} without modifying indexes/state.



Gets {@link Router} IP address. This may return {@link Optional#empty()} if the {@link Router} is stopped. Gets {@link Router} port. This may return {@link Optional#empty()} if the {@link Router} is stopped. Gets {@link Protocol} implemented by this {@link Router}. Starts the {@link Router}. Stops the {@link Router}.








Adds a {@link Route} to the {@link RoutingTable}.
Returns the number of {@link Route}s present in the routing table. Returns a stream of all {@link Route}s in the routing table. Returns a {@link Stream} of {@link Route}s matching the initial criteria


Apply data conversion. The input row can be modified in-place or a new one, of equal or different size, can be created.




Returns the address associated with this RpcManager or null if not part of the cluster. Creates a new {@link org.infinispan.remoting.rpc.RpcOptionsBuilder}. <p/> The {@link org.infinispan.remoting.rpc.RpcOptionsBuilder} is configured with {@link org.infinispan.remoting.inboundhandler.DeliverOrder#NONE} if the {@param sync} is {@code true} otherwise, with {@link org.infinispan.remoting.inboundhandler.DeliverOrder#PER_SENDER}. Creates a new {@link org.infinispan.remoting.rpc.RpcOptionsBuilder}. Returns members of a cluster scoped to the cache owning this RpcManager. Note that this List is always a subset of {@link Transport#getMembers()} Creates a new {@link org.infinispan.remoting.rpc.RpcOptionsBuilder}. <p/> The {@link org.infinispan.remoting.rpc.RpcOptionsBuilder} is configured with the {@link org.infinispan.remoting.rpc.ResponseMode} and with {@link org.infinispan.remoting.inboundhandler.DeliverOrder#NONE} if the {@link org.infinispan.remoting.rpc.ResponseMode} is synchronous otherwise, with {@link org.infinispan.remoting.inboundhandler.DeliverOrder#PER_SENDER} if asynchronous. Creates a new {@link org.infinispan.remoting.rpc.RpcOptionsBuilder}. Returns the current topology id. As opposed to the viewId which is updated whenever the cluster changes, the topologyId is updated when a new cache instance is started or removed - this doesn't necessarily coincide with a node being added/removed to the cluster.  Invokes an RPC call on other caches in the cluster. Invokes a command on remote nodes. Asynchronously sends the {@link ReplicableCommand} to the destination using the specified {@link DeliverOrder}. Asynchronously sends the {@link ReplicableCommand} to the set of destination using the specified {@link DeliverOrder}.

-------------------------------------------- JMX information -----------------------------------------------  mainly for unit testing

Sets the {@link ResponseFilter}. {@code null} by default, meaning it will wait for all or none response depending if the remote invocation is synchronous or asynchronous respectively. Sets the {@link ResponseMode} for the remote invocation. See {@link ResponseMode} documentation to see the available values.  See {@link #timeout(long, java.util.concurrent.TimeUnit)} Sets the timeout value and its {@link TimeUnit}.














Closes this output stream and releases any system resources associated with this stream. Flushes this output stream












Returns an iterator of all of the registered {@code SaslClientFactory}s where the order is based on the order of the Provider registration and/or class path order. Returns an iterator of all of the registered {@code SaslClientFactory}s where the order is based on the order of the Provider registration and/or class path order.  Class path providers are listed before global providers; in the event of a name conflict, the class path provider is preferred. Returns an iterator of all of the registered {@code SaslServerFactory}s where the order is based on the order of the Provider registration and/or class path order. Returns an iterator of all of the registered {@code SaslServerFactory}s where the order is based on the order of the Provider registration and/or class path order.  Class path providers are listed before global providers; in the event of a name conflict, the class path provider is preferred.

Prefers owners from the second hash -> effectively this will make pendingCH == unionCH (I think)
Merges two consistent hash objects that have the same number of segments, numOwners and hash function. For each segment, the primary owner of the first CH has priority, the other primary owners become backups. Leavers are removed and segments without owners are assigned new owners. Joiners might get some of the un-owned segments but otherwise they are not taken into account (that should happen during a rebalance).



Confirm that this node has received cache topology with given topologyId and that it has moved all the segments it does not own according to consistent hash to the {@link ScatteredVersionManager.SegmentState#NOT_OWNED} state.
This method handles creating the backup copy and invalidation on other nodes for segments that this node keeps from previous topology.
Forget all non-processed invalidations scheduled through {@link #scheduleKeyInvalidation(Object, EntryVersion, boolean)}   Generates a new version for an entry in given segment.  All key + version data from given segment have been received, or the key transfer failed. All entries have been received and we can put segments owned according to consistent hash to {@link SegmentState#OWNED} state. Move the segment to {@link SegmentState#BLOCKED} state. Notifies the manager that an operation on given key with version previously retrieved from {@link #incrementVersion(int)} has finished. This operation has to be executed on originator of the operation once the entry was stored on both nodes. Eventually order versions of entries will be removed on other nodes. When the entry was completely removed by the operation, the nodes have stored a tombstone of that entry. The older versions will be dropped regularly and after this is confirmed the tombstones will be invalidated, too. Move the segment from {@link SegmentState#NOT_OWNED} to {@link SegmentState#OWNED} without transferring data. Set current topology id. Move the segments from {@link SegmentState#BLOCKED} to {@link SegmentState#KEY_TRANSFER} state. Move the segment to {@link SegmentState#NOT_OWNED} state. This is called only during preload. Makes sure that the cache will start with topology higher than the one stored in a cache store.
just after preload before StateConsumerImpl and StateTransferManagerImpl


Add key/value property pair to this executor factory configuration Specify factory class for executor NOTE: Currently Infinispan will not use the object instance, but instead instantiate a new instance of the class. Therefore, do not expect any state to survive, and provide a no-args constructor to any instance. This will be resolved in Infinispan 5.2.0 Set key/value properties to this executor factory configuration







This method should be where all Custom schemas are registered.


Performs the specified action on every entry of the state Returns the checksum of the properties excluding those prefixed with @ Retrieves a float state property Retrieves an integer state property Retrieves a state property Returns the name of this persistent state's scope Sets a float state property. Sets an integer state property. Sets a state property. Values will be unicode-escaped when written









Adds a new named script. Retrieves the source code of an existing script. Retrieves names of all available scripts. Removes a script. Runs a named script Runs a named script using the specified {@link TaskContext}





Checks if an index exists for the given class. This is not intended to test whether the entity class is indexable (via annotations or programmatically).
Experimental. Provides Hibernate Search DSL to build full text queries Retrieves the scoped analyzer for a given class type. Retrieve an analyzer instance by its definition name Experimental! Use it to try out the newly introduced distributed queries. The MassIndexer can be used to rebuild the Lucene indexes from the entries stored in Infinispan. This is a simple method that will just return a {@link CacheQuery}, filtered according to a set of classes passed in.  If no classes are passed in, it is assumed that no type filtering is performed and so all known types will be searched. Get access to the Query specific statistics for this SearchManager instance Remove all entities of particular class from the index. This method gives access to internal Infinispan types, and should not be normally needed. The API of the internal types can (and probably will) change without notice.
(non-Javadoc) @see org.infinispan.query.SearchManager#buildQueryBuilderForClass(java.lang.Class) This probably should be hided in the getQuery method. (non-Javadoc) @see org.infinispan.query.SearchManager#getQuery(org.apache.lucene.search.Query, java.lang.Class) Internal and experimental! Creates a {@link CacheQuery}, filtered according to the given {@link HSQuery}.
Registers a {@link org.infinispan.query.Transformer} for the supplied key class. When storing keys in cache that are neither simple (String, int, ...) nor annotated with @Transformable, Infinispan-Query will need to know what Transformer to use when transforming the keys to Strings. Clients must specify what Transformer to use for a particular key class by registering it through this method. Define the timeout exception factory to customize the exception thrown when the query timeout is exceeded.




Creates a Work instance for a given entity. Creates a collection of Work instances that Hibernate-Search should perform for all the entities of the given entity type. Creates a collection of Work instances that Hibernate-Search should perform for the given entity



Creates a forward commit or rollback commands to send to the member who executed the transaction. Commits or Rollbacks the transaction. Commits or rollbacks a local transaction. Commits or rollbacks the transaction as a remote transaction since the member who executed the transaction left the cluster












Returns {@link Principal} based on user/password combination.
This method will be invoked when the operation is known to be performing on a given set of segments and this node no longer owns 1 or many of them.  Returns whether the lost segment affected the results or not.  If stopIfLost is true then doneWithOperation will not be invoked as it would normally.


Acquires a readlock, in order to prevent other invocations to {@link #deleteOrReleaseReadLock(String)} from deleting the file. It will release a previously acquired readLock, or if no readLock was acquired it will mark the file to be deleted as soon as all pending locks are releases. If it's invoked on a file without pending locks the file is deleted.

Convert a 1.4 segments value to a 1.3 virtual nodes value Convert a 1.3 virtual nodes value to a 1.4 segments value


Signal that a task that called {@link #continueTaskInBackground()} has finished and optionally execute another task on the just-freed thread. When stopping, cancel any queued tasks. Called from a task to remove the permit that would otherwise be freed when the task finishes running When the asynchronous part of the task finishes, it must call {@link #backgroundTaskFinished(Callable)} to make the permit available again.








































Helper method that allows for quick registration of an {@link AdvancedExternalizer} implementation alongside its corresponding identifier. Remember that the identifier needs to a be positive number, including 0, and cannot clash with other identifiers in the system. Helper method that allows for quick registration of an {@link AdvancedExternalizer} implementation alongside its corresponding identifier. Remember that the identifier needs to a be positive number, including 0, and cannot clash with other identifiers in the system. Helper method that allows for quick registration of {@link AdvancedExternalizer} implementations. Class resolver to use when unmarshalling objects. Set the marshaller instance that will marshall and unmarshall cache entries. Largest allowable version to use when marshalling internal state. Set this to the lowest version cache instance in your cluster to ensure compatibility of communications. However, setting this too low will mean you lose out on the benefit of improvements in newer versions of the marshaller. Largest allowable version to use when marshalling internal state. Set this to the lowest version cache instance in your cluster to ensure compatibility of communications. However, setting this too low will mean you lose out on the benefit of improvements in newer versions of the marshaller.

Specify the externalizer class to be used by the annotated class. Specify the value matching capabilities of this function.

Specify the externalizer class to be used by the annotated class.




This method should be where all Custom serializers are registered to the Kryo parameter.
// IMPORTANT NOTE: Hot Rod protocol agrees to this calculation for a node // address hash code calculation, so any changes to the implementation // require modification of the protocol. override def hashCode() = Arrays.hashCode( "%s:%d".format(host, port).getBytes(UTF8))

Get a callback handler for the given mechanism name. This method is called each time a mechanism is selected for the connection and the resulting AuthorizingCallbackHandler will be cached and used multiple times for this connection, AuthorizingCallbackHandler should either be thread safe or the ServerAuthenticationProvider should provide a new instance each time called.














Sets the task context Store the value in your task implementation to be able to access caches and other resources in the task


Register a ServerTask in the registry Returns a {@link ServerTaskWrapper} for a task with given name. ServerTaskWrapper wraps {@link ServerTask} to make it compatible with {@link Task} Lists the registered server tasks. Checks if task with given name is registered in this registry. Unregister server task with given name


Trigger execution of a ServerTask with given name. Returns a CompletableFuture, from which the result of execution can be obtained.



Adds the {@link TxState} to the global transaction table if it does not exist already. Adds the {@link EmbeddedTransaction} in the local transaction table.   testing only Removes the {@link TxState} from the global transaction table. Removes the {@code xid} from the global and local transaction table. Removes the local {@link EmbeddedTransaction} associated to {@code xid}. Updates the state in the global transaction table.


Generics friendly version of {@link ServiceRegistry#getService(ServiceName)} Returns the value of the specified service, if the service exists and is started. Generics friendly version of {@link ServiceRegistry#getRequiredService(ServiceName)} Returns the service value of the specified service, starting it if necessary. Ensures the specified service is removed. Ensures the specified service is started. Ensures the specified service is stopped.


Provides an iterable collection of references, even if the original array is null Explode the dictionary into a ,-delimited list of key=value pairs Returns the bundle context.
Returns the associated service name

Creates a new cache Returns a named cache. If the cacheName parameter is null, the current cache is returned Obtains the CacheManager to which this session is attached Returns the currently active codec used to encode/decode keys/values Returns a specific codec Returns the list of available key/value codecs Obtains the currently selected cache. If none has been selected, the default cache is returned Returns the name of the currently selected cache. If none has been selected, the default cache is returned Returns the unique id of this session Returns the time the session was last accessed Resets the session, by aborting any dangling batches and transactions and updating the timestamp Sets the codec to use for encoding/decoding keys/values Sets the current cache.








@return ShardId where a certain key belongs to    Initializes the {@link ShardAllocatorManager} with the configured number of segments and shards.


HELPERS   NOT YET IMPLEMENTED   MARSHALLING














This is a hack to allow the cast to work.  Java doesn't like subtypes in generics This method can be called only from dataContainer.compute()'s action! This method can be called only from dataContainer.compute()'s action; as we'll replace the old value when it's expired
















Add a user to the authentication table. {@inheritDoc }






Writes a new free entry to the file and also adds it to the free list Allocates the requested space in the file. The base class implementation calls {@link #load(Object)} for this, we can do better because we keep all keys in memory. Try to evict an entry if the capacity of the cache store is reached. Frees the space of the specified file entry (for reuse by allocate). <p/> Note: Caller must hold the {@code resizeLock} in shared mode. Coalesces adjacent free entries to create larger free entries (so that the probability of finding a free entry during allocation increases) Manipulates the free entries for optimizing disk space. Rebuilds the in-memory index from file. Removes free entries towards the end of the file and truncates the file.

The store tries to fit in a new entry into an existing entry from a free entry pool (if one is available) However, this existing free entry may be quite bigger than what is required to contain the new entry It may then make sense to split the free entry into two parts: 1. That is required to contain the new entry requested 2. the remaining part to be returned to the pool of free entries. The fragmentationFactor decides when to split the free entry. So, if this value is set as 0.75, then the free entry will be split if the new entry is equal to or less than 0.75 times the size of free entry Sets a location on disk where the store can write. In order to speed up lookups, the single file cache store keeps an index of keys and their corresponding position in the file. To avoid this index resulting in memory consumption problems, this cache store can bounded by a maximum number of entries that it stores. If this limit is exceeded, entries are removed permanently using the LRU algorithm both from the in-memory index and the underlying file based cache store. So, setting a maximum limit only makes sense when Infinispan is used as a cache, whose contents can be recomputed or they can be retrieved from the authoritative data store. If this maximum limit is set when the Infinispan is used as an authoritative data store, it could lead to data loss, and hence it's not recommended for this use case.

gets the database representation of the String key stored with hotrod client (when using string store) simple test to see that write-behind store works







Method called when the cache either becomes the coordinator or stops being the coordinator. If it becomes the coordinator, it can optionally start the in-memory state transfer to the underlying cache store. Method that waits for the in-memory to cache loader state to finish. This method's called in case a push state is already in progress and we need to wait for it to finish. Called when the SingletonStore discovers that the cache has become the coordinator and push in memory state has been enabled. It might not actually push the state if there's an ongoing push task running, in which case will wait for the push task to finish. Pushes the state of a specific cache by reading the cache's data and putting in the cache store. Waits, within a time constraint, for a task to finish.


If true, the singleton store cache store is enabled. If pushStateWhenCoordinator is true, this property sets the maximum number of milliseconds that the process of pushing the in-memory state to the underlying cache loader should take. If true, when a node becomes the coordinator, it will transfer in-memory state to the underlying cache store. This can be very useful in situations where the coordinator crashes and there's a gap in time until the new coordinator is elected.
Enable the singleton store cache store Enable the singleton store cache store If true, the singleton store cache store is enabled. If pushStateWhenCoordinator is true, this property sets the maximum number of milliseconds that the process of pushing the in-memory state to the underlying cache loader should take. If pushStateWhenCoordinator is true, this property sets the maximum number of milliseconds that the process of pushing the in-memory state to the underlying cache loader should take. If true, when a node becomes the coordinator, it will transfer in-memory state to the underlying cache store. This can be very useful in situations where the coordinator crashes and there's a gap in time until the new coordinator is elected.


Returns the name of the local site. Must be a valid name defined in {@link #siteConfigurations()}
Sets the name of the local site. Must be a valid name from the list of sites defined.





Returns the list of all sites where this cache might back up its data. The list of actual sites is defined by {@link #inUseBackupSites}.  Returns true if this cache won't backup its data remotely. It would still accept other sites backing up data on this site. Returns the list of {@link BackupConfiguration} that have {@link org.infinispan.configuration.cache.BackupConfiguration#enabled()} == true.
Defines the site names, from the list of sites names defined within 'backups' element, to which this cache backups its data. Returns true if this cache won't backup its data remotely. It would still accept other sites backing up data on this site.















Observe the cache started event for the cache associated with @Cache1
Add an integer to the set without boxing the parameter. Check if the set contains an integer without boxing the parameter. Remove an integer from the set without boxing. Add an integer to the set without boxing the parameter or checking if the integer was already present in the set. If {@code value} is {@code true}, add the integer to the set, otherwise remove the integer from the set.





Return <code>true</code> if handshake was successful.

This method should be called by reflection to get more info about the missing/invalid key (from test tools)










The field path. Indicates if sorting is ascending or descending.









Return the {@link org.infinispan.manager.EmbeddedCacheManager <code>org.infinispan.manager.EmbeddedCacheManager</code>} that backs this <code>CacheManager</code>. Stop the {@link EmbeddedCacheManager <code>EmbeddedCacheManager</code>} this <code>CacheManager</code> delegates to.
------------------------------------------------------------------------ org.springframework.beans.factory.InitializingBean ------------------------------------------------------------------------  ------------------------------------------------------------------------ org.springframework.beans.factory.DisposableBean ------------------------------------------------------------------------ Shuts down the <code>SpringEmbeddedCacheManager</code> instance created by this <code>FactoryBean</code>. ------------------------------------------------------------------------ org.springframework.beans.factory.FactoryBean ------------------------------------------------------------------------   Always returns <code>true</code>.

<p> As of Infinispan 4.2.0.FINAL <code>org.infinispan.client.hotrod.RemoteCache</code> does <strong>not</strong> support retrieving the set of all cache names from the hotrod server. This restriction may be lifted in the future. Currently, this operation will always throw an <code>UnsupportedOperationException</code>. </p> Return the {@link org.infinispan.client.hotrod.RemoteCacheManager <code>org.infinispan.client.hotrod.RemoteCacheManager</code>} that backs this <code>SpringRemoteCacheManager</code>. Start the {@link org.infinispan.client.hotrod.RemoteCacheManager <code>org.infinispan.client.hotrod.RemoteCacheManager</code>} that backs this <code>SpringRemoteCacheManager</code>. Stop the {@link org.infinispan.client.hotrod.RemoteCacheManager <code>org.infinispan.client.hotrod.RemoteCacheManager</code>} that backs this <code>SpringRemoteCacheManager</code>.
------------------------------------------------------------------------ org.springframework.beans.factory.InitializingBean ------------------------------------------------------------------------  ------------------------------------------------------------------------ org.springframework.beans.factory.DisposableBean ------------------------------------------------------------------------ {@link org.infinispan.client.hotrod.RemoteCacheManager#stop() <code>stop</code>} the <code>RemoteCacheManager</code> created by this factory. ------------------------------------------------------------------------ org.springframework.beans.factory.FactoryBean ------------------------------------------------------------------------   Always return <code>true</code>.


Disables the SSL support Enables the SSL support Enables or disables the SSL support Specifies the password needed to access private key associated with certificate stored in specified {@link #keyStoreFileName(String)}. If password is not specified, password provided in {@link #keyStorePassword(char[])} will be used. Specifies the filename of a keystore to use to create the {@link SSLContext} You also need to specify a {@link #keyStorePassword(char[])}. Alternatively specify an initialized {@link #sslContext(SSLContext)} Specifies the password needed to open the keystore You also need to specify a {@link #keyStoreFileName(String)}. Alternatively specify an initialized {@link #sslContext(SSLContext)} Specifies the type of the keystore, such as JKS or JCEKS. Defaults to JKS Configures the secure socket protocol. Specifies the TLS SNI hostname for the connection Specifies the filename of a truststore to use to create the {@link SSLContext} You also need to specify a {@link #trustStorePassword(char[])}. Alternatively specify an initialized {@link #sslContext(SSLContext)} Specifies the password needed to open the truststore You also need to specify a {@link #trustStoreFileName(String)}. Alternatively specify an initialized {@link #sslContext(SSLContext)} Specifies the type of the truststore, such as JKS or JCEKS. Defaults to JKS



Selects a specific key to choose from the keystore Specifies the password needed to access private key associated with certificate stored in specified {@link #keyStoreFileName(String)}. If password is not specified, the password provided in {@link #keyStorePassword(char[])} will be used. Specifies the filename of a keystore to use to create the {@link SSLContext} You also need to specify a {@link #keyStorePassword(char[])}. Alternatively specify an initialized {@link #sslContext(SSLContext)}. Specifies the password needed to open the keystore You also need to specify a {@link #keyStoreFileName(String)}. Alternatively specify an initialized {@link #sslContext(SSLContext)}. Specifies the type of the keystore, such as JKS or JCEKS. Defaults to JKS Configures the secure socket protocol. Sets the {@link SSLContext} to use for setting up SSL connections. Specifies the filename of a truststore to use to create the {@link SSLContext} You also need to specify a {@link #trustStorePassword(char[])}. Alternatively specify an initialized {@link #sslContext(SSLContext)}. Specifies the password needed to open the truststore You also need to specify a {@link #trustStoreFileName(String)}. Alternatively specify an initialized {@link #sslContext(SSLContext)}. Specifies the type of the truststore, such as JKS or JCEKS. Defaults to JKS
Creates Netty's {@link SslContext} based on optional standard JDK's {@link SSLContext}. If {@link Optional#empty()} is passed as an argument, this method will return the default {@link SslContext}.













Receive notification of topology changes. StateRequestCommands are issued for segments that are new to this member and the segments that are no longer owned are discarded.  Cancels all incoming state transfers. The already received data is not discarded. This is executed when the cache is shutting down. Stops applying incoming state. Also stops tracking updated keys. Should be called at the end of state transfer or when a ClearCommand is committed during state transfer.
not used in scattered cache not used in scattered cache Cancel transfers for segments we no longer own. not used in scattered cache Check if any of the existing transfers should be restarted from a different source because the initial source is no longer a member. Must run after the PersistenceManager Stops applying incoming state. Also stops tracking updated keys. Should be called at the end of state transfer or when a ClearCommand is committed during state transfer.

Cancel sending of cache entries that belong to the given set of segments. This is invoked in response to a StateRequestCommand of type StateRequestCommand.Type.CANCEL_STATE_TRANSFER. Gets the list of transactions that affect keys from the given segments. This is invoked in response to a StateRequestCommand of type StateRequestCommand.Type.GET_TRANSACTIONS. Receive notification of topology changes. Cancels all outbound transfers to destinations that are no longer members. The other outbound transfers remain unaffected. Start to send cache entries that belong to the given set of segments. This is invoked in response to a StateRequestCommand of type StateRequestCommand.Type.START_STATE_TRANSFER. If the applyState field is set to false, then upon delivery at the destination the cache entries are processed by a {@link StateReceiver} and are not applied to the local cache. Cancels all outbound state transfers. This is executed when the cache is shutting down.

Return all replicas of a cache entry for a given segment. We require the ConsitentHash to be passed here, as it is necessary for the hash of the last stable topology to be utilised during an automatic merge, before a new merged topology is installed. Cancels all ongoing replica requests. This is executed when the cache is shutting down.



Define an action for a state. <p/> States that depend on another state with an associated action can only be entered after the action has finished. Equivalent to {@code enter(state); exit(state);}. Equivalent to {@code enter(state, timeout, unit); exit(state);}. Enter a state and block until all its dependencies have been exited, using the default timeout. Enter a state and block until all its dependencies have been exited. Exit a state and signal the waiters on its dependent states. Define a logical thread. <p/> States in a logical thread are implicitly ordered - they must be entered in the order in which they were defined. Define a partial order between states in different logical threads. Stop doing anything on {@code enter()} or {@code exit()}. Existing threads waiting in {@code enter()} will be waken up.
Advance to the every state in the {@code states} list, in the given order, but only if {@code condition} is true. <p/> Does nothing if {@code states} is {@code null} or empty. Start decorating the component {@code componentClass} on {@code cache} to interact with a {@code StateSequencer} when a method is called. Start decorating the component {@code componentClass} on {@code cacheManager} to interact with a {@code StateSequencer} when a method is called. Start decorating the {@code InboundInvocationHandler} on {@code cacheManager} to interact with a {@code StateSequencer} when a {@code CacheRpcCommand} is received. Start decorating interceptor {@code interceptorClass} on {@code cache} to interact with a {@code StateSequencer}. Start decorating the {@code RpcManager} on {@code cacheManager} to interact with a {@code StateSequencer} when a command is sent. Start building a {@link CommandMatcher}. Start building a {@link InvocationMatcher}.

If {@code true}, this will cause the first call to method {@code CacheManager.getCache()} on the joiner node to block and wait until the joining is complete and the cache has finished receiving state from neighboring caches (if fetchInMemoryState is enabled). This option applies to distributed and replicated caches only and is enabled by default. Please note that setting this to {@code false} will make the cache object available immediately but any access to keys that should be available locally but are not yet transferred will actually cause a (transparent) remote access. While this will not have any impact on the logic of your application it might impact performance. The state will be transferred in batches of {@code chunkSize} cache entries. If chunkSize is equal to Integer.MAX_VALUE, the state will be transferred in all at once. Not recommended. If {@code true}, the cache will fetch data from the neighboring caches when it starts up, so the cache starts 'warm', although it will impact startup time. <p/> In distributed mode, state is transferred between running caches as well, as the ownership of keys changes (e.g. because a cache left the cluster). Disabling this setting means a key will sometimes have less than {@code numOwner} owners. We want to remember if the user didn't configure awaitInitialTransfer for the default cache. This is the maximum amount of time - in milliseconds - to wait for state from neighboring caches, before throwing an exception and aborting startup. This is the maximum amount of time - in milliseconds - to wait for state from neighboring caches, before throwing an exception and aborting startup.
If {@code true}, this will cause the first call to method {@code CacheManager.getCache()} on the joiner node to block and wait until the joining is complete and the cache has finished receiving state from neighboring caches (if fetchInMemoryState is enabled). This option applies to distributed and replicated caches only and is enabled by default. Please note that setting this to {@code false} will make the cache object available immediately but any access to keys that should be available locally but are not yet transferred will actually cause a (transparent) remote access. While this will not have any impact on the logic of your application it might impact performance. The state will be transferred in batches of {@code chunkSize} cache entries. If chunkSize is equal to Integer.MAX_VALUE, the state will be transferred in all at once. Not recommended. If {@code true}, the cache will fetch data from the neighboring caches when it starts up, so the cache starts 'warm', although it will impact startup time. <p/> In distributed mode, state is transferred between running caches as well, as the ownership of keys changes (e.g. because a cache left the cluster). Disabling this setting means a key will sometimes have less than {@code numOwner} owners. This is the maximum amount of time - in milliseconds - to wait for state from neighboring caches, before throwing an exception and aborting startup. This is the maximum amount of time - in milliseconds - to wait for state from neighboring caches, before throwing an exception and aborting startup.

For non-tx write commands, we retry the command locally if the topology changed. But we only retry on the originator, and only if the command doesn't have the {@code CACHE_MODE_LOCAL} flag. Special processing required for transaction commands.
topology change lock topology installation latch TODO move this to Cluster/LocalTopologyManagerImpl and don't start requesting state until every node has the jgroups view with the local node transaction data latch

If there is an state transfer happening at the moment, this method forwards the supplied command to the nodes that are new owners of the data, in order to assure consistency.  todo [anistor] this is inaccurate. this node does not hold state yet in current implementation Checks if an inbound state transfer is in progress. Checks if an inbound state transfer is in progress for a given key.
Decorates the given cache topology to add a key partitioner. The key partitioner may include support for grouping as well. TODO Investigate merging ownsData() and getFirstTopologyAsMember(), as they serve a similar purpose If no ConsistentHashFactory was explicitly configured we choose a suitable one based on cache mode. needs to be AFTER the DistributionManager and *after* the cache loader manager (if any) inits and preloads

















Optional parameter which defines the order in which this method will be called when the ComponentRegistry moves to the STOPPING state.  Defaults to 10.




Whether the store can be shared amongst nodes in a distributed/replicated cache
Enables defensive copies. Enables storing both keys and values as binary. Enables storing keys as binary. Enables storing values as binary.
When defensive copying is disabled, Infinispan keeps object references around and marshalls keys lazily. So clients can modify entries via original object references, and marshalling only happens when entries are to be replicated/distributed, or stored in a cache store. Since client references are valid, clients can make changes to entries in the cache using those references, but these modifications are only local and you still need to call one of the cache's put/replace... methods in order for changes to replicate. When defensive copies are enabled, Infinispan marshalls objects the moment they're stored, hence changes made to object references are not stored in the cache, not even for local caches. Disables storing both keys and values as binary. Enables storing both keys and values as binary. Sets whether this feature is enabled or disabled. Specify whether keys are stored as binary or not. Specify whether values are stored as binary or not.
Configuration for the async cache loader. If enabled, this provides you with asynchronous writes to the cache store, giving you 'write-behind' caching. If true, fetch persistent state when joining a cluster. If multiple cache stores are chained, only one of them can have this property enabled. Persistent state transfer with a shared cache store does not make sense, as the same persistent store that provides the data will just end up receiving it. Therefore, if a shared cache store is used, the cache will not allow a persistent state transfer even if a cache store has this property set to true. Finally, setting it to true only makes sense if in a clustered environment, and only 'replication' and 'invalidation' cluster modes are supported. If true, any operation that modifies the cache (put, remove, clear, store...etc) won't be applied to the cache store. This means that the cache store could become out of sync with the cache. If true, purges this cache store when it starts up. SingletonStore is a delegating cache store used for situations when only one instance in a cluster should interact with the underlying store. The coordinator of the cluster will be responsible for the underlying CacheStore. SingletonStore is a simply facade to a real CacheStore implementation. It always delegates reads to the real CacheStore.

<p> Defines a single property. Can be used multiple times to define all needed properties, but the full set is overridden by {@link #withProperties(java.util.Properties)}. </p> <p> These properties are passed directly to the cache store. </p> Configuration for the async cache store. If enabled, this provides you with asynchronous writes to the cache store, giving you 'write-behind' caching. If true, fetch persistent state when joining a cluster. If multiple cache stores are chained, only one of them can have this property enabled. Persistent state transfer with a shared cache store does not make sense, as the same persistent store that provides the data will just end up receiving it. Therefore, if a shared cache store is used, the cache will not allow a persistent state transfer even if a cache store has this property set to true. Finally, setting it to true only makes sense if in a clustered environment, and only 'replication' and 'invalidation' cluster modes are supported. If true, any operation that modifies the cache (put, remove, clear, store...etc) won't be applied to the cache store. This means that the cache store could become out of sync with the cache. The maximum size of a batch to be inserted/deleted from the store. If the value is less than one, then no upper limit is placed on the number of operations in a batch. If true, when the cache starts, data stored in the cache store will be pre-loaded into memory. This is particularly useful when data in the cache store will be needed immediately after startup and you want to avoid cache operations being delayed as a result of loading this data lazily. Can be used to provide a 'warm-cache' on startup, however there is a performance penalty as startup time is affected by this process. If true, purges this cache store when it starts up. This setting should be set to true when multiple cache instances share the same cache store (e.g., multiple nodes in a cluster using a JDBC-based CacheStore pointing to the same, shared database.) Setting this to true avoids multiple cache instances writing the same modification multiple times. If enabled, only the node where the modification originated will write to the cache store. <p/> If disabled, each individual cache reacts to a potential remote update by storing the data to the cache store. Note that this could be useful if each individual node has its own cache store - perhaps local on-disk. SingletonStore is a delegating cache store used for situations when only one instance in a cluster should interact with the underlying store. The coordinator of the cluster will be responsible for the underlying CacheStore. SingletonStore is a simply facade to a real CacheStore implementation. It always delegates reads to the real CacheStore. This setting should be set to true when the underlying cache store supports transactions and it is desirable for the underlying store and the cache to remain synchronized. With this enabled any Exceptions thrown whilst writing to the underlying store will result in both the store's and the cache's transaction rollingback. <p/> If enabled and this store is shared, then writes to this store will be performed at prepare time of the Infinispan Tx. If an exception is encountered by the store during prepare time, then this will result in the global Tx being rolledback along with this stores writes, otherwise writes to this store will be committed during the commit phase of 2PC. If this is not enabled, then writes to the cache store are performed during the commit phase of a Tx. <p/> Note that this requires {@link #shared(boolean)} to be set to true. Properties passed to the cache store or loader








Predicate taht always returns true irrespective of the value provided Provides a function that returns the key of the entry when invoked. Provides a function that returns the value of the entry when invoked. Provides a predicate that returns true when the object is equal. Provides a function that given a key will return the {@link CacheEntry} that maps to this key. This function only works when used with a {@link org.infinispan.CacheStream} returned from the desired {@link Cache}. The entry will be read from the <b>Cache</b> of which the <b>CacheStream</b> was created from. Predicate that returns true if the object passed to it is not null.



Adds the key to the read top-key. Adds the lock information about the key, namely if the key suffer some contention and if the keys was locked or not. Adds the key to the put top-key. Adds the key to the write skew failed top-key. See {@link #getTopKFrom(StreamSummaryContainer.Stat, int)}.  Same as {@link #getTopKFrom(org.infinispan.stats.topK.StreamSummaryContainer.Stat)} but the keys are returned in their String format. Same as {@link #getTopKFrom(org.infinispan.stats.topK.StreamSummaryContainer.Stat, int)} but the keys are returned in their String format.  Resets all the top-key collected so far. Sets the capacity of the top-key. The capacity defines the maximum number of keys that are tracked. Remember that top-key is a probabilistic counter so the higher the number of keys, the more precise will be the counters Enables or disables the top-key collection Tries to flush all the enqueue offers to be visible globally.
Finish using the given ObjectInput. After opening a ObjectInput and calling objectFromObjectStream() multiple times, use this method to flush the data and close if necessary Finish using the given ObjectOutput. After opening a ObjectOutput and calling objectToObjectStream() multiple times, use this method to flush the data and close if necessary Unmarshall an object from an {@link InputStream} Unmarshalls an object from an {@link java.io.ObjectInput} Marshalls an object to a given {@link java.io.ObjectOutput} <p>Create and open a new ObjectInput for the given input stream. This method should be used for opening data inputs when multiple objectFromObjectStream() calls will be made before the stream is closed.</p> <p>This method also takes a boolean that represents whether this particular call to startObjectInput() is reentrant or not. A call to startObjectInput() should be marked reentrant whenever a 2nd or more calls to this method are made without having called finishObjectInput() first.</p> <p>To potentially speed up calling startObjectInput multiple times in a non-reentrant way, i.e. startObjectInput/finishObjectInput...startObjectInput/finishObjectInput...etc, which is is the most common case, the StreamingMarshaller implementation could potentially use some mechanisms to speed up this startObjectInput call.</p> <p>Create and open an ObjectOutput instance for the given output stream. This method should be used for opening data outputs when multiple objectToObjectStream() calls will be made before the stream is closed by calling finishObjectOutput().</p> <p>This method also takes a boolean that represents whether this particular call to startObjectOutput() is reentrant or not. A call to startObjectOutput() should be marked reentrant whenever a 2nd or more calls to this method are made without having called finishObjectOutput() first. <p>To potentially speed up calling startObjectOutput multiple times in a non-reentrant way, i.e. startObjectOutput/finishObjectOutput...startObjectOutput/finishObjectOutput...etc, which is is the most common case, the StreamingMarshaller implementation could potentially use some mechanisms to speed up this startObjectOutput call. <p>On the other hand, when a call is reentrant, i.e. startObjectOutput/startObjectOutput(reentrant)...finishObjectOutput/finishObjectOutput, the StreamingMarshaller implementation might treat it differently. An example of reentrancy would be marshalling of {@link MarshalledValue}. When sending or storing a MarshalledValue, a call to startObjectOutput() would occur so that the stream is open and following, a 2nd call could occur so that MarshalledValue's raw byte array version is calculated and sent across. This enables storing as binary on the receiver side which is performance gain. The StreamingMarshaller implementation could decide that it needs a separate ObjectOutput or similar for the 2nd call since it's aim is only to get the raw byte array version and the close finish with it.</p> Stop the marshaller. Implementations of this method should clear up any cached data, or close any resources while marshalling/unmarshalling that have not been already closed.
Retrieves the value of the specified key as an {@link InputStream}. It is up to the application to ensure that the stream is consumed and closed. The marshaller is ignored, i.e. all data will be read in its raw binary form. The returned input stream implements the {@link VersionedMetadata} interface. The returned input stream is not thread-safe. Initiates a streaming put operation. It is up to the application to write to the returned {@link OutputStream} and close it when there is no more data to write. The marshaller is ignored, i.e. all data will be written in its raw binary form. The returned output stream is not thread-safe. An overloaded form of {@link #put(Object)}, which takes in lifespan parameters. The returned output stream is not thread-safe. An overloaded form of {@link #put(Object)}, which takes in lifespan and maxIdle parameters. The returned output stream is not thread-safe. A conditional form of put which inserts an entry into the cache only if no mapping for the key is already present. The operation is atomic. The server only performs the operation once the stream has been closed. The returned output stream is not thread-safe. An overloaded form of {@link #putIfAbsent(Object)} which takes in lifespan parameters. The returned output stream is not thread-safe. An overloaded form of {@link #putIfAbsent(Object)} which takes in lifespan and maxIdle parameters. The returned output stream is not thread-safe. A form of {@link #put(Object)}, which takes in a version. The value will be replaced on the server only if the existing entry's version matches. The returned output stream is not thread-safe. An overloaded form of {@link #replaceWithVersion(Object, long)} which takes in lifespan parameters. The returned output stream is not thread-safe. An overloaded form of {@link #replaceWithVersion(Object, long)} which takes in lifespan and maxIdle parameters. The returned output stream is not thread-safe.

/////////////////////////////////////////////////////////////////////// Closing                               // /////////////////////////////////////////////////////////////////////// Attempt to close an <tt>InputStream</tt>. Attempt to close an array of <tt>InputStream</tt>s. Attempt to close an <tt>OutputStream</tt>. Attempt to close an array of <tt>OutputStream</tt>s. Attempt to close an <tt>InputStream</tt> or <tt>OutputStream</tt>. Attempt to close an array of <tt>InputStream</tt>a and/or <tt>OutputStream</tt>s. Copy all of the bytes from the input stream to the output stream. Copy all of the bytes from the input stream to the output stream. Copy all of the bytes from the input stream to the output stream. Copy a limited number of bytes from the input stream to the output stream. Copy a limited number of bytes from the input stream to the output stream. Copy a limited number of bytes from the input stream to the output stream. Copy all of the bytes from the input stream to the output stream wrapping streams in buffers as needed. Attempt to flush and close an <tt>OutputStream</tt>. Attempt to flush and close an array of <tt>OutputStream</tt>s. /////////////////////////////////////////////////////////////////////// Flushing                             // /////////////////////////////////////////////////////////////////////// Attempt to flush an <tt>OutputStream</tt>. Attempt to flush an array of <tt>OutputStream</tt>s.


When a node joins a cluster, it should fetch state from other caches in the cluster and also its underlying cache store should contain the same state immediately. This is ensured by fetch-state attribute. The singleton attribute ensures that only a coordinator in a cluster works with its underlying cache store. So even if a key is stored to a cache on server2 only server1 should store it into its underlying cache store as server1 is the coordinator.





Go through the input string and replace any occurance of ${p} with the System.getProperty(p) value. If there is no such property p defined, then the ${p} reference will remain unchanged. <p/> If the property reference is of the form ${p:v} and there is no such property p, then the default value v will be returned. <p/> If the property reference is of the form ${p1,p2} or ${p1,p2:v} then the primary and the secondary properties will be tried in turn, before returning either the unchanged input, or the default value. <p/> The property ${/} is replaced with System.getProperty("file.separator") value and the property ${:} is replaced with System.getProperty("path.separator"). Go through the input string and replace any occurance of ${p} with the props.getProperty(p) value. If there is no such property p defined, then the ${p} reference will remain unchanged. <p/> If the property reference is of the form ${p:v} and there is no such property p, then the default value v will be returned. <p/> If the property reference is of the form ${p1,p2} or ${p1,p2:v} then the primary and the secondary properties will be tried in turn, before returning either the unchanged input, or the default value. <p/> The property ${/} is replaced with System.getProperty("file.separator") value and the property ${:} is replaced with System.getProperty("path.separator"). Try to resolve a "key" from the provided properties by checking if it is actually a "key1,key2", in which case try first "key1", then "key2". If all fails, return null. <p/> It also accepts "key1," and ",key2".


It calculates the segment in which the object belongs.
Retrieves the read write lock attributed to the given object using its hashCode for lookup. Retrieves the lock associated with the given hashCode Retrieves the given lock at a provided offset.  Note this is not hashCode based.  This method requires care and the knowledge of how many locks there are.  This is useful when iterating over all locks Locks all write locks.  Ensure that {@link StripedLock#unlockAll()} is called in a proper finally block Unlocks all write locks, useful after {@link StripedLock#lockAll()} was invoked.

Atomically adds the given value and return the new value. Registers a {@link CounterListener} to this counter. Atomically sets the value to the given updated value if the current value {@code ==} the expected value. Atomically decrements the counter and returns the new value   It fetches the current value. <p> It may go remotely to fetch the current value. Atomically increments the counter and returns the new value. Resets the counter to its initial value.

Sets the lower bound (inclusive) of the counter if a bounded counter is desired. <p> Default value is {@link Long#MIN_VALUE}. Sets the upper bound (inclusive) of the counter if a bounded counter is desired. <p> Default value is {@link Long#MAX_VALUE}.


Get the principals for this user. Returns the subject Get the name for this user.



Determine the output type of this accumulator.






This is the timeout used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown. This is the timeout used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.
This is the timeout used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown. This is the timeout used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.













Returns an appropriate system-dependent folder for storing application-specific data. The logic in this method uses the os.name to decide which is best. Currently it uses: ~/.config/${appName} on Unix/Linux (as per Freedesktop.org) %APPDATA%/Sun/Java/${appName} on Windows ~/Library/Java/${appName} on Mac OS X





Determines whether database tables should be created by the store on startup The name of the database column used to store the entries The type of the database column used to store the entries Determines whether database tables should be dropped by the store on shutdown For DB queries the fetch size is on {@link java.sql.ResultSet#setFetchSize(int)}. This is optional parameter, if not specified will be defaulted to {@link TableManager#DEFAULT_FETCH_SIZE}. The name of the database column used to store the keys The type of the database column used to store the keys Sets the prefix for the name of the table where the data will be stored. "_<cache name>" will be appended to this prefix in order to enforce unique table names for each cache. The name of the database column used to store the timestamps The type of the database column used to store the timestamps


The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'minTimeToWait'. The minimal number of millis to wait before taking this site offline, even in the case 'afterFailures' is reached. If smaller or equal to 0, then only 'afterFailures' is considered.
Disconnects the target from the source. This operation is the last step that must be performed after a rolling upgrade. Returns the name of this migrator Performs the synchronization of data between source and target Performs the synchronization of data between source and target

Adds a named parameter to the task context The cache against which this task will be executed. This will be the task's default cache, but other caches can be obtained from the cache manager The cache manager with which this task should be executed The default cache. Other caches can be obtained from cache manager ({@link Cache#getCacheManager()}) CacheManager for this task execution Marshaller for this task execution Gets a map of named parameters for the task The optional {@link Subject} which is executing this task Whether executing this task will generate an event in the event log Whether execution will generate an event in the event log The marshaller with which this task should be executed A map of named parameters that will be passed to the task. Invoking this method overwrites any previously set parameters The subject to impersonate when running this task. If unspecified, the Subject (if any) will be retrieved via {@link Security#getSubject()}

Returns the name of the engine Returns the list of tasks managed by this engine Returns whether this task engine knows about a specified named task Executes the named task on the specified cache, passing a map of named parameters.
Returns the name of the task Returns the time when the task was started An optional context to which the task was applied. Usually the name of a cache The node/address where the task was initiated An optional name of the principal who has executed this task. If the task was triggered internally, this method will return an empty {@link Optional}



Retrieves the currently executing tasks. If running in a cluster this operation will return all of the tasks running on all nodes Retrieves the installed task engines Retrieves the list of all available tasks Registers a new {@link TaskEngine} Executes the named task, passing an optional cache and a map of named parameters.






This will makes sure that, when the evictor thread kicks in the minIdle is set. We don't want to do this is the caller's thread, as this is the user. Note that the returned <code>RequestBalancingStrategy</code> may not be thread-safe. Note that the returned <code>ConsistentHash</code> may not be thread-safe.



Handles injection of components for various intermediate and this operation. Actually runs the terminal operation returning the result from the operation Sets the local supplier for the stream.  This is to be invoked on a remote node after the object is unmarshalled to set the supplier to use


In the particular case of Memcached, the end of operation/command is signaled by "\r\n" characters. So, if end of operation is found, this method would return true. On the contrary, if space was found instead of end of operation character, then it'd return the element and false.

Create a ThresholdFilter.
Format the thread name string. <ul> <li>{@code %%} - emit a percent sign</li> <li>{@code %t} - emit the per-factory thread sequence number</li> <li>{@code %g} - emit the global thread sequence number</li> <li>{@code %f} - emit the factory sequence number</li> <li>{@code %p} - emit the {@code ":"}-separated thread group path</li> <li>{@code %i} - emit the thread ID</li> <li>{@code %G} - emit the thread group name</li> <li>{@code %n} - emit the node name</li> <li>{@code %c} - emit the component name</li> </ul>






Validate parameters for the thread pool executor factory




It is equivalent to {@code timeDuration(startTime, time(), outputTimeUnit)}.








Used only for testing purposes









It notifies the cache topology change.











It waits for this synchronization block to be unblocked.  Unblocks this synchronization block

It ensures the validation order for the transaction corresponding to the prepare command. This allow the prepare command to be moved to a thread pool. It notifies the end of the state transfer possibly unblock waiting prepares. It notifies that a state transfer is about to start. Release the locked key possibly unblock waiting prepares.

returns the {@link TotalOrderRemoteTransactionState} associated with this transaction, creating one if no one was associated to this transaction. marks the prepare phase as 1PC to apply immediately the modifications. It is used when the {@code org.infinispan.commands.tx.CommitCommand} is received before the {@code org.infinispan.commands.tx.PrepareCommand}. it signals that the write skew check is not needed (for versioned entries). It is used when the {@code org.infinispan.commands.tx.CommitCommand} is received before the {@code org.infinispan.commands.tx.PrepareCommand}.
check if the transaction is marked for commit (by the Commit Command)  check if the transaction is marked for rollback (by the Rollback Command) mark the transaction as prepared (the validation was finished) and notify a possible pending commit or rollback command mark the transaction as preparing, blocking the commit and rollback commands until the {@link #prepared()} is invoked Sets the {@code TotalOrderLatch} to be associated to this transaction Commit and rollback commands invokes this method and they are blocked here if the state is PREPARING














If the cache is transactional (i.e. {@link #transactionMode()} == TransactionMode.TRANSACTIONAL) and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true. If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout. It is recommended that this value does not exceed the transaction timeout because even if a new transaction was started just before the cache was stopped, this could only last as long as the transaction timeout allows it. If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout. It is recommended that this value does not exceed the transaction timeout because even if a new transaction was started just before the cache was stopped, this could only last as long as the transaction timeout allows it.  Configures whether the cache uses optimistic or pessimistic locking. If the cache is not transactional then the locking mode is ignored. Configures whether the cache uses optimistic or pessimistic locking. If the cache is not transactional then the locking mode is ignored.   This method allows configuration of the transaction recovery cache. When this method is called, it automatically enables recovery. So, if you want it to be disabled, make sure you call {@link RecoveryConfigurationBuilder#enabled(boolean)} with false as parameter If true, the cluster-wide commit phase in two-phase commit (2PC) transactions will be synchronous, so Infinispan will wait for responses from all nodes to which the commit was sent. Otherwise, the commit phase will be asynchronous. Keeping it as false improves performance of 2PC transactions, but it can lead to inconsistencies when the primary owner releases the lock before the backup commits the change. If true, the cluster-wide commit phase in two-phase commit (2PC) transactions will be synchronous, so Infinispan will wait for responses from all nodes to which the commit was sent. Otherwise, the commit phase will be asynchronous. Keeping it as false improves performance of 2PC transactions, but it can lead to inconsistencies when the primary owner releases the lock before the backup commits the change. If true, the cluster-wide rollback phase in two-phase commit (2PC) transactions will be synchronous, so Infinispan will wait for responses from all nodes to which the rollback was sent. Otherwise, the rollback phase will be asynchronous. Keeping it as false improves performance of 2PC transactions. If true, the cluster-wide rollback phase in two-phase commit (2PC) transactions will be synchronous, so Infinispan will wait for responses from all nodes to which the rollback was sent. Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.   Configure Transaction Synchronization Registry lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional. Before Infinispan 5.1 you could access the cache both transactionally and non-transactionally. Naturally the non-transactional access is faster and offers less consistency guarantees. From Infinispan 5.1 onwards, mixed access is no longer supported, so if you wanna speed up transactional caches and you're ready to trade some consistency guarantees, you can enable use1PcForAutoCommitTransactions. <p/> What this configuration option does is force an induced transaction, that has been started by Infinispan as a result of enabling autoCommit, to commit in a single phase. So only 1 RPC instead of 2RPCs as in the case of a full 2 Phase Commit (2PC). <p/> <b>N.B.</b> this option should NOT be used when modifying the same key from multiple transactions as 1PC does not offer any consistency guarantees under concurrent access.
If the cache is transactional (i.e. {@link #transactionMode(org.infinispan.transaction.TransactionMode)} == TransactionMode.TRANSACTIONAL) and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true. If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout. It is recommended that this value does not exceed the transaction timeout because even if a new transaction was started just before the cache was stopped, this could only last as long as the transaction timeout allows it. <p/> This configuration property may be adjusted at runtime If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout. It is recommended that this value does not exceed the transaction timeout because even if a new transaction was started just before the cache was stopped, this could only last as long as the transaction timeout allows it. <p/> This configuration property may be adjusted at runtime The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000. Configures whether the cache uses optimistic or pessimistic locking. If the cache is not transactional then the locking mode is ignored.  The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000. This method allows configuration of the transaction recovery cache. When this method is called, it automatically enables recovery. So, if you want it to be disabled, make sure you call {@link RecoveryConfigurationBuilder#disable()} )} See {@link #syncCommitPhase(boolean)} If true, the cluster-wide commit phase in two-phase commit (2PC) transactions will be synchronous, so Infinispan will wait for responses from all nodes to which the commit was sent. Otherwise, the commit phase will be asynchronous. Keeping it as false improves performance of 2PC transactions, but it can lead to inconsistencies when a backup owner only commits the transaction after the primary owner released the lock. If true, the cluster-wide rollback phase in two-phase commit (2PC) transactions will be synchronous, so Infinispan will wait for responses from all nodes to which the rollback was sent. Otherwise, the rollback phase will be asynchronous. Keeping it as false can lead to inconsistencies when a transaction is rolled back because of a commit timeout, as a backup owner could commit the transaction after the primary released the lock. Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional. See {@link #transactionProtocol(TransactionProtocol)}. Configure Transaction Synchronization Registry lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional. Before Infinispan 5.1 you could access the cache both transactionally and non-transactionally. Naturally the non-transactional access is faster and offers less consistency guarantees. From Infinispan 5.1 onwards, mixed access is no longer supported, so if you wanna speed up transactional caches and you're ready to trade some consistency guarantees, you can enable use1PcForAutoCommitTransactions. <p/> What this configuration option does is force an induced transaction, that has been started by Infinispan as a result of enabling autoCommit, to commit in a single phase. So only 1 RPC instead of 2RPCs as in the case of a full 2 Phase Commit (2PC). See {@link #useSynchronization(boolean)} Configures whether the cache registers a synchronization with the transaction manager, or registers itself as an XA resource. It is often unnecessary to register as a full XA resource unless you intend to make use of recovery as well, and registering a synchronization is significantly more efficient.



Advances the {@link TxState}. Forgets the transaction cluster-wise and from global and local transaction tables.    Rollbacks a transaction that is remove in all the cluster members.



Attempt to commit this transaction. De-list an XA resource from this transaction. Enlist an XA resource with this transaction. Get the status of the transaction. Must be defined for increased performance Register a {@link Synchronization} callback with this transaction. Rolls back this transaction. Runs the second phase of two-phase-commit protocol. <p> If {@code forceRollback} is {@code true}, then a {@link RollbackException} is thrown with the message {@link #FORCE_ROLLBACK_MESSAGE}. Mark the transaction so that the only possible outcome is a rollback.



Returns a new TransactionManager.
{@inheritDoc }










Adds a value to a statistic collected for this transaction. Copies a statistic value and adds it to another statistic. Merges this statistics in the global container.  Increments a statistic value. It is equivalent to {@code addValue(stat, 1)}.    Sets this transaction as a write transaction. See also {@link #isReadOnly()}. Signals the reception of the {@link org.infinispan.commands.tx.PrepareCommand}. Sets the transaction outcome. See {@link #isCommitted()}. Signals this transaction as completed and updates the statistics to the final values ready to be merged in the cache statistics. This method is abstract in order to be override for the local and the remote transactions. Signals this transaction as completed and updates the statistics to the final values ready to be merged in the cache statistics.

Returns a new TransactionSynchronizationRegistry.





Same comment as for {@link #prepare(javax.transaction.xa.Xid)} applies for commit. the only situation in which it returns true is when the other xa resource pertains to the same cache, on the same node. This can be call for any transaction object. See Section 3.4.6 (Resource Sharing) from JTA spec v1.1. Same comment as for {@link #prepare(javax.transaction.xa.Xid)} applies for commit.
Commit the provided transaction's changes to the underlying store. Write modifications to the store in the prepare phase, as this is the only way we know the FINAL values of the entries. This is required to handle scenarios where an objects value is changed after the put command has been executed, but before the commit is called on the Tx. Rollback the provided transaction's changes to the underlying store.

Returns a JTA transaction. Returns a boolean value whether or not a transaction is in progress (JTA transaction and in this case *not* an org.hibernate transaction). Registers the synchronization passed in as a parameter with the ongoing transaction. <p/> If there is no ongoing transaction, then this method will do nothing and simply return. <p/>

{@inheritDoc }
It creates the transaction context.
Removes the lock, without committing pending changes or involving transactions. Used by Lucene at Directory creation: we expect the lock to not exist in this case. Will clear the lock, eventually suspending a running transaction to make sure the release is immediately taking effect. Commits the existing transaction. It's illegal to call this if a transaction was not started. Since Lucene 4.7, method release() was renamed to close() Starts a new transaction. Used to batch changes in LuceneDirectory: a transaction is created at lock acquire, and closed on release. It's also committed and started again at each IndexWriter.commit();


This should really be Class<? extends Transformer> however, since migrating to JBoss Logging and using annotation processor for generating log objects, if the previous definition is used, a compiler bug is hit. You can find more info in https://issues.jboss.org/browse/ISPN-380





Returns the address of the endpoint this transport is connected to, or <code>null</code> if it is unconnected. Invalidates transport instance. reads an vint which is size; then an array having that size.






This will be called by the test thread when testWhileIdle==true.



Dump service via JMX and find out whether test-infinispan-transport executor was picked up. When setting a stack attribute on <transport> config. element, there has to be a TCP protocol MBean available via JMX. Its attributes must match those in standalone.xml config file (in fact, these are default values taken from jgroups-defaults.xml configuration file in clustering/jgroups subsystem). When setting a stack attribute on <transport> config. element, there has to be a UDP protocol MBean available via JMX. Its attributes must match those in standalone.xml config file (in fact, these are default values taken from jgroups-defaults.xml configuration file in clustering/jgroups subsystem)
A terminal operation that returns whether all elements of this traversable match the provided predicate. <p>An important reason to keep this method is the fact as opposed to a reduction which must evaluate all elements in the traversable, this method could stop as soon as it has found an element that does not match the predicate. A terminal operation that returns whether any elements of this traversable match the provided predicate. <p>An important reason to keep this method is the fact as opposed to a reduction which must evaluate all elements in the traversable, this method could stop as soon as it has found an element that matches. A terminal operation that transforms the traversable into a result container, first constructed with the given supplier, and then accumulating elements over it with the given consumer. <p>The combiner can be used to combine accumulated results executed in parallel or coming from different nodes in a distributed environment. <p>In distributed environments where some keys are remote, the {@link Supplier} and {@link BiConsumer} instances passed in are sent to other nodes and hence they need to be marshallable. If the collect operation can be defined using the helper methods in {@link java.util.stream.Collectors}, it is recommended that those are used, which can easily be made marshalled using the {@code org.infinispan.stream.CacheCollectors#serializableCollector} method. A terminal operation that transforms the traversable into a result container using a {@code Collector}. <p>In distributed environments where some keys are remote, the {@link Collector} instance passed in is sent other nodes and hence it needs to be marshallable. This can easily be made achieved using the {@code org.infinispan.stream.CacheCollectors#serializableCollector} method. A terminal operation that returns the number of elements in the traversable. An intermediate operation that returns a traversable containing elements matching the given predicate. A terminal operation that returns an optional containing an element of the traversable, or an empty optional if empty. An intermediate operation that returns a traversable containing the results of replacing each element of this traversable with the contents of a traversable produced by applying the provided function to each element. <p>From a functional map perspective, this operation is particularly handy when the values are collections. A terminal operation that applies an operation to all elements of this traversable. An intermediate operation that returns a traversable containing the results of applying the given function over the elements of the traversable. A terminal operation that returns an optional containing the maximum element of this traversable based on the comparator passed in. If the traversable is empty, it returns an empty optional. A terminal operation that returns an optional containing the minimum element of this traversable based on the comparator passed in. If the traversable is empty, it returns an empty optional. A terminal operation that returns whether no elements of this traversable match the provided predicate. <p>An important reason to keep this method is the fact as opposed to a reduction which must evaluate all elements in the traversable, this method could stop as soon as it has found an element that does matches the predicate. A terminal operation that applies a binary folding operation to a start value and the result of each element having a mapping function applied. <p>This is a combined map/reduce which could potentially be done more efficiently than if a map is executed and then reduce. A terminal operation that applies a binary folding operation to a start value and all elements of this traversable. A terminal operation that applies a binary folding operation to all elements of this traversable, and wraps the result in an optional. If the traversable is empty, it returns an empty optional.

Convenience method that takes in a String represenation of the Fqn.  Otherwise identical to {@link #clearData(Fqn)}. Removes the keys and properties from a named node. <p/> A convenience method to retrieving a node and getting keys from the node directly. Tests if an Fqn exists.  Convenience method for {@link #exists(Fqn)} Tests if an Fqn exists. Convenience method that takes a string representation of an Fqn.  Otherwise identical to {@link #get(Fqn, Object)} Convenience method that allows for direct access to the data in a {@link Node}.  Retrieves a defensively copied data map of the underlying node.  A convenience method to retrieving a node and getting data from the node directly. Convenience method that takes in a String represenation of the Fqn.  Otherwise identical to {@link #getKeys(Fqn)}. Returns a set of attribute keys for the Fqn. Returns null if the node is not found, otherwise a Set. The set is a copy of the actual keys for this node. <p/> A convenience method to retrieving a node and getting keys from the node directly. Convenience method that takes a string representation of an Fqn.  Otherwise identical to {@link #getNode(Fqn)} A convenience method to retrieve a node directly from the cache.  Equivalent to calling cache.getRoot().getChild(fqn). Returns the root node of this cache. Convenience method that takes in string representations of Fqns.  Otherwise identical to {@link #move(Fqn, Fqn)} Moves a part of the cache to a different subtree. <p/> E.g.: <p/> assume a cache structure such as: <p/> <pre> /a/b/c /a/b/d /a/b/e <p/> <p/> Fqn f1 = Fqn.fromString("/a/b/c"); Fqn f2 = Fqn.fromString("/a/b/d"); <p/> cache.move(f1, f2); </pre> <p/> Will result in: <pre> <p/> /a/b/d/c /a/b/e <p/> </pre> <p/> and now <p/> <pre> Fqn f3 = Fqn.fromString("/a/b/e"); Fqn f4 = Fqn.fromString("/a"); cache.move(f3, f4); </pre> <p/> will result in: <pre> /a/b/d/c /a/e </pre> No-op if the node to be moved is the root node. <p/> <b>Note</b>: As of 3.0.0 and when using MVCC locking, more specific behaviour is defined as follows: <ul> <li>A no-op if the node is moved unto itself.  E.g., <tt>move(fqn, fqn.getParent())</tt> will not do anything.</li> <li>If a target node does not exist it will be created silently, to be more consistent with other APIs such as <tt>put()</tt> on a nonexistent node.</li> <li>If the source node does not exist this is a no-op, to be more consistent with other APIs such as <tt>get()</tt> on a nonexistent node.</li> </ul> Convenience method that takes a string representation of an Fqn.  Otherwise identical to {@link #put(Fqn, Object, Object)} Convenience method that takes a string representation of an Fqn.  Otherwise identical to {@link #put(Fqn, java.util.Map)} Associates the specified value with the specified key for a {@link Node} in this cache. If the {@link Node} previously contained a mapping for this key, the old value is replaced by the specified value. Copies all of the mappings from the specified map to a {@link Node}. Convenience method that takes a string representation of an Fqn.  Otherwise identical to {@link #remove(Fqn, Object)} Removes the mapping for this key from a Node. Returns the value to which the Node previously associated the key, or <code>null</code> if the Node contained no mapping for this key. Convenience method that takes a string representation of an Fqn.  Otherwise identical to {@link #removeNode(Fqn)} Removes a {@link Node} indicated by absolute {@link Fqn}.
Creates a TreeCache instance by taking in a {@link org.infinispan.Cache} as a parameter
------------------ nothing different; just delegate to the cache
Returns a String representation of a tree cache.
Performs this operation on the given arguments.

TODO: this should just override handleNonTxWriteCommand when functional commands will be triangelized


action interface lock listener interface

Maps a String back to its original key



This only happens during state transfer.




If we are within one transaction we won't do any replication as replication would only be performed at commit time. If the operation didn't originate locally we won't do any replication either. ---- TX boundary commands



Registers a new participant with the transaction. Returns the set of keys that are affected by this transaction.  Used to generate appropriate recipient groups for cluster-wide prepare and commit calls. Returns the id of the transaction associated  with the current call. Returns the modifications performed in the scope of the current transaction. Any modifications having Flag.CACHE_MODE_LOCAL are ignored. The returned list can be null. Returns the tx associated with the current thread. This method MUST be guarded with a call to {@link #isOriginLocal()}, as {@link javax.transaction.Transaction} are not propagated from the node where tx was started. Checks if there are modifications performed within the tx's scope. Any modifications having Flag.CACHE_MODE_LOCAL are ignored.

We need to intercept PrepareCommand, not InvalidateCommand since the interception takes place before EntryWrappingInterceptor and the PrepareCommand is multiplexed into InvalidateCommands as part of EntryWrappingInterceptor






Returns the actual internal representation the entity. It might be a Class, or anything else. Returns the type name of the represented entity.

Apply the configuration overrides in this {@link TypeOverrides} instance to the cache configuration builder passed as parameter. Maximum number of entries in a cache for this cached type. Cache size is guaranteed  not to exceed upper limit specified by max entries. However, due to the nature of eviction it is unlikely to ever be exactly maximum number of entries specified here. Sets eviction strategy for cached type. Sets how often eviction process should be run for the cached type. Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire. Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire. Enable statistics gathering and reporting via JMX. Validate the configuration for this cached type.
Get the property associated with the key, optionally applying string property replacement as defined in {@link StringPropertyReplacer#replaceProperties} to the result. Factory method that converts a JDK {@link Properties} instance to an instance of TypedProperties, if needed.




Synchronously checks if classpath looks correct for Uber Jar usage. Asynchronously checks if classpath looks correct for Uber Jar usage.











Specifies whether Infinispan is allowed to disregard the {@link Map} contract when providing return values for {@link org.infinispan.Cache#put(Object, Object)} and {@link org.infinispan.Cache#remove(Object)} methods.
Specify whether Infinispan is allowed to disregard the {@link Map} contract when providing return values for {@link org.infinispan.Cache#put(Object, Object)} and {@link org.infinispan.Cache#remove(Object)} methods. <p /> Providing return values can be expensive as they may entail a read from disk or across a network, and if the usage of these methods never make use of these return values, allowing unreliable return values helps Infinispan optimize away these remote calls or disk reads. <p />

Reads an int stored in variable-length format.  Reads between one and five bytes.  Smaller values take fewer bytes.  Negative numbers are not supported. Reads an int stored in variable-length format.  Reads between one and five bytes.  Smaller values take fewer bytes.  Negative numbers are not supported. Reads an int stored in variable-length format.  Reads between one and nine bytes.  Smaller values take fewer bytes.  Negative numbers are not supported. Reads a long stored in variable-length format.  Reads between one and nine bytes.  Smaller values take fewer bytes.  Negative numbers are not supported. Writes an int in a variable-length format.  Writes between one and five bytes.  Smaller values take fewer bytes. Negative numbers are not supported. Writes an int in a variable-length format.  Writes between one and five bytes.  Smaller values take fewer bytes. Negative numbers are not supported. Writes an int in a variable-length format.  Writes between one and nine bytes.  Smaller values take fewer bytes. Negative numbers are not supported. Writes a long in a variable-length format.  Writes between one and nine bytes.  Smaller values take fewer bytes. Negative numbers are not supported.






















Awaits for the counter operation and throws any exception as {@link CounterException}. Calculates the {@link CounterState} to use based on the value and the boundaries. <p> If the value is less than the lower bound, {@link CounterState#LOWER_BOUND_REACHED} is returned. On other hand, if the value is higher than the upper bound, {@link CounterState#UPPER_BOUND_REACHED} is returned. Otherwise, {@link CounterState#VALID} is returned. Checks if the value is inside the boundaries. Returns a {@link CounterException} with the throwable.




Process an exception from a target. Process a target leaving the cluster or stopping the cache. Process a valid response from a target.











Generates a new entry version






Create an error response based on the Throwable instance received. Create a response for get a request. Create a response indicating the the operation could not be executed. Create a response indicating that the key, which the message tried to operate on, did not exist. Create a response for the stats command. Create a successful response. Read operation specific data for an operation that only requires a header Handle a protocol specific key reading. Handle a protocol specific value reading. Get an optimized cache instance depending on the operation parameters. Having read the message's Id, read the rest of Hot Rod header from the given buffer and return it. Returns whether the entire header was read or not. Read the parameters of the operation, if present.

Write an event, including its header, using the given channel buffer Write the header to the given channel buffer Write operation response using the given channel buffer







This entry is only used when versioning is enabled, and in these situations, versions are generated internally and assigned at a different stage to the rest of metadata. So, keep the versioned API to make it easy to apply version information when needed.









Blocks for a certain amount of time until a view change is received.  Note that this class will start listening for the view change the moment it is constructed.


Gets the current list of members. Gets the previous list of members. Get JGroups view id.

Accept a visitor, and return the result of accepting this visitor. Used to determine whether the command should be invoked or not. Commands can opt to be discarded in case the cache status is not suited (as {@link InvalidateCommand})  Performs the primary function of the command.  Please see specific implementation classes for details on what is performed as well as return types. <b>Important</b>: this method will be invoked at the end of interceptors chain. It should never be called directly from a custom interceptor. Used by the InboundInvocationHandler to determine whether the command should be invoked or not.



Adds the given value to the new value. Adds a {@link CounterListener} to this counter. Decrements the counter.   It returns the counter's value. <p> This value may be not the mot up-to-data value. Increments the counter. Resets the counter to its initial value.

Sets the counter's concurrency level. <p> It sets the number of concurrent updates in the counter. A higher value will support a higher number of updates but it increases the read of the counter's value. <p> Default value is 16.
Debug only! Debug only! Initializes the key set. <p> Only one key will have the initial value and the remaining is zero.

Create new value ref instance. Create map. Create map. Create map. Remove all entries whose values have been discarded.













Only returns when the last operation on this thread has finished. Only returns when this thread added the given key value. Does a put on the worker thread. Doesn't wait for the put operation to finish. However, it will wait for the previous operation on this thread to finish. Returns without waiting for the threads to finish. Starts doing cache put operations in a loop on the worker thread. Doesn't wait for the loop to finish - in fact the loop will finish only when the worker is stopped. However, it will wait for the previous operation on this thread to finish.


Use MarshalledValue.Externalizer to deserialize. Use MarshalledValue.Externalizer to serialize.

The offset of where data starts in the backed array. Retrieves the byte given an offset.  This offset should always be less than {@link WrappedBytes#getLength()}. The backing array if there is one otherwise null is returned.  Callers should use {@link WrappedBytes#backArrayOffset()} to know where to read the bytes from.  This byte[] should never be modified by the caller The length of the underlying wrapped bytes.  This will always be >= 0.





Make subsequent invocations of {@link #isSuccessful()} return <code>false</code>.   Certain commands only work based on a certain condition or state of the cache.  For example, {@link org.infinispan.Cache#putIfAbsent(Object, Object)} only does anything if a condition is met, i.e., the entry in question is not already present.  This method tests whether the command in question is conditional or not. Some commands may want to provide information on whether the command was successful or not.  This is different from a failure, which usually would result in an exception being thrown.  An example is a putIfAbsent() not doing anything because the key in question was present.  This would result in a isSuccessful() call returning false. Indicates whether the command is write-only, meaning that it makes no attempt to read the previously associated value with key for which the command is directed.  Used for conditional commands, to update the status of the command on the originator based on the result of its execution on the primary owner.













Get the value of an attribute as a space-delimited string list. Returns the schema of currently being processed Handle an {@code <xs:any>}-type nested element, passing in the given value, returning after the end of the element. Must be positioned on a {@code START_ELEMENT} or an exception will occur. On return the cursor will be positioned on the corresponding {@code END_ELEMENT}. Sets the current schema






for debug only!




It applies state from other site. It notifies the end of state transfer from other site.  It notifies the start of state transfer from other site.

It cancels the state transfer for the remote site. If no state transfer is available, it should do nothing.   It notifies this node to start sending state to the remote site. Also, it should keep information about which node requested the state transfer in order to send back the notification when finishes.




If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries. If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512. The maximum number of retries when a push state command fails. A value <= 0 (zero) mean that the command will not retry. Default value is 30. The time (in milliseconds) to wait for the backup site acknowledge the state chunk received and applied. Default value is 20 min. The waiting time (in milliseconds) between each retry. The value should be > 0 (zero). Default value is 2 seconds.

Makes this node the coordinator for the state transfer to the site name. <p/> This method is invoked when the coordinator dies and this node receives a late start state transfer request. It cancels a running state transfer. Sets the cluster to normal state. <p/> The main use for this method is when the link between the sites is broken and the receiver site keeps it state transfer state forever. Clears the completed state transfer status in all the cluster. Clears the completed state transfer status.     It receives the notifications from local site when some node finishes pushing the state to the remote site. It notifies all nodes from local site to start transfer the state to the remote site.




Only does the conversion if recovery is enabled. Start before cache loader manager

Escapes backslashes ('\') with additional backslashes in a given String, returning a new, escaped String. Retrieves the value of a given attribute for the first encountered instance of a tag in an element. <p/> E.g., if you have a {@link Element} which represents the following XML snippet: </p> <pre> &lt;ItemQuantity Colour="Red"&gt;100&lt;/ItemQuantity&gt; &lt;ItemQuantity Colour="Blue"&gt;30&lt;/ItemQuantity&gt; &lt;ItemQuantity Colour="Black"&gt;10&lt;/ItemQuantity&gt; <pre> <p/> The following results could be expected: </p> <pre> getAttributeValue(element, "ItemQuantity", "Colour"); // "Red" getTagContents(element, "Blah", "Colour"); // null getTagContents(element, "ItemQuantity", "Blah"); // null </pre> None of the parameters should be null - otherwise the method may throw a NullPointerException. Returns the root element of a given input stream Reads the contents of the element passed in. <p/> None of the parameters should be null - otherwise the method may throw a NullPointerException. Gets the first child element of an element Returns a named sub-element of the current element passed in. <p/> None of the parameters should be null - otherwise the method may throw a NullPointerException. Returns the contents of a specific node of given element name, provided a certain attribute exists and is set to value. E.g., if you have a {@link Element} which represents the following XML snippet: <pre> &lt;ItemQuantity Colour="Red"&gt;100&lt;/ItemQuantity&gt; &lt;ItemQuantity Colour="Blue"&gt;30&lt;/ItemQuantity&gt; &lt;ItemQuantity Colour="Black"&gt;10&lt;/ItemQuantity&gt; <pre> <p/> The following results could be expected: </p> <pre> getTagContents(element, "Red", "ItemQuantity", "Colour"); // 100 getTagContents(element, "Black", "ItemQuantity", "Colour"); // 10 getTagContents(element, "Blah", "ItemQuantity", "Colour"); // null getTagContents(element, "Red", "Blah", "Colour"); // null getTagContents(element, "Black", "ItemQuantity", "Blah"); // null </pre> <p/> None of the parameters should be null - otherwise the method may throw a NullPointerException. </p> Retrieves the boolean value of a given attribute for the first encountered instance of elementName Similar to {@link #readStringContents(org.w3c.dom.Element,String)} except that it returns a boolean. Similar to {@link #readStringContents(org.w3c.dom.Element,String)} except that it returns a boolean. Reads the contents of a named sub element within a given element, and attempts to parse the contents as a Java properties file. <p/> E.g., if you have a {@link Element} which represents the following XML snippet: <p/> <pre> &lt;props&gt; my.attrib.1 = blah my.attrib.2 = blahblah &lt;/props&gt; <pre> <p/> The following results could be expected: <p/> <pre> Properties p = readPropertiesContents(element, "props"); p.getProperty("my.attrib.1"); // blah p.getProperty("my.attrib.2"); // blahblah </pre> None of the parameters should be null - otherwise the method may throw a NullPointerException. Reads the contents of the first occurrence of elementName under the given element, trimming results of whitespace. <p/> None of the parameters should be null - otherwise the method may throw a NullPointerException. Converts a String representing an XML snippet into an {@link org.w3c.dom.Element}.

